unit FState;
//本单元提供系统中的所有对话框显示
interface

uses
  Windows, SysUtils, StrUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, AbstractCanvas, AbstractTextures, AsphyreTextureFonts,
  Vectors2,
  Grobal2, clFunc, AspHUtil32, EDcode, soundUtil, actor, IniFiles,
  AspDWinCtl, Share, AspWil, uAspDScrollBar, uAspDListView, uAspDTreeView, EDcodeUnit,
  uAspDScrollBox, uAspDLabel, uAspDCheckBox, uAspDComboBox, uMyDxUnit, AsphyreTypes,
  uAspDChatMemo;

const
   BOTTOMBOARD800 = 371;//主操作介面图形号
   BOTTOMBOARD1024 = 2;//主操作介面图形号
   //VIEWCHATLINE = 9;
   MAXSTATEPAGE = 4;
   LISTLINEHEIGHT = 13;
   MAXMENU = 10;

   STRLINS = 50;

   AdjustAbilHints : array[0..8] of string = (
      '攻击点',
      '魔法点',
      '道法点',
      '防御点',
      '魔防点',
      '生命值',
      '能量值',
      '准确点',
      '敏捷点'
   );

type
  {$IF M2Version = 2}
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmPlayDrink);
  {$ELSE}
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmPlayDrink, dmArmsTear, dmArmsExchange);//20100708

  TSkillMemoClickPoint = record
    rc: TRect;
    Ident: Word;
  end;
  pTSkillMemoClickPoint = ^TSkillMemoClickPoint;
  {$IFEND}

  TClickPoint = record
     rc: TRect;
     RStr: string;
     TStr: string; //标题
  end;
  pTClickPoint = ^TClickPoint;
  TClickSLPoint = record
     rc: TRect;
     RStr: string;  //里面有唯一标实
     SStr: string;  //真正内容
  end;
  pTClickSLPoint = ^TClickSLPoint;
  TDiceInfo = record
    nDicePoint :Integer;      //0x66C
    nPlayPoint :Integer;//0x670 当前骰子点数
    nX         :Integer;      //0x674
    nY         :Integer;      //0x678
    n67C       :Integer;      //0x67C
    n680       :Integer;      //0x680
    dwPlayTick :LongWord; //0x684
  end;
  pTDiceInfo = ^TDiceInfo;
  
  TMissionLabel = class(TDTreeNode)
  public
    m_sCmd: string;
  end;

  {$IF M2Version <> 2}
  TFactionMember = class
  public
    m_Icon: TAspDButton;
    m_Name: TAspDLabel;
    m_DivisionMember: TClientDivisionMember;
    constructor Create();
    destructor Destroy; override;
  end;
  {$IFEND}

  TFrmDlg = class(TForm)
    DStateWin: TAspDWindow;
    DBackground: TAspDWindow;
    DItemBag: TAspDWindow;
    DGold: TAspDButton;
    DPrevState: TAspDButton;
    DItemsUpBut: TAspDButton;
    DCloseBag: TAspDButton;
    DCloseState: TAspDButton;
    DLogIn: TAspDWindow;
    DNewAccount: TAspDWindow;
    DSelectChr: TAspDWindow;
    DscSelect1: TAspDButton;
    DscSelect2: TAspDButton;
    DscStart: TAspDButton;
    DscNewChr: TAspDButton;
    DscEraseChr: TAspDButton;
    DscCredits: TAspDButton;
    DscExit: TAspDButton;
    DCreateChr: TAspDWindow;
    DItemGrid: TAspDGrid;
    DMsgDlg: TAspDWindow;
    DMsgDlgOk: TAspDButton;
    DMsgDlgYes: TAspDButton;
    DMsgDlgCancel: TAspDButton;
    DMsgDlgNo: TAspDButton;
    DNextState: TAspDButton;
    DSWNecklace: TAspDButton;
    DSWLight: TAspDButton;
    DSWArmRingR: TAspDButton;
    DSWArmRingL: TAspDButton;
    DSWRingR: TAspDButton;
    DSWRingL: TAspDButton;
    DSWWeapon: TAspDButton;
    DSWDress: TAspDButton;
    DSWHelmet: TAspDButton;
    DSWBujuk: TAspDButton;
    DSWBelt: TAspDButton;
    DSWBoots: TAspDButton;
    DSWCharm: TAspDButton;
    DChgPw: TAspDWindow;
    DChgpwOk: TAspDButton;
    DChgpwCancel: TAspDButton;
    DMerchantDlg: TAspDWindow;
    DMerchantDlgClose: TAspDButton;
    DMenuDlg: TAspDWindow;
    DMenuPrev: TAspDButton;
    DMenuNext: TAspDButton;
    DMenuBuy: TAspDButton;
    DMenuClose: TAspDButton;
    DSellDlg: TAspDWindow;
    DSellDlgOk: TAspDButton;
    DSellDlgClose: TAspDButton;
    DSellDlgSpot: TAspDButton;
    DStMag1: TAspDButton;
    DStMag2: TAspDButton;
    DStMag3: TAspDButton;
    DStMag4: TAspDButton;
    DStMag5: TAspDButton;
    DKeySelDlg: TAspDWindow;
    DKsIcon: TAspDButton;
    DKsF1: TAspDButton;
    DKsF2: TAspDButton;
    DKsF3: TAspDButton;
    DKsF4: TAspDButton;
    DKsNone: TAspDButton;
    DKsOk: TAspDButton;
    DGroupDlg: TAspDWindow;
    DGrpAllowGroup: TAspDButton;
    DGrpDlgClose: TAspDButton;
    DGrpCreate: TAspDButton;
    DGrpAddMem: TAspDButton;
    DGrpDelMem: TAspDButton;
    DStPageUp: TAspDButton;
    DStPageDown: TAspDButton;
    DDealRemoteDlg: TAspDWindow;
    DDealDlg: TAspDWindow;
    DDRGrid: TAspDGrid;
    DDGrid: TAspDGrid;
    DDealOk: TAspDButton;
    DDealClose: TAspDButton;
    DDGold: TAspDButton;
    DDRGold: TAspDButton;
    DSelServerDlg: TAspDWindow;
    DUserState1: TAspDWindow;
    DCloseUS1: TAspDButton;
    DWeaponUS1: TAspDButton;
    DHelmetUS1: TAspDButton;
    DNecklaceUS1: TAspDButton;
    DDressUS1: TAspDButton;
    DLightUS1: TAspDButton;
    DArmringRUS1: TAspDButton;
    DRingRUS1: TAspDButton;
    DArmringLUS1: TAspDButton;
    DRingLUS1: TAspDButton;

    DBujukUS1: TAspDButton;
    DBeltUS1: TAspDButton;
    DBootsUS1: TAspDButton;
    DCharmUS1: TAspDButton;
    DGuildDlg: TAspDWindow;
    DGDHome: TAspDButton;
    DGDList: TAspDButton;
    DGDChat: TAspDButton;
    DGDAddMem: TAspDButton;
    DGDDelMem: TAspDButton;
    DGDEditNotice: TAspDButton;
    DGDEditGrade: TAspDButton;
    DGDAlly: TAspDButton;
    DGDBreakAlly: TAspDButton;
    DGDWar: TAspDButton;
    DGDCancelWar: TAspDButton;
    DGDUp: TAspDButton;
    DGDDown: TAspDButton;
    DGDClose: TAspDButton;
    DGuildEditNotice: TAspDWindow;
    DGEClose: TAspDButton;
    DGEOk: TAspDButton;
    DAdjustAbility: TAspDWindow;
    DPlusDC: TAspDButton;
    DPlusMC: TAspDButton;
    DPlusSC: TAspDButton;
    DPlusAC: TAspDButton;
    DPlusMAC: TAspDButton;
    DPlusHP: TAspDButton;
    DPlusMP: TAspDButton;
    DPlusHit: TAspDButton;
    DPlusSpeed: TAspDButton;
    DMinusDC: TAspDButton;
    DMinusMC: TAspDButton;
    DMinusSC: TAspDButton;
    DMinusAC: TAspDButton;
    DMinusMAC: TAspDButton;
    DMinusMP: TAspDButton;
    DMinusHP: TAspDButton;
    DMinusHit: TAspDButton;
    DMinusSpeed: TAspDButton;
    DAdjustAbilClose: TAspDButton;
    DAdjustAbilOk: TAspDButton;
    DKsF5: TAspDButton;
    DKsF6: TAspDButton;
    DKsF7: TAspDButton;
    DKsF8: TAspDButton;
    DKsConF1: TAspDButton;
    DKsConF2: TAspDButton;
    DKsConF3: TAspDButton;
    DKsConF4: TAspDButton;
    DKsConF5: TAspDButton;
    DKsConF6: TAspDButton;
    DKsConF7: TAspDButton;
    DKsConF8: TAspDButton;
    DFriendDlg: TAspDWindow;
    DFrdClose: TAspDButton;
    DStateHero: TAspDWindow;
    DCloseHeroState: TAspDButton;
    DSHHelmet: TAspDButton;
    DSHWeapon: TAspDButton;
    DSHDress: TAspDButton;
    DPrevStateHero: TAspDButton;
    DSHArmRingR: TAspDButton;
    DSHRingR: TAspDButton;
    DNextStateHero: TAspDButton;
    DSHNecklace: TAspDButton;
    DSHLight: TAspDButton;
    DSHArmRingL: TAspDButton;
    DSHRingL: TAspDButton;
    DStMagHero1: TAspDButton;
    DStMagHero2: TAspDButton;
    DStMagHero3: TAspDButton;
    DStMagHero4: TAspDButton;
    DStMagHero5: TAspDButton;
    DSHPageUp: TAspDButton;
    DSHPageDown: TAspDButton;
    DSHBujuk: TAspDButton;
    DSHBelt: TAspDButton;
    DSHBoots: TAspDButton;
    DSHCharm: TAspDButton;
    DHeroItemBag: TAspDWindow;
    DHeroItemGrid: TAspDGrid;
    DHeroItemGridClose: TAspDButton;
    DShop: TAspDWindow;
    DShopClose: TAspDButton;
    DShopImgLogo: TAspDButton;
    DShopDecorate: TAspDButton;
    DShopSupplies: TAspDButton;
    DshopStrengthen: TAspDButton;
    DShopFriend: TAspDButton;
    DShopCapacity: TAspDButton;
    DShopPrev: TAspDButton;
    DShopNext: TAspDButton;
    DShopBuy: TAspDButton;
    DShopPresent: TAspDButton;
    DShopClose1: TAspDButton;
    DShopImg1: TAspDButton;
    DShopImg2: TAspDButton;
    DShopImg3: TAspDButton;
    DShopImg4: TAspDButton;
    DShopImg5: TAspDButton;
    DShopImg6: TAspDButton;
    DShopImg7: TAspDButton;
    DShopImg8: TAspDButton;
    DShopImg9: TAspDButton;
    DShopImg10: TAspDButton;
    DShopSpeciallyImg1: TAspDButton;
    DShopSpeciallyImg2: TAspDButton;
    DShopSpeciallyImg3: TAspDButton;
    DShopSpeciallyImg4: TAspDButton;
    DShopSpeciallyImg5: TAspDButton;
    DWLevelOrder: TAspDWindow;
    DLevelOrderClose: TAspDButton;
    DIndividualOrder: TAspDButton;
    DHeroOrder: TAspDButton;
    DMasterOrder: TAspDButton;
    DColonyHeroOrder: TAspDButton;
    DWarriorOrder: TAspDButton;
    DWizerdOrder: TAspDButton;
    DTaoistOrder: TAspDButton;
    DHeroAllOrder: TAspDButton;
    DWarriorHeroOrder: TAspDButton;
    DWizerdHeroOrder: TAspDButton;
    DTaoistHeroOrder: TAspDButton;
    DLevelOrderIndex: TAspDButton;
    DLevelOrderPrev: TAspDButton;
    DLevelOrderNext: TAspDButton;
    DLevelOrderLastPage: TAspDButton;
    DMyLevelOrder: TAspDButton;
    DBoxs: TAspDWindow;
    DBoxsBelt1: TAspDButton;
    DBoxsBelt2: TAspDButton;
    DBoxsBelt3: TAspDButton;
    DBoxsBelt4: TAspDButton;
    DBoxsBelt5: TAspDButton;
    DBoxsBelt6: TAspDButton;
    DBoxsBelt7: TAspDButton;
    DBoxsBelt8: TAspDButton;
    DBoxsBelt9: TAspDButton;
    DBoxsTautology: TAspDButton;
    DLieDragon: TAspDWindow;
    DLieDragonClose: TAspDButton;
    DLieDragonPrevPage: TAspDButton;
    DLieDragonNextPage: TAspDButton;
    DGoToLieDragon: TAspDButton;
    DLieDragonNpc: TAspDWindow;
    DLieDragonNpcClose: TAspDButton;
    DItemsUp: TAspDWindow;
    DItemsUpClose: TAspDButton;
    DItemsUpBelt1: TAspDButton;
    DItemsUpBelt2: TAspDButton;
    DItemsUpBelt3: TAspDButton;
    DItemsUpOk: TAspDButton;
    DGameGirdExchange: TAspDButton;
    DWSellOff: TAspDWindow;
    DSellOffClose: TAspDButton;
    DSellOffOk: TAspDButton;
    DSellOffCancel: TAspDButton;
    DSellOffItemGrid: TAspDGrid;
    DWSellOffList: TAspDWindow;
    DSellOffListColse: TAspDButton;
    DEditSellOffName: TAspDButton;
    DEditSellOffNum: TAspDButton;
    DSellOffItem1: TAspDButton;
    DSellOffItem2: TAspDButton;
    DSellOffItem3: TAspDButton;
    DSellOffItem4: TAspDButton;
    DSellOffItem5: TAspDButton;
    DSellOffItem6: TAspDButton;
    DSellOffItem7: TAspDButton;
    DSellOffItem8: TAspDButton;
    DSellOffItem9: TAspDButton;
    DSellOffItem0: TAspDButton;
    DSellOffListCancel: TAspDButton;
    DSellOffBuyCancel: TAspDButton;
    DSellOffBuy: TAspDButton;
    DWGameGold: TAspDButton;
    DStMag6: TAspDButton;
    DStMagHero6: TAspDButton;
    DWiGetHero: TAspDWindow;
    DGetHeroClose: TAspDButton;
    DSelHero1: TAspDButton;
    DSelHero2: TAspDButton;
    DPlayDrink: TAspDWindow;
    DPlayDrinkClose: TAspDButton;
    DPlayDrinkFist: TAspDButton;
    DPlayDrinkScissors: TAspDButton;
    DPlayDrinkCloth: TAspDButton;
    DPlayFist: TAspDButton;
    DDrink3: TAspDButton;
    DDrink1: TAspDButton;
    DDrink2: TAspDButton;
    DDrink4: TAspDButton;
    DDrink5: TAspDButton;
    DDrink6: TAspDButton;
    DWPleaseDrink: TAspDWindow;
    DPDrink1: TAspDButton;
    DPDrink2: TAspDButton;
    DPleaseDrinkClose: TAspDButton;
    DPleaseDrinkDrink: TAspDButton;
    DPleaseDrinkExit: TAspDButton;
    DPlayDrinkNpcNum: TAspDButton;
    DPlayDrinkPlayNum: TAspDButton;
    DPlayDrinkWhoWin: TAspDButton;
    DLOGO: TAspDButton;
    DFriendDlgFrd: TAspDButton;
    DFriendDlgTanget: TAspDButton;
    DHeiMingDan: TAspDButton;
    DPrevFriendDlg: TAspDButton;
    DNextFriendDlg: TAspDButton;
    DFriendList: TAspDButton;
    DAddFriend: TAspDButton;
    DDelFriend: TAspDButton;
    DWCheckNum: TAspDWindow;
    DCheckNumClose: TAspDButton;
    DCheckNumOK: TAspDButton;
    DCheckNumChange: TAspDButton;
    DEditCheckNum: TAspDEdit;
    DWMakeWineDesk: TAspDWindow;
    DMakeWineDeskClose: TAspDButton;
    DLiquorProgress: TAspDButton;
    DMakeWineHelp: TAspDButton;
    DMaterialMemo: TAspDButton;
    DStartMakeWine: TAspDButton;
    DBMateria: TAspDButton;
    DBWineSong: TAspDButton;
    DBWater: TAspDButton;
    DBWineCrock: TAspDButton;
    DBAssistMaterial1: TAspDButton;
    DBAssistMaterial2: TAspDButton;
    DBAssistMaterial3: TAspDButton;
    DBDrug: TAspDButton;
    DBWine: TAspDButton;
    DBWineBottle: TAspDButton;
    DHeroLiquorProgress: TAspDButton;
    DWNewSdoAssistant: TAspDWindow;
    DNewSdoAssistantClose: TAspDButton;
    DNewSdoBasic: TAspDButton;
    DNewSdoProtect: TAspDButton;
    DNewSdoSkill: TAspDButton;
    DNewSdoKey: TAspDButton;
    DNedSdoHelp: TAspDButton;
    DCheckSdoNameShow: TAspDCheckBox;
    DCheckSdoDuraWarning: TAspDCheckBox;
    DCheckSdoAvoidShift: TAspDCheckBox;
    DCheckSdoLongHit: TAspDCheckBox;
    DCheckSdoAutoWideHit: TAspDCheckBox;
    DCheckSdoAutoFireHit: TAspDCheckBox;
    DCheckSdoZhuri: TAspDCheckBox;
    DCheckSdoAutoShield: TAspDCheckBox;
    DCheckSdoHeroShield: TAspDCheckBox;
    DCheckSdoAutoHide: TAspDCheckBox;
    DCheckSdoAutoMagic: TAspDCheckBox;
    DEdtSdoAutoMagicTimer: TAspDEdit;
    DCheckSdoAutoDrinkWine: TAspDCheckBox;
    DEdtSdoDrunkWineDegree: TAspDEdit;
    DCheckSdoHeroAutoDrinkWine: TAspDCheckBox;
    DEdtSdoHeroDrunkWineDegree: TAspDEdit;
    DWChallenge: TAspDWindow;
    DChallengeClose: TAspDButton;
    DChallengeOK: TAspDButton;
    DChallengeCancel: TAspDButton;
    DChallengeGrid: TAspDGrid;
    DChallengeGold: TAspDButton;
    DRChallengeGrid: TAspDGrid;
    dwRecoverChr: TAspDWindow;
    dgrdRecoverName: TAspDGrid;
    btnRecover: TAspDButton;
    btnRecvChrClose: TAspDButton;
    DCheckSdoExpFiltrate: TAspDCheckBox;
    DCheckSdoAutoDrinkDrugWine: TAspDCheckBox;
    DEdtSdoDrunkDrugWineDegree: TAspDEdit;
    DCheckSdoHeroAutoDrinkDrugWine: TAspDCheckBox;
    DEdtSdoHeroDrunkDrugWineDegree: TAspDEdit;
    DStateTab: TAspDButton;
    DHeroStateTab: TAspDButton;
    DSighIcon: TAspDButton;
    DWExpCrystal: TAspDWindow;
    DExpCrystalTop: TAspDButton;
    DCrystalExp: TAspDButton;
    DCrystalNGExp: TAspDButton;
    DCheckSdoMapDesc: TAspDCheckBox;
    DNewBoxsHelp: TAspDButton;
    DBNewHelpBtn: TAspDButton;
    DNewBoxsHelpClose: TAspDButton;
    DCheckAutoOpenBoxs: TAspDCheckBox;
    DBoxsNewBelt1: TAspDButton;
    DBoxsNewBelt2: TAspDButton;
    DBoxsNewBelt3: TAspDButton;
    DBoxsNewClose: TAspDButton;
    DSdoMemo: TAspDMemo;
    DSdoMemoScrollBar: TAspDMemoScrollBar;
    DCheckAutoButch: TAspDCheckBox;
    DCheckAutoUseHuolongzhu: TAspDCheckBox;
    DCheckAutoUseJingyuandan: TAspDCheckBox;
    DEdtSdoExpFiltrate: TAspDEdit;
    DWNQState: TAspDWindow;
    DNQExp: TAspDButton;
    DNQBoxs: TAspDButton;
    DWKimNeedle: TAspDWindow;
    DKimNeedleLogo: TAspDButton;
    DKimNeedleHelp: TAspDButton;
    DKimNeedleMemo: TAspDButton;
    DStartKimNeedle: TAspDButton;
    DKimNeedleBar: TAspDButton;
    DKimNeedle1: TAspDButton;
    DKimNeedle2: TAspDButton;
    DKimNeedle3: TAspDButton;
    DKimNeedle4: TAspDButton;
    DKimNeedle5: TAspDButton;
    DKimNeedle6: TAspDButton;
    DKimNeedle7: TAspDButton;
    DKimNeedle8: TAspDButton;
    DKimNeedleClose: TAspDButton;
    DStateSsas: TAspDButton;
    DStateWinPulse: TAspDButton;
    DStateWinBatter: TAspDButton;
    DWinBatterTopMag1: TAspDButton;
    DWinBatterTopMag2: TAspDButton;
    DWinBatterTopMag3: TAspDButton;
    DWinBatterMag1: TAspDButton;
    DWinBatterMag2: TAspDButton;
    DWinBatterMag3: TAspDButton;
    DWinBatterMag4: TAspDButton;
    DWinBatterCom: TAspDButton;
    DWinBatterRandom: TAspDButton;
    DWinBatterSetKey: TAspDButton;
    DHeroStateSsas: TAspDButton;
    DWWhisper: TAspDWindow;
    DWhisperClose: TAspDButton;
    DMemoWhisperList: TAspDMemo;
    DMemoWhisperListScrollBar: TAspDMemoScrollBar;
    DCheckWhisper: TAspDCheckBox;
    DEdtWhisper: TAspDEdit;
    DHeroStateWinPulse: TAspDButton;
    DHeroStateWinBatter: TAspDButton;
    DHeroBatterTopMag1: TAspDButton;
    DHeroBatterTopMag2: TAspDButton;
    DHeroBatterTopMag3: TAspDButton;
    DHeroBatterRandom: TAspDButton;
    DHeroBatterCom: TAspDButton;
    DHeroBatterMag1: TAspDButton;
    DHeroBatterMag2: TAspDButton;
    DHeroBatterMag3: TAspDButton;
    DHeroBatterMag4: TAspDButton;
    DCheckMyHp: TAspDCheckBox;
    DCheckHeroBatterNotMob: TAspDCheckBox;
    HBExp: TAspDButton;
    JQExp: TAspDButton;
    DCheckDeputyHeroWarr: TAspDCheckBox;
    DCheckDeputyHeroWiz: TAspDCheckBox;
    DCheckDeputyHeroTaos: TAspDCheckBox;
    DCheckHeroDeputyHeroWarr: TAspDCheckBox;
    DCheckHeroDeputyHeroWiz: TAspDCheckBox;
    DCheckHeroDeputyHeroTaos: TAspDCheckBox;
    DWHeroAssess: TAspDWindow;
    DHeroAssessSign: TAspDButton;
    DHeroAssessClose: TAspDButton;
    DHeroAssessClose1: TAspDButton;
    DHeroAssessSign1: TAspDButton;
    DHeroAssessMenu: TAspDButton;
    DWHeroAutoPractice: TAspDWindow;
    DHeroAutoPracticeMemo: TAspDButton;
    DHeroAutoPraMapPrev: TAspDButton;
    DHeroAutoPraMapNext: TAspDButton;
    DHeroAutoPraYDSPrev: TAspDButton;
    DHeroAutoPraYDSNext: TAspDButton;
    DHeroAutoPraClose: TAspDButton;
    DStartHeroAutoPra: TAspDButton;
    DCheckHeroLevelHint: TAspDCheckBox;
    DHeroJQExp: TAspDButton;
    DWJenniferLongBox: TAspDWindow;
    DJenniferLongBoxClose: TAspDButton;
    DJLChangeItem: TAspDButton;
    DJLStartItem: TAspDButton;
    DJLBoxBelt1: TAspDButton;
    DJLBoxBelt2: TAspDButton;
    DJLBoxBelt3: TAspDButton;
    DJLBoxBelt4: TAspDButton;
    DJLBoxBelt5: TAspDButton;
    DJLBoxBelt6: TAspDButton;
    DJLBoxBelt7: TAspDButton;
    DJLBoxBelt8: TAspDButton;
    DJLBoxFlash: TAspDButton;
    DGJLBoxFreeItem: TAspDGrid;
    DListViewFilterItem: TAspDListView;
    DScrollBarFilterItem: TAspDScrollBar;
    DNewSdoFilterItem: TAspDButton;
    DCBFilterItemStdMode: TAspDComboBox;
    DEdtFilterItemStdMode: TAspDEdit;
    DBtnDefaultFilterItem: TAspDButton;
    DCheckBFilterItemPickUpAll: TAspDCheckBox;
    DWStall: TAspDWindow;
    DGStall: TAspDGrid;
    DBStallClose: TAspDButton;
    DEdtStallName: TAspDEdit;
    DBtnStallStart: TAspDButton;
    DBtnStallStop: TAspDButton;
    DWWStallPrice: TAspDWindow;
    DEdtWStallPrice: TAspDEdit;
    DBWStallPriceOK: TAspDButton;
    DBWStallPriceCancel: TAspDButton;
    DBWStallPriceClose: TAspDButton;
    DBWStallPriceTab1: TAspDButton;
    DBWStallPriceTab2: TAspDButton;
    DWUserStall: TAspDWindow;
    DGUserStall: TAspDGrid;
    DBUserStallClose: TAspDButton;
    DBBuyUserStallItem: TAspDButton;
    DWinBatterTopMag4: TAspDButton;
    DHeroBatterTopMag4: TAspDButton;
    DCheckScreenShake: TAspDCheckBox;
    DWMission: TAspDWindow;
    DBMissionClose: TAspDButton;
    DWMiniMap: TAspDMapMini;
    DTreeViewMission1: TAspDTreeView;
    DScrollBarMission1: TAspDScrollBar;
    DMemoMissionBottom: TAspDMemo;
    DMemoMissionBottomScrollBar: TAspDMemoScrollBar;
    DBMission1: TAspDButton;
    DBMission2: TAspDButton;
    DBMission3: TAspDButton;
    DBMissionClose1: TAspDButton;
    DCheckShowHeroStateNumber: TAspDCheckBox;
    DCheckShowSpecialDamage: TAspDCheckBox;
    DWSignedItems: TAspDWindow;
    DWSkillMemo: TAspDWindow;
    DWHeroSkillMemo: TAspDWindow;
    DBSkillMemoClose: TAspDButton;
    DBHeroSkillMemoClose: TAspDButton;
    DBSkillMemoIcon: TAspDButton;
    DBSkillMemoLink: TAspDButton;
    DBJDSee: TAspDButton;
    DBHeroSkillMemoIcon: TAspDButton;
    DBHeroSkillMemoLink: TAspDButton;
    DBHeroQSSSee: TAspDButton;
    DBSignedItem: TAspDButton;
    DBSignedChangeItem: TAspDButton;
    DBSignedMemo: TAspDButton;
    DBSignedChangeMemo: TAspDButton;
    DBSignedItemsClose: TAspDButton;
    DBSignedBelt1: TAspDButton;
    DBSignedBelt2: TAspDButton;
    DBOrdSigned: TAspDButton;
    DBHighSigned: TAspDButton;
    DBSignedChange: TAspDButton;
    DWJudgeItems: TAspDWindow;
    DBJudgeItem: TAspDButton;
    DBJudgeItemMemo: TAspDButton;
    DBJudgeBelt1: TAspDButton;
    DBJudgeStart: TAspDButton;
    DBJudgeItemsClose: TAspDButton;
    DWMakeSigned: TAspDWindow;
    DBMakeSignedRead: TAspDButton;
    DBMakeSignedMake: TAspDButton;
    DBMakeSignedReadMemo: TAspDButton;
    DBMakeSignedMakeMemo: TAspDButton;
    DBMakeSignedBelt1: TAspDButton;
    DBMakeSignedBelt2: TAspDButton;
    DBMakeSignedBelt3: TAspDButton;
    DBMakeSignedClose: TAspDButton;
    DBMakeSignedExp1: TAspDButton;
    DBMakeSignedExp2: TAspDButton;
    DBMakeSignedReadStart: TAspDButton;
    DBMakeSignedLeve1: TAspDButton;
    DBMakeSignedLeve2: TAspDButton;
    DBMakeSignedLeve3: TAspDButton;
    DBMakeSignedLeve4: TAspDButton;
    DBLevelOrderUseItem: TAspDButton;
    DBLevelOrderCloud: TAspDButton;
    DBOrderWeapon: TAspDButton;
    DBOrderRing: TAspDButton;
    DBOrderDress: TAspDButton;
    DBOrderBoots: TAspDButton;
    DBOrderHelmet: TAspDButton;
    DBOrderBelt: TAspDButton;
    DBOrderNecklace: TAspDButton;
    DBOrderMedal: TAspDButton;
    DBOrderWristlet: TAspDButton;
    DBOrderHat: TAspDButton;
    DBItemLevelBelt1: TAspDButton;
    DBItemLevelBelt2: TAspDButton;
    DBItemLevelBelt3: TAspDButton;
    DBItemLevelBelt4: TAspDButton;
    DBItemLevelBelt5: TAspDButton;
    DBItemLevelBelt6: TAspDButton;
    DBItemLevelBelt7: TAspDButton;
    DBItemLevelBelt8: TAspDButton;
    DBItemLevelBelt9: TAspDButton;
    DBItemLevelBelt10: TAspDButton;
    DCheckAutoDragInBody: TAspDCheckBox;
    DCheckHideHumanWing: TAspDCheckBox;
    DCheckHideWeaponEffect: TAspDCheckBox;
    DBNewSdoProtect1: TAspDButton;
    DScrollBoxPro: TAspDScrollBox;
    DLoginOk: TAspDButton;
    DLoginNew: TAspDButton;
    m_EdId: TAspDEdit;
    m_EdPasswd: TAspDEdit;
    DLoginClose: TAspDButton;
    DLoginChgPw: TAspDButton;
    DNewAccountOk: TAspDButton;
    DNewAccountCancel: TAspDButton;
    DNewAccountClose: TAspDButton;
    DSServer6: TAspDButton;
    DSServer5: TAspDButton;
    DSServer4: TAspDButton;
    DSServer3: TAspDButton;
    DSServer2: TAspDButton;
    DSServer1: TAspDButton;
    DSSrvClose: TAspDButton;
    DccOk: TAspDButton;
    DccClose: TAspDButton;
    DccRightHair: TAspDButton;
    DccLeftHair: TAspDButton;
    DccMale: TAspDButton;
    DccWarrior: TAspDButton;
    DccWizzard: TAspDButton;
    DccMonk: TAspDButton;
    DccReserved: TAspDButton;
    DccFemale: TAspDButton;
    DScrollBarPro: TAspDScrollBar;
    DLabelProCap: TAspDLabel;
    DLabel2: TAspDLabel;
    DCheckBoxBookHPPro: TAspDCheckBox;
    DEdtBookHPPro: TAspDEdit;
    DLabel3: TAspDLabel;
    DCBBookHPMan: TAspDComboBox;
    DCheckBoxBookMPPro: TAspDCheckBox;
    DEdtBookMPPro: TAspDEdit;
    DLabel4: TAspDLabel;
    DLabel5: TAspDLabel;
    DLabel6: TAspDLabel;
    DCheckBoxRenewHP: TAspDCheckBox;
    DEdtRenewHP: TAspDEdit;
    DEdtRenewHPTime: TAspDEdit;
    DCheckBoxRenewMP: TAspDCheckBox;
    DEdtRenewMp: TAspDEdit;
    DEdtRenewMpTime: TAspDEdit;
    DCheckBoxRenewHPSpecial: TAspDCheckBox;
    DEdtRenewHPSpecial: TAspDEdit;
    DEdtRenewHPSpecialTime: TAspDEdit;
    DCheckBoxRenewMPSpecial: TAspDCheckBox;
    DEdtRenewMPSpecial: TAspDEdit;
    DEdtRenewMPSpecialTime: TAspDEdit;
    DCheckBoxUseSuperMedica: TAspDCheckBox;
    DLabel7: TAspDLabel;
    DLabel8: TAspDLabel;
    DCheckBoxUseSuperMedicaItemName1: TAspDCheckBox;
    DEditSuperMedicaHP1: TAspDEdit;
    DEditSuperMedicaHPTime1: TAspDEdit;
    DEditSuperMedicaMP1: TAspDEdit;
    DEditSuperMedicaMPTime1: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName2: TAspDCheckBox;
    DEditSuperMedicaHP2: TAspDEdit;
    DEditSuperMedicaHPTime2: TAspDEdit;
    DEditSuperMedicaMP2: TAspDEdit;
    DEditSuperMedicaMPTime2: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName3: TAspDCheckBox;
    DEditSuperMedicaHP3: TAspDEdit;
    DEditSuperMedicaHPTime3: TAspDEdit;
    DEditSuperMedicaMP3: TAspDEdit;
    DEditSuperMedicaMPTime3: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName4: TAspDCheckBox;
    DEditSuperMedicaHP4: TAspDEdit;
    DEditSuperMedicaHPTime4: TAspDEdit;
    DEditSuperMedicaMP4: TAspDEdit;
    DEditSuperMedicaMPTime4: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName5: TAspDCheckBox;
    DEditSuperMedicaHP5: TAspDEdit;
    DEditSuperMedicaHPTime5: TAspDEdit;
    DEditSuperMedicaMP5: TAspDEdit;
    DEditSuperMedicaMPTime5: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName6: TAspDCheckBox;
    DEditSuperMedicaHP6: TAspDEdit;
    DEditSuperMedicaHPTime6: TAspDEdit;
    DEditSuperMedicaMP6: TAspDEdit;
    DEditSuperMedicaMPTime6: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName7: TAspDCheckBox;
    DEditSuperMedicaHP7: TAspDEdit;
    DEditSuperMedicaHPTime7: TAspDEdit;
    DEditSuperMedicaMP7: TAspDEdit;
    DEditSuperMedicaMPTime7: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName8: TAspDCheckBox;
    DEditSuperMedicaHP8: TAspDEdit;
    DEditSuperMedicaHPTime8: TAspDEdit;
    DEditSuperMedicaMP8: TAspDEdit;
    DEditSuperMedicaMPTime8: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName9: TAspDCheckBox;
    DEditSuperMedicaHP9: TAspDEdit;
    DEditSuperMedicaHPTime9: TAspDEdit;
    DEditSuperMedicaMP9: TAspDEdit;
    DEditSuperMedicaMPTime9: TAspDEdit;
    DCBBookMPMan: TAspDComboBox;
    DWQJPractice: TAspDWindow;
    DBQJPracticeClose: TAspDButton;
    DBQJPracticePage1: TAspDButton;
    DBQJPracticeStart: TAspDButton;
    DLQJPracticeLink1: TAspDLabel;
    DLQJPracticeLink2: TAspDLabel;
    DLQJPracticeLink3: TAspDLabel;
    DLQJPracticeLink4: TAspDLabel;
    DBQJPracticeItem: TAspDButton;
    DWQJFurnace: TAspDWindow;
    DBQJFurnaceClose: TAspDButton;
    DBQJFurnaceStart: TAspDButton;
    DCheckBoxUseSuperMedicaItemName10: TAspDCheckBox;
    DEditSuperMedicaHP10: TAspDEdit;
    DEditSuperMedicaHPTime10: TAspDEdit;
    DEditSuperMedicaMP10: TAspDEdit;
    DEditSuperMedicaMPTime10: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName11: TAspDCheckBox;
    DEditSuperMedicaHP11: TAspDEdit;
    DEditSuperMedicaHPTime11: TAspDEdit;
    DEditSuperMedicaMP11: TAspDEdit;
    DEditSuperMedicaMPTime11: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName12: TAspDCheckBox;
    DEditSuperMedicaHP12: TAspDEdit;
    DEditSuperMedicaHPTime12: TAspDEdit;
    DEditSuperMedicaMP12: TAspDEdit;
    DEditSuperMedicaMPTime12: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName13: TAspDCheckBox;
    DEditSuperMedicaHP13: TAspDEdit;
    DEditSuperMedicaHPTime13: TAspDEdit;
    DEditSuperMedicaMP13: TAspDEdit;
    DEditSuperMedicaMPTime13: TAspDEdit;
    DCheckBoxUseSuperMedicaItemName14: TAspDCheckBox;
    DEditSuperMedicaHP14: TAspDEdit;
    DEditSuperMedicaHPTime14: TAspDEdit;
    DEditSuperMedicaMP14: TAspDEdit;
    DEditSuperMedicaMPTime14: TAspDEdit;
    DLabel9: TAspDLabel;
    DScrollBoxKey: TAspDScrollBox;
    DScrollBarKey: TAspDScrollBar;
    DCheckSdoStartKey: TAspDCheckBox;
    DLabel10: TAspDLabel;
    DLabel11: TAspDLabel;
    DScrollBoxKeySurface: TAspDButton;
    DBtnSdoCallHeroKey: TAspDButton;
    DBtnSdoHeroAttackTargetKey: TAspDButton;
    DBtnSdoHeroGotethKey: TAspDButton;
    DBtnSdoHeroStateKey: TAspDButton;
    DBtnSdoHeroGuardKey: TAspDButton;
    DBtnSdoAttackModeKey: TAspDButton;
    DBtnSdoMinMapKey: TAspDButton;
    DBtnSdoSeriesKillKey: TAspDButton;
    DBtnSdoCallHero1Key: TAspDButton;
    DBTitleMan: TAspDButton;
    DBTitle1: TAspDButton;
    DBTitle2: TAspDButton;
    DBTitle3: TAspDButton;
    DBTitle4: TAspDButton;
    DBPrevTitle: TAspDButton;
    DBNextTitle: TAspDButton;
    DBUserTitleMan: TAspDButton;
    DBUserTitle1: TAspDButton;
    DBUserTitle2: TAspDButton;
    DBUserTitle3: TAspDButton;
    DBUserTitle4: TAspDButton;
    DBUserPrevTitle: TAspDButton;
    DBUserNextTitle: TAspDButton;
    DWPFLingPai: TAspDWindow;
    DLPFLingPaiPrev: TAspDLabel;
    DLPFLingPaiDown: TAspDLabel;
    DBPFLingPaiIcon1: TAspDButton;
    DBPFLingPaiIcon2: TAspDButton;
    DBPFLingPaiIcon3: TAspDButton;
    DBPFLingPaiIcon4: TAspDButton;
    DBPFLingPaiIcon5: TAspDButton;
    DBPFLingPaiClose: TAspDButton;
    DBPFLingPaiName1: TAspDButton;
    DBPFLingPaiName2: TAspDButton;
    DBPFLingPaiName3: TAspDButton;
    DBPFLingPaiName4: TAspDButton;
    DBPFLingPaiName5: TAspDButton;
    DBPFLingPaiCall1: TAspDButton;
    DBPFLingPaiCall2: TAspDButton;
    DBPFLingPaiCall3: TAspDButton;
    DBPFLingPaiCall4: TAspDButton;
    DBPFLingPaiCall5: TAspDButton;
    DBPFLingPaiMove1: TAspDButton;
    DBPFLingPaiMove2: TAspDButton;
    DBPFLingPaiMove3: TAspDButton;
    DBPFLingPaiMove4: TAspDButton;
    DBPFLingPaiMove5: TAspDButton;
    DWZZLingPai: TAspDWindow;
    DLabel12: TAspDLabel;
    DBZZLingPaiTab1: TAspDButton;
    DBZZLingPaiTab3: TAspDButton;
    DBZZLingPaiTab2: TAspDButton;
    DMZZLingPai: TAspDMemo;
    DMZZLingPaiScrollBar: TAspDMemoScrollBar;
    DBZZLingPaiIcon1: TAspDButton;
    DBZZLingPaiIcon2: TAspDButton;
    DBZZLingPaiIcon3: TAspDButton;
    DBZZLingPaiIcon4: TAspDButton;
    DBZZLingPaiIcon5: TAspDButton;
    DLZZLingPaiPrev: TAspDLabel;
    DLZZLingPaiDown: TAspDLabel;
    DBZZLingPaiName5: TAspDButton;
    DBZZLingPaiName4: TAspDButton;
    DBZZLingPaiName3: TAspDButton;
    DBZZLingPaiName2: TAspDButton;
    DBZZLingPaiName1: TAspDButton;
    DBZZLingPaiCall1: TAspDButton;
    DBZZLingPaiCall2: TAspDButton;
    DBZZLingPaiCall3: TAspDButton;
    DBZZLingPaiCall4: TAspDButton;
    DBZZLingPaiCall5: TAspDButton;
    DBZZLingPaiMove5: TAspDButton;
    DBZZLingPaiMove4: TAspDButton;
    DBZZLingPaiMove3: TAspDButton;
    DBZZLingPaiMove2: TAspDButton;
    DBZZLingPaiMove1: TAspDButton;
    DLabel15: TAspDLabel;
    DBZZLingPaiClose: TAspDButton;
    DBZZLingPaiMapName1: TAspDButton;
    DBZZLingPaiMapName2: TAspDButton;
    DBZZLingPaiMapName3: TAspDButton;
    DBZZLingPaiMapName4: TAspDButton;
    DBZZLingPaiMapName5: TAspDButton;
    DBZZLingPaiMapName6: TAspDButton;
    DBZZLingPaiMapName7: TAspDButton;
    DBZZLingPaiMapName8: TAspDButton;
    DBZZLingPaiMapName9: TAspDButton;
    DBZZLingPaiMapName10: TAspDButton;
    DBZZLingPaiMapName11: TAspDButton;
    DBZZLingPaiMapName12: TAspDButton;
    DBZZLingPaiMapName13: TAspDButton;
    DBZZLingPaiMapName14: TAspDButton;
    DBZZLingPaiMapName15: TAspDButton;
    DBZZLingPaiMapName16: TAspDButton;
    DBZZLingPaiMapName17: TAspDButton;
    DBZZLingPaiMapName18: TAspDButton;
    DCheckBoxHideTitle: TAspDCheckBox;
    DCheckBoxHideShiti: TAspDCheckBox;
    DLNGUpLevel1: TAspDLabel;
    DLNGUpLevel2: TAspDLabel;
    DLNGUpLevel3: TAspDLabel;
    DLNGUpLevel4: TAspDLabel;
    DLNGUpLevel5: TAspDLabel;
    DLNGUpLevel6: TAspDLabel;
    DLHeroNGUpLevel1: TAspDLabel;
    DLHeroNGUpLevel2: TAspDLabel;
    DLHeroNGUpLevel3: TAspDLabel;
    DLHeroNGUpLevel4: TAspDLabel;
    DLHeroNGUpLevel5: TAspDLabel;
    DLHeroNGUpLevel6: TAspDLabel;
    DWPetLog: TAspDWindow;
    DBPetLogClose: TAspDButton;
    DLPetLogPagePrv: TAspDLabel;
    DLPetLogPageNext: TAspDLabel;
    DLPetLogMove: TAspDLabel;
    DCheckSdoPosLongHit: TAspDCheckBox;
    DWFactionDlg: TAspDWindow;
    DLFactionDlgHome: TAspDLabel;
    DLFactionDlgList: TAspDLabel;
    DLFactionDlgExit: TAspDLabel;
    DLFactionDlgEditNotice: TAspDLabel;
    DLFactionDlgManageApply: TAspDLabel;
    DLFactionDlgGetTitle: TAspDLabel;
    DLFactionDlgKick: TAspDLabel;
    DBFactionDlgClose: TAspDButton;
    DWFactionAddDlg: TAspDWindow;
    DLFactionAddPrev: TAspDLabel;
    DLFactionAddNext: TAspDLabel;
    DLFactionAddQuery: TAspDLabel;
    DLFactionApplyAdd1: TAspDLabel;
    DLFactionApplyAdd2: TAspDLabel;
    DLFactionApplyAdd3: TAspDLabel;
    DLFactionApplyAdd4: TAspDLabel;
    DLFactionApplyAdd5: TAspDLabel;
    DBFactionAddDlgClose: TAspDButton;
    DEditFactionAddQuery: TAspDEdit;
    DWFactionApplyManage: TAspDWindow;
    DLFactionApplyManageAllSel: TAspDLabel;
    DLFactionApplyManageNotAllSel: TAspDLabel;
    DWFactionApplyManageClose: TAspDButton;
    DLFactionApplyManageAgree: TAspDLabel;
    DLFactionApplyManageRefuse: TAspDLabel;
    DGridFactionApplySel: TAspDGrid;
    DWFactionDlgEditNotice: TAspDWindow;
    DBFactionDlgEditNoticeClose: TAspDButton;
    DLFactionDlgEditNoticeOK: TAspDLabel;
    DWLingWUXinFa: TAspDWindow;
    DLLingWUXinFa: TAspDLabel;
    DLXinFaHelp: TAspDLabel;
    DLXinFaMakeName: TAspDLabel;
    DLHelpXinfa: TAspDLabel;
    DLLingwuZhaoshi: TAspDLabel;
    DLXinFaChangeSelName: TAspDLabel;
    DBLingWUXinFaClose: TAspDButton;
    DBLingWuXinFaName: TAspDButton;
    DBXinFaNamePrev: TAspDButton;
    DBXinFaNameNext: TAspDButton;
    DWNewStateWin: TAspDWindow;
    DBNewStateTab1: TAspDButton;
    DBNewStateTab2: TAspDButton;
    DBNewStateTab3: TAspDButton;
    DBNewStateWinClose: TAspDButton;
    DPNewStateWinTab: TAspDPageControl;
    DWNewStateWinTab1: TAspDWindow;
    DPNewStateWinPage: TAspDPageControl;
    DWNewStateWinPageTab1: TAspDWindow;
    DBNewSWHelmet: TAspDButton;
    DBNewSWDress: TAspDButton;
    DBNewSWLight: TAspDButton;
    DBNewSWArmRingR: TAspDButton;
    DBNewSWRingR: TAspDButton;
    DBNewSWNecklace: TAspDButton;
    DBNewSWArmRingL: TAspDButton;
    DBNewSWRingL: TAspDButton;
    DBNewSWBujuk: TAspDButton;
    DBNewSWBelt: TAspDButton;
    DBNewSWBoots: TAspDButton;
    DBNewSWDrum: TAspDButton;
    DBNewSWCharm: TAspDButton;
    DBNewSWWeapon: TAspDButton;
    DWNewStateWinPageTab2: TAspDWindow;
    DBNewLiquorProgress: TAspDButton;
    DWNewStateWinPageTab3: TAspDWindow;
    DWNewStateWinPageTab4: TAspDWindow;
    DBNewTitleMan: TAspDButton;
    DBNewTitle1: TAspDButton;
    DBNewTitle2: TAspDButton;
    DBNewTitle3: TAspDButton;
    DBNewTitle4: TAspDButton;
    DBNewTitle5: TAspDButton;
    DBNewPrevTitle: TAspDButton;
    DBNewNextTitle: TAspDButton;
    DWNewStateWinPageTab5: TAspDWindow;
    DBNewStMag1: TAspDButton;
    DBNewStMag2: TAspDButton;
    DBNewStMag3: TAspDButton;
    DBNewStMag4: TAspDButton;
    DBNewStMag5: TAspDButton;
    DBNewStPageUp: TAspDButton;
    DBNewStPageDown: TAspDButton;
    DBNewJDSee: TAspDButton;
    DBNewHBExp: TAspDButton;
    DBNewJQExp: TAspDButton;
    DWNewStateWinPageTab6: TAspDWindow;
    DCheckNewDeputyHeroWarr: TAspDCheckBox;
    DCheckNewDeputyHeroWiz: TAspDCheckBox;
    DCheckNewDeputyHeroTaos: TAspDCheckBox;
    DBNewStateWinPage: TAspDButton;
    DWNewStateWinTab2: TAspDWindow;
    DBNewStateWinNGPage: TAspDButton;
    DPNewStateWinNGPage: TAspDPageControl;
    DWNewStateWinNGPageTab1: TAspDWindow;
    DWNewStateWinNGPageTab2: TAspDWindow;
    DBNewStNGMag1: TAspDButton;
    DBNewStNGMag2: TAspDButton;
    DBNewStNGMag3: TAspDButton;
    DBNewStNGMag4: TAspDButton;
    DBNewStNGMag5: TAspDButton;
    DBNewStNGPageUp: TAspDButton;
    DBNewStNGPageDown: TAspDButton;
    DLNewNGUpLevel1: TAspDLabel;
    DLNewNGUpLevel2: TAspDLabel;
    DLNewNGUpLevel3: TAspDLabel;
    DLNewNGUpLevel4: TAspDLabel;
    DLNewNGUpLevel5: TAspDLabel;
    DWNewStateWinNGPageTab3: TAspDWindow;
    DBNewWinPointIcon1: TAspDButton;
    DBNewWinPointIcon2: TAspDButton;
    DBNewWinPointIcon3: TAspDButton;
    DBNewWinPointIcon4: TAspDButton;
    DBNewWinPointIcon5: TAspDButton;
    DLNewWinPointName1: TAspDLabel;
    DLNewWinPointName2: TAspDLabel;
    DLNewWinPointName3: TAspDLabel;
    DLNewWinPointName4: TAspDLabel;
    DLNewWinPointName5: TAspDLabel;
    DBNewWinPointPage1: TAspDButton;
    DBNewWinPointPage2: TAspDButton;
    DBNewWinPointPage3: TAspDButton;
    DBNewWinPointPage4: TAspDButton;
    DBNewWinPointPage5: TAspDButton;
    DBNewWinPointPractice: TAspDButton;
    DWNewStateWinNGPageTab4: TAspDWindow;
    DBNewWinBatterTopMag1: TAspDButton;
    DBNewWinBatterTopMag2: TAspDButton;
    DBNewWinBatterTopMag3: TAspDButton;
    DBNewWinBatterTopMag4: TAspDButton;
    DBNewWinBatterRandom: TAspDButton;
    DBNewWinBatterSetKey: TAspDButton;
    DBNewWinBatterMag1: TAspDButton;
    DBNewWinBatterMag2: TAspDButton;
    DBNewWinBatterMag3: TAspDButton;
    DBNewWinBatterMag4: TAspDButton;
    DBNewWinBatterCom: TAspDButton;
    DWNewStateWinTab3: TAspDWindow;
    DBNewStateWinXFPage: TAspDButton;
    DPNewStateWinXFPage: TAspDPageControl;
    DWNewStateWinXFPageTab1: TAspDWindow;
    DBXinFaExp: TAspDButton;
    DBXinFaAbdomenMouseHint: TAspDButton;
    DMemoXinFaHint: TAspDMemo;
    DWNewStateWinXFPageTab2: TAspDWindow;
    DBWinXinFaMag1: TAspDButton;
    DBWinXinFaMag2: TAspDButton;
    DBWinXinFaMag3: TAspDButton;
    DBWinXinFaMag4: TAspDButton;
    DBWinXinFaMag5: TAspDButton;
    DBWinXinFaMagPageUp: TAspDButton;
    DBWinXinFaMagPageDown: TAspDButton;
    DWNewStateHero: TAspDWindow;
    DBNewStateHeroTab1: TAspDButton;
    DBNewStateHeroTab2: TAspDButton;
    DBNewStateHeroClose: TAspDButton;
    DPNewStateHeroTab: TAspDPageControl;
    DWNewStateHeroTab1: TAspDWindow;
    DPNewStateHeroPage: TAspDPageControl;
    DWNewStateHeroPageTab1: TAspDWindow;
    DBNewSHHelmet: TAspDButton;
    DBNewSHDress: TAspDButton;
    DBNewSHLight: TAspDButton;
    DBNewSHArmRingR: TAspDButton;
    DBNewSHRingR: TAspDButton;
    DBNewSHNecklace: TAspDButton;
    DBNewSHArmRingL: TAspDButton;
    DBNewSHRingL: TAspDButton;
    DBNewSHBujuk: TAspDButton;
    DBNewSHBelt: TAspDButton;
    DBNewSHBoots: TAspDButton;
    DBNewSHDrum: TAspDButton;
    DBNewSHCharm: TAspDButton;
    DBNewSHWeapon: TAspDButton;
    DWNewStateHeroPageTab2: TAspDWindow;
    DBNewHeroLiquorProgress: TAspDButton;
    DWNewStateHeroPageTab3: TAspDWindow;
    DWNewStateHeroPageTab5: TAspDWindow;
    DBNewHeroStMag1: TAspDButton;
    DBNewHeroStMag2: TAspDButton;
    DBNewHeroStMag3: TAspDButton;
    DBNewHeroStMag4: TAspDButton;
    DBNewHeroStMag5: TAspDButton;
    DBNewHeroStPageUp: TAspDButton;
    DBNewHeroStPageDown: TAspDButton;
    DBNewHeroJQExp: TAspDButton;
    DBNewStateHeroPage: TAspDButton;
    DWNewStateHeroTab2: TAspDWindow;
    DBNewStateHeroNGPage: TAspDButton;
    DPNewStateHeroNGPage: TAspDPageControl;
    DWNewStateHeroNGPageTab1: TAspDWindow;
    DWNewStateHeroNGPageTab2: TAspDWindow;
    DBNewHeroStNGMag1: TAspDButton;
    DBNewHeroStNGMag2: TAspDButton;
    DBNewHeroStNGMag3: TAspDButton;
    DBNewHeroStNGMag4: TAspDButton;
    DBNewHeroStNGMag5: TAspDButton;
    DBNewHeroStNGPageUp: TAspDButton;
    DBNewHeroStNGPageDown: TAspDButton;
    DLNewHeroNGUpLevel1: TAspDLabel;
    DLNewHeroNGUpLevel2: TAspDLabel;
    DLNewHeroNGUpLevel3: TAspDLabel;
    DLNewHeroNGUpLevel4: TAspDLabel;
    DLNewHeroNGUpLevel5: TAspDLabel;
    DWNewStateHeroNGPageTab3: TAspDWindow;
    DBNewHeroPointIcon1: TAspDButton;
    DBNewHeroPointIcon2: TAspDButton;
    DBNewHeroPointIcon3: TAspDButton;
    DBNewHeroPointIcon4: TAspDButton;
    DBNewHeroPointIcon5: TAspDButton;
    DLNewHeroPointName1: TAspDLabel;
    DLNewHeroPointName2: TAspDLabel;
    DLNewHeroPointName3: TAspDLabel;
    DLNewHeroPointName4: TAspDLabel;
    DLNewHeroPointName5: TAspDLabel;
    DBNewHeroPointPage1: TAspDButton;
    DBNewHeroPointPage2: TAspDButton;
    DBNewHeroPointPage3: TAspDButton;
    DBNewHeroPointPage4: TAspDButton;
    DBNewHeroPointPage5: TAspDButton;
    DBNewHeroPointPractice: TAspDButton;
    DWNewStateHeroNGPageTab4: TAspDWindow;
    DBNewHeroBatterTopMag1: TAspDButton;
    DBNewHeroBatterTopMag2: TAspDButton;
    DBNewHeroBatterTopMag3: TAspDButton;
    DBNewHeroBatterTopMag4: TAspDButton;
    DBNewHeroBatterRandom: TAspDButton;
    DBNewHeroBatterMag1: TAspDButton;
    DBNewHeroBatterMag2: TAspDButton;
    DBNewHeroBatterMag3: TAspDButton;
    DBNewHeroBatterMag4: TAspDButton;
    DBNewHeroBatterCom: TAspDButton;
    DWNewStateUser: TAspDWindow;
    DLNewStateUserName: TAspDLabel;
    DBNewStateUserClose: TAspDButton;
    DPNewStateUserTab: TAspDPageControl;
    DWNewStateUserTab1: TAspDWindow;
    DPNewStateUserPage: TAspDPageControl;
    DWNewStateUserPageTab1: TAspDWindow;
    DBNewSUHelmet: TAspDButton;
    DBNewSUDress: TAspDButton;
    DBNewSULight: TAspDButton;
    DBNewSUArmRingR: TAspDButton;
    DBNewSURingR: TAspDButton;
    DBNewSUNecklace: TAspDButton;
    DBNewSUArmRingL: TAspDButton;
    DBNewSURingL: TAspDButton;
    DBNewSUBujuk: TAspDButton;
    DBNewSUBelt: TAspDButton;
    DBNewSUBoots: TAspDButton;
    DBNewSUDrum: TAspDButton;
    DBNewSUCharm: TAspDButton;
    DLNewStateUserGuildName: TAspDLabel;
    DBNewSUWeapon: TAspDButton;
    DWNewStateUserPageTab2: TAspDWindow;
    DBNewUserTitleMan: TAspDButton;
    DBNewUserTitle1: TAspDButton;
    DBNewUserTitle2: TAspDButton;
    DBNewUserTitle3: TAspDButton;
    DBNewUserTitle4: TAspDButton;
    DBNewUserTitle5: TAspDButton;
    DBNewUserPrevTitle: TAspDButton;
    DBNewUserNextTitle: TAspDButton;
    DBNewStateUserPage: TAspDButton;
    DWLingWuXinFaKey: TAspDWindow;
    DLLingWuXinFaKeyNext: TAspDLabel;
    DLLingWuXinFaKeyOK: TAspDLabel;
    DLLingWuXinFaKeyChange: TAspDLabel;
    DLLingWuXinFaKeyPrev: TAspDLabel;
    DGridLingWuXinFaKey: TAspDGrid;
    DBLingWuXinFaKeyClose: TAspDButton;
    DBInternet: TAspDButton;
    DBelt1: TAspDButton;
    DBelt2: TAspDButton;
    DBelt3: TAspDButton;
    DBelt4: TAspDButton;
    DBelt5: TAspDButton;
    DBelt6: TAspDButton;
    DBotMiniMap: TAspDButton;
    DBotTrade: TAspDButton;
    DBotGuild: TAspDButton;
    DBotGroup: TAspDButton;
    DBotPlusAbil: TAspDButton;
    DBotFriend: TAspDButton;
    Challenge: TAspDButton;
    DBotFaction: TAspDButton;
    CharacterSranking: TAspDButton;
    DBWhisper: TAspDButton;
    DBotStall: TAspDButton;
    DBotLogout: TAspDButton;
    DBotExit: TAspDButton;
    DBHelp: TAspDButton;
    DBMission: TAspDButton;
    DBCallHero: TAspDButton;
    DBHeroState: TAspDButton;
    DBHeroPackage: TAspDButton;
    DBCallDeputyHero: TAspDButton;
    DBXinfaExpAbsorb: TAspDButton;
    DBGlory: TAspDButton;
    DMyState: TAspDButton;
    DMyBag: TAspDButton;
    DMyMagic: TAspDButton;
    DOption: TAspDButton;
    DBRefuseguild: TAspDButton;
    DBRefuseWHISPER: TAspDButton;
    DBRefuseCRY: TAspDButton;
    DBRefusePublicChat: TAspDButton;
    DBLingMeiBelt: TAspDButton;
    DButtonHP: TAspDButton;
    DDrunkScale: TAspDButton;
    DButtonMP: TAspDButton;
    DWBottomLeft: TAspDWindow;
    DChatMemo: TAspDChatMemo;
    DWBottomRight: TAspDWindow;
    DWBottomCenter: TAspDWindow;
    DBCommandFrame: TAspDButton;
    DBatterShowImg: TAspDButton;
    DBHeroSpleenImg: TAspDButton;
    DBotMemo: TAspDButton;
    DHeroRoleIcon: TAspDButton;
    DHeroIcon: TAspDWindow;
    DBAutoCRY: TAspDButton;
    DBCommand: TAspDButton;
    DMemoXinFaHintScrollBar: TAspDMemoScrollBar;
    DMsgDlgGameGoldBuy: TAspDButton;
    DMsgDlgGamePointBuy: TAspDButton;
    DWRefineDrum: TAspDWindow;
    DBRefineDrumCloseBtn: TAspDButton;
    DBRefineDrumOKBtn: TAspDButton;
    RefineBtn2: TAspDButton;
    RefineBtn3: TAspDButton;
    RefineBtn4: TAspDButton;
    RefineBtn5: TAspDButton;
    RefineBtn1: TAspDButton;
    RefineBtn6: TAspDButton;
    DBigMerchantDlgClose: TAspDButton;
    DBigMerchantDlg: TAspDWindow;
    DWBottomCenterFir: TAspDWindow;


    procedure DMyStateDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DOptionClick();
    procedure DItemBagDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DItemsUpButDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStateWinDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure FormCreate(Sender: TObject);
    procedure DPrevStateDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLoginNewDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DscSelect1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DccCloseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DItemGridGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DItemGridDblClick(Sender: TObject);
    procedure DMsgDlgOkDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMsgDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMsgDlgKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DCloseBagDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBackgroundBackgroundClick(Sender: TObject);
    procedure DItemGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure FormDestroy(Sender: TObject);
    procedure DBelt1DblClick(Sender: TObject);
    procedure DLoginCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLoginOkClick(Sender: TObject; X, Y: Integer);
    procedure DLoginNewClick(Sender: TObject; X, Y: Integer);
    procedure DLoginChgPwClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountOkClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
    procedure DccCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgpwOkClick(Sender: TObject; X, Y: Integer);
    procedure DscSelect1Click(Sender: TObject; X, Y: Integer);
    procedure DCloseStateClick(Sender: TObject; X, Y: Integer);
    procedure DPrevStateClick(Sender: TObject; X, Y: Integer);
    procedure DNextStateClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponClick(Sender: TObject; X, Y: Integer);//移动英雄装备物品
    procedure HeroPageChanged;
    procedure HeroInternalForcePageChanged;
    procedure DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DCloseBagClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DMyStateClick(Sender: TObject; X, Y: Integer);
    procedure DStateWinClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMerchantDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMerchantDlgShowText(Sender: TObject; Msg, SelectStr: string; X, Y: Word;
      Points: TList; var AddPoints: Boolean);
    procedure DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    function DMerchantDlgSelect(const RStr, sTitle: string; var LStr: string): Boolean;
    procedure DMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMenuCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMenuDlgClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DSellDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DMenuBuyClick(Sender: TObject; X, Y: Integer);
    procedure DMenuPrevClick(Sender: TObject; X, Y: Integer);
    procedure DMenuNextClick(Sender: TObject; X, Y: Integer);
    procedure DGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSWLightDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSHLightDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);  //显示英雄装备    $010
    procedure DBackgroundMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLoginNewClickSound(Sender: TObject;
      Clicksound: TClickSound);
    procedure DStMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DKsIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DKsF1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DKsOkClick(Sender: TObject; X, Y: Integer);
    procedure DKsF1Click(Sender: TObject; X, Y: Integer);
    procedure DKeySelDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBotGroupDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGrpAllowGroupDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpCreateClick(Sender: TObject; X, Y: Integer);
    procedure DGroupDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGrpAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGrpDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DBotLogoutClick(Sender: TObject; X, Y: Integer);
    procedure DBotExitClick(Sender: TObject; X, Y: Integer);
    procedure DStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBottomMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DDealOkClick(Sender: TObject; X, Y: Integer);
    procedure DDealCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotTradeClick(Sender: TObject; X, Y: Integer);
    procedure DDealRemoteDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DDealDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DDGridGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DDGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DDRGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSServer1Click(Sender: TObject; X, Y: Integer);
    procedure DSSrvCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotMiniMapClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUserState1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCloseUS1Click(Sender: TObject; X, Y: Integer);
    procedure DNecklaceUS1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBotGuildClick(Sender: TObject; X, Y: Integer);
    procedure DGuildDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGDUpClick(Sender: TObject; X, Y: Integer);
    procedure DGDDownClick(Sender: TObject; X, Y: Integer);
    procedure DGDCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGDHomeClick(Sender: TObject; X, Y: Integer);
    procedure DGDListClick(Sender: TObject; X, Y: Integer);
    procedure DGDAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditGradeClick(Sender: TObject; X, Y: Integer);
    procedure DGECloseClick(Sender: TObject; X, Y: Integer);
    procedure DGEOkClick(Sender: TObject; X, Y: Integer);
    procedure DGuildEditNoticeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGDChatClick(Sender: TObject; X, Y: Integer);
    procedure DGoldDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DNewAccountDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilityDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
    procedure DPlusDCClick(Sender: TObject; X, Y: Integer);
    procedure DMinusDCClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
    procedure DBotPlusAbilDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DUserState1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DGDAllyClick(Sender: TObject; X, Y: Integer);
    procedure DGDBreakAllyClick(Sender: TObject; X, Y: Integer);

    procedure DFrdFriendDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBotFriendClick(Sender: TObject; X, Y: Integer);
    procedure DFrdCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgGamePwdDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);

    procedure DCloseHeroStateClick(Sender: TObject; X, Y: Integer); //$008 2007.10.21
    procedure DStateHeroDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCloseHeroStateDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSHWeaponMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
    procedure HeroPackageClick(Sender: TObject; X, Y: Integer);
    procedure DNextStateHeroClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemBagDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DHeroItemGridCloseClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DHeroItemGridGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DHeroItemGridDblClick(Sender: TObject);
    function HeroIcon(sex:integer;job:integer):integer;
    procedure DHeroRoleIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroSpleenImgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPrevStateHeroClick(Sender: TObject; X, Y: Integer);
    procedure DSHPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DHeroIconClick(Sender: TObject; X, Y: Integer);
    procedure DStMagHero1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStateHeroMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBotMemoClick(Sender: TObject; X, Y: Integer);
    procedure ShopStrWord(s:string;dsurface: TAsphyreCanvas; x,y:integer);//取|符号 左右边的内容
    procedure DShopDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DShopCloseClick(Sender: TObject; X, Y: Integer);
    procedure DShopImg1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DShopNextClick(Sender: TObject; X, Y: Integer);
    procedure DShopDecorateClick(Sender: TObject; X, Y: Integer);
    procedure DShopImg1Click(Sender: TObject; X, Y: Integer);
    procedure Itemstrorlist(str:string; WIDTH,HEIGH:integer);
    procedure DShopBuyClick(Sender: TObject; X, Y: Integer);
    procedure DShopSpeciallyImg1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DShopSpeciallyImg1Click(Sender: TObject; X, Y: Integer);
    //Shop 物品动画演示
    procedure ShopGifInfo(dsurface: TAsphyreCanvas;dx,dy,ShopGifBegin,ShopGifEnd:integer);
    procedure DShopPresentClick(Sender: TObject; X, Y: Integer);
    procedure CharacterSrankingClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderCloseClick(Sender: TObject; X, Y: Integer);
    procedure DIndividualOrderClick(Sender: TObject; X, Y: Integer);
    procedure DHeroOrderClick(Sender: TObject; X, Y: Integer);
    procedure DWLevelOrderDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DColonyHeroOrderClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAllOrderClick(Sender: TObject; X, Y: Integer);
    procedure DMasterOrderClick(Sender: TObject; X, Y: Integer);
    procedure DMyLevelOrderClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderIndexClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderLastPageClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderNextClick(Sender: TObject; X, Y: Integer);
    procedure DBottomMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure typeTimeimg; //英雄怒气变换函数
    procedure DPlayGameNum();
    procedure ItemLightTimeImg();//物品发光变换函数 20080223
//    procedure JNItemLightTimeImg(btType: Byte);//金牛物品发光   0为首饰发光， 1为头盔发光
    function StateItemEffect(btType: Byte): Integer; //内观物品发光
    procedure BoxsFlash(Button: TAspDButton;dsurface: TAsphyreCanvas);
    procedure BoxsFillFlash(Button: TAspDButton;dsurface: TAsphyreCanvas);//宝箱填充物品动画
    procedure BoxsRandomImg;
    procedure BoxsRunning(dsurface: TAsphyreCanvas);
    procedure JLBoxRunning(dsurface: TAsphyreCanvas);//珍珑宝箱更换奖励
    procedure JLBoxFreeRunning(dsurface: TAsphyreCanvas); //珍珑免费宝箱翻牌
    procedure DBoxsDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBoxsClick(Sender: TObject; X, Y: Integer);
    procedure DBoxsBelt5DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBoxsBelt5MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBoxsTautologyClick(Sender: TObject; X, Y: Integer);
    procedure DBoxsTautologyMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBoxsBelt1DblClick(Sender: TObject);
    procedure DLieDragonDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonCloseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLieDragonNextPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonPrevPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonNextPageClick(Sender: TObject; X, Y: Integer);
    procedure DGoToLieDragonDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonNpcDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonNpcCloseClick(Sender: TObject; X, Y: Integer);
    procedure ShowBoxsGird(Show: Boolean; IsNewBoxs:Byte);
    procedure DGoToLieDragonClick(Sender: TObject; X, Y: Integer);
    procedure DItemsUpButMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DItemsUpButClick(Sender: TObject; X, Y: Integer);
    procedure DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCIDSpleenDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DButton4DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);


    procedure DSHWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DHelpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGameGirdExchangeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGameGirdExchangeClick(Sender: TObject; X, Y: Integer);
    procedure DWLevelOrderClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffItemGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DSellOffItemGridGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
      dsurface: TAsphyreCanvas);
    procedure DSellOffItemGridGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DWSellOffDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSellOffOkClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffCancelClick(Sender: TObject; X, Y: Integer);
    procedure ShowSellOffListDlg;
    procedure DEditSellOffNameClick(Sender: TObject; X, Y: Integer);
    procedure DEditSellOffNumClick(Sender: TObject; X, Y: Integer);
    procedure DEditSellOffNameDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DEditSellOffNumDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSellOffListColseClick(Sender: TObject; X, Y: Integer);
    procedure DWSellOffListDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSellOffItem0DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSellOffItem0Click(Sender: TObject; X, Y: Integer);
    procedure DSellOffListCancelClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffBuyCancelClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffBuyClick(Sender: TObject; X, Y: Integer);
    procedure DWGameGoldMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DSelectChrMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCIDSpleenMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUserState1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroIconMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBoxsTautologyDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DItemsUpBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DItemsUpBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DItemsUpOkClick(Sender: TObject; X, Y: Integer);
    procedure DItemsUpBelt1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DItemsUpCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGetHeroCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSelHero1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPlayDrinkDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure ChallengeClick(Sender: TObject; X, Y: Integer);
    procedure DDrink1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWiGetHeroDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSelHero1Click(Sender: TObject; X, Y: Integer);
    procedure DPlayFistClick(Sender: TObject; X, Y: Integer);
    procedure DPlayDrinkCloseDirctPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPlayDrinkMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DPlayDrinkMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DPlayDrinkClick(Sender: TObject; X, Y: Integer);
    procedure DWPleaseDrinkDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPDrink1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPlayDrinkCloseClick(Sender: TObject; X, Y: Integer);
    procedure DPlayDrinkFistClick(Sender: TObject; X, Y: Integer);
    procedure DPlayDrinkNpcNumDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPlayDrinkPlayNumDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DPlayDrinkWhoWinDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas); //显示寄售列表界面 20080317
    procedure ShowPlayDrinkImg(Show: Boolean);
    procedure DPlayDrinkFistDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DPlayDrinkMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DDrink1Click(Sender: TObject; X, Y: Integer);
    procedure DPDrink1Click(Sender: TObject; X, Y: Integer);
    procedure DPDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWPleaseDrinkMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DPleaseDrinkExitClick(Sender: TObject; X, Y: Integer);
    procedure DPleaseDrinkDrinkClick(Sender: TObject; X, Y: Integer);
    procedure DWPleaseDrinkClick(Sender: TObject; X, Y: Integer);
    procedure DWPleaseDrinkMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWPleaseDrinkMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DLOGODirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLOGOClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgFrdDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DFriendDlgFrdClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DFriendListDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DFriendListDblClick(Sender: TObject);
    procedure DFriendListMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DPrevFriendDlgClick(Sender: TObject; X, Y: Integer);
    procedure DAddFriendClick(Sender: TObject; X, Y: Integer);
    procedure DDelFriendClick(Sender: TObject; X, Y: Integer);
    procedure DInternetClick(Sender: TObject; X, Y: Integer);
    procedure DStMagHero1Click(Sender: TObject; X, Y: Integer);
    procedure DWCheckNumDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCheckNumOKDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCheckNumOKClick(Sender: TObject; X, Y: Integer);
    procedure DEditCheckNumKeyPress(Sender: TObject; var Key: Char);
    procedure DEditCheckNumKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DCheckNumChangeClick(Sender: TObject; X, Y: Integer);
    procedure DWMakeWineDeskDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMakeWineHelpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMakeWineDeskCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMakeWineHelpClick(Sender: TObject; X, Y: Integer);
    procedure DMaterialMemoClick(Sender: TObject; X, Y: Integer);
    procedure DBMateriaMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWMakeWineDeskMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure ShowMakeWine(bool:Boolean);
    procedure DBMateriaClick(Sender: TObject; X, Y: Integer);
    procedure DBMateriaDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBDrugDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBDrugClick(Sender: TObject; X, Y: Integer);
    procedure DStartMakeWineClick(Sender: TObject; X, Y: Integer);
    procedure DDrunkScaleDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBDrugMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCheckSdoNameShowDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DNewSdoBasicDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewSdoAssistantDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DNewSdoBasicClick(Sender: TObject; X, Y: Integer);
    procedure DEdtSdoAutoMagicTimerDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DNewSdoAssistantCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBtnSdoCallHeroKeyDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
//    procedure DBtnSdoRandomNameDirectPaint(Sender: TObject;
//      dsurface: TAsphyreCanvas);
    procedure DCheckSdoNameShowClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoCommonHpClick(Sender: TObject; X, Y: Integer);
    procedure DEdtSdoCommonHpChange(Sender: TObject);
    procedure DCheckSdoLongHitClick(Sender: TObject; X, Y: Integer);
    procedure DBtnSdoCallHeroKeyKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DBtnSdoCallHeroKeyMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DEdtSdoCommonHpKeyPress(Sender: TObject; var Key: Char);
    procedure DWChallengeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DChallengeGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DChallengeGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DChallengeGridGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DChallengeCloseClick(Sender: TObject; X, Y: Integer);
    procedure DRChallengeGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DRChallengeGridGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
      dsurface: TAsphyreCanvas);
    procedure DChallengeOKClick(Sender: TObject; X, Y: Integer);
    procedure DChallengeGoldClick(Sender: TObject; X, Y: Integer);
    procedure btnRecvChrCloseClick(Sender: TObject; X, Y: Integer);
    procedure dgrdRecoverNameGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
      dsurface: TAsphyreCanvas);
    procedure dgrdRecoverNameGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure btnRecoverClick(Sender: TObject; X, Y: Integer);
    procedure DWChallengeMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DEdtSdoCommonHpTimerKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DCheckSdoExpFiltrateMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWNewSdoAssistantMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DStateTabClick(Sender: TObject; X, Y: Integer);
    procedure DStateTabDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroStateTabDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroStateTabClick(Sender: TObject; X, Y: Integer);
    procedure DSighIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSighIconClick(Sender: TObject; X, Y: Integer);
    procedure DCrystalExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DExpCrystalTopMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWExpCrystalMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCrystalExpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DExpCrystalTopDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DExpCrystalTopClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DNewBoxsHelpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHelpBtnClick(Sender: TObject; X, Y: Integer);
    procedure DNewBoxsHelpCloseClick(Sender: TObject; X, Y: Integer);
    procedure DCheckAutoOpenBoxsDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBoxsNewCloseClick(Sender: TObject; X, Y: Integer);
    procedure DCheckAutoOpenBoxsClick(Sender: TObject; X, Y: Integer);
    procedure DSdoMemoDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DSdoMemoScrollBarDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure m_EdIdKeyPress(Sender: TObject; var Key: Char);
    procedure m_EdPasswdKeyPress(Sender: TObject; var Key: Char);
    procedure m_EdIdKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure m_EdPasswdKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DAdjustAbilOkDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGDWarClick(Sender: TObject; X, Y: Integer);
    procedure DWNQStateMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DNQBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DNQExpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNQStateDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DKimNeedleHelpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWKimNeedleDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DKimNeedleLogoDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DKimNeedle1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DKimNeedle6DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWKimNeedleMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKimNeedle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKimNeedle6MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKimNeedleHelpClick(Sender: TObject; X, Y: Integer);
    procedure DKimNeedleMemoClick(Sender: TObject; X, Y: Integer);
    procedure DStartKimNeedleClick(Sender: TObject; X, Y: Integer);
    procedure DKimNeedleCloseClick(Sender: TObject; X, Y: Integer);
    procedure DKimNeedle1Click(Sender: TObject; X, Y: Integer);
    procedure DKimNeedleBarDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStateSsasDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStateSsasClick(Sender: TObject; X, Y: Integer);
    procedure DStateWinPulseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStateWinPulseMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DStateWinPulseClick(Sender: TObject; X, Y: Integer);
    procedure DWinBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DStateWinBatterDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWinBatterComDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroSpleenDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBatterShowImgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWinBatterComMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWinBatterComMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWinBatterRandomDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWinBatterRandomClick(Sender: TObject; X, Y: Integer);
    procedure DWinBatterSetKeyClick(Sender: TObject; X, Y: Integer);
    procedure DWinBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWinBatterTopMag1MouseUp(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWinBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DStateWinBatterMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroStateSsasClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateSsasDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMemoWhisperListDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMemoWhisperListMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DMemoWhisperListClick(Sender: TObject; X, Y: Integer);
    procedure DMemoWhisperListScrollBarChange(Sender: TObject);
    procedure DWhisperCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBWhisperClick(Sender: TObject; X, Y: Integer);
    procedure DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DStMagHero1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKeySelDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHelpClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateWinPulseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroStateWinPulseClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateWinPulseMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroStateWinBatterDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroBatterTopMag1MouseUp(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
    procedure DHeroBatterComDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroBatterComMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroBatterComMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure HBExpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure HBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure JQExpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure JQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWHeroAssessDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroAssessSign1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCheckDeputyHeroWarrClick(Sender: TObject; X, Y: Integer);
    procedure DCheckHeroDeputyHeroWarrClick(Sender: TObject; X,
      Y: Integer);
    procedure DHeroAssessSignClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAssessMenuDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroAssessMenuMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroAssessMenuMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroAssessCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWHeroAutoPracticeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroAutoPracticeMemoDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroAutoPraMapPrevClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAutoPraYDSPrevClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAutoPraCloseClick(Sender: TObject; X, Y: Integer);
    procedure DStartHeroAutoPraClick(Sender: TObject; X, Y: Integer);
    procedure DCheckHeroLevelHintClick(Sender: TObject; X, Y: Integer);
    procedure DHeroJQExpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DHeroJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWJenniferLongBoxDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DJLChangeItemMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DJLBoxBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DJLBoxBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWJenniferLongBoxMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWJenniferLongBoxClick(Sender: TObject; X, Y: Integer);
    procedure DJenniferLongBoxCloseClick(Sender: TObject; X, Y: Integer);
    procedure DJLChangeItemDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DJLChangeItemClick(Sender: TObject; X, Y: Integer);
    procedure DJLStartItemClick(Sender: TObject; X, Y: Integer);
    procedure DJLBoxBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DJLBoxBelt1DblClick(Sender: TObject);
    procedure DJLBoxFlashDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DGJLBoxFreeItemGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
      dsurface: TAsphyreCanvas);
    procedure DGJLBoxFreeItemGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGJLBoxFreeItemGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGJLBoxFreeItemDblClick(Sender: TObject);
    procedure DBCommandFrameDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBCommandMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBCommandFrameMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBCommandFrameMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DCBFilterItemStdModeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DEdtFilterItemStdModeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBtnDefaultFilterItemDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DEdtFilterItemStdModeChange(Sender: TObject);
    procedure DCBFilterItemStdModeChange(Sender: TObject);
    procedure DBtnDefaultFilterItemClick(Sender: TObject; X, Y: Integer);
    procedure DListViewFilterItemListItemClick(Sender: TObject; ARow,
      ACol: Integer; ListItem: TDListItem; ViewItem: pTViewItem);
    procedure DBotMemoDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWWStallPriceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBWStallPriceTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBWStallPriceTab1Click(Sender: TObject; X, Y: Integer);
    procedure DBotStallClick(Sender: TObject; X, Y: Integer);
    procedure DGStallGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DGStallGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBStallCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBWStallPriceCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBWStallPriceOKClick(Sender: TObject; X, Y: Integer);
    procedure DBtnStallStartClick(Sender: TObject; X, Y: Integer);
    procedure DBtnStallStopClick(Sender: TObject; X, Y: Integer);
    procedure DGStallGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DGUserStallGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DGUserStallGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWUserStallDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWStallMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWUserStallMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGUserStallGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBBuyUserStallItemClick(Sender: TObject; X, Y: Integer);
    procedure DWMiniMapDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWMiniMapMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWMiniMapMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DTreeViewMission1Select(Sender: TObject; TreeNode: TDTreeNode);
    procedure DMemoMissionBottomDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMemoMissionBottomMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DMemoMissionBottomClick(Sender: TObject; X, Y: Integer);
    procedure DMemoMissionBottomScrollBarChange(Sender: TObject);
    procedure DBMissionCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBMission1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBMission1Click(Sender: TObject; X, Y: Integer);
    procedure DBMissionClick(Sender: TObject; X, Y: Integer);
    procedure DBMissionDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBMissionClose1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWSkillMemoDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBSkillMemoIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBSkillMemoCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBHeroSkillMemoCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBJDSeeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBJDSeeClick(Sender: TObject; X, Y: Integer);
    procedure DBJDSeeMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBHeroQSSSeeClick(Sender: TObject; X, Y: Integer);
    procedure DWHeroSkillMemoDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBHeroSkillMemoIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBHeroSkillMemoLinkDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBHeroSkillMemoLinkClick(Sender: TObject; X, Y: Integer);
    procedure DBHeroSkillMemoLinkMouseUp(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DBHeroSkillMemoLinkMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWSignedItemsDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBSignedItemDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBSignedItemClick(Sender: TObject; X, Y: Integer);
    procedure DBOrdSignedDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBSignedBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBSignedBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DBSignedItemsCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWJudgeItemsDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBJudgeItemClick(Sender: TObject; X, Y: Integer);
    procedure DBJudgeItemsCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWMakeSignedDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBMakeSignedExp1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWMakeSignedMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBMakeSignedReadClick(Sender: TObject; X, Y: Integer);
    procedure DBOrdSignedClick(Sender: TObject; X, Y: Integer);
    procedure DBSignedBelt1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWSignedItemsMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBSignedChangeClick(Sender: TObject; X, Y: Integer);
    procedure DscStartDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBMakeSignedBelt3DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBMakeSignedBelt3Click(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedLeve1Click(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBMakeSignedCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedBelt3MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBMakeSignedBelt1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBMakeSignedReadStartClick(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedExp1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBLingMeiBeltDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBLingMeiBeltClick(Sender: TObject; X, Y: Integer);
    procedure DIndividualOrderDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBLevelOrderUseItemClick(Sender: TObject; X, Y: Integer);
    procedure DBJudgeBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBJudgeBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DBJudgeStartClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderClick(Sender: TObject; X, Y: Integer);
    procedure DBItemLevelBelt1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBItemLevelBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DWLevelOrderMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBJudgeBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWJudgeItemsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBLingMeiBeltMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBLingMeiBeltDblClick(Sender: TObject);
    procedure DLoginNewInitialize(Sender: TObject);
    procedure DLoginOkInitialize(Sender: TObject);
    procedure DLoginCloseInitialize(Sender: TObject);
    procedure DLoginChgPwInitialize(Sender: TObject);
    procedure DLogInInitialize(Sender: TObject);
    procedure DNewAccountOkInitialize(Sender: TObject);
    procedure DNewAccountCancelInitialize(Sender: TObject);
    procedure DNewAccountCloseInitialize(Sender: TObject);
    procedure DNewAccountInitialize(Sender: TObject);
    procedure DSServer1Initialize(Sender: TObject);
    procedure DSServer2Initialize(Sender: TObject);
    procedure DSServer3Initialize(Sender: TObject);
    procedure DSServer4Initialize(Sender: TObject);
    procedure DSServer5Initialize(Sender: TObject);
    procedure DSServer6Initialize(Sender: TObject);
    procedure DSSrvCloseInitialize(Sender: TObject);
    procedure DSelServerDlgInitialize(Sender: TObject);
    procedure DccWarriorInitialize(Sender: TObject);
    procedure DccWizzardInitialize(Sender: TObject);
    procedure DccMonkInitialize(Sender: TObject);
    procedure DccMaleInitialize(Sender: TObject);
    procedure DccFemaleInitialize(Sender: TObject);
    procedure DccLeftHairInitialize(Sender: TObject);
    procedure DccRightHairInitialize(Sender: TObject);
    procedure DccOkInitialize(Sender: TObject);
    procedure DccCloseInitialize(Sender: TObject);
    procedure DCreateChrInitialize(Sender: TObject);
    procedure DChgpwOkInitialize(Sender: TObject);
    procedure DChgpwCancelInitialize(Sender: TObject);
    procedure DChgPwInitialize(Sender: TObject);
    procedure DKsF1Initialize(Sender: TObject);
    procedure DKsF2Initialize(Sender: TObject);
    procedure DKsF3Initialize(Sender: TObject);
    procedure DKsF4Initialize(Sender: TObject);
    procedure DKsF5Initialize(Sender: TObject);
    procedure DKsF6Initialize(Sender: TObject);
    procedure DKsF7Initialize(Sender: TObject);
    procedure DKsF8Initialize(Sender: TObject);
    procedure DKsConF1Initialize(Sender: TObject);
    procedure DKsConF2Initialize(Sender: TObject);
    procedure DKsConF3Initialize(Sender: TObject);
    procedure DKsConF4Initialize(Sender: TObject);
    procedure DKsConF5Initialize(Sender: TObject);
    procedure DKsConF6Initialize(Sender: TObject);
    procedure DKsConF7Initialize(Sender: TObject);
    procedure DKsConF8Initialize(Sender: TObject);
    procedure DKsNoneInitialize(Sender: TObject);
    procedure DKsOkInitialize(Sender: TObject);
    procedure DKeySelDlgInitialize(Sender: TObject);
    procedure DscSelect1Initialize(Sender: TObject);
    procedure DscSelect2Initialize(Sender: TObject);
    procedure DscStartInitialize(Sender: TObject);
    procedure DscNewChrInitialize(Sender: TObject);
    procedure DscEraseChrInitialize(Sender: TObject);
    procedure DscCreditsInitialize(Sender: TObject);
    procedure DscExitInitialize(Sender: TObject);
    procedure DItemGridInitialize(Sender: TObject);
    procedure DGoldInitialize(Sender: TObject);
    procedure DWGameGoldInitialize(Sender: TObject);
    procedure DItemsUpButInitialize(Sender: TObject);
    procedure DCloseBagInitialize(Sender: TObject);
    procedure DItemBagInitialize(Sender: TObject);
    procedure DDRGoldInitialize(Sender: TObject);
    procedure DDealRemoteDlgInitialize(Sender: TObject);
    procedure DDGoldInitialize(Sender: TObject);
    procedure DDealOkInitialize(Sender: TObject);
    procedure DDealCloseInitialize(Sender: TObject);
    procedure DDealDlgInitialize(Sender: TObject);
    procedure DMenuPrevInitialize(Sender: TObject);
    procedure DMenuNextInitialize(Sender: TObject);
    procedure DMenuBuyInitialize(Sender: TObject);
    procedure DMenuCloseInitialize(Sender: TObject);
    procedure DMenuDlgInitialize(Sender: TObject);
    procedure DStateTabInitialize(Sender: TObject);
    procedure DCloseStateInitialize(Sender: TObject);
    procedure DStateSsasInitialize(Sender: TObject);
    procedure DPrevStateInitialize(Sender: TObject);
    procedure DNextStateInitialize(Sender: TObject);
    procedure DBJDSeeInitialize(Sender: TObject);
    procedure HBExpInitialize(Sender: TObject);
    procedure JQExpInitialize(Sender: TObject);
    procedure DStPageUpInitialize(Sender: TObject);
    procedure DStPageDownInitialize(Sender: TObject);
    procedure DLiquorProgressInitialize(Sender: TObject);
    procedure DStateWinInitialize(Sender: TObject);
    procedure DGrpAllowGroupInitialize(Sender: TObject);
    procedure DGrpCreateInitialize(Sender: TObject);
    procedure DGrpAddMemInitialize(Sender: TObject);
    procedure DGrpDelMemInitialize(Sender: TObject);
    procedure DGrpDlgCloseInitialize(Sender: TObject);
    procedure DGroupDlgInitialize(Sender: TObject);
    procedure DGEOkInitialize(Sender: TObject);
    procedure DGECloseInitialize(Sender: TObject);
    procedure DGuildEditNoticeInitialize(Sender: TObject);
    procedure DIndividualOrderInitialize(Sender: TObject);
    procedure DHeroOrderInitialize(Sender: TObject);
    procedure DMasterOrderInitialize(Sender: TObject);
    procedure DBLevelOrderUseItemInitialize(Sender: TObject);
    procedure DBLevelOrderCloudInitialize(Sender: TObject);
    procedure DLevelOrderCloseInitialize(Sender: TObject);
    procedure DColonyHeroOrderInitialize(Sender: TObject);
    procedure DWarriorOrderInitialize(Sender: TObject);
    procedure DWizerdOrderInitialize(Sender: TObject);
    procedure DTaoistOrderInitialize(Sender: TObject);
    procedure DHeroAllOrderInitialize(Sender: TObject);
    procedure DWarriorHeroOrderInitialize(Sender: TObject);
    procedure DWizerdHeroOrderInitialize(Sender: TObject);
    procedure DTaoistHeroOrderInitialize(Sender: TObject);
    procedure DLevelOrderIndexInitialize(Sender: TObject);
    procedure DLevelOrderPrevInitialize(Sender: TObject);
    procedure DLevelOrderNextInitialize(Sender: TObject);
    procedure DLevelOrderLastPageInitialize(Sender: TObject);
    procedure DMyLevelOrderInitialize(Sender: TObject);
    procedure DBOrderWeaponInitialize(Sender: TObject);
    procedure DBOrderRingInitialize(Sender: TObject);
    procedure DBOrderDressInitialize(Sender: TObject);
    procedure DBOrderBootsInitialize(Sender: TObject);
    procedure DBOrderHelmetInitialize(Sender: TObject);
    procedure DBOrderBeltInitialize(Sender: TObject);
    procedure DBOrderNecklaceInitialize(Sender: TObject);
    procedure DBOrderMedalInitialize(Sender: TObject);
    procedure DBOrderWristletInitialize(Sender: TObject);
    procedure DBOrderHatInitialize(Sender: TObject);
    procedure DWLevelOrderInitialize(Sender: TObject);
    procedure m_EdIdInitialize(Sender: TObject);
    procedure m_EdPasswdInitialize(Sender: TObject);
    procedure DBotMiniMapInitialize(Sender: TObject);
    procedure DBotTradeInitialize(Sender: TObject);
    procedure DBotGuildInitialize(Sender: TObject);
    procedure DBotGroupInitialize(Sender: TObject);
    procedure DBotPlusAbilInitialize(Sender: TObject);
    procedure DBotFriendInitialize(Sender: TObject);
    procedure ChallengeInitialize(Sender: TObject);
    procedure CharacterSrankingInitialize(Sender: TObject);
    procedure DBWhisperInitialize(Sender: TObject);
    procedure DBotStallInitialize(Sender: TObject);
    procedure DBotLogoutInitialize(Sender: TObject);
    procedure DBotExitInitialize(Sender: TObject);
    procedure DMyStateInitialize(Sender: TObject);
    procedure DMyBagInitialize(Sender: TObject);
    procedure DMyMagicInitialize(Sender: TObject);
    procedure DOptionInitialize(Sender: TObject);
    procedure DDrunkScaleInitialize(Sender: TObject);
    procedure DBMissionInitialize(Sender: TObject);
    procedure DBatterShowImgInitialize(Sender: TObject);
    procedure DBotMemoInitialize(Sender: TObject);
    procedure DMsgDlgOkInitialize(Sender: TObject);
    procedure DMsgDlgCancelInitialize(Sender: TObject);
    procedure DMsgDlgYesInitialize(Sender: TObject);
    procedure DMsgDlgNoInitialize(Sender: TObject);
    procedure DMsgDlgInitialize(Sender: TObject);
    procedure DStateWinPulseInitialize(Sender: TObject);
    procedure DWinBatterRandomInitialize(Sender: TObject);
    procedure DWinBatterSetKeyInitialize(Sender: TObject);
    procedure DWinBatterComInitialize(Sender: TObject);
    procedure DHeroItemBagInitialize(Sender: TObject);
    procedure DHeroItemGridCloseInitialize(Sender: TObject);
    procedure DExpCrystalTopInitialize(Sender: TObject);
    procedure DCrystalExpInitialize(Sender: TObject);
    procedure DCrystalNGExpInitialize(Sender: TObject);
    procedure DWExpCrystalInitialize(Sender: TObject);
    procedure DMerchantDlgInitialize(Sender: TObject);
    procedure DMerchantDlgCloseInitialize(Sender: TObject);
    procedure DBtnStallStartInitialize(Sender: TObject);
    procedure DBtnStallStopInitialize(Sender: TObject);
    procedure DBStallCloseInitialize(Sender: TObject);
    procedure DWStallInitialize(Sender: TObject);
    procedure DBWStallPriceTab1Initialize(Sender: TObject);
    procedure DBWStallPriceTab2Initialize(Sender: TObject);
    procedure DBWStallPriceOKInitialize(Sender: TObject);
    procedure DBWStallPriceCancelInitialize(Sender: TObject);
    procedure DBWStallPriceCloseInitialize(Sender: TObject);
    procedure DWWStallPriceInitialize(Sender: TObject);
    procedure DBBuyUserStallItemInitialize(Sender: TObject);
    procedure DBUserStallCloseInitialize(Sender: TObject);
    procedure DWUserStallInitialize(Sender: TObject);
    procedure DGDUpInitialize(Sender: TObject);
    procedure DGDDownInitialize(Sender: TObject);
    procedure DGDCloseInitialize(Sender: TObject);
    procedure DGDHomeInitialize(Sender: TObject);
    procedure DGDAddMemInitialize(Sender: TObject);
    procedure DGDEditNoticeInitialize(Sender: TObject);
    procedure DGDAllyInitialize(Sender: TObject);
    procedure DGDWarInitialize(Sender: TObject);
    procedure DGDListInitialize(Sender: TObject);
    procedure DGDChatInitialize(Sender: TObject);
    procedure DGDDelMemInitialize(Sender: TObject);
    procedure DGDEditGradeInitialize(Sender: TObject);
    procedure DGDBreakAllyInitialize(Sender: TObject);
    procedure DGDCancelWarInitialize(Sender: TObject);
    procedure DGuildDlgInitialize(Sender: TObject);
    procedure DBMission1Initialize(Sender: TObject);
    procedure DBMission2Initialize(Sender: TObject);
    procedure DBMission3Initialize(Sender: TObject);
    procedure DBMissionCloseInitialize(Sender: TObject);
    procedure DBMissionClose1Initialize(Sender: TObject);
    procedure DScrollBarMission1Initialize(Sender: TObject);
    procedure DTreeViewMission1Initialize(Sender: TObject);
    procedure DWMissionInitialize(Sender: TObject);
    procedure DMemoMissionBottomInitialize(Sender: TObject);
    procedure DMemoMissionBottomScrollBarInitialize(Sender: TObject);
    procedure DSellDlgInitialize(Sender: TObject);
    procedure DSellDlgCloseInitialize(Sender: TObject);
    procedure DSellDlgOkInitialize(Sender: TObject);
    procedure DPlusMCInitialize(Sender: TObject);
    procedure DPlusDCInitialize(Sender: TObject);
    procedure DPlusSCInitialize(Sender: TObject);
    procedure DPlusACInitialize(Sender: TObject);
    procedure DPlusMACInitialize(Sender: TObject);
    procedure DPlusHPInitialize(Sender: TObject);
    procedure DPlusMPInitialize(Sender: TObject);
    procedure DPlusHitInitialize(Sender: TObject);
    procedure DPlusSpeedInitialize(Sender: TObject);
    procedure DMinusDCInitialize(Sender: TObject);
    procedure DMinusMCInitialize(Sender: TObject);
    procedure DMinusSCInitialize(Sender: TObject);
    procedure DMinusACInitialize(Sender: TObject);
    procedure DMinusMACInitialize(Sender: TObject);
    procedure DMinusHPInitialize(Sender: TObject);
    procedure DMinusMPInitialize(Sender: TObject);
    procedure DMinusHitInitialize(Sender: TObject);
    procedure DMinusSpeedInitialize(Sender: TObject);
    procedure DAdjustAbilCloseInitialize(Sender: TObject);
    procedure DAdjustAbilOkInitialize(Sender: TObject);
    procedure DAdjustAbilityInitialize(Sender: TObject);
    procedure DHeroIconInitialize(Sender: TObject);
    procedure DCloseUS1Initialize(Sender: TObject);
    procedure DUserState1Initialize(Sender: TObject);
    procedure DSelHero1Initialize(Sender: TObject);
    procedure DSelHero2Initialize(Sender: TObject);
    procedure DGetHeroCloseInitialize(Sender: TObject);
    procedure DWiGetHeroInitialize(Sender: TObject);
    procedure DCheckNumOKInitialize(Sender: TObject);
    procedure DCheckNumChangeInitialize(Sender: TObject);
    procedure DCheckNumCloseInitialize(Sender: TObject);
    procedure DWCheckNumInitialize(Sender: TObject);
    procedure DChallengeOKInitialize(Sender: TObject);
    procedure DChallengeCancelInitialize(Sender: TObject);
    procedure DChallengeCloseInitialize(Sender: TObject);
    procedure DWChallengeInitialize(Sender: TObject);
    procedure DBoxsBelt1Initialize(Sender: TObject);
    procedure DBoxsBelt2Initialize(Sender: TObject);
    procedure DBoxsBelt3Initialize(Sender: TObject);
    procedure DBoxsBelt4Initialize(Sender: TObject);
    procedure DBoxsBelt5Initialize(Sender: TObject);
    procedure DBoxsBelt6Initialize(Sender: TObject);
    procedure DBoxsBelt7Initialize(Sender: TObject);
    procedure DBoxsBelt8Initialize(Sender: TObject);
    procedure DBoxsBelt9Initialize(Sender: TObject);
    procedure DBNewHelpBtnInitialize(Sender: TObject);
    procedure DBoxsNewCloseInitialize(Sender: TObject);
    procedure DNewBoxsHelpCloseInitialize(Sender: TObject);
    procedure DNewBoxsHelpInitialize(Sender: TObject);
    procedure DBoxsInitialize(Sender: TObject);
    procedure DFriendDlgFrdInitialize(Sender: TObject);
    procedure DFriendDlgTangetInitialize(Sender: TObject);
    procedure DHeiMingDanInitialize(Sender: TObject);
    procedure DAddFriendInitialize(Sender: TObject);
    procedure DDelFriendInitialize(Sender: TObject);
    procedure DPrevFriendDlgInitialize(Sender: TObject);
    procedure DNextFriendDlgInitialize(Sender: TObject);
    procedure DFrdCloseInitialize(Sender: TObject);
    procedure DFriendDlgInitialize(Sender: TObject);
    procedure DSighIconInitialize(Sender: TObject);
    procedure DItemsUpOkInitialize(Sender: TObject);
    procedure DItemsUpCloseInitialize(Sender: TObject);
    procedure DItemsUpInitialize(Sender: TObject);
    procedure DSellOffOkInitialize(Sender: TObject);
    procedure DSellOffCancelInitialize(Sender: TObject);
    procedure DSellOffCloseInitialize(Sender: TObject);
    procedure DWSellOffInitialize(Sender: TObject);
    procedure DSellOffListCancelInitialize(Sender: TObject);
    procedure DSellOffBuyCancelInitialize(Sender: TObject);
    procedure DSellOffBuyInitialize(Sender: TObject);
    procedure DSellOffListColseInitialize(Sender: TObject);
    procedure DWSellOffListInitialize(Sender: TObject);
    procedure DMemoWhisperListInitialize(Sender: TObject);
    procedure DMemoWhisperListScrollBarInitialize(Sender: TObject);
    procedure DWhisperCloseInitialize(Sender: TObject);
    procedure DWWhisperInitialize(Sender: TObject);
    procedure DHeroAssessSign1Initialize(Sender: TObject);
    procedure DHeroAssessClose1Initialize(Sender: TObject);
    procedure DHeroAssessSignInitialize(Sender: TObject);
    procedure DHeroAssessCloseInitialize(Sender: TObject);
    procedure DWHeroAssessInitialize(Sender: TObject);
    procedure DHeroAutoPraMapPrevInitialize(Sender: TObject);
    procedure DHeroAutoPraMapNextInitialize(Sender: TObject);
    procedure DHeroAutoPraYDSPrevInitialize(Sender: TObject);
    procedure DHeroAutoPraYDSNextInitialize(Sender: TObject);
    procedure DStartHeroAutoPraInitialize(Sender: TObject);
    procedure DHeroAutoPraCloseInitialize(Sender: TObject);
    procedure DWHeroAutoPracticeInitialize(Sender: TObject);
    procedure DShopPrevInitialize(Sender: TObject);
    procedure DShopNextInitialize(Sender: TObject);
    procedure DShopBuyInitialize(Sender: TObject);
    procedure DShopPresentInitialize(Sender: TObject);
    procedure DShopClose1Initialize(Sender: TObject);
    procedure DShopCloseInitialize(Sender: TObject);
    procedure DShopInitialize(Sender: TObject);
    procedure DStateHeroInitialize(Sender: TObject);
    procedure DHeroStateTabInitialize(Sender: TObject);
    procedure DCloseHeroStateInitialize(Sender: TObject);
    procedure DHeroStateSsasInitialize(Sender: TObject);
    procedure DPrevStateHeroInitialize(Sender: TObject);
    procedure DNextStateHeroInitialize(Sender: TObject);
    procedure DSHPageUpInitialize(Sender: TObject);
    procedure DSHPageDownInitialize(Sender: TObject);
    procedure DHeroJQExpInitialize(Sender: TObject);
    procedure DBHeroQSSSeeInitialize(Sender: TObject);
    procedure DHeroLiquorProgressInitialize(Sender: TObject);
    procedure DHeroStateWinPulseInitialize(Sender: TObject);
    procedure DHeroBatterRandomInitialize(Sender: TObject);
    procedure DHeroBatterComInitialize(Sender: TObject);
    procedure DHeroStateWinBatterInitialize(Sender: TObject);
    procedure DPDrink1Initialize(Sender: TObject);
    procedure DPDrink2Initialize(Sender: TObject);
    procedure DPleaseDrinkDrinkInitialize(Sender: TObject);
    procedure DPleaseDrinkExitInitialize(Sender: TObject);
    procedure DWPleaseDrinkInitialize(Sender: TObject);
    procedure DPleaseDrinkCloseInitialize(Sender: TObject);
    procedure DDrink1Initialize(Sender: TObject);
    procedure DDrink2Initialize(Sender: TObject);
    procedure DDrink3Initialize(Sender: TObject);
    procedure DDrink4Initialize(Sender: TObject);
    procedure DDrink5Initialize(Sender: TObject);
    procedure DDrink6Initialize(Sender: TObject);
    procedure DPlayDrinkCloseInitialize(Sender: TObject);
    procedure DPlayDrinkFistInitialize(Sender: TObject);
    procedure DPlayDrinkScissorsInitialize(Sender: TObject);
    procedure DPlayDrinkClothInitialize(Sender: TObject);
    procedure DPlayFistInitialize(Sender: TObject);
    procedure DPlayDrinkInitialize(Sender: TObject);
    procedure btnRecoverInitialize(Sender: TObject);
    procedure btnRecvChrCloseInitialize(Sender: TObject);
    procedure dwRecoverChrInitialize(Sender: TObject);
    procedure DMakeWineHelpInitialize(Sender: TObject);
    procedure DMaterialMemoInitialize(Sender: TObject);
    procedure DStartMakeWineInitialize(Sender: TObject);
    procedure DMakeWineDeskCloseInitialize(Sender: TObject);
    procedure DWMakeWineDeskInitialize(Sender: TObject);
    procedure DNQExpInitialize(Sender: TObject);
    procedure DWNQStateInitialize(Sender: TObject);
    procedure DKimNeedleHelpInitialize(Sender: TObject);
    procedure DKimNeedleMemoInitialize(Sender: TObject);
    procedure DStartKimNeedleInitialize(Sender: TObject);
    procedure DKimNeedleLogoInitialize(Sender: TObject);
    procedure DKimNeedleBarInitialize(Sender: TObject);
    procedure DKimNeedleCloseInitialize(Sender: TObject);
    procedure DWKimNeedleInitialize(Sender: TObject);
    procedure DJLBoxBelt8Initialize(Sender: TObject);
    procedure DJLBoxBelt1Initialize(Sender: TObject);
    procedure DJLBoxBelt2Initialize(Sender: TObject);
    procedure DJLBoxBelt3Initialize(Sender: TObject);
    procedure DJLBoxBelt4Initialize(Sender: TObject);
    procedure DJLBoxBelt5Initialize(Sender: TObject);
    procedure DJLBoxBelt6Initialize(Sender: TObject);
    procedure DJLBoxBelt7Initialize(Sender: TObject);
    procedure DJLChangeItemInitialize(Sender: TObject);
    procedure DJLStartItemInitialize(Sender: TObject);
    procedure DJenniferLongBoxCloseInitialize(Sender: TObject);
    procedure DWJenniferLongBoxInitialize(Sender: TObject);
    procedure DBSkillMemoCloseInitialize(Sender: TObject);
    procedure DWSkillMemoInitialize(Sender: TObject);
    procedure DBHeroSkillMemoCloseInitialize(Sender: TObject);
    procedure DWHeroSkillMemoInitialize(Sender: TObject);
    procedure DBSignedItemInitialize(Sender: TObject);
    procedure DBSignedChangeItemInitialize(Sender: TObject);
    procedure DBSignedMemoInitialize(Sender: TObject);
    procedure DBSignedChangeMemoInitialize(Sender: TObject);
    procedure DBSignedBelt1Initialize(Sender: TObject);
    procedure DBSignedBelt2Initialize(Sender: TObject);
    procedure DBSignedChangeInitialize(Sender: TObject);
    procedure DBOrdSignedInitialize(Sender: TObject);
    procedure DBHighSignedInitialize(Sender: TObject);
    procedure DBSignedItemsCloseInitialize(Sender: TObject);
    procedure DWSignedItemsInitialize(Sender: TObject);
    procedure DBJudgeItemInitialize(Sender: TObject);
    procedure DBJudgeItemMemoInitialize(Sender: TObject);
    procedure DBJudgeBelt1Initialize(Sender: TObject);
    procedure DBJudgeStartInitialize(Sender: TObject);
    procedure DBJudgeItemsCloseInitialize(Sender: TObject);
    procedure DWJudgeItemsInitialize(Sender: TObject);
    procedure DBMakeSignedReadInitialize(Sender: TObject);
    procedure DBMakeSignedMakeInitialize(Sender: TObject);
    procedure DBMakeSignedReadMemoInitialize(Sender: TObject);
    procedure DBMakeSignedMakeMemoInitialize(Sender: TObject);
    procedure DBMakeSignedExp1Initialize(Sender: TObject);
    procedure DBMakeSignedExp2Initialize(Sender: TObject);
    procedure DBMakeSignedBelt1Initialize(Sender: TObject);
    procedure DBMakeSignedBelt2Initialize(Sender: TObject);
    procedure DBMakeSignedBelt3Initialize(Sender: TObject);
    procedure DBMakeSignedReadStartInitialize(Sender: TObject);
    procedure DBMakeSignedLeve1Initialize(Sender: TObject);
    procedure DBMakeSignedLeve2Initialize(Sender: TObject);
    procedure DBMakeSignedLeve3Initialize(Sender: TObject);
    procedure DBMakeSignedLeve4Initialize(Sender: TObject);
    procedure DBMakeSignedCloseInitialize(Sender: TObject);
    procedure DWMakeSignedInitialize(Sender: TObject);
    procedure DWNewSdoAssistantInitialize(Sender: TObject);
    procedure DNewSdoBasicInitialize(Sender: TObject);
    procedure DNewSdoFilterItemInitialize(Sender: TObject);
    procedure DNewSdoProtectInitialize(Sender: TObject);
    procedure DNewSdoSkillInitialize(Sender: TObject);
    procedure DNewSdoKeyInitialize(Sender: TObject);
    procedure DNedSdoHelpInitialize(Sender: TObject);
    procedure DScrollBarFilterItemInitialize(Sender: TObject);
    procedure DListViewFilterItemInitialize(Sender: TObject);
    procedure DNewSdoAssistantCloseInitialize(Sender: TObject);
    procedure DCBFilterItemStdModeInitialize(Sender: TObject);
    procedure DCheckSdoStartKeyInitialize(Sender: TObject);
    procedure DSdoMemoScrollBarInitialize(Sender: TObject);
    procedure DSdoMemoInitialize(Sender: TObject);
    procedure DSWBujukDblClick(Sender: TObject);
    procedure DBNewSdoProtect1Initialize(Sender: TObject);
    procedure DScrollBarProInitialize(Sender: TObject);
    procedure DScrollBoxProDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBProMySelfDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCheckSdoNameShowInitialize(Sender: TObject);
    procedure DCBBookHPManInitialize(Sender: TObject);
    procedure DCBBookHPManDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DCheckBoxBookHPProClick(Sender: TObject; X, Y: Integer);
    procedure DCBBookHPManChange(Sender: TObject);
    procedure DEdtBookHPProChange(Sender: TObject);
    procedure DScrollBoxProMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWQJPracticeInitialize(Sender: TObject);
    procedure DWQJPracticeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBQJPracticeCloseInitialize(Sender: TObject);
    procedure DBQJPracticePage1Initialize(Sender: TObject);
    procedure DBQJPracticePage1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBQJPracticeStartInitialize(Sender: TObject);
    procedure DBQJPracticeItemDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBQJPracticeItemClick(Sender: TObject; X, Y: Integer);
    procedure DBQJPracticeCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWQJFurnaceInitialize(Sender: TObject);
    procedure DBQJFurnaceCloseInitialize(Sender: TObject);
    procedure DWQJFurnaceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBQJPracticeStartClick(Sender: TObject; X, Y: Integer);
    procedure DLQJPracticeLink1Click(Sender: TObject; X, Y: Integer);
    procedure DLQJPracticeLink3Click(Sender: TObject; X, Y: Integer);
    procedure DLQJPracticeLink4Click(Sender: TObject; X, Y: Integer);
    procedure DBQJFurnaceStartClick(Sender: TObject; X, Y: Integer);
    procedure DBQJFurnaceCloseClick(Sender: TObject; X, Y: Integer);
    procedure DScrollBoxProInitialize(Sender: TObject);
    procedure DScrollBarKeyInitialize(Sender: TObject);
    procedure DScrollBoxKeyInitialize(Sender: TObject);
    procedure DScrollBoxKeySurfaceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBTitleManInitialize(Sender: TObject);
    procedure DBTitle1Initialize(Sender: TObject);
    procedure DBPrevTitleInitialize(Sender: TObject);
    procedure DBNextTitleInitialize(Sender: TObject);
    procedure DBTitle1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBTitleManDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBTitle1Click(Sender: TObject; X, Y: Integer);
    procedure DBTitleManClick(Sender: TObject; X, Y: Integer);
    procedure DBPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBUserTitle1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBUserTitleManDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBUserPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBUserTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWPFLingPaiInitialize(Sender: TObject);
    procedure DWPFLingPaiDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBPFLingPaiIcon1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBPFLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWPFLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBPFLingPaiCloseInitialize(Sender: TObject);
    procedure DBPFLingPaiCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLPFLingPaiPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBPFLingPaiName1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBPFLingPaiCall1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBPFLingPaiMove1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBPFLingPaiCall1Click(Sender: TObject; X, Y: Integer);
    procedure DBPFLingPaiMove1Click(Sender: TObject; X, Y: Integer);
    procedure DWZZLingPaiInitialize(Sender: TObject);
    procedure DWZZLingPaiDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBPFLingPaiName1Click(Sender: TObject; X, Y: Integer);
    procedure DLabel12Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBZZLingPaiTab1Initialize(Sender: TObject);
    procedure DBZZLingPaiTab1Click(Sender: TObject; X, Y: Integer);
    procedure DMZZLingPaiDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMZZLingPaiInitialize(Sender: TObject);
    procedure DMZZLingPaiScrollBarInitialize(Sender: TObject);
    procedure DBZZLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBZZLingPaiIcon1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBZZLingPaiName1Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiName1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBZZLingPaiCall1Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiCall1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBZZLingPaiCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiMove1Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiMove1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLabel15Click(Sender: TObject; X, Y: Integer);
    procedure DLZZLingPaiPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiMapName1Initialize(Sender: TObject);
    procedure DBZZLingPaiMapName1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBZZLingPaiMapName1Click(Sender: TObject; X, Y: Integer);
    procedure DWZZLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNGUpLevel1Initialize(Sender: TObject);
    procedure DLNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DLHeroNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DWPetLogInitialize(Sender: TObject);
    procedure DBPetLogCloseInitialize(Sender: TObject);
    procedure DBPetLogCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWPetLogDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DLPetLogPagePrvClick(Sender: TObject; X, Y: Integer);
    procedure DLPetLogMoveClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBotFactionClick(Sender: TObject; X, Y: Integer);
    procedure DBotFactionClickSound(Sender: TObject; Clicksound: TClickSound);
    procedure DBotFactionInitialize(Sender: TObject);
    procedure DWFactionDlgInitialize(Sender: TObject);
    procedure DWFactionDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLFactionDlgHomeInitialize(Sender: TObject);
    procedure DBFactionDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBFactionDlgCloseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBFactionDlgCloseInitialize(Sender: TObject);
    procedure DLFactionAddPrevClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionAddQueryClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionApplyAdd1Click(Sender: TObject; X, Y: Integer);
    procedure DEditFactionAddQueryDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBFactionAddDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBFactionAddDlgCloseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWFactionAddDlgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWFactionApplyManageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWFactionApplyManageInitialize(Sender: TObject);
    procedure DLFactionApplyManageAllSelClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionApplyManageCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGridFactionApplySelGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
      dsurface: TAsphyreCanvas);
    procedure DGridFactionApplySelGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DLFactionApplyManageAgreeClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionDlgEditNoticeInitialize(Sender: TObject);
    procedure DLFactionDlgEditNoticeOKClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgEditNoticeOKInitialize(Sender: TObject);
    procedure DBFactionDlgEditNoticeCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionApplyManageRefuseClick(Sender: TObject; X, Y: Integer);
    procedure DWLingWUXinFaDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWLingWUXinFaInitialize(Sender: TObject);
    procedure DLLingWUXinFaClick(Sender: TObject; X, Y: Integer);
    procedure DLLingWUXinFaInitialize(Sender: TObject);
    procedure DLXinFaMakeNameClick(Sender: TObject; X, Y: Integer);
    procedure DLXinFaMakeNameInitialize(Sender: TObject);
    procedure DLHelpXinfaClick(Sender: TObject; X, Y: Integer);
    procedure DLXinFaChangeSelNameClick(Sender: TObject; X, Y: Integer);
    procedure DLXinFaChangeSelNameInitialize(Sender: TObject);
    procedure DBXinFaNamePrevClick(Sender: TObject; X, Y: Integer);
    procedure DBXinFaNamePrevDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBXinFaNamePrevInitialize(Sender: TObject);
    procedure DBXinFaNameNextInitialize(Sender: TObject);
    procedure DGridLingWuXinFaKeyGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
    procedure DGridLingWuXinFaKeyGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DLLingWuXinFaKeyPrevClick(Sender: TObject; X, Y: Integer);
    procedure DLLingWuXinFaKeyPrevInitialize(Sender: TObject);
    procedure DLLingWuXinFaKeyChangeClick(Sender: TObject; X, Y: Integer);
    procedure DLLingWuXinFaKeyOKClick(Sender: TObject; X, Y: Integer);
    procedure DBLingWuXinFaKeyCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBLingWUXinFaCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBLingWUXinFaCloseInitialize(Sender: TObject);
    procedure DBLingWuXinFaNameClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgHomeClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgExitClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgManageApplyClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgKickClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgListClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgGetTitleClick(Sender: TObject; X, Y: Integer);
    procedure DWBottomLeftDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWBottomLeftInitialize(Sender: TObject);
    procedure DWBottomLeftMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBotFactionMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBInternetClick(Sender: TObject; X, Y: Integer);
    procedure DBHelpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBInternetInitialize(Sender: TObject);
    procedure DBRefusePublicChatClick(Sender: TObject; X, Y: Integer);
    procedure DBRefusePublicChatInitialize(Sender: TObject);
    procedure DBRefuseCRYClick(Sender: TObject; X, Y: Integer);
    procedure DBRefuseCRYInitialize(Sender: TObject);
    procedure DBRefuseWHISPERClick(Sender: TObject; X, Y: Integer);
    procedure DBRefuseWHISPERInitialize(Sender: TObject);
    procedure DBRefuseguildClick(Sender: TObject; X, Y: Integer);
    procedure DBRefuseguildInitialize(Sender: TObject);
    procedure DWBottomCenterDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWBottomCenterInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DWBottomCenterMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWBottomCenterMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DChatMemoChange(Sender: TObject);
    procedure DChatMemoInitialize(Sender: TObject);
    procedure DChatMemoInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DChatMemoMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWBottomRightDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWBottomRightInitialize(Sender: TObject);
    procedure DWBottomRightMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBCallHeroInitialize(Sender: TObject);
    procedure DBHeroStateInitialize(Sender: TObject);
    procedure DBHeroPackageInitialize(Sender: TObject);
    procedure DBCallDeputyHeroInitialize(Sender: TObject);
    procedure DBHelpClick(Sender: TObject; X, Y: Integer);
    procedure DBHelpInitialize(Sender: TObject);
    procedure DBHeroSpleenImgDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBXinfaExpAbsorbClick(Sender: TObject; X, Y: Integer);
    procedure DBGloryDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBCallDeputyHeroClick(Sender: TObject; X, Y: Integer);
    procedure DBAutoCRYClick(Sender: TObject; X, Y: Integer);
    procedure DBAutoCRYInitialize(Sender: TObject);
    procedure DBCommandInitialize(Sender: TObject);
    procedure DBCallHeroClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinInitialize(Sender: TObject);
    procedure DWNewStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewStateTab1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinCloseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStateWinXFPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinXFPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStateWinXFPageInitialize(Sender: TObject);
    procedure DWNewStateWinXFPageTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinXFPageTab1Initialize(Sender: TObject);
    procedure DBXinFaExpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBXinFaExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBXinFaAbdomenMouseHintMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DMemoXinFaHintDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMemoXinFaHintInitialize(Sender: TObject);
    procedure DWNewStateWinXFPageTab2DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinXFPageTab2Initialize(Sender: TObject);
    procedure DBWinXinFaMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBWinXinFaMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBWinXinFaMagPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBWinXinFaMagPageUpInitialize(Sender: TObject);
    procedure DBWinXinFaMagPageDownInitialize(Sender: TObject);
    procedure DMemoXinFaHintScrollBarDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DMemoXinFaHintScrollBarInitialize(Sender: TObject);
    procedure DBNewStateWinPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStateWinPageInitialize(Sender: TObject);
    procedure DCheckNewDeputyHeroWarrClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinNGPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinNGPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinNGPageTab4Initialize(Sender: TObject);
    procedure DBNewWinBatterTopMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewWinBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewWinBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewWinBatterRandomInitialize(Sender: TObject);
    procedure DBNewWinBatterComClick(Sender: TObject; X, Y: Integer);
    procedure DBNewWinBatterComDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewWinBatterComMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewWinBatterMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewWinBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewStateHeroPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateHeroPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStateHeroPageInitialize(Sender: TObject);
    procedure DWNewStateHeroMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWNewStateHeroPageTab5DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroPageTab5Initialize(Sender: TObject);
    procedure DBNewHeroStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroStMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewHeroJQExpDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewHeroStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroStPageUpInitialize(Sender: TObject);
    procedure DBNewHeroStPageDownInitialize(Sender: TObject);
    procedure DWNewStateHeroDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroInitialize(Sender: TObject);
    procedure DBNewStateHeroTab1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewStateHeroCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateHeroCloseDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStateHeroNGPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateHeroNGPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStateHeroNGPageInitialize(Sender: TObject);
    procedure DWNewStateHeroNGPageTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroNGPageTab1Initialize(Sender: TObject);
    procedure DWNewStateHeroNGPageTab2DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroNGPageTab2Initialize(Sender: TObject);
    procedure DBNewHeroStNGMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroStNGMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroStNGMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNewHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DLNewHeroNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewHeroStNGPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroStNGPageUpInitialize(Sender: TObject);
    procedure DBNewHeroStNGPageDownInitialize(Sender: TObject);
    procedure DWNewStateHeroNGPageTab3DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroNGPageTab3Initialize(Sender: TObject);
    procedure DBNewHeroPointIcon1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroPointIcon1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroPointIcon1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewHeroPointPracticeClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroPointPracticeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroPointPracticeInitialize(Sender: TObject);
    procedure DBNewHeroPointPracticeMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewHeroPointPage1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroPointPage1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroPointPage1Initialize(Sender: TObject);
    procedure DWNewStateHeroNGPageTab4Initialize(Sender: TObject);
    procedure DBNewHeroBatterTopMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroBatterRandomInitialize(Sender: TObject);
    procedure DBNewHeroBatterComClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroBatterComDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroBatterComMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewHeroBatterMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWNewStateUserDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateUserInitialize(Sender: TObject);
    procedure DWNewStateUserMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNewStateUserNameClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateUserPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateUserPageInitialize(Sender: TObject);
    procedure DBNewStateUserPageDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateUserPageTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinPageTab1Initialize(Sender: TObject);
    procedure DBNewSUWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNewStateUserGuildNameClick(Sender: TObject; X, Y: Integer);
    procedure DBNewSUNecklaceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateUserPageTab2DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinPageTab4Initialize(Sender: TObject);
    procedure DBNewUserTitleManDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewTitleManInitialize(Sender: TObject);
    procedure DBNewUserTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewUserTitle1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewTitle1Initialize(Sender: TObject);
    procedure DBNewUserPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBNewPrevTitleInitialize(Sender: TObject);
    procedure DBNewNextTitleInitialize(Sender: TObject);
    procedure DWNewStateWinPageTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DBNewSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewSWNecklaceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewSWBujukDblClick(Sender: TObject);
    procedure DWNewStateWinPageTab2DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinPageTab2Initialize(Sender: TObject);
    procedure DBNewLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewLiquorProgressInitialize(Sender: TObject);
    procedure DWNewStateWinPageTab3DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinPageTab3Initialize(Sender: TObject);
    procedure DWNewStateWinPageTab4DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewTitleManClick(Sender: TObject; X, Y: Integer);
    procedure DBNewTitleManDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewTitle1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewTitle1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBNewPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinPageTab5DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinPageTab5Initialize(Sender: TObject);
    procedure DBNewStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewStMag1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBNewStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewHBExpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBNewHBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewJQExpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBNewJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStPageUpInitialize(Sender: TObject);
    procedure DBNewStPageDownInitialize(Sender: TObject);
    procedure DBNewStateWinNGPageInitialize(Sender: TObject);
    procedure DWNewStateWinNGPageTab3DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinNGPageTab3Initialize(Sender: TObject);
    procedure DWNewStateWinNGPageTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinNGPageTab1Initialize(Sender: TObject);
    procedure DWNewStateWinNGPageTab2DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateWinNGPageTab2Initialize(Sender: TObject);
    procedure DBNewStNGMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewStNGMag1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewStNGMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNewNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewStNGPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBNewWinPointIcon1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewWinPointIcon1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewWinPointIcon1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewWinPointPage1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewWinPointPage1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewWinPointPage1Initialize(Sender: TObject);
    procedure DBHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DBHeroPackageClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateHeroPageTab1DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroPageTab1Initialize(Sender: TObject);
    procedure DBNewSHWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DBNewSHWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewSHNecklaceDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroPageTab2DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroPageTab2Initialize(Sender: TObject);
    procedure DBNewHeroLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBNewHeroLiquorProgressInitialize(Sender: TObject);
    procedure DWNewStateHeroPageTab3DirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWNewStateHeroPageTab3Initialize(Sender: TObject);
    procedure AspDButton1Initialize(Sender: TObject);
    procedure DWLingWuXinFaKeyInitialize(Sender: TObject);
    procedure DMsgDlgGameGoldBuyInitialize(Sender: TObject);
    procedure DMsgDlgGamePointBuyInitialize(Sender: TObject);
    procedure DBRefineDrumCloseBtnInitialize(Sender: TObject);
    procedure DBRefineDrumCloseBtnClick(Sender: TObject; X, Y: Integer);
    procedure DBRefineDrumOKBtnDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBRefineDrumCloseBtnDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBRefineDrumOKBtnInitialize(Sender: TObject);
    procedure DBRefineDrumOKBtnClick(Sender: TObject; X, Y: Integer);
    procedure DWRefineDrumInitialize(Sender: TObject);
    procedure RefineBtn1Click(Sender: TObject; X, Y: Integer);
    procedure RefineBtn1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure RefineBtn1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DBigMerchantDlgInitialize(Sender: TObject);
    procedure DBigMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DBigMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBigMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBigMerchantDlgCloseInitialize(Sender: TObject);
    procedure DWFactionAddDlgInitialize(Sender: TObject);
    procedure DBNewWinPointPracticeInitialize(Sender: TObject);
    procedure DBNewWinPointPracticeClick(Sender: TObject; X, Y: Integer);
    procedure DBNewWinPointPracticeDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DWBottomCenterInitialize(Sender: TObject);
    procedure DWBottomCenterFirInitialize(Sender: TObject);
    procedure DWBottomCenterFirDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DLieDragonInitialize(Sender: TObject);
    procedure DLabelProCapInitialize(Sender: TObject);
    procedure DLoginOkDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DLogInDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure DSServer1DirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);

    {$IF M2Version <> 2}
    procedure DBFactionIconDirectPaint(Sender: TObject;
      dsurface: TAsphyreCanvas);
    procedure DBFactionIconMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLFactionNameClick(Sender: TObject; X, Y: Integer);
    {$IFEND}

    {.$if Version <> 0}
       // constructor Create(AOwner: TComponent); override;
    {.$IFEND}
  private
    DlgTemp: TList;
    magcur, magtop, HeroMagTop: integer;
    EdDlgEdit: TEdit;
    Memo: TMemo;

    MoveChatDlgY: Integer; // liuzhigang add
    ChatMemoHeight: Integer;
    
    ViewDlgEdit: Boolean;
    msglx, msgly: integer;
    MenuTop: integer;

    MagKeyIcon, MagKeyCurKey, MagKeyEffect, MagKeyID, MagKeyLevel: integer;
    MagKeyLevelEx: Byte;
    MagKeyMagName: string;


    {$IF M2Version <> 2}
    m_btUserTitlePage: Byte;
    m_btTitlePage: Byte;
    m_btXinFaPage: Byte;
    
    SkillMemoTitle, SkillMemoName: string;
    SkillMemoId, SkillMemoEffect, SKillMemoIcon, SkillMemoLevel: Integer;
    HeroSkillMemoTitle, HeroSkillMemoName, HeroSkillMemoUserName: string;
    HeroSkillMemoId, HeroSkillMemoEffect, HeroSkillMemoIcon: Integer;
    HeroSkillMemoLinkIdx: Byte;

    m_dwAbilTick: LongWord; // liuzhigang add
    m_btAbilIndex: Byte;
    {$IFEND}

    InternalForceMagicPage: integer;  //内功技能页
    HeroMagicPage: integer;
    HeroInternalForceMagicPage: integer; //英雄内功技能页
    BlinkTime: Longword;
    BlinkCount: integer;  //0..9荤捞甫 馆汗

    imginsex:integer;// 
    typetime: longword;

    SighIconTimeTick: LongWord; //感叹号时间间隔
    SighIconImginsex: Byte;

    ExpCrystalTopTimeTick: LongWord; //天地结晶显示时间间隔
    ExpCrystalTopImginsex: Byte;
    ExpCrystalTopEffectTimeTick: LongWord; //天地结晶动画显示时间间隔
    ExpCrystalTopEffectImginsex: Byte;

    ExpNQTimeTick: LongWord; //牛气显示时间间隔
    ExpNQImginsex: Byte;
    //评定英雄按钮动画
    HeroAssessSignTimeTick: LongWord;
    HeroAssessSignImginsex: Byte;
    //金针logo上的动画
    KimNeedleLogoTimeTick: LongWord;
    KimNeedleLogoImginsex: Byte;
    //金针锻造状态下的火苗
    KimNeedleStartFlameTimeTick: LongWord;
    KimNeedleStartFlameImginsex: Byte;
    //显示开始锻造的滚动条
    KimShowBarTimeTick: LongWord;
    KimShowBarImginsex: Byte;
    boKimShowBarSend: Boolean;
    //学位闪亮动画
    PulseOriginTimeTick: LongWord;
    PulseOriginImginsex: Byte;
    //可以使用连击时的小块动画
    BatterShowTimeTick: LongWord;
    BatterShowImginsex: Byte;
    BatterTopTimeTick: LongWord;
    BatterTopImginsex: Byte;
    BatterTopMagIndex: Byte;
    HeroBatterTopMagIndex: Byte;
    WinBatterComIndex: Integer;
    HeroBatterComIndex: Integer;
    //私聊系统
    WhisperPoints: TList;
    WhisperAddPoints: Boolean;
    WhisperMoveedStr: string;
    WhisperSelectStr: string;
    //内观刀发光动画变量
    WeaponTimeTick: LongWord;
    WeaponImginsex: Byte;

    //任务系统
    MissionBottomPoints: TList;
    MissionBottomAddPoints: Boolean;
    MissionMoveedBottomStr: string;
    m_dwMissionEffTick: LongWord;
    m_btMissionEffImg: Byte;
    {$IF M2Version = 1}
    m_boQJPracticeHero: Boolean;
    m_sQJPracticeObjectName: string;
    m_btQjPracticeSkillLevel: Byte;
    m_dwQjPracticeCurTrain: Longword;
    m_dwQJpracticeMaxTrain: LongWord;
    {$IFEND}
    procedure MissionPageChanged;//任务系统页数改变
    procedure SendMissionSelect (rstr: string);
    procedure HideAllControls;
    procedure RestoreHideControls;
    procedure PageChanged;
    procedure InternalForcePageChanged;
    procedure LevelOrderPageChanged;//等级排行榜页数改变 2007.12.12
//    procedure MouseRightItem(WhoItemBag{谁的包裹},ACol,ARow:Integer);//右键穿装备
    procedure DealItemReturnBag (mitem: TClientEffecItem);
    procedure ChallengeItemReturnBag (mitem: TClientEffecItem);
    procedure SellOffItemReturnBag (mitem: TClientEffecItem);//元宝寄售返回包裹 20080316
    //procedure ItemUpReturnBag (mitem: TMovingItem); //粹练返回包裹 20080506
    procedure DealZeroGold;
    function  GetMiniMapNum(num:Integer): TAsphyreLockableTexture;  //获得新小地图号  20080324
    procedure NpcAutoSelDrinkRuning(dsurface: TAsphyreCanvas);

    {$IF M2Version = 1}
    procedure ShowQJPractice(boIsHero: Boolean);
    procedure ChangeNGPointPage();
    procedure ChangeHeroNGPointPage();
    {$IFEND}
    
    {$IF M2Version <> 2}
    function GetTitlePageIdx(btMaxPage: Byte): Byte;
    function GetUserTitlePageIdx(): Byte;
    procedure ShowFactionDlgEditNotice();
    {$IFEND}

    procedure SetChatDlgHeight(Value: Integer);
  public
    MagicPage: integer;
    StateTab: Byte; //内功上面的页
    HeroStateTab: Byte; //英雄内功上面的页
    InternalForcePage: Integer; //内功状态页
    HeroInternalForcePage: Integer; //英雄内功状态页

    StatePage: Integer;
    LevelOrderPage: Integer; //大分类页数
    StatePulsePage: Integer; //冲脉，阴跷，阴维，任脉，奇经

    strorlist    :array[0..STRLINS-1] of String;
    strorlistidx :array[0..STRLINS-1] of Integer;
    strorliscont :Integer;
    HeroStatePage: Integer; //英雄信息页码 $012 2007.10.21
    HeroStatePulsePage: Integer; //冲脉，阴跷，阴维，任脉，奇经
    MsgText: string;
    DialogSize: Integer;
    RefuseWHISPERLevel:Integer; //拒绝私聊的等级

    m_nDiceCount:Integer;
    m_boPlayDice:Boolean;
    m_Dice:array[0..9] of TDiceInfo;

    MerchantName: string;
    MerchantFace: Integer;
    MDlgStr: string;
    MDlgPoints: TList;
    RequireAddPoints: Boolean;
    SelectMenuStr: string;
    LastestClickTime: longword;
    SpotDlgMode: TSpotDlgMode;
    DlgShopTime: LongWord;
    MenuList: TList; //list of PTClientGoods
    WinType:Integer;
    MenuIndex: integer;
    CurDetailItem: string;
    MenuTopLine: integer;
    BoDetailMenu: Boolean;
    BoStorageMenu: Boolean;
    BoNoDisplayMaxDura: Boolean;
    BoMakeDrugMenu: Boolean;
    NAHelps: TStringList;
    NewAccountTitle: string;
    DlgEditText: string;
    UserState1: TUserStateInfo;
    Guild: string;
    GuildFlag: string;
    GuildCommanderMode: Boolean;
    GuildStrs: TStringList;
    GuildStrs2: TStringList;
    GuildNotice: TStringList;
    GuildMembers: TStringList;
    GuildTopLine: integer;
    GuildEditHint: string;
    GuildChats: TStringList;
    BoGuildChat: Boolean;
    //任务
    m_boMissionEff: Boolean;
    m_btMissionPage: Byte;
    //内挂药品
    m_btProPage: Byte;
    {$IF M2Version <> 2}
    m_btSignedItemsPage: Byte;
    m_btJudjeItemsPage: Byte;
    m_btMakeSignedPage: Byte;
    m_boSignedLock: Boolean; //鉴定 发送消息后锁定
    m_boMakeSignedLock: Boolean; //解读 发送消息后锁定
    m_dwSignedTimeTick: LongWord; //鉴定时间间隔
    m_btSignedImginsex: Byte;
    m_dwMakeSignedTimeTick: LongWord; //解读时间间隔
    m_btMakeSignedImginsex: Byte;
    m_dwLingMeiTimeTick: LongWord; //灵媒时间间隔
    m_btLingMeiImgFrame: Byte;
    m_boLingMeiEffect: Boolean; //是否执行动画
    m_btSignedSuccess: Byte; //鉴定 1-成功 2-失败   更换3-成功 4-失败
    m_btSignedHint: Byte; //鉴定 1-成功的提示 2-失败的提示
    m_btMakeSignedSuccess: Byte; //鉴定 1-成功 2-失败   更换3-成功 4-失败
    m_btMakeSignedHint: byte; //解读 兑换卷轴1-成功的提示 2-失败的提示  解读属性3-成功的提示 4-失败的提示
    HeroSkillMemoAddHp: Integer;
    m_btPJLingPaiPage: Byte;
    m_sSelPJLingPaiName: string; //护花令牌选择人名
    m_btZZLingPaiPage: Byte; //主宰令牌分页
    m_btZZHWLingPaiPage: Byte; //主宰近卫军分页
    m_sSelHWLingPaiName: string; //近卫军选择人名
    m_btFactionPage: Byte;
    {$IFEND}
    
    procedure Initialize;
    procedure PlayInitialize;
    procedure InitializePlace; //初始化图象位置 20080524
    procedure OpenMyStatus;
    procedure OpenUserState (UserState: TUserStateInfo);
    procedure OpenItemBag;
    procedure ViewBottomBox (visible: Boolean);
    procedure CancelItemMoving;
    procedure CancelHeroItemMoving; // 取消英雄物品移动
    procedure DropMovingItem;
    procedure DropHeroMovingItem; //英雄往地上扔东西
    procedure OpenAdjustAbility;
    procedure ShowSelectServerDlg;
    function  DMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons; bClearEdit:Boolean=True): TModalResult;
    procedure ShowMDlg (face: integer; mname, msgstr: string);
    procedure ShowMBigDlg (face: integer; mname, msgstr: string);
    procedure ShowGuildDlg;
    procedure ShowGuildEditNotice;
    procedure ShowGuildEditGrade;
    procedure ResetMenuDlg;
    procedure ShowShopMenuDlg;
    procedure ShowShopSellDlg;
    procedure ShowShopSellOffDlg;  //元宝寄售显示窗口 20080316
    procedure CloseDSellDlg;
    procedure CloseMDlg;
    procedure CloseMBigDlg;
    procedure ToggleShowGroupDlg;
    procedure OpenDealDlg;
    procedure OpenChallengeDlg; //打开挑战对话框
    procedure CloseChallengeDlg;
    procedure CloseDealDlg;
    procedure OpenFriendDlg;
    procedure SoldOutGoods (itemserverindex: integer);
    procedure DelStorageItem (itemserverindex: integer);

    procedure GetMouseItemInfo (var iname, iname1, line1, line2, line3, line4, line5, sUnKnow1, sUnKnow2: string; var useable: boolean; Who: Integer{1为主人,2为英雄});
    procedure ShowMouseItemInfo(X, Y: Integer; AddLine: string; who:Byte; DrawUp: Boolean);

    procedure SetMagicKeyDlg (icon: integer; Effect, Level,LevelEx: Byte; MagID: Word; magname: string; var curkey: word);

    {$IF M2Version <> 2}
    function  GetTitleInfo(TitleItem: TClientHumTitle; var List: TStringList; boNewState: Boolean): string;
    procedure SetSkillMemoDlg(MagID, MagLevel: Word; Effect: Byte; magname, magTitle: string);
    procedure SetHeroSkillMemoDlg(MagID: Word; Effect: Byte; magname, magTitle: string);
    procedure UseLingMeiItem();
    procedure ChangeZZLingPaiPage(btPage: Byte);
    procedure NGUpLevelState(boIsHero: Boolean);
    procedure NewNGUpLevelState(boIsHero: Boolean);

    procedure ShowFactionDlg;
    procedure AddFactionMember(DivisionMember: TClientDivisionMember; X, Y: Integer);
    procedure FactionMemberListFree();
    procedure SetNewWinStateTabVisible(boVisible, boIsXinFa: Boolean);
    procedure SetNewHeroStateTabVisible(boVisible: Boolean);
    {$IFEND}
    procedure AddGuildChat (str: string);
    procedure ShowPlayDrink (Who1: integer; msgstr: string);
    procedure NewSdoAssistantPageChanged;//新盛大内挂页数改变 20080624
    procedure ShowKimNeedle(Bool: Boolean);
    procedure AddWhisper(str: string);
    procedure AutoWhisper(str: string);
    procedure JLBoxItemBelt(Sender: TObject; dsurface: TAsphyreCanvas);
    procedure ClientGetMissionSay(nParam: Integer; Text: string);
    procedure ChangeProPage(nPage: Byte);
    procedure CreateParams(var Params:TCreateParams);override;//设置程序的类名 20080412

    procedure NewMagicBtnNotVisible();
    procedure InitOtherParm;
    procedure GotoShopPage(CurPage:Integer);
  end;

var
  FrmDlg: TFrmDlg;

implementation

uses
   ClMain, MShare, Browser, DrawScrn;

{$R *.DFM}

{$IF M2Version <> 2}
{ TFactionMember }

constructor TFactionMember.Create;
begin
  m_Icon := TAspDButton.Create(FrmDlg.DWFactionDlg.Owner);
  m_Icon.OnDirectPaint := FrmDlg.DBFactionIconDirectPaint;
  m_Icon.OnMouseMove := FrmDlg.DBFactionIconMouseMove;
  m_Icon.DParent := FrmDlg.DWFactionDlg;
  //FrmDlg.DWFactionDlg.AddChild(m_Icon);
  m_Name := TAspDLabel.Create(FrmDlg.DWFactionDlg.Owner);
  m_Name.OnClick := FrmDlg.DLFactionNameClick;
  m_Name.DParent := FrmDlg.DWFactionDlg;
  m_Name.Font.Size:=9;
  m_Name.Font.Name:='宋体';
  m_Name.Down:=True;
  //FrmDlg.DWFactionDlg.AddChild(m_Name);
  m_Name.UpColor := clWhite;
  m_Name.HotColor := clWhite;
  m_Name.BoldFont := True;
  FillChar(m_DivisionMember, SizeOf(TClientDivisionMember), #0);
end;

destructor TFactionMember.Destroy;
begin
  m_Name.Free;
  m_Icon.Free;
  inherited;
end;
{$IFEND}

procedure TFrmDlg.FormCreate(Sender: TObject);
begin
   //frmMain.DXDraw.Initialize;
   //ItemLightImgIdx := 0; //初始化物品发光图片ID为0 20080223
   RefuseWHISPERLevel:=9999; //容许和所有等级的人说话
   JNHelmetLightImgIdx := 0;
   g_boBoxsMiddleItems := False; //初始化宝箱物品为中间
   StatePage := 0;
   m_btMissionPage := 0;
   m_btProPage := 0;
   StatePulsePage := 0;
   LevelOrderPage := 0;
   g_nBoxsImg := 0;
   g_BoxsFlashImg := 0;
   g_BoxsFilleFlashImg := 0;
   g_LieDragonPage := 0; //卧龙
   HeroStatePage := 0;
   HeroMagicPage := 0;
   DlgTemp := TList.Create;
   DialogSize := 1;
   m_nDiceCount:=0;
   m_boPlayDice:=False;
   magcur := 0;
   magtop := 0;
   HeroMagTop := 0;
   MDlgPoints := TList.Create;
   WhisperPoints := TList.create;
   MissionBottomPoints := TList.Create;
   SelectMenuStr := '';
   MenuList := TList.Create;
   MenuIndex := -1;
   MenuTopLine := 0;
   BoDetailMenu := FALSE;
   BoStorageMenu := FALSE;
   BoNoDisplayMaxDura := FALSE;
   BoMakeDrugMenu := FALSE;
   MagicPage := 0;
   InternalForceMagicPage := 0;
   HeroInternalForceMagicPage := 0;
   NAHelps := TStringList.Create;
   BlinkTime := GetTickCount;
   DlgShopTime := GetTickCount;
   BlinkCount := 0;
   g_ShopPage:=0;
   ShopGifFrame:=0;
   imginsex:=0;
   //ShopImgIdx := 0;
   SighIconImginsex := 0;
   WeaponImginsex := 0;
   ExpCrystalTopImginsex := 0;
   ExpCrystalTopEffectImginsex := 0;
   ExpNQImginsex := 0;
   ShowNQExpInc := 0;
   KimNeedleLogoImginsex := 0;
   KimNeedleStartFlameImginsex := 0;
   PulseOriginImginsex := 0;
   BatterShowImginsex := 0;
   BatterTopImginsex := 0;
   BatterTopMagIndex := 0;
   HeroBatterTopMagIndex := 0;
   {$IF M2Version <> 2}
   m_btUserTitlePage := 0;
   m_btTitlePage := 0;
   m_btXinFaPage := 0;

   m_btPJLingPaiPage := 0;
   m_btZZLingPaiPage := 0;
   m_btZZHWLingPaiPage := 0;
   m_boMissionEff := False;
   m_btMissionEffImg := 0;
   HeroSkillMemoLinkIdx := 0;
   m_boSignedLock := False;
   m_boMakeSignedLock := False;
   m_btSignedImginsex := 0;
   m_btLingMeiImgFrame := 0;
   m_btMakeSignedImginsex := 0;
   m_boLingMeiEffect := False;
   m_btSignedSuccess := 0; //1-成功 2-失败
   m_btSignedHint := 0;
   m_btMakeSignedSuccess := 0;
   m_btMakeSignedHint := 0;

   m_btFactionPage := 0;
   //m_dwAbilTick := GetTickCount();
   //m_btAbilIndex := 0;
   {$IFEND}
   
   g_SellDlgItem.ClientItem.S.Name := '';
   Guild := '';
   GuildFlag := '';
   GuildCommanderMode := FALSE;
   GuildStrs := TStringList.Create;
   GuildStrs2 := TStringList.Create; //归诀侩
   GuildNotice := TStringList.Create;
   GuildMembers := TStringList.Create;
   GuildChats := TStringList.Create;
   g_PlayDrinkPoints := TList.Create; //20080515
   EdDlgEdit := TEdit.Create (FrmMain.Owner);
   with EdDlgEdit do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Size := 9;
      MaxLength := 30;
      Height := 16;
      Ctl3d := FALSE;
      BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
      Visible := FALSE;
   end;
   Memo := TMemo.Create (FrmMain.Owner);
   with Memo do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Size := 9;
      Ctl3d := FALSE;
      BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
      Visible := FALSE;
   end;
end;

procedure TFrmDlg.FormDestroy(Sender: TObject);
var
  I: Integer;
begin
   DlgTemp.Free;
   for I:=0 to MDlgPoints.Count - 1  do begin  //20080718释放内存
    if pTClickPoint(MDlgPoints[i]) <> nil then
      Dispose(pTClickPoint(MDlgPoints[i]));
   end;
   FreeAndNil(MDlgPoints);
   for I:=0 to WhisperPoints.Count - 1 do begin
     if pTClickSLPoint(WhisperPoints[I]) <> nil then
      Dispose(pTClickSLPoint(WhisperPoints[i]))
   end;
   FreeAndNil(WhisperPoints);
   for I:=0 to MissionBottomPoints.Count - 1 do begin
     if pTClickPoint(MissionBottomPoints[I]) <> nil then
      Dispose(pTClickPoint(MissionBottomPoints[I]))
   end;
   FreeAndNil(MissionBottomPoints);
   g_PlayDrinkPoints.Free;  
   MenuList.Free;
   NAHelps.Free;
   GuildStrs.Free;
   GuildStrs2.Free;
   GuildNotice.Free;
   GuildMembers.Free;
   GuildChats.Free;
end;

procedure TFrmDlg.HideAllControls;
var
   i: integer;
   c: TControl;
begin
   DlgTemp.Clear;
   with FrmMain do
      if ControlCount > 0 then //20080629
      for i:=0 to ControlCount-1 do begin
         c := Controls[i];
         if c is TEdit then
            if (c.Visible) and (c <> EdDlgEdit) then begin
               DlgTemp.Add (c);
               c.Visible := FALSE;
            end;
      end;
end;

procedure TFrmDlg.RestoreHideControls;
var
   i: integer;
begin
   if DlgTemp.Count > 0 then //20080629
   for i:=0 to DlgTemp.Count-1 do begin
      TControl(DlgTemp[i]).Visible := TRUE;
   end;
end;

procedure TFrmDlg.Initialize;  //初始化窗口   2007.10.20  New Copy
var
  d: TAsphyreLockableTexture;
begin
  g_DWinMan.ClearAll;
  DBackground.GLeft := 0;
  DBackground.GTop := 0;
  DBackground.GWidth := g_D3DConfig.wScreenWidth;
  DBackground.GHeight := g_D3DConfig.wScreenHeight;
  DBackground.Background := TRUE;
  g_DWinMan.AddDControl (DBackground, TRUE);
  {$IF M2Version <> 2}
  DPNewStateWinTab.ActivePage := 1;
  DPNewStateWinPage.ActivePage := 0;
  DPNewStateWinNGPage.ActivePage := 0;
  DPNewStateWinXFPage.ActivePage := 0;
  //英雄
  DPNewStateHeroTab.ActivePage := 0;
  DPNewStateHeroPage.ActivePage := 0;
  DPNewStateHeroNGPage.ActivePage := 0;
  d := g_WUI1Images.Images[2185];
  g_boNewNewStateWin := d <> nil;
  d := g_WUI1Images.Images[2232];
  g_boNewNewHeroState := d <> nil;
  {$IFEND}
  g_boDoFadeIn := True;
end;

//初始化图象位置 20080524
procedure TFrmDlg.InitializePlace;   // New Copy
begin

  ChatMemoHeight := 211;
  MoveChatDlgY := 0;
//去不掉的
{$IF M2Version = 2} //1.76
  DItemBag.GLeft := 0;
  DItemBag.GTop := 0;
{$ELSE}
  DItemBag.GLeft := -5;
  DItemBag.GTop := 69;//20090304修改
{$IFEND}
  {$IF M2Version = 2}
  DBHelp.Visible := False;
  DBInternet.Visible := False;
  DBCallHero.Visible := False;
  DBHeroState.Visible := False;
  DBHeroPackage.Visible := False;
  DBCallDeputyHero.Visible := False;
  DBGlory.Visible := False;
  DSWBujuk.Visible := False;
  DSWBelt.Visible := False;
  DSWBoots.Visible := False;
  DSWCharm.Visible := False;
  DStateSsas.Visible := False;
  DLiquorProgress.Visible := False;
  DBujukUS1.Visible := False;
  DBeltUS1.Visible := False;
  DBootsUS1.Visible := False;
  DCharmUS1.Visible := False;
  DDrunkScale.Visible := False;
  DItemsUpBut.Visible := False;
  DWGameGold.Visible := False;
  DGameGirdExchange.Visible := False;
  DCheckAutoButch.Visible := False;
  DCheckAutoUseHuolongzhu.Visible := False;
  DCheckAutoUseJingyuandan.Visible := False;
  DCheckBoxHideTitle.Visible := False;
  DCheckScreenShake.Visible := False;
  DCheckHeroLevelHint.Visible := False;
  DCheckSdoAutoDrinkWine.Visible := False;
  DEdtSdoDrunkWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkWine.Visible := False;
  DEdtSdoHeroDrunkWineDegree.Visible := False;
  DCheckSdoAutoDrinkDrugWine.Visible := False;
  DEdtSdoDrunkDrugWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkDrugWine.Visible := False;
  DEdtSdoHeroDrunkDrugWineDegree.Visible := False;
  DCheckSdoZhuri.Visible := False;
  DCheckSdoHeroShield.Visible := False;
  DCheckShowHeroStateNumber.Visible := False;
  DCheckShowSpecialDamage.Visible := False;
  DCheckAutoDragInBody.Visible := False;
  DCheckHeroBatterNotMob.Visible := False;
  DCheckHideHumanWing.Visible := False;
  DCheckHideWeaponEffect.Visible := False;
  {DBProMyHero1.Visible := False;
  DBProMyHero2.Visible := False;
  DBProMyHero3.Visible := False;
  DBProMyHero4.Visible := False;  }
  DBotFaction.Visible := False;
  {$IFEND}
end;

procedure TFrmDlg.PlayInitialize;
begin
  {$IF M2Version <> 2}
  DBLevelOrderUseItem.Visible := True;
  DBLevelOrderCloud.Visible := True;
  DBOrderWeapon.Visible := True;
  DBOrderRing.Visible := True;
  DBOrderDress.Visible := True;
  DBOrderBoots.Visible := True;
  DBOrderHelmet.Visible := True;
  DBOrderBelt.Visible := True;
  DBOrderNecklace.Visible := True;
  DBOrderMedal.Visible := True;
  DBOrderWristlet.Visible := True;
  DBOrderHat.Visible := True;
  DBMission.Visible := True;
  {$IFEND}
  g_boOnePlay := True;
end;

{$REGION '控件初始化'}
{$REGION '登录窗体'}
procedure TFrmDlg.DLoginNewInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DLoginNew.SetImgIndex (g_WMainImages, 61);
  DLoginNew.GLeft := 25;
  DLoginNew.GTop  := 207;
{$ELSE}
  DLoginNew.SetImgIndex (g_WMainImages, 61);
  DLoginNew.GLeft := 32;
  DLoginNew.GTop  := 173;
{$IFEND}
end;

procedure TFrmDlg.DLoginOkInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DLoginOk.SetImgIndex (g_WMainImages, 62);
  DLoginOk.GLeft := 169;
  DLoginOk.GTop := 163;
{$ELSE}
  DLoginOk.SetImgIndex (g_WMain3Images, 10);
  DLoginOk.GLeft := 164;
  DLoginOk.GTop := 172;
{$IFEND}
end;

procedure TFrmDlg.DLoginChgPwInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DLoginChgPw.SetImgIndex (g_WMainImages, 53);
  DLoginChgPw.GLeft := 130;
  DLoginChgPw.GTop  := 207;
{$ELSE}
  DLoginChgPw.SetImgIndex (g_WMain3Images, 28);
  DLoginChgPw.GLeft := 164;
  DLoginChgPw.GTop  := 215;
{$IFEND}
end;

procedure TFrmDlg.DLoginCloseInitialize(Sender: TObject);
begin
  DLoginClose.SetImgIndex (g_WMainImages, 64);
{$IF M2Version = 2} //1.76
  DLoginClose.GLeft := 252;
  DLoginClose.GTop := 28;
{$ELSE}
  DLoginClose.GLeft := 258;
  DLoginClose.GTop := 24;
{$IFEND}
end;

procedure TFrmDlg.DLogInDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
  D : TAsphyreLockableTexture;
begin
  with TAspDWindow(Sender) do begin
  if WLib <> nil then begin
    d := WLib.Images[FaceIndex];
    if d <> nil then begin
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end else
      dsurface.FrameRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clWhite);
  end;
  end;
end;

procedure TFrmDlg.DLogInInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
{$IF M2Version = 2} //1.76
  d := g_WMainImages.Images[60];
  if d <> nil then begin
    DLogIn.SetImgIndex (g_WMainImages, 60);
  end;
{$ELSE}
  d := g_qingqingImages.Images[34];
  if d <> nil then begin
    DLogIn.SetImgIndex (g_qingqingImages, 34);
  end;
{$IFEND}
  //修改无图片显示背景框 By TasNat at: 2012-03-26 09:36:01
  if d = nil then begin
    m_EdId.Transparent := False;
    m_EdPasswd.Transparent := False;
  end;
  //修改为真实大小 By TasNat at: 2012-03-26 09:36:01
  DLogIn.GLeft := (g_D3DConfig.wScreenWidth - DLogIn.GWidth) div 2;
  DLogIn.GTop := (g_D3DConfig.wScreenHeight - DLogIn.GHeight) div 2;
end;
procedure TFrmDlg.m_EdIdInitialize(Sender: TObject);
begin
  with m_Edid do begin
    {$IF M2Version = 2} //1.76
    GLeft := 98;
    GTop := 83;
    {$ELSE}
    GLeft := 123;
    GTop := 70;
    {$IFEND}
  end;
end;
procedure TFrmDlg.m_EdPasswdInitialize(Sender: TObject);
begin
  with m_EdPasswd do begin
    {$IF M2Version = 2} //1.76
    GLeft := 98;
    GTop := 115;
   {$ELSE}
    GLeft := 123;
    GTop := 102;
   {$IFEND}
  end;
end;
{$ENDREGION}
{$REGION '注册窗体'}
procedure TFrmDlg.DNewAccountOkInitialize(Sender: TObject);
begin
  DNewAccountOk.SetImgIndex (g_WMainImages, 62);
end;

procedure TFrmDlg.DNewAccountCancelInitialize(Sender: TObject);
begin
  DNewAccountCancel.SetImgIndex (g_WMainImages, 52);
end;

procedure TFrmDlg.DNewAccountCloseInitialize(Sender: TObject);
begin
  DNewAccountClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DNewAccountInitialize(Sender: TObject);
begin
  DNewAccount.SetImgIndex (g_WMainImages, 63);
end;
{$ENDREGION}
{$REGION '选择服务器'}
procedure TFrmDlg.DSServer1Initialize(Sender: TObject);
begin
  DSServer1.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer2Initialize(Sender: TObject);
begin
  DSServer2.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer3Initialize(Sender: TObject);
begin
  DSServer3.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer4Initialize(Sender: TObject);
begin
  DSServer4.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer5Initialize(Sender: TObject);
begin
  DSServer5.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer6Initialize(Sender: TObject);
begin
  DSServer6.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSSrvCloseInitialize(Sender: TObject);
begin
  DSSrvClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DSelServerDlgInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[256]; //81];
  if d <> nil then begin
    DSelServerDlg.SetImgIndex (g_WMainImages, 256);
  end;
  DSelServerDlg.GLeft := (g_D3DConfig.wScreenWidth - DSelServerDlg.GWidth) div 2;
  DSelServerDlg.GTop := (g_D3DConfig.wScreenHeight - DSelServerDlg.GHeight) div 2;
end;
{$ENDREGION}
{$REGION '创建人物'}
procedure TFrmDlg.DccWarriorInitialize(Sender: TObject);
begin
  DccWarrior.SetImgIndex (g_WMainImages, 74);
end;

procedure TFrmDlg.DccWizzardInitialize(Sender: TObject);
begin
  DccWizzard.SetImgIndex (g_WMainImages, 75);
end;

procedure TFrmDlg.DccMaleInitialize(Sender: TObject);
begin
  DccMale.SetImgIndex (g_WMainImages, 77);
end;

procedure TFrmDlg.DccMonkInitialize(Sender: TObject);
begin
  DccMonk.SetImgIndex (g_WMainImages, 76);
end;

procedure TFrmDlg.DccOkInitialize(Sender: TObject);
begin
  DccOk.SetImgIndex (g_WMainImages, 62);
end;

procedure TFrmDlg.DccFemaleInitialize(Sender: TObject);
begin
  DccFemale.SetImgIndex (g_WMainImages, 78);
end;

procedure TFrmDlg.DccLeftHairInitialize(Sender: TObject);
begin
  DccLeftHair.SetImgIndex (g_WMainImages, 79);
end;

procedure TFrmDlg.DccRightHairInitialize(Sender: TObject);
begin
  DccRightHair.SetImgIndex (g_WMainImages, 80);
end;

procedure TFrmDlg.DccCloseInitialize(Sender: TObject);
begin
  DccClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DCreateChrInitialize(Sender: TObject);
begin
  DCreateChr.SetImgIndex (g_WMainImages, 73);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '修改密码窗体'}
procedure TFrmDlg.DChgpwOkInitialize(Sender: TObject);
begin
  DChgpwOk.SetImgIndex (g_WMainImages, 62);
end;

procedure TFrmDlg.DChgpwCancelInitialize(Sender: TObject);
begin
  DChgpwCancel.SetImgIndex (g_WMainImages, 52);
end;

procedure TFrmDlg.DChgPwInitialize(Sender: TObject);
begin
  DChgPw.SetImgIndex (g_WMainImages, 50);
end;
{$ENDREGION}
{$REGION '设置魔法快捷键'}
procedure TFrmDlg.DKsF1Initialize(Sender: TObject);
begin
  DKsF1.SetImgIndex (g_WMainImages, 232);
end;

procedure TFrmDlg.DKsF2Initialize(Sender: TObject);
begin
  DKsF2.SetImgIndex (g_WMainImages, 234);
end;

procedure TFrmDlg.DKsF3Initialize(Sender: TObject);
begin
  DKsF3.SetImgIndex (g_WMainImages, 236);
end;

procedure TFrmDlg.DKsF4Initialize(Sender: TObject);
begin
  DKsF4.SetImgIndex (g_WMainImages, 238);
end;

procedure TFrmDlg.DKsF5Initialize(Sender: TObject);
begin
  DKsF5.SetImgIndex (g_WMainImages, 240);
end;

procedure TFrmDlg.DKsF6Initialize(Sender: TObject);
begin
  DKsF6.SetImgIndex (g_WMainImages, 242);
end;

procedure TFrmDlg.DKsF7Initialize(Sender: TObject);
begin
  DKsF7.SetImgIndex (g_WMainImages, 244);
end;

procedure TFrmDlg.DKsF8Initialize(Sender: TObject);
begin
  DKsF8.SetImgIndex (g_WMainImages, 246);
end;

procedure TFrmDlg.DKsConF1Initialize(Sender: TObject);
begin
  DKsConF1.SetImgIndex (g_WMain3Images, 132);
end;

procedure TFrmDlg.DKsConF2Initialize(Sender: TObject);
begin
  DKsConF2.SetImgIndex (g_WMain3Images, 134);
end;

procedure TFrmDlg.DKsConF3Initialize(Sender: TObject);
begin
  DKsConF3.SetImgIndex (g_WMain3Images, 136);
end;

procedure TFrmDlg.DKsConF4Initialize(Sender: TObject);
begin
  DKsConF4.SetImgIndex (g_WMain3Images, 138);
end;

procedure TFrmDlg.DKsConF5Initialize(Sender: TObject);
begin
  DKsConF5.SetImgIndex (g_WMain3Images, 140);
end;

procedure TFrmDlg.DKsConF6Initialize(Sender: TObject);
begin
  DKsConF6.SetImgIndex (g_WMain3Images, 142);
end;

procedure TFrmDlg.DKsConF7Initialize(Sender: TObject);
begin
  DKsConF7.SetImgIndex (g_WMain3Images, 144);
end;

procedure TFrmDlg.DKsConF8Initialize(Sender: TObject);
begin
  DKsConF8.SetImgIndex (g_WMain3Images, 146);
end;

procedure TFrmDlg.DKsNoneInitialize(Sender: TObject);
begin
  DKsNone.SetImgIndex (g_WMain3Images, 129);
end;

procedure TFrmDlg.DKsOkInitialize(Sender: TObject);
begin
  DKsOk.SetImgIndex (g_WMain3Images, 127);
end;

procedure TFrmDlg.DKeySelDlgInitialize(Sender: TObject);
begin
  DKeySelDlg.SetImgIndex (g_WMain3Images, 126);
end;
{$ENDREGION}
{$REGION '选择人物'}
procedure TFrmDlg.DscSelect1Initialize(Sender: TObject);
begin
  DscSelect1.SetImgIndex (g_WMainImages, 66);
  with TAspDButton(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DscSelect2Initialize(Sender: TObject);
begin
  DscSelect2.SetImgIndex (g_WMainImages, 67);
  with TAspDButton(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DscStartInitialize(Sender: TObject);
begin
  DscStart.SetImgIndex (g_qingqingImages, 21);
  with DscStart do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DscNewChrInitialize(Sender: TObject);
begin
  DscNewChr.SetImgIndex (g_WMainImages, 69);
  with TAspDButton(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DscEraseChrInitialize(Sender: TObject);
begin
  DscEraseChr.SetImgIndex (g_WMainImages, 70);
  with DscEraseChr do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DscCreditsInitialize(Sender: TObject);
begin
  DscCredits.SetImgIndex (g_WMain3Images, 405);
  with DscCredits do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DscExitInitialize(Sender: TObject);
begin
  DscExit.SetImgIndex (g_WMainImages, 72);
  with DscExit do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '人物包裹'} // new copy by liuzhigang
procedure TFrmDlg.DItemGridInitialize(Sender: TObject);
begin
  with DItemGrid do begin
  {$IF M2Version = 2} //1.76
    GLeft := 20;
    GTop  := 13;
    GWidth := 286;
    GHeight := 162;
  {$ELSE}
    GLeft := 28;
    GTop  := 41;
    GWidth := 286;
    GHeight := 162;
  {$IFEND}
  end;
end;

procedure TFrmDlg.DGoldInitialize(Sender: TObject);
begin
  with DGold do begin
    SetImgIndex (g_WMainImages, 29);
    {$IF M2Version = 2} //1.76
      GLeft := 10;
      GTop  := 190;
    {$ELSE}
      GLeft := 18;
      GTop  := 217;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DWGameGoldInitialize(Sender: TObject);
begin
  DWGameGold.SetImgIndex(g_qingqingImages, 2);
end;

procedure TFrmDlg.DItemsUpButInitialize(Sender: TObject);
begin
  DItemsUpBut.SetImgIndex (g_qingqingImages, 3);
end;

procedure TFrmDlg.DCloseBagInitialize(Sender: TObject);
begin
  with DClosebag do begin
    SetImgIndex (g_WMainImages, 371);
    {$IF M2Version = 2} //1.76
      GLeft := 309;
      GTop := 203;
    {$ELSE}
      GLeft := 336;
      GTop := 59;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DItemBagInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DItemBag.SetImgIndex (g_WMainImages, 3);
{$ELSE}
  DItemBag.SetImgIndex (g_qingqingImages, 1);
{$IFEND}
end;
{$ENDREGION}
{$REGION '交易2个窗体'}
procedure TFrmDlg.DDRGoldInitialize(Sender: TObject);
begin
  DDRGold.SetImgIndex (g_WMainImages, 28);
end;

procedure TFrmDlg.DDealRemoteDlgInitialize(Sender: TObject);
begin
  DDealRemoteDlg.SetImgIndex (g_WMainImages, 390);
end;

procedure TFrmDlg.DDGoldInitialize(Sender: TObject);
begin
  DDGold.SetImgIndex (g_WMainImages, 28);
end;

procedure TFrmDlg.DDealOkInitialize(Sender: TObject);
begin
  DDealOk.SetImgIndex (g_WMainImages, 391);
end;

procedure TFrmDlg.DDealCloseInitialize(Sender: TObject);
begin
  DDealClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DDealDlgInitialize(Sender: TObject);
begin
  DDealDlg.SetImgIndex (g_WMainImages, 389);
end;
{$ENDREGION}
{$REGION '商店窗体'}
procedure TFrmDlg.DMenuPrevInitialize(Sender: TObject);
begin
  DMenuPrev.SetImgIndex (g_WMainImages, 388);
end;

procedure TFrmDlg.DMenuNextInitialize(Sender: TObject);
begin
  DMenuNext.SetImgIndex (g_WMainImages, 387);
end;

procedure TFrmDlg.DMenuBuyInitialize(Sender: TObject);
begin
  DMenuBuy.SetImgIndex (g_WMainImages, 386);
end;

procedure TFrmDlg.DMenuCloseInitialize(Sender: TObject);
begin
  DMenuClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DMenuDlgInitialize(Sender: TObject);
begin
  DMenuDlg.SetImgIndex (g_WMainImages, 385);
end;
{$ENDREGION}
{$REGION '人物状态窗体'}
procedure TFrmDlg.DStateTabInitialize(Sender: TObject);
begin
  DStateTab.SetImgIndex(g_WMain2Images, 744);
end;

procedure TFrmDlg.DCloseStateInitialize(Sender: TObject);
begin
  DCloseState.SetImgIndex (g_WMainImages, 371);
end;

procedure TFrmDlg.DStateSsasInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
{$IF M2Version <> 2} //1.76
  with DStateSsas do begin
    d := g_WMainImages.Images[792];
    if d <> nil then begin
      SetImgIndex(g_WMainImages, 792);
    end else begin
      Visible := False;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DPrevStateInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  with DPrevState do begin
{$IF M2Version = 2} //1.76
    d := g_WMainImages.Images[370];
    if d <> nil then begin
      SetImgIndex (g_WMainImages, 373);
//      Visible := True;
    end;
{$ELSE}
    d := g_WMainImages.Images[806];
    if d <> nil then begin
      Visible := False;
    end else begin
      d := g_WMain3Images.Images[207];
      if d <> nil then begin
        SetImgIndex (g_WMainImages, 373);
      end;
    end;
{$IFEND}
  end;
end;

procedure TFrmDlg.DNextStateInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  with DNextState do begin
{$IF M2Version = 2} //1.76
    d := g_WMainImages.Images[370];
    if d <> nil then begin
      SetImgIndex (g_WMainImages, 372);
      //Visible := True;
    end;
{$ELSE}
    d := g_WMainImages.Images[806];
    if d <> nil then begin
      Visible := False;
    end else begin
      d := g_WMain3Images.Images[207];
      if d <> nil then begin
        SetImgIndex (g_WMainImages, 372);
      end;
    end;
{$IFEND}
  end;
end;
procedure TFrmDlg.DBJDSeeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJDSee.SetImgIndex(g_WUI1Images, 482);
{$IFEND}
end;
procedure TFrmDlg.HBExpInitialize(Sender: TObject);
begin
  HBExp.SetImgIndex(g_WMain2Images, 577);
end;
procedure TFrmDlg.JQExpInitialize(Sender: TObject);
begin
  if Sender=JQExp then
    JQExp.SetImgIndex(g_WMain2Images, 577)
  else
    DBNewJQExp.SetImgIndex(g_WMain2Images, 577);
end;
procedure TFrmDlg.DStPageUpInitialize(Sender: TObject);
begin
  DStPageUp.SetImgIndex (g_WMainImages, 398);
end;
procedure TFrmDlg.DStPageDownInitialize(Sender: TObject);
begin
  DStPageDown.SetImgIndex (g_WMainImages, 396);
end;
procedure TFrmDlg.DLiquorProgressInitialize(Sender: TObject);
begin
  DLiquorProgress.SetImgIndex(g_WMain2Images, 575);
end;
procedure TFrmDlg.DStateWinPulseInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[806];
  if d <> nil then begin
    DStateWinPulse.SetImgIndex(g_WMainImages, 820);
  end else begin
    DStateWinPulse.Visible := False;
  end;
end;
procedure TFrmDlg.DWinBatterRandomInitialize(Sender: TObject);
begin
  DWinBatterRandom.SetImgIndex(g_WMainImages, 901);
end;
procedure TFrmDlg.DWinBatterSetKeyInitialize(Sender: TObject);
begin
  DWinBatterSetKey.SetImgIndex(g_WMainImages, 901);
end;
procedure TFrmDlg.DWinBatterComInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 911);
{$IFEND}
end;

procedure TFrmDlg.DStateWinInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  with DStateWin do begin
    {$IF M2Version = 2} //1.76
    SetImgIndex (g_WMainImages, 370); //人物状态
    {$ELSE}
    d := g_WMainImages.Images[806];
    if d <> nil then begin
      SetImgIndex (g_WMainImages, 806); //人物状态  4格图
      DStateWinBatter.SetImgIndex(g_WMainImages, 900);
      g_boNewStateWin := True;
    end else begin
     DStateWinBatter.Visible := False;
     g_boNewStateWin := False;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DLNGUpLevel1Initialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
	with Sender as TAspDLabel do begin
    d := g_WUI1Images.Images[482];
    if d <> nil then
    	SetImgIndex(g_WUI1Images, 482);
  end;
end;

{$ENDREGION}
{$REGION '组队窗体'}
procedure TFrmDlg.DGrpAllowGroupInitialize(Sender: TObject);
begin
  DGrpAllowGroup.SetImgIndex (g_WMainImages, 122);
end;
procedure TFrmDlg.DGrpCreateInitialize(Sender: TObject);
begin
  DGrpCreate.SetImgIndex (g_WMainImages, 123);
end;
procedure TFrmDlg.DGrpAddMemInitialize(Sender: TObject);
begin
  DGrpAddMem.SetImgIndex (g_WMainImages, 124);
end;
procedure TFrmDlg.DGrpDelMemInitialize(Sender: TObject);
begin
  DGrpDelMem.SetImgIndex (g_WMainImages, 125);
end;
procedure TFrmDlg.DGrpDlgCloseInitialize(Sender: TObject);
begin
  DGrpDlgClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DGroupDlgInitialize(Sender: TObject);
begin
  DGroupDlg.SetImgIndex (g_WMainImages, 120);
end;
{$ENDREGION}
{$REGION '行会公告编辑框'}
procedure TFrmDlg.DGEOkInitialize(Sender: TObject);
begin
  DGEOK.SetImgIndex (g_WMainImages, 361);
end;
procedure TFrmDlg.DGECloseInitialize(Sender: TObject);
begin
  DGEClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DGuildEditNoticeInitialize(Sender: TObject);
begin
  DGuildEditNotice.SetImgIndex (g_WMainImages, 204);
end;
{$ENDREGION}
{$REGION '排行榜'}
procedure TFrmDlg.DIndividualOrderInitialize(Sender: TObject);
begin
  with DIndividualOrder do begin
  {$IF M2Version <> 2}
    SetImgIndex(g_Wmain2Images, 161);
    GTop := 61;
  {$ELSE}
    SetImgIndex(g_Wmain3Images,443);
    GTop := 60;
  {$IFEND}
  end;
end;
procedure TFrmDlg.DHeroOrderInitialize(Sender: TObject);
begin
  with DHeroOrder do begin
  {$IF M2Version <> 2}
    SetImgIndex(g_Wmain2Images, 162);
    GLeft := 86;
    GTop := 61;
  {$ELSE}
    SetImgIndex(g_Wmain3Images,444);
    GLeft := 123;
    GTop := 60;
  {$IFEND}
  end;
end;
procedure TFrmDlg.DMasterOrderInitialize(Sender: TObject);
begin
  with DMasterOrder do begin
  {$IF M2Version <> 2}
    SetImgIndex(g_Wmain2Images, 163);
    GLeft := 143;
    GTop := 61;
  {$ELSE}
    SetImgIndex(g_Wmain3Images,445);
    GLeft := 220;
    GTop := 60;
  {$IFEND}
  end;
end;
procedure TFrmDlg.DBLevelOrderUseItemInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
    DBLevelOrderUseItem.SetImgIndex(g_WUI1Images, 1343);
  {$IFEND}
end;
procedure TFrmDlg.DBLevelOrderCloudInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
    DBLevelOrderCloud.SetImgIndex(g_WMain2Images, 165);
  {$IFEND}
end;
procedure TFrmDlg.DLevelOrderCloseInitialize(Sender: TObject);
begin
  DLevelOrderClose.SetImgIndex(g_WmainImages,371);
end;
procedure TFrmDlg.DColonyHeroOrderInitialize(Sender: TObject);
begin
  DColonyHeroOrder.SetImgIndex(g_Wmain3Images,427);
end;
procedure TFrmDlg.DWarriorOrderInitialize(Sender: TObject);
begin
  DWarriorOrder.SetImgIndex(g_Wmain3Images,431);
end;

procedure TFrmDlg.DWBottomCenterDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  nLeft, nTop, nLen: Integer;
  PaintRect: TRect;
begin
  with DWBottomCenter do begin
    DScreen.DelChatTopString();
    dsurface.FillRect(Bounds(GLeft, GTop + 56, GWidth, GHeight), clWhite);
    d := g_WchantkkImages.Images[11];
    if d <> nil then begin
      nLen := GLeft + GWidth;
      nLeft := GLeft;
      nTop := GTop + 54;
      while nLeft < nLen do begin
        if nLeft + d.Width <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, Width - nLeft, d.Height);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nLeft, d.Width);
      end;
    end;
    d := g_WchantkkImages.Images[16];
    if d <> nil then begin
      nLen := GLeft + GWidth;
      nLeft := GLeft;
      nTop := GTop + (GHeight - d.Height);
      while nLeft < nLen do begin
        if nLeft + d.Width <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, GWidth - nLeft, d.Height);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nLeft, d.Width);
      end;
    end;
    d := g_WchantkkImages.Images[13];
    if d <> nil then begin
      nLen := GTop + GHeight;
      nLeft := GLeft;
      nTop := GTop + 54;
      while nTop < nLen do begin
        if nTop + d.Height <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, GWidth, GHeight - nTop);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nTop, d.Height);
      end;
    end;
    d := g_WchantkkImages.Images[14];
    if d <> nil then begin
      nLen := GTop + GHeight;
      nLeft := GLeft + (GWidth - d.Width);
      nTop := GTop + 54;
      while nTop < nLen do begin
        if nTop + d.Height <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, GWidth, GHeight - nTop);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nTop, d.Height);
      end;
    end;
    d := g_WchantkkImages.Images[10];
    if d <> nil then begin
      nLeft := GLeft;
      nTop := GTop + 54;
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[12];
    if d <> nil then begin
      nLeft := GLeft + (GWidth - d.Width);
      nTop := GTop + 54;
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[15];
    if d <> nil then begin
      nLeft := GLeft;
      nTop := GTop + (GHeight - d.Height);
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[17];
    if d <> nil then begin
      nLeft := GLeft + (GWidth - d.Width);
      nTop := GTop + (GHeight - d.Height);
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end; 
  end;
end;

procedure TFrmDlg.DWBottomCenterFirDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DWBottomCenterFir do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DWBottomCenterFirInitialize(Sender: TObject);
begin
  DWBottomCenterFir.SetImgIndex(g_WchantkkImages, 2);
  DWBottomCenterFir.GLeft := (DWBottomCenter.GWidth - DWBottomCenterFir.GWidth) div 2;
  DWBottomCenterFir.GTop := - (DWBottomCenterFir.GHeight)  + 54;
end;

procedure TFrmDlg.DWBottomCenterInitialize(Sender: TObject);
begin
  DWBottomRightInitialize(nil);
  DWBottomCenter.GTop := g_D3DConfig.wScreenHeight - DWBottomCenter.GHeight;
  DWBottomCenter.GWidth :=  DWBottomRight.GLeft - DWBottomLeft.GWidth + 14;
  DWBottomCenter.GLeft := DWBottomLeft.GWidth - 6;
  DChatMemo.GWidth := DWBottomCenter.GWidth - (413 - 397);
  DBotExitInitialize(DBotExit);
  DBotLogoutInitialize(DBotLogout);
  DBotFactionInitialize(DBotFaction);
  DWBottomCenterFirInitialize(nil);
end;

procedure TFrmDlg.DWBottomCenterInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var
  d: TAsphyreLockableTexture;
begin
  if Y >= 54 then IsRealArea := True
  else begin
    d := g_WchantkkImages.Images[27];
    if (d <> nil) then
      IsRealArea := d.Pixels[X, Y] > 0
    else
      IsRealArea := True;
  end;
end;

procedure TFrmDlg.DWBottomCenterMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  MoveChatDlgY := Y;
end;

procedure TFrmDlg.DWBottomCenterMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  if DWBottomCenter.Downed and (MoveChatDlgY <> Y) then begin
    ChatMemoHeight := _MAX(ChatMemoHeight + (MoveChatDlgY - Y), 211);
    ChatMemoHeight := _MIN(ChatMemoHeight, g_D3DConfig.wScreenHeight);
    SetChatDlgHeight(ChatMemoHeight);
    {DWBottomCenter.GHeight := ChatMemoHeight;
    DWBottomCenter.GTop := g_D3DConfig.wScreenHeight - DWBottomCenter.GHeight; }
    MoveChatDlgY := Y;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWBottomLeftDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  Rc: TRect;
begin
  with DWBottomLeft do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    {$IF M2Version <> 2}
    if g_boOpenLeiMei then begin
      d := g_WUI1Images.Images[896];
      if d <> nil then
          dsurface.Draw (0, SurfaceY(GTop)+20, d.ClientRect, d, TRUE);
    end;
    {$IFEND}
    if g_MySelf <> nil then begin
    //显示HP及MP 图形
      if (g_MySelf.m_Abil.MaxHP > 0) and (g_MySelf.m_Abil.MaxMP > 0) then
      begin
        if (g_MySelf.m_btJob = 0) and (g_MySelf.m_Abil.Level < 28) then begin //武士
          d := g_WMainImages.Images[5];
          if d <> nil then begin
            Rc := d.ClientRect;
            Rc.Right := d.ClientRect.Right - 2;
            dsurface.Draw (38, SurfaceY(GTop)+91, Rc, d, FALSE);
          end;
          d := g_WMainImages.Images[6];
          if d <> nil then begin
            Rc := d.ClientRect;
            Rc.Right := d.ClientRect.Right - 2;
            Rc.Top := Round(Rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
            dsurface.Draw (38, SurfaceY(GTop)+91+Rc.Top, Rc, d, FALSE);
          end;
        end else begin
          d := g_WMainImages.Images[4];
          if d <> nil then begin
            //HP 图形
            Rc := d.ClientRect;
            Rc.Right := d.ClientRect.Right div 2 -1;
            Rc.Top := Round(Rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
            dsurface.Draw (40, SurfaceY(GTop)+92+Rc.Top, Rc, d, FALSE);
            //MP 图形
            Rc := d.ClientRect;
            Rc.Left := d.ClientRect.Right div 2 + 1;
            Rc.Right := d.ClientRect.Right - 1;
            Rc.Top := Round(Rc.Bottom / g_MySelf.m_Abil.MaxMP * (g_MySelf.m_Abil.MaxMP - g_MySelf.m_Abil.MP));
            dsurface.Draw (40 + Rc.Left, SurfaceY(GTop)+93+Rc.Top, Rc, d, FALSE);
          end;
        end;
      end;
    {$IF M2Version = 1}
      if g_MySelf.m_Abil.MaxTransferValue > 0 then begin
        d := g_WMainImages.Images[1200];
        if d <> nil then begin
          dsurface.Draw (12, 416, d.ClientRect, d, TRUE);
        end;

        d:= g_WMainImages.Images[1201];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxTransferValue * (g_MySelf.m_Abil.MaxTransferValue - g_MySelf.m_Abil.TransferValue));
          dsurface.Draw (20, 425+rc.Top, rc, d, TRUE);
        end;
      end;
    {$IFEND}
      AspTextureFont.BoldTextOut (27, g_D3DConfig.wScreenHeight - (600 - 564), clWhite, clBlack, (format('%d/%d',[g_MySelf.m_Abil.HP,g_MySelf.m_Abil.MaxHP])));
      AspTextureFont.BoldTextOut (92, g_D3DConfig.wScreenHeight - (600 - 564), clWhite, clBlack, (format('%d/%d',[g_MySelf.m_Abil.MP,g_MySelf.m_Abil.MaxMP])));
      AspTextureFont.BoldTextOut (7,  g_D3DConfig.wScreenHeight -15, clWhite, clBlack, Format('%s %d:%d',[g_sMapTitle, g_MySelf.m_nCurrX, g_MySelf.m_nCurrY]));
      {$IF M2Version <> 2}
      if g_MySelf.m_nState and $00020000 <> 0 then begin //心法激活
        if GetTickCount - m_dwAbilTick > 100 then begin
          m_dwAbilTick := GetTickCount;
          Inc(m_btAbilIndex);
          if m_btAbilIndex >= 12 then m_btAbilIndex := 0;
        end;
        d := g_WMagic10Images.Images[240 + m_btAbilIndex];
        if d <> nil then
          dsurface.DrawBlend(38, SurfaceY(GTop)+90, d.ClientRect,d);
        d := g_WMagic10Images.Images[260 + m_btAbilIndex];
        if d <> nil then
          dsurface.DrawBlend(38, SurfaceY(GTop)+90, d.ClientRect,d);
        d := g_WMagic10Images.Images[280 + m_btAbilIndex];
        if d <> nil then
          dsurface.DrawBlend(-62, SurfaceY(GTop)-10, d.ClientRect,d);
      end;
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DWBottomLeftInitialize(Sender: TObject);
begin
  DWBottomLeft.SetImgIndex(g_WchantkkImages, 0);
  DWBottomLeft.GTop := g_D3DConfig.wScreenHeight - DWBottomLeft.GHeight;
end;

procedure TFrmDlg.DWBottomLeftMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg: string;
  nHintX, nHintY: Integer;
begin
  {$IF M2Version = 1}
  if g_MySelf <> nil then begin
    if ((X>=42) and (X<=60)) and ((Y>=g_D3DConfig.wScreenHeight-177) and (Y<=g_D3DConfig.wScreenHeight-139)) then begin
      if g_MySelf.m_Abil.MaxTransferValue <= 0 then Exit;
      sMsg := IntToStr(g_MySelf.m_Abil.TransferValue)+ '/' + IntToStr(g_MySelf.m_Abil.MaxTransferValue);
      nHintX := 12;
      nHintY := g_D3DConfig.wScreenHeight - 186;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      Exit;
    end;
  end;
  {$IFEND}
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWBottomRightDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  Rc: TRect;
  r: Real;
begin
  with DWBottomRight do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    d := nil;
    case g_nDayBright of
      0: d := g_WMainImages.Images[15];  //早上
      1: d := g_WMainImages.Images[12];  //白天
      2: d := g_WMainImages.Images[13];  //傍晚
      3: d := g_WMainImages.Images[14];  //晚上
    end;
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+148, SurfaceY(GTop)+81, d.ClientRect, d, FALSE);
    {$IF M2Version <> 2}
    if g_boOpenHero then begin
      d := g_WMain3Images.Images[313];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+33, SurfaceY(GTop)+105, d.ClientRect, d, TRUE);
    end;
    {$IFEND}
    if g_MySelf <> nil then begin
      if DBNewStateTab3.Visible then
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+66, SurfaceY(GTop)+147, clYellow, clBlack, IntToStr(g_MySelf.m_Abil.Level))
      else PomiTextOut (dsurface, SurfaceX(GLeft)+60, SurfaceY(GTop)+150, IntToStr(g_MySelf.m_Abil.Level));
      {$IF M2Version = 2}
      AspTextureFont.BoldTextOut (635, 464, clWhite, clBlack, g_sAttackMode);
      {$ELSE}
      if g_boOpenHero then begin
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+35, SurfaceY(GTop)+128, clWhite, clBlack, g_sAttackMode);
      end else begin
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+41, SurfaceY(GTop)+115, clWhite, clBlack, g_sAttackMode);
      end;
      {$IFEND}
      if (g_MySelf.m_Abil.MaxExp > 0) and (g_MySelf.m_Abil.MaxWeight > 0) then begin
        d := g_WMainImages.Images[7];
        if d <> nil then begin
          //经验条
          rc := d.ClientRect;
          if g_MySelf.m_Abil.Exp > 0 then
            r := g_MySelf.m_Abil.MaxExp / g_MySelf.m_Abil.Exp
          else r := 0;
          if r > 0 then
            rc.Right := Round (rc.Right / r)
          else rc.Right := 0;
          dsurface.Draw (SurfaceX(GLeft)+66, SurfaceY(GTop)+179, rc, d, FALSE);
          //背包重量条
          rc := d.ClientRect;
          if g_MySelf.m_Abil.Weight > 0 then
            r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
          else r := 0;
          if r > 0 then
            rc.Right := Round (rc.Right / r)
          else rc.Right := 0;
          dsurface.Draw (SurfaceX(GLeft)+66, SurfaceY(GTop)+212, rc, d, FALSE);
         end;
      end;
      //饥饿程度
      if g_nMyHungryState in [1..4] then begin
        d := g_WMainImages.Images[16 + g_nMyHungryState-1];
        if d <> nil then begin
          dsurface.Draw (SurfaceX(GLeft)+154, SurfaceY(GTop)+207, d.ClientRect, d, TRUE);
        end;
      end;
      {$IF M2Version <> 2}
      if g_boXinFaType then begin //105魔法
        d := g_WUI1Images.Images[2330];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+38, SurfaceY(GTop)+140, d.ClientRect, d, True);
        d := g_WUI1Images.Images[2331];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+38, SurfaceY(GTop)+172, d.ClientRect, d, True);
        if g_boShowXinFaAbsorb then begin
          if GetTickCount - g_dwXinFaAbsorbTimeKick > 200 then begin
            g_dwXinFaAbsorbTimeKick := GetTickCount;
            Inc(g_btXinFaAbsorbImgIndex);
            if g_btXinFaAbsorbImgIndex > 1 then g_btXinFaAbsorbImgIndex := 0;
          end;
          d := g_WMainImages.Images[918+g_btXinFaAbsorbImgIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+42, SurfaceY(GTop)+192, d.ClientRect, d, TRUE);
        end;
      end;
      {$IFEND}
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+72, SurfaceY(GTop)+230, clWhite, clBlack, FormatDateTime('hh:mm:ss',Now));
    end;
  end;
end;

procedure TFrmDlg.DWBottomRightInitialize(Sender: TObject);
begin
  {$IF M2Version = 2} //1.76
  DWBottomRight.SetImgIndex(g_qingqingImages, 25);
  {$ELSE}
  DWBottomRight.SetImgIndex(g_WchantkkImages, 1);
  {$IFEND}
  DWBottomRight.GLeft := g_D3DConfig.wScreenWidth - DWBottomRight.GWidth;
  DWBottomRight.GTop := g_D3DConfig.wScreenHeight - DWBottomRight.GHeight;
end;

procedure TFrmDlg.DWBottomRightMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg: string;
  nHintX, nHintY: Integer;
begin
  if g_MySelf <> nil then begin
    if ((X >= g_D3DConfig.wScreenWidth - 135) and (X <= g_D3DConfig.wScreenWidth - 96)) and ((Y >= g_D3DConfig.wScreenHeight - 108) and (Y <= g_D3DConfig.wScreenHeight - 92)) then begin
      sMsg := '当前等级';
      nHintX := g_D3DConfig.wScreenWidth - 135;
      nHintY := g_D3DConfig.wScreenHeight - 92+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end
    else if ((X >= g_D3DConfig.wScreenWidth - 135) and (X <= g_D3DConfig.wScreenWidth - 55)) and ((Y >= g_D3DConfig.wScreenHeight - 77) and (Y <= g_D3DConfig.wScreenHeight - 63)) then begin
      sMsg := '当前经验';
      nHintX := g_D3DConfig.wScreenWidth - 135;
      nHintY := g_D3DConfig.wScreenHeight - 63+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg+FloatToStrFixFmt(100 * (g_MySelf.m_Abil.Exp / g_MySelf.m_Abil.MaxExp), 3, 2) +'%', clWhite, TRUE);
      Exit;
    end
    else if ((X >= g_D3DConfig.wScreenWidth - 135) and (X <= g_D3DConfig.wScreenWidth - 55)) and ((Y >= g_D3DConfig.wScreenHeight - 44) and (Y <= g_D3DConfig.wScreenHeight - 28)) then begin
      sMsg := format('包裹负重%d/%d',[g_MySelf.m_Abil.Weight,g_MySelf.m_Abil.MaxWeight]);
      nHintX := g_D3DConfig.wScreenWidth - 135;
      nHintY := g_D3DConfig.wScreenHeight - 28+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end;
  end;
  DScreen.ClearHint;
end;
procedure TFrmDlg.DWizerdOrderInitialize(Sender: TObject);
begin
  DWizerdOrder.SetImgIndex(g_Wmain3Images,433);
end;

procedure TFrmDlg.DTaoistOrderInitialize(Sender: TObject);
begin
  DTaoistOrder.SetImgIndex(g_Wmain3Images,435);
end;
procedure TFrmDlg.DHeroAllOrderInitialize(Sender: TObject);
begin
  DHeroAllOrder.SetImgIndex(g_Wmain3Images,429);
end;
procedure TFrmDlg.DWarriorHeroOrderInitialize(Sender: TObject);
begin
  DWarriorHeroOrder.SetImgIndex(g_Wmain3Images,437);
end;
procedure TFrmDlg.DWizerdHeroOrderInitialize(Sender: TObject);
begin
  DWizerdHeroOrder.SetImgIndex(g_Wmain3Images,439);
end;
procedure TFrmDlg.DTaoistHeroOrderInitialize(Sender: TObject);
begin
  DTaoistHeroOrder.SetImgIndex(g_Wmain3Images,441);
end;
procedure TFrmDlg.DLevelOrderIndexInitialize(Sender: TObject);
begin
  DLevelOrderIndex.SetImgIndex(g_Wmain3Images,450);
end;
procedure TFrmDlg.DLevelOrderPrevInitialize(Sender: TObject);
begin
  DLevelOrderPrev.SetImgIndex(g_Wmain3Images,452);
end;

procedure TFrmDlg.DLFactionAddPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if Sender = DLFactionAddPrev then begin
      frmMain.SendFactionAddPageChanged(0);
    end else begin
      frmMain.SendFactionAddPageChanged(1);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionAddQueryClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
	if Trim(DEditFactionAddQuery.Text) <> '' then
    frmMain.SendFactionAddQueryListByName(Trim(DEditFactionAddQuery.Text));
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyAdd1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  FactionAddInfo: pTClientDivisionInfo;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDLabel do begin
    if Tag <= g_FactionAddList.Count then begin
      FactionAddInfo := g_FactionAddList[Tag];
      if FactionAddInfo <> nil then begin
        if FactionAddInfo.sDivisionName <> '' then
        frmMain.SendFactionAddApplyAdd(FactionAddInfo.sDivisionName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyManageAgreeClick(Sender: TObject; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    Lines := '';
    for I:=Low(g_FactionApplyManageSel) to High(g_FactionApplyManageSel) do begin
      if g_FactionApplyManageNameList.Count > I then begin
        if g_FactionApplyManageSel[I] then
          Lines := Lines + g_FactionApplyManageNameList.Strings[I] + '|';
      end;
    end;
    if Lines <> '' then frmMain.SendFactionManageAgree(Lines);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyManageAllSelClick(Sender: TObject; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DLFactionApplyManageAllSel then
    FillChar(g_FactionApplyManageSel, SizeOf(g_FactionApplyManageSel), True)
  else FillChar(g_FactionApplyManageSel, SizeOf(g_FactionApplyManageSel), #0);
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyManageRefuseClick(Sender: TObject; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    Lines := '';
    for I:=Low(g_FactionApplyManageSel) to High(g_FactionApplyManageSel) do begin
      if g_FactionApplyManageNameList.Count > I then begin
        if g_FactionApplyManageSel[I] then
          Lines := Lines + g_FactionApplyManageNameList.Strings[I] + '|';
      end;
    end;
    if Lines <> '' then frmMain.SendFactionManageRefuse(Lines);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  ShowFactionDlgEditNotice();
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgEditNoticeOKClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DBFactionDlgEditNoticeCloseClick (self, 0, 0);
  DMsgDlg.DialogResult := mrOk;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgEditNoticeOKInitialize(Sender: TObject);
begin
  with Sender as TAspDLabel do
	  SetImgIndex(g_WMainImages, 1614);
end;

procedure TFrmDlg.DLFactionDlgExitClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_FactionDlg.boIsAdmin then begin
    if mrOk = DMessageDlg ('你确定要解散师门？', [mbOk, mbCancel]) then begin
      FrmMain.SendFactionMemberDel(FrmMain.CharName);
    end;
  end else begin
    if mrOk = DMessageDlg ('你确定要退出师门？', [mbOk, mbCancel]) then begin
      FrmMain.SendFactionMemberDel(FrmMain.CharName);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgGetTitleClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    frmMain.SendFactionTitle;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgHomeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    frmMain.SendOpenFactionDLgHome();
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgHomeInitialize(Sender: TObject);
begin
	with Sender as TAspDLabel do
  	SetImgIndex(g_WMainImages, 1738);
end;

procedure TFrmDlg.DLFactionDlgKickClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_FactionMember.SelMemberName <> '' then begin
    if mrOk = DMessageDlg ('你是否要将“'+g_FactionMember.SelMemberName+'”逐出师门？', [mbOk, mbCancel]) then begin
      FrmMain.SendFactionMemberDel(g_FactionMember.SelMemberName);
    end;
  end else begin
    DMessageDlg('请选择要逐出师门的成员！！！', [mbOk]);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgListClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    FrmMain.SendGetFactionMemberList;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgManageApplyClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    FrmMain.SendGetFactionManageApplyList;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLevelOrderNextInitialize(Sender: TObject);
begin
  DLevelOrderNext.SetImgIndex(g_Wmain3Images,454);
end;
procedure TFrmDlg.DLevelOrderLastPageInitialize(Sender: TObject);
begin
  DLevelOrderLastPage.SetImgIndex(g_Wmain3Images,456);
end;
procedure TFrmDlg.DMyLevelOrderInitialize(Sender: TObject);
begin
  DMyLevelOrder.SetImgIndex(g_Wmain3Images,458);
end;
procedure TFrmDlg.DBOrderWeaponInitialize(Sender: TObject);
begin
  DBOrderWeapon.SetImgIndex(g_WUI1Images, 1368);
end;
procedure TFrmDlg.DBOrderWristletInitialize(Sender: TObject);
begin
  DBOrderWristlet.SetImgIndex(g_WUI1Images, 1362);
end;
procedure TFrmDlg.DBOrderRingInitialize(Sender: TObject);
begin
  DBOrderRing.SetImgIndex(g_WUI1Images, 1364);
end;

procedure TFrmDlg.DBOrderBeltInitialize(Sender: TObject);
begin
  DBOrderBelt.SetImgIndex(g_WUI1Images, 1376);
end;

procedure TFrmDlg.DBOrderBootsInitialize(Sender: TObject);
begin
  DBOrderBoots.SetImgIndex(g_WUI1Images, 1372);
end;

procedure TFrmDlg.DBOrderDressInitialize(Sender: TObject);
begin
  DBOrderDress.SetImgIndex(g_WUI1Images, 1378);
end;
procedure TFrmDlg.DBOrderHatInitialize(Sender: TObject);
begin
  DBOrderHat.SetImgIndex(g_WUI1Images, 1360);
end;

procedure TFrmDlg.DBOrderHelmetInitialize(Sender: TObject);
begin
  DBOrderHelmet.SetImgIndex(g_WUI1Images, 1366);
end;

procedure TFrmDlg.DBOrderMedalInitialize(Sender: TObject);
begin
  DBOrderMedal.SetImgIndex(g_WUI1Images, 1374);
end;

procedure TFrmDlg.DBOrderNecklaceInitialize(Sender: TObject);
begin
  DBOrderNecklace.SetImgIndex(g_WUI1Images, 1370);
end;

procedure TFrmDlg.DWLevelOrderInitialize(Sender: TObject);
begin
  with DWLevelOrder do begin
    {$IF M2Version <> 2}
      SetImgIndex (g_WUI1Images, 1340);
    {$ELSE}
      SetImgIndex (g_WMain3Images, 420);
    {$IFEND}
  end;
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '底部窗体'}
procedure TFrmDlg.DBotMiniMapInitialize(Sender: TObject);
begin
  DBotMiniMap.SetImgIndex (g_WMainImages, 130);
end;
procedure TFrmDlg.DBotTradeInitialize(Sender: TObject);
begin
  DBotTrade.SetImgIndex (g_WMainImages, 132);
end;
procedure TFrmDlg.DBotGuildInitialize(Sender: TObject);
begin
  DBotGuild.SetImgIndex (g_WMainImages, 134);
end;
procedure TFrmDlg.DBotGroupInitialize(Sender: TObject);
begin
  DBotGroup.SetImgIndex (g_WMainImages, 128);
end;
procedure TFrmDlg.DBotPlusAbilInitialize(Sender: TObject);
begin
  DBotPlusAbil.SetImgIndex (g_WMainImages, 140);
end;
procedure TFrmDlg.ChallengeInitialize(Sender: TObject);
begin
  Challenge.SetImgIndex (g_WMain3Images,36);  //挑战
end;
procedure TFrmDlg.DBWhisperInitialize(Sender: TObject);
begin
  DBWhisper.SetImgIndex(g_WMainImages, 1151); //私聊信息
end;

procedure TFrmDlg.DBWinXinFaMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  i, idx: integer;
  selkey: word;
  keych: char;
  pm: PTClientMagic;
  icon :Integer;
  boChange: Boolean;
{$IFEND}
begin
{$IF M2Version <> 2}
  idx := _Max(TAspDButton(Sender).Tag + m_btXinFaPage * 5, 0);
  if (idx >= 0) and (idx < g_XinFaMagic.Count) then begin
    pm := PTClientMagic (g_XinFaMagic[idx]);
    if pm.Def.wMagicId in [105, 110..111,112..114] then
    begin
      selkey := word(pm.Key);
      GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
      SetMagicKeyDlg(icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey);
      keych := char(selkey);
      boChange := False;
      if g_MagicList.Count > 0 then //20080629
      for i:=0 to g_MagicList.Count-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if pm.Key = keych then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
           boChange := True;
        end;
      end;
      if not boChange then begin
        for i:=0 to g_XinFaMagic.Count-1 do begin
          pm := PTClientMagic (g_XinFaMagic[i]);
          if pm.Key = keych then begin
             pm.Key := #0;
             FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
             boChange := True;
          end;
        end;
      end;
      pm := PTClientMagic (g_XinFaMagic[idx]);
      pm.Key := keych;
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d:  TAsphyreLockableTexture;
  pm: PTClientMagic;
  wm: TAspWMImages;
  sKeyName: string;
  btKeyLeft: Byte;
  boPieceExp: Boolean;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    pm := nil;
    Idx := _Max(Tag + m_btXinFaPage * 5, 0);
    if Idx < g_XinFaMagic.Count then begin
      pm := PTClientMagic (g_XinFaMagic[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
          end;
        end;
        sKeyName := '';
        case byte(pm.Key) of
          byte('1'): begin
            sKeyName := 'F1';
            btKeyLeft:= 15;
          end;
          byte('2'): begin
            sKeyName := 'F2';
            btKeyLeft:= 15;
          end;
          byte('3'): begin
            sKeyName := 'F3';
            btKeyLeft:= 15;
          end;
          byte('4'): begin
            sKeyName := 'F4';
            btKeyLeft:= 15;
          end;
          byte('5'): begin
            sKeyName := 'F5';
            btKeyLeft:= 15;
          end;
          byte('6'): begin
            sKeyName := 'F6';
            btKeyLeft:= 15;
          end;
          byte('7'): begin
            sKeyName := 'F7';
            btKeyLeft:= 15;
          end;
          byte('8'): begin
            sKeyName := 'F8';
            btKeyLeft:= 15;
          end;
          byte('E'): begin
            sKeyName := 'C+F1';
            btKeyLeft:= 5;
          end;
          byte('F'): begin
            sKeyName := 'C+F2';
            btKeyLeft:= 5;
          end;
          byte('G'): begin
            sKeyName := 'C+F3';
            btKeyLeft:= 5;
          end;
          byte('H'): begin
            sKeyName := 'C+F4';
            btKeyLeft:= 5;
          end;
          byte('I'): begin
            sKeyName := 'C+F5';
            btKeyLeft:= 5;
          end;
          byte('J'): begin
            sKeyName := 'C+F6';
            btKeyLeft:= 5;
          end;
          byte('K'): begin
            sKeyName := 'C+F7';
            btKeyLeft:= 5;
          end;
          byte('L'): begin
            sKeyName := 'C+F8';
            btKeyLeft:= 5;
          end;
        end;

        if sKeyName <> '' then
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+btKeyLeft, SurfaceY(GTop)+20, $00FF00,clBlack, sKeyName);
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, clSilver, clBlack, pm.Def.sMagicName);
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        end;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
        //if not (pm.Level in [0..4]) then pm.Level := 0;
        if pm.Def.wMagicId in [107..109] then begin
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+71, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          end;
          if pm.Level < 10 then
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]))
          else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMagPageDownInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2203);
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMagPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBWinXinFaMagPageUp then begin
    if m_btXinFaPage > 0 then begin
      Dec (m_btXinFaPage);
    end;
  end else begin
    if m_btXinFaPage < (g_XinFaMagic.Count+4) div 5 - 1 then begin
      Inc (m_btXinFaPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMagPageUpInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2200);
{$IFEND}
end;

procedure TFrmDlg.DBotStallInitialize(Sender: TObject);
begin
  DBotStall.SetImgIndex(g_qingqingImages, 13); //摆摊
end;
procedure TFrmDlg.DBotLogoutInitialize(Sender: TObject);
begin
  DBotLogout.SetImgIndex (g_WMainImages, 136);
  with TAspDControl(Sender) do begin
    GLeft := DBotExit.GLeft - 5 - GWidth;
  end;
end;
procedure TFrmDlg.DBotExitInitialize(Sender: TObject);
begin
  DBotExit.SetImgIndex (g_WMainImages, 138);
  with TAspDControl(Sender) do begin
    GLeft := DParent.GWidth - GWidth - 20;
  end;
end;
procedure TFrmDlg.DMyStateInitialize(Sender: TObject);
begin
  DMyState.SetImgIndex (g_WMainImages, 8);
end;

procedure TFrmDlg.DMyBagInitialize(Sender: TObject);
begin
  DMyBag.SetImgIndex (g_WMainImages, 9);
end;
procedure TFrmDlg.DMyMagicInitialize(Sender: TObject);
begin
  DMyMagic.SetImgIndex (g_WMainImages, 10);
end;
procedure TFrmDlg.DOptionInitialize(Sender: TObject);
begin
  DOption.SetImgIndex (g_WMainImages, 11);
end;
procedure TFrmDlg.DDrunkScaleInitialize(Sender: TObject);
begin
  DDrunkScale.SetImgIndex(g_WMain2Images, 511);
end;

procedure TFrmDlg.DBMissionInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
  DBMission.SetImgIndex(g_WMainImages, 283);
  {$IFEND}
end;

procedure TFrmDlg.DBatterShowImgInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DBatterShowImg.SetImgIndex(g_WMainImages, 1120);
  {$IFEND}
end;

procedure TFrmDlg.DBCallDeputyHeroInitialize(Sender: TObject);
begin
  DBCallDeputyHero.SetImgIndex(g_qingqingImages,33);    //召唤副将英雄
end;

procedure TFrmDlg.DBAutoCRYClick(Sender: TObject; X, Y: Integer);
begin
  g_boAutoTalk := not g_boAutoTalk;
  if g_boAutoTalk then begin
     DBAutoCRY.SetImgIndex(g_WMain3Images,289);
     g_sAutoTalkStr := PlayScene.EdChat.Text;
     g_btAutoTalkNum := 0;
     DScreen.AddChatBoardString('[启用了自动喊话功能，聊天框中的内容已记录为喊话内容]', GetRGB(219), clWhite)
  end else begin
     DBAutoCRY.SetImgIndex(g_WMain3Images,288);
     g_sAutoTalkStr := '';
     DScreen.AddChatBoardString('[自动喊话功能已关闭]', GetRGB(219), clWhite)
  end;
end;

procedure TFrmDlg.DBAutoCRYInitialize(Sender: TObject);
begin
  DBAutoCRY.SetImgIndex(g_WMain3Images,288);   //自动喊话开关
end;

procedure TFrmDlg.DBotMemoInitialize(Sender: TObject);
begin
  DBotMemo.SetImgIndex (g_WMain3Images,297);
end;
{$ENDREGION}
{$REGION '提示对话框'}
procedure TFrmDlg.DMsgDlgOkInitialize(Sender: TObject);
begin
  DMsgDlgOk.SetImgIndex (g_WMainImages, 361);
end;
procedure TFrmDlg.DMsgDlgYesInitialize(Sender: TObject);
begin
  DMsgDlgYes.SetImgIndex (g_WMainImages, 363);
end;
procedure TFrmDlg.DMsgDlgCancelInitialize(Sender: TObject);
begin
  DMsgDlgCancel.SetImgIndex (g_WMainImages, 365);
end;
procedure TFrmDlg.DMsgDlgNoInitialize(Sender: TObject);
begin
  DMsgDlgNo.SetImgIndex (g_WMainImages, 367);
end;
procedure TFrmDlg.DMsgDlgInitialize(Sender: TObject);
begin

end;
{$ENDREGION}
{$REGION '英雄包裹'}
procedure TFrmDlg.DHeroItemBagInitialize(Sender: TObject);
begin
  DHeroItemBag.SetImgIndex (g_WMain3Images, 376);
end;
procedure TFrmDlg.DHeroItemGridCloseInitialize(Sender: TObject);
begin
  DHeroItemGridClose.SetImgIndex (g_WMainImages, 371);
end;

{$ENDREGION}
{$REGION '天地结晶'}
procedure TFrmDlg.DExpCrystalTopInitialize(Sender: TObject);
begin
  DExpCrystalTop.SetImgIndex(g_WMainImages, 468);
end;
procedure TFrmDlg.DCrystalExpInitialize(Sender: TObject);
begin
  DCrystalExp.SetImgIndex(g_WMainImages, 484);
end;
procedure TFrmDlg.DCrystalNGExpInitialize(Sender: TObject);
begin
  DCrystalNGExp.SetImgIndex(g_WMainImages, 485);
end;
procedure TFrmDlg.DWExpCrystalInitialize(Sender: TObject);
begin
  DWExpCrystal.SetImgIndex(g_WMainImages, 464);
end;
{$ENDREGION}
{$REGION 'NPC对话框'}
procedure TFrmDlg.DMerchantDlgInitialize(Sender: TObject);
begin
  DMerchantDlg.SetImgIndex (g_WMainImages, 384);
end;
procedure TFrmDlg.DMerchantDlgCloseInitialize(Sender: TObject);
begin
  DMerchantDlgClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DBigMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  msg: TDefaultMessage;
  sData: string;
begin
   if GetTickCount < LastestClickTime then exit;
   L := DBigMerchantDlg.GLeft;
   T := DBigMerchantDlg.GTop;
   with DBigMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            PlaySound (s_glass_button_click);
            if DMerchantDlgSelect(p.RStr, p.TStr, sData) then FrmMain.SendMerchantDlgSelect(g_nCurMerchant, sData);
            LastestClickTime := GetTickCount + 2000; //20080803修改 以前为5000
            break;
         end;
      end;
end;

procedure TFrmDlg.DBigMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseMBigDlg;
end;

procedure TFrmDlg.DBigMerchantDlgCloseInitialize(Sender: TObject);
begin
  DBigMerchantDlgClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DBigMerchantDlgInitialize(Sender: TObject);
begin
  DBigMerchantDlg.SetImgIndex (g_WMainImages, 402);
end;

procedure TFrmDlg.DBigMerchantDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   if GetTickCount < LastestClickTime then exit; 
   SelectMenuStr := '';
   L := DBigMerchantDlg.GLeft;
   T := DBigMerchantDlg.GTop;
   with DBigMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
   if DHeroIcon.Visible then DHeroIcon.Visible := False;  //20080521
end;
{$ENDREGION}
{$REGION '摆摊'}
procedure TFrmDlg.DBtnStallStartInitialize(Sender: TObject);
begin
  DBtnStallStart.SetImgIndex(g_WMain2Images, 275);
end;
procedure TFrmDlg.DBtnStallStopInitialize(Sender: TObject);
begin
  DBtnStallStop.SetImgIndex(g_WMain2Images, 275);
end;
procedure TFrmDlg.DBStallCloseInitialize(Sender: TObject);
begin
  DBStallClose.SetImgIndex(g_WMainImages, 64);
end;

procedure TFrmDlg.DBTitle1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do 
    SetImgIndex(g_WUI1Images, 675);
{$IFEND}
end;

procedure TFrmDlg.DBTitleManInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
  SetImgIndex(g_WUI1Images, 670);
{$IFEND}
end;

procedure TFrmDlg.DWStallInitialize(Sender: TObject);
begin
  DWStall.SetImgIndex(g_qingqingImages, 9);
end;
procedure TFrmDlg.DBWStallPriceTab1Initialize(Sender: TObject);
begin
  DBWStallPriceTab1.SetImgIndex(g_qingqingImages, 11);
end;
procedure TFrmDlg.DBWStallPriceTab2Initialize(Sender: TObject);
begin
  DBWStallPriceTab2.SetImgIndex(g_qingqingImages, 11);
end;

procedure TFrmDlg.DBXinFaAbdomenMouseHintMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version <> 2}
const
  XinFaHint: array[0..4] of string = (
    ('紫金为帝王之象，紫金心法戾气最重。\性格杀伐果断，十荡十决的勇气适合修\炼紫金心法，紫金心法讲究大开大合，\包罗万象。'),
    ('乙木为自然循环往生的法则，天生怀一\个怜悯之心的人，则适合修炼乙木心法\，乙木心法运行讲究生生不息，气息悠\长，最善持久战。'),
    ('大地心法主旨沉稳，不动如山。肉体强\横，老成持重的人最适合此类心法，大\地心法的运行讲究一力降十会，以拙破\巧，先立于不败之地。'),
    ('抽刀水更流，四两拨千斤。葵水心法讲\究以柔克刚，劲力阴柔，伤人经脉。修\习葵水心法讲究平心静气，后发制人，\适合心态平和之人。'),
    ('阳炎天火，焚尽万物。习此心法者，功\法凶狠毒辣，招招搏命。阳炎心法以怒\火仇恨为根本，有时伤敌伤己，爆发力\最是强劲。')
  );
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBXinFaAbdomenMouseHint do
  DScreen.ShowSpecialHint(SurfaceX(GLeft)-160, SurfaceY(GTop)+20,
                          '<'+g_XinFaName[g_HeartAbility.nHeartTpye]+'心法/c=Yellow>\'+XinFaHint[g_HeartAbility.nHeartTpye], False);
{$IFEND}
end;

procedure TFrmDlg.DBXinfaExpAbsorbClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_boXinFaType and (GetTickCount > g_dwQueryMsgTick) then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    frmMain.SendXinfaExpAbsorb;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  pcm: PTClientMagic;
  rc : TRect;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  d := g_WUI1Images.Images[1607];
  if d <> nil then begin
    for I:=0 to g_XinFaMagic.Count-1 do begin
      pcm := pTClientMagic(g_XinFaMagic[I]);
      if pcm <> nil then begin
        if pcm.Def.wMagicId in [105, 106] then begin
          rc := d.ClientRect;
          if (pcm.CurTrain > 0)  and (pcm.Level < 100) then begin
            rc.Right := Round((rc.Right-rc.Left) / pcm.Def.MaxTrain[0] * pcm.CurTrain);
            with DBXinFaExp do 
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
          end;
          Break;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
  function GetJobMemo(): string;
  begin
    Result := '';
    if g_MySelf <> nil then
      case g_MySelf.m_btJob of
        1: Result := '魔法';
        2: Result := '道术';
        else Result := '攻击';
      end;
  end;
const                                      //M
  sLongWeiLines = '心法经验吸收：<%d/%d/c=Red>\'+
                  ' \'+
                  '<心法下一级即可获得：/c=Lime>\'+
                  '神圣%s：<%d-%d/c=Red>\'+
                  '%s\'+
                  '对心法等级<%d/c=Red>级以下的玩家造成加成伤害';
  sChuanChengLines = '师门人气值：<%d/%d/c=Red>\'+
                     ' \'+
                     '<心法下一级/c=Yellow>\'+
                     '<升级需求：/c=Yellow>\'+
                     '<师父心法等级/c=Yellow><%d/c=Red><级/c=Yellow>\'+
                     '<本人等级/c=Yellow><%d/c=Red><级/c=Yellow>\'+
                     '<师门弟子通过完成任务获得/c=Yellow>\'+
                     '<传承心法经验/c=Yellow>';
var
  I: Integer;
  pcm: PTClientMagic;
  sShenSheng: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBXinFaExp do
  if g_HeartAbility.boTpye then begin
    for I:=0 to g_XinFaMagic.Count-1 do begin
      pcm := PTClientMagic(g_XinFaMagic[I]);
      if pcm <> nil then begin
        if pcm.Def.wMagicId = 105 then begin
          if g_HeartAbility.sUpLevelSKillName = '' then
            sShenSheng := ''
          else sShenSheng := '可以学习<'+g_HeartAbility.sUpLevelSKillName+'/c=Red>';
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+20,
                                Format(sLongWeiLines, [pcm.CurTrain, pcm.Def.MaxTrain[0],
                                GetJobMemo, g_HeartAbility.wUpPower, g_HeartAbility.wUpMaxPower,
                                       sShenSheng, _Max(0, pcm.Level-1)]), False);
        end;
      end;
    end;
  end else begin
    for I:=0 to g_XinFaMagic.Count-1 do begin
      pcm := PTClientMagic(g_XinFaMagic[I]);
      if pcm <> nil then begin
        if pcm.Def.wMagicId = 106 then begin;
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+20,
                                Format(sChuanChengLines, [pcm.CurTrain, pcm.Def.MaxTrain[0],
                                g_HeartAbility.wUpPassHeartLevel, g_HeartAbility.wUpLevel]), False);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaNameNextInitialize(Sender: TObject);
begin
  DBXinFaNameNext.SetImgIndex(g_WUI1Images, 685);
end;

procedure TFrmDlg.DBXinFaNamePrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    if Sender = DBXinFaNamePrev then begin
      if btIndex > 0 then Dec (btIndex);
    end else begin
      if btIndex < 4 then
         Inc (btIndex);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaNamePrevDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
	with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if MouseMoveing then d := WLib.Images[FaceIndex+1]
      else if Downed then d := WLib.Images[FaceIndex+2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaNamePrevInitialize(Sender: TObject);
begin
  DBXinFaNamePrev.SetImgIndex(g_WUI1Images, 680);
end;

procedure TFrmDlg.DBWStallPriceOKInitialize(Sender: TObject);
begin
  DBWStallPriceOK.SetImgIndex(g_WMain2Images, 277);
end;
procedure TFrmDlg.DBWStallPriceCancelInitialize(Sender: TObject);
begin
  DBWStallPriceCancel.SetImgIndex(g_WMain2Images, 277);
end;
procedure TFrmDlg.DBWStallPriceCloseInitialize(Sender: TObject);
begin
  with Sender as TAspDButton do begin
    SetImgIndex(g_WMain2Images, 279);
  end;
end;
procedure TFrmDlg.DWWStallPriceInitialize(Sender: TObject);
begin
  DWWStallPrice.SetImgIndex(g_qingqingImages, 10);
end;

procedure TFrmDlg.DWZZLingPaiInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWZZLingPai.SetImgIndex(g_WUI1Images, 550);
{$IFEND}
end;

procedure TFrmDlg.DWZZLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBBuyUserStallItemInitialize(Sender: TObject);
begin
  DBBuyUserStallItem.SetImgIndex(g_WMain2Images, 275);
end;
procedure TFrmDlg.DBUserStallCloseInitialize(Sender: TObject);
begin
  DBUserStallClose.SetImgIndex(g_WMainImages, 64);
end;

procedure TFrmDlg.DWUserStallInitialize(Sender: TObject);
begin
  DWUserStall.SetImgIndex(g_qingqingImages, 9);
end;
{$ENDREGION}
{$REGION '行会'}
procedure TFrmDlg.DGDUpInitialize(Sender: TObject);
begin
  DGDUp.SetImgIndex (g_WMainImages, 373);
end;
procedure TFrmDlg.DGDDownInitialize(Sender: TObject);
begin
  DGDDown.SetImgIndex (g_WMainImages, 372);
end;
procedure TFrmDlg.DGDCloseInitialize(Sender: TObject);
begin
  DGDClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DGDHomeInitialize(Sender: TObject);
begin
  DGDHome.SetImgIndex (g_WMainImages, 198);
end;
procedure TFrmDlg.DGDAddMemInitialize(Sender: TObject);
begin
  DGDAddMem.SetImgIndex (g_WMainImages, 182);
end;
procedure TFrmDlg.DGDEditNoticeInitialize(Sender: TObject);
begin
  DGDEditNotice.SetImgIndex (g_WMainImages, 196);
end;
procedure TFrmDlg.DGDAllyInitialize(Sender: TObject);
begin
  DGDAlly.SetImgIndex (g_WMainImages, 184);
end;
procedure TFrmDlg.DGDWarInitialize(Sender: TObject);
begin
  DGDWar.SetImgIndex (g_WMainImages, 202);
end;
procedure TFrmDlg.DGDListInitialize(Sender: TObject);
begin
  DGDList.SetImgIndex (g_WMainImages, 200);
end;
procedure TFrmDlg.DGDChatInitialize(Sender: TObject);
begin
  DGDChat.SetImgIndex (g_WMainImages, 190);
end;
procedure TFrmDlg.DGDDelMemInitialize(Sender: TObject);
begin
  DGDDelMem.SetImgIndex (g_WMainImages, 192);
end;
procedure TFrmDlg.DGDEditGradeInitialize(Sender: TObject);
begin
  DGDEditGrade.SetImgIndex (g_WMainImages, 194);
end;
procedure TFrmDlg.DGDBreakAllyInitialize(Sender: TObject);
begin
  DGDBreakAlly.SetImgIndex (g_WMainImages, 186);
end;
procedure TFrmDlg.DGDCancelWarInitialize(Sender: TObject);
begin
  DGDCancelWar.SetImgIndex (g_WMainImages, 188);
end;
procedure TFrmDlg.DGuildDlgInitialize(Sender: TObject);
begin
  DGuildDlg.SetImgIndex (g_WMainImages, 180);
end;
{$ENDREGION}
{$REGION '任务'}
procedure TFrmDlg.DBMission1Initialize(Sender: TObject);
begin
  DBMission1.SetImgIndex(g_WMainImages, 286);
end;
procedure TFrmDlg.DBMission2Initialize(Sender: TObject);
begin
  DBMission2.SetImgIndex(g_WMainImages, 286);
end;
procedure TFrmDlg.DBMission3Initialize(Sender: TObject);
begin
  DBMission3.SetImgIndex(g_WMainImages, 286);
end;
procedure TFrmDlg.DBMissionCloseInitialize(Sender: TObject);
begin
  DBMissionClose.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DBMissionClose1Initialize(Sender: TObject);
begin
  DBMissionClose1.SetImgIndex(g_WMainImages, 286);
end;

procedure TFrmDlg.DScrollBarMission1Initialize(Sender: TObject);
begin
  DScrollBarMission1.ItemHeight := 15;
  DScrollBarMission1.SetImgIndex(g_WMain2Images, 574);
  DScrollBarMission1.GHeight := 134;
  DScrollBarMission1.ScrollSize := 15;
  DScrollBarMission1.PrevImageIndex.Up := 292;
  DScrollBarMission1.PrevImageIndex.Down := 293;
  DScrollBarMission1.NextImageIndex.Up := 294;
  DScrollBarMission1.NextImageIndex.Down := 295;
  DScrollBarMission1.BarImageIndex.Up := 581;
  DScrollBarMission1.RemoveSize :=  135;
  DScrollBarMission1.MaxValue := 0;
  DScrollBarMission1.Position := 0;
end;

procedure TFrmDlg.DScrollBoxKeyInitialize(Sender: TObject);
var
  ItemList: TStringList;
begin
  {$IF M2Version = 2}
    DBtnSdoHeroAttackTargetKey.Visible := False;
    DBtnSdoHeroGuardKey.Visible := False;
    DBtnSdoHeroStateKey.Visible := False;
    DBtnSdoHeroGotethKey.Visible := False;
    DBtnSdoCallHeroKey.Visible := False;
    DBtnSdoCallHero1Key.Visible := False;
    DBtnSdoSeriesKillKey.Visible := False;
    DBtnSdoAttackModeKey.GLeft := DBtnSdoSeriesKillKey.GLeft;
    DBtnSdoAttackModeKey.GTop := DBtnSdoSeriesKillKey.GTop;
    DBtnSdoMinMapKey.GLeft := DBtnSdoCallHeroKey.GLeft;
    DBtnSdoMinMapKey.GTop := DBtnSdoCallHeroKey.GTop;
  {$ELSE}
    {$IF M2Version = 0}
    DBtnSdoSeriesKillKey.Visible := False;
    DBtnSdoMinMapKey.GLeft := DBtnSdoAttackModeKey.GLeft;
    DBtnSdoMinMapKey.GTop := DBtnSdoAttackModeKey.GTop;
    DBtnSdoAttackModeKey.GLeft := DBtnSdoHeroGuardKey.GLeft;
    DBtnSdoAttackModeKey.GTop := DBtnSdoHeroGuardKey.GTop;
    DBtnSdoHeroGuardKey.GLeft := DBtnSdoHeroStateKey.GLeft;
    DBtnSdoHeroGuardKey.GTop := DBtnSdoHeroStateKey.GTop;
    DBtnSdoHeroStateKey.GLeft := DBtnSdoHeroGotethKey.GLeft;
    DBtnSdoHeroStateKey.GTop := DBtnSdoHeroGotethKey.GTop;
    DBtnSdoHeroGotethKey.GLeft := DBtnSdoHeroAttackTargetKey.GLeft;
    DBtnSdoHeroGotethKey.GTop := DBtnSdoHeroAttackTargetKey.GTop;
    DBtnSdoHeroAttackTargetKey.GLeft := DBtnSdoCallHero1Key.GLeft;
    DBtnSdoHeroAttackTargetKey.GTop := DBtnSdoCallHero1Key.GTop;
    DBtnSdoCallHero1Key.GLeft := DBtnSdoCallHeroKey.GLeft;
    DBtnSdoCallHero1Key.GTop := DBtnSdoCallHeroKey.GTop;
    DBtnSdoCallHeroKey.GLeft := DBtnSdoSeriesKillKey.GLeft;
    DBtnSdoCallHeroKey.GTop := DBtnSdoSeriesKillKey.GTop;
    DScrollBoxKey.SpareSize := 10;
    ItemList := DScrollBoxKey.Add;
    DScrollBoxKey.AddSuItem(ItemList, DCheckSdoStartKey);
    DScrollBoxKey.AddSuItem(ItemList, DLabel10);
    DScrollBoxKey.AddSuItem(ItemList, DLabel11);
    DScrollBoxKey.AddSuItem(ItemList, DScrollBoxKeySurface);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroAttackTargetKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoMinMapKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoAttackModeKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGuardKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroStateKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGotethKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHeroKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHero1Key);
    DScrollBarKey.MaxValue := 240;
    {$ELSE}
    DScrollBoxKey.SpareSize := 10;
    ItemList := DScrollBoxKey.Add;
    DScrollBoxKey.AddSuItem(ItemList, DCheckSdoStartKey);
    DScrollBoxKey.AddSuItem(ItemList, DLabel10);
    DScrollBoxKey.AddSuItem(ItemList, DLabel11);
    DScrollBoxKey.AddSuItem(ItemList, DScrollBoxKeySurface);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroAttackTargetKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoMinMapKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoAttackModeKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGuardKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroStateKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGotethKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHeroKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHero1Key);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoSeriesKillKey);
    DScrollBarKey.MaxValue := 260;
    {$IFEND}
  {$IFEND}
end;

procedure TFrmDlg.DScrollBoxKeySurfaceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  Rc: TRect;
begin
  with DScrollBoxKeySurface do begin
    {$IF M2Version = 2}
    AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 2, '切换攻击模式', clSilver, clBlack);
    AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22+2, '切换小地图', clSilver, clBlack);
    Rc.Left := SurfaceX(GLeft)+90;
    Rc.Top := SurfaceY(GTop);
    Rc.Right := Rc.Left + 110;
    Rc.Bottom := Rc.Top + 19;
    {asp 引擎
    dsurface.FastFillRect(Rc, $00040404);
    dsurface.FastFrameRect(Rc, $00848284);}
    Rc.Left := SurfaceX(GLeft)+90;
    Rc.Top := SurfaceY(GTop)+22;
    Rc.Right := Rc.Left + 110;
    Rc.Bottom := Rc.Top + 19;
    {asp 引擎
    dsurface.FastFillRect(Rc, $00040404);
    dsurface.FastFrameRect(Rc, $00848284);}
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 3, 'Ctrl+H', clSilver, clBlack);
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127+9, SurfaceY(GTop) + 22+3, 'Tab', clSilver, clBlack);
    {$ELSE}
      {$IF M2Version = 0}
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 2, '召唤英雄', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22+2, '召唤副将英雄', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*2+2, '英雄攻击目标', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*3+2, '使用合击技', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*4+2, '切换英雄状态', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*5+2, '英雄守护', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*6+2, '切换攻击模式', clSilver, clBlack);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*7+2, '切换小地图', clSilver, clBlack);
      {asp 引擎
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop);
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*2;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*3;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*4;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*5;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*6;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*7;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);   }
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22+3, clSilver, clBlack, 'Ctrl+F');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*2+3, clSilver, clBlack, 'Ctrl+W');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*3+3, clSilver, clBlack, 'Ctrl+S');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*4+3, clSilver, clBlack, 'Ctrl+E');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*5+3, clSilver, clBlack, 'Ctrl+Q');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*6+3, clSilver, clBlack, 'Ctrl+H');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127+9, SurfaceY(GTop) + 22*7+3, clSilver, clBlack, 'Tab');
      {$ELSE}
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 2, clRed, clBlack, '连击技');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22+2, clSilver, clBlack, '召唤英雄');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*2+2, clSilver, clBlack, '召唤副将英雄');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*3+2, clSilver, clBlack, '英雄攻击目标');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*4+2, clSilver, clBlack, '使用合击技');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*5+2, clSilver, clBlack, '切换英雄状态');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*6+2, clSilver, clBlack, '英雄守护');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*7+2, clSilver, clBlack, '切换攻击模式');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*8+2, clSilver, clBlack, '切换小地图');
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop);
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*2;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*3;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*4;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*5;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*6;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*7;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*8;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FillRect(Rc, $00040404);
      dsurface.FrameRect(Rc, $00848284);

      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 3, clSilver, clBlack, 'Ctrl+D');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*2+3, clSilver, clBlack, 'Ctrl+F');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*3+3, clSilver, clBlack, 'Ctrl+W');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*4+3, clSilver, clBlack, 'Ctrl+S');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*5+3, clSilver, clBlack, 'Ctrl+E');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*6+3, clSilver, clBlack, 'Ctrl+Q');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*7+3, clSilver, clBlack, 'Ctrl+H');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127+9, SurfaceY(GTop) + 22*8+3, clSilver, clBlack, 'Tab'); 
      {$IFEND}
    {$IFEND}
  end;
end;

procedure TFrmDlg.DScrollBoxProDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  Rc: TRect;
begin
  with DScrollBoxPro do begin
    Rc.Top := SurfaceY(GTop);
    Rc.Bottom := SurfaceY(GTop+GHeight);
    Rc.Left := SurfaceX(GLeft+29);
    Rc.Right := SurfaceX(GLeft+30);
    dsurface.FillRect(Rc,$00848284);
  end;

end;

procedure TFrmDlg.DScrollBoxProInitialize(Sender: TObject);
var
  ItemList: TStringList;
begin
  DScrollBoxPro.SpareSize := 10;
  ItemList := DScrollBoxPro.Add;
  DScrollBoxPro.AddSuItem(ItemList, DLabelProCap);
  DScrollBoxPro.AddSuItem(ItemList, DLabel9);
  DScrollBoxPro.AddSuItem(ItemList, DLabel2);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxBookHPPro);
  DScrollBoxPro.AddSuItem(ItemList, DEdtBookHPPro);
  DScrollBoxPro.AddSuItem(ItemList, DLabel3);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxBookMPPro);
  DScrollBoxPro.AddSuItem(ItemList, DEdtBookMPPro);
  DScrollBoxPro.AddSuItem(ItemList, DLabel4);
  DScrollBoxPro.AddSuItem(ItemList, DLabel5);
  DScrollBoxPro.AddSuItem(ItemList, DLabel6);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewHP);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHP);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHPTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewMP);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMp);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMpTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewHPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHPSpecialTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewMPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMPSpecialTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedica);
  DScrollBoxPro.AddSuItem(ItemList, DLabel7);
  DScrollBoxPro.AddSuItem(ItemList, DLabel8);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime1);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime2);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime3);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime4);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime5);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime6);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime7);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime8);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime9);
  //DScrollBarPro.MaxValue := 500+25*5;
end;

procedure TFrmDlg.DScrollBoxProMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DTreeViewMission1Initialize(Sender: TObject);
begin
  DTreeViewMission1.WWLib := g_WMainImages;
  DTreeViewMission1.unfoldImg := 291;
  DTreeViewMission1.shrinkImg := 292;
end;
procedure TFrmDlg.DWMissionInitialize(Sender: TObject);
begin
  DWMission.SetImgIndex(g_WMainImages, 290);
end;
procedure TFrmDlg.DMemoMissionBottomInitialize(Sender: TObject);
begin
  DMemoMissionBottom.DScroll := DMemoMissionBottomScrollBar;
  DMemoMissionBottom.DScroll.GTop := -3;
  DMemoMissionBottom.DScroll.GLeft := DMemoMissionBottom.GWidth+3;
  DMemoMissionBottom.DScroll.GHeight := DMemoMissionBottom.GHeight;
  DMemoMissionBottom.DScroll.GWidth := 16;
  DMemoMissionBottom.DScroll.Bar.GTop := 17;
  DMemoMissionBottom.DScroll.BDown.GTop := DMemoMissionBottom.DScroll.GHeight-17;
  DMemoMissionBottom.DScroll.BUp.GTop := 2;
end;
procedure TFrmDlg.DMemoMissionBottomScrollBarInitialize(Sender: TObject);
begin
  DMemoMissionBottomScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DMemoMissionBottomScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DMemoMissionBottomScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;
{$ENDREGION}
{$REGION '卖东西'}
procedure TFrmDlg.DSellDlgInitialize(Sender: TObject);
begin
  DSellDlg.SetImgIndex (g_WMainImages, 392);
end;
procedure TFrmDlg.DSellDlgCloseInitialize(Sender: TObject);
begin
  DSellDlgClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DSellDlgOkInitialize(Sender: TObject);
begin
  DSellDlgOk.SetImgIndex (g_WMainImages, 393);
end;
{$ENDREGION}
{$REGION '属性点'}
procedure TFrmDlg.DAdjustAbilityInitialize(Sender: TObject);
begin
  DAdjustAbility.SetImgIndex (g_WMainImages, 226);
end;
procedure TFrmDlg.DAdjustAbilOkInitialize(Sender: TObject);
begin
  DAdjustAbilOk.SetImgIndex (g_WMainImages, 62);
end;
procedure TFrmDlg.DAdjustAbilCloseInitialize(Sender: TObject);
begin
  DAdjustAbilClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DMinusDCInitialize(Sender: TObject);
begin
  DMinusDC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusHitInitialize(Sender: TObject);
begin
  DMinusHit.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusHPInitialize(Sender: TObject);
begin
  DMinusHP.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusMACInitialize(Sender: TObject);
begin
  DMinusMAC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusMCInitialize(Sender: TObject);
begin
  DMinusMC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusMPInitialize(Sender: TObject);
begin
  DMinusMP.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusSCInitialize(Sender: TObject);
begin
  DMinusSC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusSpeedInitialize(Sender: TObject);
begin
  DMinusSpeed.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DPlusMACInitialize(Sender: TObject);
begin
  DPlusMAC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusMCInitialize(Sender: TObject);
begin
  DPlusMC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DMinusACInitialize(Sender: TObject);
begin
  DMinusAC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DPlusMPInitialize(Sender: TObject);
begin
  DPlusMP.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusACInitialize(Sender: TObject);
begin
  DPlusAC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusSCInitialize(Sender: TObject);
begin
  DPlusSC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusSpeedInitialize(Sender: TObject);
begin
  DPlusSpeed.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusDCInitialize(Sender: TObject);
begin
  DPlusDC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusHitInitialize(Sender: TObject);
begin
  DPlusHit.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusHPInitialize(Sender: TObject);
begin
  DPlusHP.SetImgIndex (g_WMainImages, 227);
end;

{$ENDREGION}
{$REGION '英雄图标'}
procedure TFrmDlg.DHeroIconInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
   d := g_WUI1Images.Images[1290];
   if d <> nil then DHeroIcon.SetImgIndex (g_WUI1Images, 1290)
   else begin
    d := g_WMainImages.Images[1214];
    if d <> nil then DHeroIcon.SetImgIndex (g_WMainImages, 1214); 
   end;
end;
{$ENDREGION}
{$REGION '其他人状态栏'}
procedure TFrmDlg.DCloseUS1Initialize(Sender: TObject);
begin
  DCloseUS1.SetImgIndex (g_WMainImages, 371);
end;
procedure TFrmDlg.DUserState1Initialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
   {$IF M2Version = 2}//1.76
   d := g_WMainImages.Images[370];
   if d <> nil then
      DUserState1.SetImgIndex (g_WMainImages, 370);
   {$ELSE}
   d := g_WMain3Images.Images[207];
   if d <> nil then
      DUserState1.SetImgIndex (g_WMain3Images, 207);   //4格
   {$IFEND}
end;
{$ENDREGION}
{$REGION '取回英雄'}
procedure TFrmDlg.DSelHero1Initialize(Sender: TObject);
begin
  DSelHero1.SetImgIndex(g_Wmain2Images,508);
end;
procedure TFrmDlg.DSelHero2Initialize(Sender: TObject);
begin
  DSelHero2.SetImgIndex(g_Wmain2Images,508);
end;
procedure TFrmDlg.DGetHeroCloseInitialize(Sender: TObject);
begin
  DGetHeroClose.SetImgIndex(g_WmainImages,371);
end;
procedure TFrmDlg.DWiGetHeroInitialize(Sender: TObject);
begin
  DWiGetHero.SetImgIndex (g_WMain2Images, 501);
end;
{$ENDREGION}
{$REGION '验证码'}
procedure TFrmDlg.DCheckNumOKInitialize(Sender: TObject);
begin
  DCheckNumOK.SetImgIndex(g_WMain2Images, 146);
end;
procedure TFrmDlg.DCheckNumChangeInitialize(Sender: TObject);
begin
  DCheckNumChange.SetImgIndex(g_WMain2Images, 146);
end;
procedure TFrmDlg.DCheckNumCloseInitialize(Sender: TObject);
begin
  DCheckNumClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DWCheckNumInitialize(Sender: TObject);
begin
  DWCheckNum.SetImgIndex(g_WMain3Images, 43);
end;
{$ENDREGION}
{$REGION '挑战'}
procedure TFrmDlg.DChallengeOKInitialize(Sender: TObject);
begin
  DChallengeOK.SetImgIndex(g_WMain3Images, 463);
end;
procedure TFrmDlg.DChatMemoChange(Sender: TObject);
var
  I: Integer;
  ChatMemo: TAspDChatMemo;
begin
  ChatMemo := TAspDChatMemo(Sender);
  if ChatMemo.Lines.Count > 200 then begin
    for I := 0 to 9 do begin
      if ChatMemo.Lines.Count > 0 then ChatMemo.Delete(0) else break;
    end;
  end;
  if ChatMemo.TopLines.Count > 3 then ChatMemo.DeleteTop(0); //不允许超过3条信息
end;

procedure TFrmDlg.DChatMemoInitialize(Sender: TObject);
begin
  DChatMemo.WLib := g_WchantkkImages;
  DChatMemo.ScrollImageIndex.Up := 20;
  DChatMemo.PrevImageIndex.Up := 21;
  DChatMemo.PrevImageIndex.Hot := 22;
  DChatMemo.PrevImageIndex.Down := 23;
  DChatMemo.BarImageIndex.Up := 27;
  DChatMemo.BarImageIndex.Hot := 28;
  DChatMemo.BarImageIndex.Down := 29;
  DChatMemo.NextImageIndex.Up := 24;
  DChatMemo.NextImageIndex.Hot := 25;
  DChatMemo.NextImageIndex.Down := 26;
  DChatMemo.Clear;
  
  {
  DChatMemo.WLib := g_qingqingImages; //DChatMemo的资源为 g_WNewopUIImages
  DChatMemo.ScrollImageIndex.Up := 50; //DChatMemo的滚动条的背景正常图片序列号为20
  DChatMemo.PrevImageIndex.Up := 51; //DChatMemo的滚动条的向上按钮的正常图片序列号为21
  DChatMemo.PrevImageIndex.Hot := 52; //DChatMemo的滚动条的向上按钮的鼠标经过时片序列号为22
  DChatMemo.PrevImageIndex.Down := 53; //DChatMemo的滚动条的向上按钮的鼠标按下时片序列号为23
  DChatMemo.BarImageIndex.Up := 57; //DChatMemo的滚动条的中间圆圆滚动按钮
  DChatMemo.BarImageIndex.Hot := 58; //DChatMemo的滚动条的中间圆圆滚动按钮
  DChatMemo.BarImageIndex.Down := 59; //DChatMemo的滚动条的中间圆圆滚动按钮
  DChatMemo.NextImageIndex.Up := 54;  //DChatMemo的滚动条的向下按钮
  DChatMemo.NextImageIndex.Hot := 55; //DChatMemo的滚动条的向下按钮
  DChatMemo.NextImageIndex.Down := 56; //DChatMemo的滚动条的向下按钮
  DChatMemo.Clear;
  }
end;

procedure TFrmDlg.DChatMemoInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
begin
  IsRealArea := True;
end;

procedure TFrmDlg.DChatMemoMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  Str: string;
  DMemo: TAspDChatMemo;

   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      if line[1]='[' then begin
        line := GetValidStr3 (line, line, [']']);
      end;
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':','[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;

begin
  DMemo := TAspDChatMemo(Sender);
  if DMemo.ShowScroll and (X >= DMemo.GLeft + DMemo.GWidth - DMemo.ScrollSize) then Exit;
  if (DMemo.ItemIndex - DMemo.TopIndex >= 0) and (DMemo.ItemIndex - DMemo.TopIndex < DMemo.TopLines.Count) then begin
    if not PlayScene.EdChat.Visible then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
    end;
    if ssCtrl in shift then begin
      PlayScene.EdChat.Text :=DMemo.TopLines[DMemo.ItemIndex - DMemo.TopIndex];
    end else begin
      PlayScene.EdChat.Text := '/' + ExtractUserName (DMemo.TopLines[DMemo.ItemIndex - DMemo.TopIndex]) + ' ';
    end;
    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
    PlayScene.EdChat.SelLength := 0;
  end else
    if (DMemo.ItemIndex - DMemo.TopLines.Count >= 0) and (DMemo.ItemIndex - DMemo.TopLines.Count < DMemo.Lines.Count) then begin
    if not PlayScene.EdChat.Visible then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
    end;
    if ssCtrl in shift then begin
      PlayScene.EdChat.Text :=DMemo.Lines[DMemo.ItemIndex - DMemo.TopLines.Count];
    end else begin
      PlayScene.EdChat.Text := '/' + ExtractUserName (DMemo.Lines[DMemo.ItemIndex - DMemo.TopLines.Count]) + ' ';
    end;
    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
    PlayScene.EdChat.SelLength := 0;
  end else
    PlayScene.EdChat.Text := '';
end;

procedure TFrmDlg.DChallengeCancelInitialize(Sender: TObject);
begin
  DChallengeCancel.SetImgIndex(g_WMain3Images, 466);
end;
procedure TFrmDlg.DChallengeCloseInitialize(Sender: TObject);
begin
  DChallengeClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DWChallengeInitialize(Sender: TObject);
begin
  DWChallenge.SetImgIndex(g_WMain3Images, 465);
end;
{$ENDREGION}
{$REGION '宝箱'}
procedure TFrmDlg.DBoxsBelt1Initialize(Sender: TObject);
begin
  DBoxsBelt1.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt2Initialize(Sender: TObject);
begin
  DBoxsBelt2.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt3Initialize(Sender: TObject);
begin
  DBoxsBelt3.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt4Initialize(Sender: TObject);
begin
  DBoxsBelt4.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt5Initialize(Sender: TObject);
begin
  DBoxsBelt5.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt6Initialize(Sender: TObject);
begin
  DBoxsBelt6.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt7Initialize(Sender: TObject);
begin
  DBoxsBelt7.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt8Initialize(Sender: TObject);
begin
  DBoxsBelt8.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt9Initialize(Sender: TObject);
begin
  DBoxsBelt9.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBNewHelpBtnInitialize(Sender: TObject);
begin
  DBNewHelpBtn.SetImgIndex(g_WMain2Images, 219);
end;
procedure TFrmDlg.DBNewHeroBatterComClick(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version = 1}
  if HeroBatterComIndex <> - 1 then begin
    if g_HeroBatterMagicList.Count - HeroBatterComIndex > 0 then begin
      for I:=Low(g_HeroBatterTopMagic) to High(g_HeroBatterTopMagic) do begin
        if g_HeroBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_HeroBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex] := pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 0;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_HeroBatterMagicList[HeroBatterComIndex]);
      pm.Key := Chr(HeroBatterTopMagIndex + 1);
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, Chr(HeroBatterTopMagIndex + 1), str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = 0 then begin//空
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = -1 then begin//随机
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 1;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end;
    DBNewHeroBatterCom.Visible := False;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterComDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  I: Integer;
  btLine: Byte;
  sStr: string;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewHeroBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if HeroBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+HeroBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+HeroBatterComIndex*15+19), clNavy);
    end;
    btLine := _MIN(4, g_HeroBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_HeroBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_HeroBatterMagicList.Items[I]).Def.sMagicName;
        if I = HeroBatterComIndex then
          AspTextureFont.TextOut(SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if HeroBatterComIndex = btLine then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if HeroBatterComIndex = btLine +1 then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  btLine: Byte;
  ss: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewHeroBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_HeroBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    HeroBatterComIndex := ss;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  Icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
  trainlv: Byte;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TAspDButton do begin
    pm := nil;
    if Tag < g_HeroBatterMagicList.Count then begin
      pm := PTClientMagic (g_HeroBatterMagicList[Tag]);
      if pm <> nil then begin
        if pm.Def.sMagicName <> '' then begin
          Icon := GetBatterMagicIcon(pm.Def.btEffect);
          if Icon > -1 then begin
            if Downed then
              d := g_WMainImages.Images[Icon+1]
            else d := g_WMainImages.Images[Icon];
            if d <> nil then
              dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          d := g_WMainImages.Images[112]; //lv
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          if not (pm.Level in [0..5]) then pm.Level := 0;
          case pm.Def.btEffect of
            102..104: begin
              case Ord(pm.Key) of
                1:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+15%暴击');
                end;
                3: begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+25%暴击');
                end;
                4: begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+30%暴击');
                end;
                else
                AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%暴击');
              end;
            end;
            105..107: begin
              case Ord(pm.Key) of
                 1:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+10%暴击');
                 end;
                 2:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+15%暴击');
                 end;
                 3:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+25%暴击');
                 end;
                 4:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+30%暴击');
                 end;
                 else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%暴击');
              end;
            end;
            108..110: begin
              case Ord(pm.Key) of
                1:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+30%暴击');
                end;
                else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%暴击');
              end;
            end;
            111..113: begin
              case Ord(pm.Key) of
                1:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+30%暴击');
                end;
                else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%暴击');
              end;
            end;
          end;
          if pm.Level in [0..3,5] then trainlv := pm.Level
          else if pm.Level = 4 then trainlv := 3
          else trainlv := 0;
          AspTextureFont.BoldTextOut (SurfaceX(GLeft)+52, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
          if pm.Def.MaxTrain[trainlv] > 0 then begin
             if trainlv < 5 then
                AspTextureFont.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
             else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  sLines: string;
{$IFEND}
begin
{$IF M2Version = 1}
  pm := nil;
  with TAspDButton(Sender) do begin
    if g_HeroBatterMagicList.Count - 1 >= Tag then begin
      pm := PTClientMagic (g_HeroBatterMagicList[Tag]);
      if pm <> nil then begin
        case pm.Def.btEffect of
          102: begin  //三绝杀
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          111: begin //横扫千军
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以自身为/c=Yellow>\<中心，对5*5范围内的目标造成/c=Yellow>\<伤害/c=Yellow>';
          end;
          105: begin //追心刺
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，冲撞单体/c=Yellow>\<目标，在迫使其后退的同时，造/c=Yellow>\<成伤害/c=Yellow>';
          end;
          108: begin //断岳斩
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对三步内/c=Yellow>\<的单体目标造成伤害/c=Yellow>';
          end;
          112, 113: begin //冰天雪地 万剑归宗
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以目标为/c=Yellow>\<中心，对5*5范围内造成持续伤/c=Yellow>\<害/c=Yellow>';
          end;
          else sLines := '';
        end;
        if sLines <> '' then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth, SurfaceY(GTop)+GHeight, sLines, False)
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  I: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  FillChar (g_HeroBatterTopMagic, sizeof(TClientMagic)*4, #0);
  if g_HeroBatterMagicList.Count > 0 then begin
    for i:=0 to g_HeroBatterMagicList.Count-1 do begin
      pm := PTClientMagic (g_HeroBatterMagicList[i]);
      if (Ord(pm.Key) = 1) or (Ord(pm.Key) = 2) or (Ord(pm.Key) = 3) or (Ord(pm.Key) = 4) then begin
        pm.Key := #0;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
      end;
    end;
  end;
  g_HeroBatterTopMagic[0].CurTrain := 1;
  g_HeroBatterTopMagic[1].CurTrain := 1;
  g_HeroBatterTopMagic[2].CurTrain := 1;
  g_HeroBatterTopMagic[3].CurTrain := 1;
  FrmMain.SendHeroMagicKeyChange (-1, #0, '1/1/1/1');
{$IFEND}
end;
procedure TFrmDlg.DBNewHeroBatterRandomInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 901);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterTopMag1Click(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewHeroBatterTopMag4 then begin
    if not g_boHeroOpen4BatterSkill then Exit;
  end;
  if g_HeroBatterMagicList.Count > 0 then begin
    DBNewHeroBatterCom.GLeft := TAspDButton(Sender).GLeft-2;
    DBNewHeroBatterCom.GTop := TAspDButton(Sender).GTop+TAspDButton(Sender).GHeight+1;
    HeroBatterTopMagIndex := TAspDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
    HeroBatterComIndex := -1;
    DBNewHeroBatterCom.Visible := True;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  {$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  Icon: Integer;
  {$IFEND}
begin
  {$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if Sender = DBNewHeroBatterTopMag4 then begin
      if not g_boHeroOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft-3), SurfaceY(GTop-5), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;
    if g_HeroBatterMagicList.Count > 0 then begin
      if g_HeroBatterTopMagic[Tag].Def.sMagicName <> '' then begin
        Icon := GetBatterMagicIcon(g_HeroBatterTopMagic[Tag].Def.btEffect);
        if Icon > -1 then begin
          if Downed then
            d := g_WMainImages.Images[icon+1]
          else d := g_WMainImages.Images[icon];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        if Downed then begin
          if g_HeroBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2+1];
          end;
        end else begin
          if g_HeroBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if (g_HeroBatterTopMagic[0].Def.sMagicName = '') and (g_HeroBatterTopMagic[1].Def.sMagicName = '') and (g_HeroBatterTopMagic[2].Def.sMagicName = '') and (g_HeroBatterTopMagic[3].Def.sMagicName = '')
           and (g_HeroBatterTopMagic[0].CurTrain <> 1) and (g_HeroBatterTopMagic[1].CurTrain <> 1) and (g_HeroBatterTopMagic[2].CurTrain <> 1) and (g_HeroBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DBNewHeroBatterTopMag1 then begin
            if (not Downed) and (not DBNewHeroBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft)+10, SurfaceY(GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewHeroBatterTopMag1 then begin
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterTopMag2 then begin
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterTopMag3 then begin
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterTopMag4 then begin
    if not g_boHeroOpen4BatterSkill then Exit;
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterRandom then begin
    DScreen.ShowHint(DBNewHeroBatterRandom.SurfaceX(DBNewHeroBatterRandom.GLeft), DBNewHeroBatterRandom.SurfaceY(DBNewHeroBatterRandom.GTop+DBNewHeroBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewHeroJQExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*5+5, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 68) then begin
            if (pm.Level < 100) then begin


              rc := d.ClientRect;
              if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
                rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
              end;
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroJQExpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*5+5, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 68) then begin
      if (pm.Level < 100) then begin
        sMsg := '当前经验:%d/%d';
        with DBNewJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      end else begin
        sMsg := '当前经验:%d/-';
        with DBNewJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain]), $00A8D4E8, FALSE);
      end;
      Break;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  rc: Trect;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DBNewHeroLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;

      if g_HeroSelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_HeroSelf.m_Abil.MaxAlcohol * g_HeroSelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroLiquorProgressInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WMain2Images, 575);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointIcon1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if HeroStatePulsePage = 4 then begin//奇经
      if TAspDControl(Sender).Tag = 0 then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
        end else begin
          ShowQJPractice(True);
        end;
      end;
      frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, TAspDControl(Sender).Tag+1);
    end else begin
      frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, TAspDControl(Sender).Tag+1);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointIcon1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= Tag+1 then
      d := g_WMainImages.Images[851]
    else if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = Tag+1)) or (HeroStatePulsePage = 4){奇经} then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

    if ((g_btHeroPulseOriginPage = HeroStatePulsePage) or (HeroStatePulsePage = 4){奇经}) and (g_btHeroPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;

    if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = Tag+1)) or ((HeroStatePulsePage = 4) and (g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0) and (Tag = 0)){奇经} then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointIcon1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);

{$IF M2Version = 1}
var
  sLines, sPointName, sPulsDesc: string;

  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwHeroInternalForceLevel >= nlevel then Result := '~y';
  end;
{$IFEND}

begin
{$IF M2Version = 1}
  if HeroStatePulsePage = 4 then begin
    if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= TAspDControl(Sender).Tag+1 then begin //已打通
      DScreen.ShowHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), '神冲穴: 已打通,点击可修炼\ \奇经穴位，通过奇经神冲丸\打通，可点击进行修炼，提\升斗转星移技能等级。' , clWhite, FALSE);
    end else begin
      DScreen.ShowTzHint (TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop),
                  '神冲穴:待打通'+'~y\', FALSE, FALSE, 0);
    end;
  end else begin
    sPointName := GetPulseName(HeroStatePulsePage,TAspDControl(Sender).Tag);
    if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= TAspDControl(Sender).Tag+1 then begin //已打通
      if sPointName <> '' then begin
        sLines := Format('%s穴:已打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'已通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' +  sPulsDesc;
        DScreen.ShowHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), sLines, clYellow, FALSE);
      end;
    end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = TAspDControl(Sender).Tag+1) then begin //待打
      if sPointName <> '' then begin
        sLines := Format('%s穴:待打通~y\需要内功等级：%d',[sPointName, g_btHeroPulseLevel])+GetRGB(g_btHeroPulseLevel);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowTzHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), sLines, FALSE, FALSE, 0);
      end;
    end else begin
      if sPointName <> '' then begin
        sLines := Format('%s穴:目前不可打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), sLines, clRed, FALSE);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPage1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version =1}
  if HeroStatePulsePage <> TAspDButton(Sender).Tag then begin
    HeroStatePulsePage := TAspDButton(Sender).Tag;
    ChangeHeroNGPointPage();
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPage1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if HeroStatePulsePage = Tag then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    if HeroStatePulsePage = Tag then
      Color := $73B2DE
    else Color := $5282A5;
    if not Downed then
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+4, SurfaceY(GTop)+5, Color, clBlack, Caption)
    else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+5, SurfaceY(GTop)+6, Color, clBlack, Caption);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPage1Initialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 812);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPracticeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendHeroPracticePulse(HeroStatePulsePage);
      end;
    end else begin
      case HeroStatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(True);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPracticeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  btWidth, btHeight: Byte;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      btWidth := GWidth div 2 - FrmMain.Canvas.TextWidth(Caption) div 2;
      btHeight := GHeight div 2 - FrmMain.Canvas.TextHeight(Caption) div 2;
      if not Enabled then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight{+ 5}, $0099A8AC, clBlack, Caption);
        Exit;
      end;
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth+1, SurfaceY(GTop) + btHeight + 1{SurfaceY(GTop) + 6}, $0048A4E8, clBlack, Caption);
      end else begin
        if MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight, $00A8D4E8, clBlack, Caption);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight, $0088C4E8, clBlack, Caption);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPracticeInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 814);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPracticeMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  str: string;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewHeroPointPractice do begin
    if HeroStatePulsePage = 4 then begin
      DScreen.ShowHint(SurfaceX(GLeft) - DScreen.HintWidth, SurfaceY(GTop) - DScreen.HintHeight,
                               '修炼穴位\点击可选择进行修炼的穴位，\提升穴位的修为，\可获得对应技能并提升等级。', clWhite, FALSE);
    end else begin
      if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
        case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
          0: str := GetPulsDesc(format('HP%s已通-%d',[GetPulsePageName(HeroStatePulsePage), g_HeroSelf.m_btJob]));
          1..4: str := GetPulsDesc('HP'+GetPulsePageName(HeroStatePulsePage)+IntToStr(g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel));
        end;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
        DScreen.ShowSpecialHint(SurfaceX(GLeft)- DScreen.HintWidth, SurfaceY(GTop)-DScreen.HintHeight,
                      format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
      end else begin
        str := GetPulsDesc('HP'+GetPulsePageName(HeroStatePulsePage)+'未通');
        if str <> '' then
        DScreen.ShowHint(SurfaceX(GLeft) - DScreen.HintWidth, SurfaceY(GTop) - DScreen.HintHeight,
                               str, clWhite, FALSE);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  keych: char;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
  idx := _Max(TAspDButton(Sender).Tag + HeroMagicPage * 5, 0);
  if (idx >= 0) and (idx < g_HeroMagicList.Count) then begin
    pm := PTClientMagic (g_HeroMagicList[idx]);
    if pm.Def.wMagicId <> 99 then begin
      if not (pm.Def.wMagicId in [3,4,60..65,67,88,95]) then begin
        if word(pm.Key) = 0 then
          keych := char(word(1))
        else keych := char(word(0));
        pm.Key := keych;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych,'');
      end;
    end else begin
      SetHeroSkillMemoDlg(pm.Def.wMagicId, pm.Def.btEffect, pm.Def.sMagicName, '强身术修炼');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
  wm: TAspWMImages;
  boPieceExp: Boolean;
  MagColor: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    pm := nil;
    Idx := _Max(Tag + HeroMagicPage * 5, 0);
    if Idx < g_HeroMagicList.Count then begin
      pm := PTClientMagic (g_HeroMagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then begin
                if word(pm.Key) = 0 then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                else begin
                  dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False, 124);
                end;
              end;
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then begin
                if word(pm.Key) = 0 then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                else begin
                  dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False, 124);
                end;
              end;
            end;
          end;
        end;
        if word(pm.Key) = 0 then begin
          MagColor := clSilver;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, MagColor, clBlack, pm.Def.sMagicName);
        end else begin
          MagColor := clGray;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, MagColor, clBlack, pm.Def.sMagicName+'[关]');
        end;
        boPieceExp := pm.Def.wMagicId in [68]; //显示经验条
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then begin
          if boPieceExp then
            dsurface.Draw (SurfaceX(GLeft)+94, SurfaceY(GTop)-1, d.ClientRect, d, TRUE)
          else dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        end;
        if not boPieceExp then begin
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+71, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          end;
        end;
        case pm.Def.wMagicId of
          68: begin//酒气护体
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+108, SurfaceY(GTop)-2, clSilver, clBlack, IntToStr(pm.Level));
            DBNewHeroJQExp.GLeft := GLeft+37;
            DBNewHeroJQExp.GTop := GTop+22;
            if not DBNewHeroJQExp.Visible then DBNewHeroJQExp.Visible := True;
          end;
          95: begin//斗转星移
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-');
          end;
          99: begin//强身术
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            if pm.Level = 99 then
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-')
            else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
          end;
          104: begin
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            if pm.Level = 100 then
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-')
            else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]));
          end;
          else begin
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            if not (pm.Level in [0..4]) then pm.Level := 0;
            if pm.Level < 3 then
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
            else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-');
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStMag1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    pm := nil;
    idx := _Max(Tag + HeroMagicPage * 5, 0);
    if idx < g_HeroMagicList.Count then begin
      pm := PTClientMagic (g_HeroMagicList[idx]);
      if pm <> nil then begin
        DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                      SurfaceY(GTop),
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  Idx: Integer;
  pm: PTClientMagic;
  keych: Char;
{$IFEND}
begin
{$IF M2Version <> 2}
  Idx := _Max(TAspDButton(Sender).Tag + HeroInternalForceMagicPage * 5, 0);
  if (Idx >= 0) and (Idx < g_HeroInternalForceMagicList.Count) then begin
    pm := PTClientMagic (g_HeroInternalForceMagicList[Idx]);
    if Word(pm.Key) = 0 then
      keych := Char(Word(1))
    else keych := Char(Word(0));
    pm.Key := keych;
    FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych, '');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
  wm: TAspWMImages;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    pm := nil;
    Idx := _Max(Tag + HeroInternalForceMagicPage * 5, 0);
    if Idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx,Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
            if d <> nil then begin
              if word(pm.Key) <> 0 then begin
                //g_ImgMixSurface.SetSize(d.Width, d.Height);

                dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True,124);
              end;
            end;
          end;
        end;
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        d := g_WMainImages.Images[111]; //exp
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
        if Word(pm.Key) = 0 then begin
          Color := clSilver;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName);
        end else begin
          Color := clGray;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName+'[关]');
        end;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+52, SurfaceY(GTop)+15, Color, clBlack, IntToStr(pm.Level));
        if pm.Level < 3 then
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
        else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    pm := nil;
    idx := _Max(Tag + HeroInternalForceMagicPage * 5, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then begin
        if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
        else
          DScreen.ShowTzHint (SurfaceX(GLeft)-120, SurfaceY(GTop),
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGPageDownInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2203);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewHeroStNGPageUp then begin
    if HeroInternalForceMagicPage > 0 then begin
      Dec (HeroInternalForceMagicPage);
      NewNGUpLevelState(True);
    end;
  end else begin
    if HeroInternalForceMagicPage < (g_HeroInternalForceMagicList.Count+4) div 5 - 1 then begin
      Inc (HeroInternalForceMagicPage);
      NewNGUpLevelState(True);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGPageUpInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2200);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStPageDownInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2203);
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewHeroStPageUp then begin
    if HeroMagicPage > 0 then begin
      if DBNewHeroJQExp.Visible then DBNewHeroJQExp.Visible := False;
      Dec (HeroMagicPage);
    end;
  end else begin
    if HeroMagicPage < (g_HeroMagicList.Count+4) div 5 - 1 then begin
      if DBNewHeroJQExp.Visible then DBNewHeroJQExp.Visible := False;
      Inc (HeroMagicPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStPageUpInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2200);
{$IFEND}
end;

procedure TFrmDlg.DBNewJQExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   I,Idx: Integer;
   magline: Integer;
   rc: TRect;
   Btn: TAspDButton;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
  begin
    if WLib <> nil then begin //20080701
      magline := _MIN(MagicPage*5+5, g_MagicList.Count);
      for i:=magtop to magline-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if (pm.Def.wMagicId = 68) then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
          d := g_WMain2Images.Images[578];
          if (pm.Level < 100) and (d<>nil) then begin
            rc := d.ClientRect;
            if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
              rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
            end;
          end;
          Break;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*5+5, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 68) then begin
      if (pm.Level < 100) then begin
        sMsg := '当前经验:%d/%d';
        with DBNewJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      end else begin
        sMsg := '当前经验:%d/-';
        with DBNewJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain]), $00A8D4E8, FALSE);
      end;
      Break;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc: Trect;
begin
  if g_MySelf = nil then Exit;
  with DBNewLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;

      if g_MySelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_MySelf.m_Abil.MaxAlcohol * g_MySelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBNewLiquorProgressInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WMain2Images, 575);
{$IFEND}
end;

procedure TFrmDlg.DBNewNextTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2209);
{$IFEND}
end;

procedure TFrmDlg.DBNewPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(g_ClientHumTitles.ClientHumTitles) to High(g_ClientHumTitles.ClientHumTitles) do begin
      if g_ClientHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBNewPrevTitle then begin
    if m_btTitlePage > 0 then Dec (m_btTitlePage);
  end else begin
    if m_btTitlePage < (GetTitleCount+4) div 5 -1 then
       Inc (m_btTitlePage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewPrevTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2206);
{$IFEND}
end;

procedure TFrmDlg.DBoxsNewCloseInitialize(Sender: TObject);
begin
  DBoxsNewClose.SetImgIndex(g_WMain2Images, 212);
end;
procedure TFrmDlg.DNewBoxsHelpCloseInitialize(Sender: TObject);
begin
  DNewBoxsHelpClose.SetImgIndex(g_WMain2Images, 212);
end;
procedure TFrmDlg.DNewBoxsHelpInitialize(Sender: TObject);
begin
  DNewBoxsHelp.SetImgIndex(g_WMain2Images, 211);
end;
procedure TFrmDlg.DBoxsInitialize(Sender: TObject);
begin
//  DBoxs.SetImgIndex(g_WMain3Images,520);
end;
{$ENDREGION}
{$REGION '关系系统'}
procedure TFrmDlg.DFriendDlgFrdInitialize(Sender: TObject);
begin
  DFriendDlgFrd.SetImgIndex (g_WMain3Images, 481);
end;
procedure TFrmDlg.DFriendDlgTangetInitialize(Sender: TObject);
begin
  DFriendDlgTanget.SetImgIndex (g_WMainImages, 301);
end;
procedure TFrmDlg.DHeiMingDanInitialize(Sender: TObject);
begin
  DHeiMingDan.SetImgIndex (g_WMain3Images, 483);
end;
procedure TFrmDlg.DAddFriendInitialize(Sender: TObject);
begin
  DAddFriend.SetImgIndex (g_WMain3Images, 485);
end;
procedure TFrmDlg.DDelFriendInitialize(Sender: TObject);
begin
  DDelFriend.SetImgIndex (g_WMain3Images, 484);
end;
procedure TFrmDlg.DPrevFriendDlgInitialize(Sender: TObject);
begin
  DPrevFriendDlg.SetImgIndex (g_WMainImages, 398);
end;
procedure TFrmDlg.DNextFriendDlgInitialize(Sender: TObject);
begin
  DNextFriendDlg.SetImgIndex (g_WMainImages, 396);
end;
procedure TFrmDlg.DFrdCloseInitialize(Sender: TObject);
begin
  DFrdClose.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DFriendDlgInitialize(Sender: TObject);
begin
  DFriendDlg.SetImgIndex (g_WMainImages, 300);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '感叹号'}
procedure TFrmDlg.DSighIconInitialize(Sender: TObject);
begin
  DSighIcon.SetImgIndex(g_WMainImages, 460);
end;
{$ENDREGION}
{$REGION '淬炼'}
procedure TFrmDlg.DItemsUpOkInitialize(Sender: TObject);
begin
  DItemsUpOk.SetImgIndex(g_WMain3Images, 463);
end;
procedure TFrmDlg.DItemsUpCloseInitialize(Sender: TObject);
begin
  DItemsUpClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DItemsUpInitialize(Sender: TObject);
begin
  DItemsUp.SetImgIndex (g_WMain3Images, 462);
end;

{$ENDREGION}
{$REGION '寄售'}
procedure TFrmDlg.DSellOffOkInitialize(Sender: TObject);
begin
  DSellOffOk.SetImgIndex(g_WMain3Images, 210);
end;
procedure TFrmDlg.DSellOffCancelInitialize(Sender: TObject);
begin
  DSellOffCancel.SetImgIndex(g_WMain3Images, 212);
end;
procedure TFrmDlg.DSellOffCloseInitialize(Sender: TObject);
begin
  DSellOffClose.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DWSellOffInitialize(Sender: TObject);
begin
  DWSellOff.SetImgIndex(g_WMain3Images, 209);
end;
procedure TFrmDlg.DSellOffListCancelInitialize(Sender: TObject);
begin
  DSellOffListCancel.SetImgIndex(g_WMain3Images, 251);
end;
procedure TFrmDlg.DSellOffBuyCancelInitialize(Sender: TObject);
begin
  DSellOffBuyCancel.SetImgIndex(g_WMain3Images, 249);
end;
procedure TFrmDlg.DSellOffBuyInitialize(Sender: TObject);
begin
  DSellOffBuy.SetImgIndex(g_WMain3Images, 247);
end;
procedure TFrmDlg.DSellOffListColseInitialize(Sender: TObject);
begin
  DSellOffListColse.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DWSellOffListInitialize(Sender: TObject);
begin
  DWSellOffList.SetImgIndex(g_WMain3Images, 277);
end;
{$ENDREGION}
{$REGION '私聊记录'}
procedure TFrmDlg.DMemoWhisperListInitialize(Sender: TObject);
begin
  DMemoWhisperList.DScroll := DMemoWhisperListScrollBar;
  DMemoWhisperList.DScroll.GTop := 0;
  DMemoWhisperList.DScroll.GLeft := 346;
  DMemoWhisperList.DScroll.GHeight := 180;
  DMemoWhisperList.DScroll.GWidth := 16;
  DMemoWhisperList.DScroll.Bar.GTop := 17;
  DMemoWhisperList.DScroll.BDown.GTop := 163;
  DMemoWhisperList.DScroll.BUp.GTop := 2;
end;
procedure TFrmDlg.DMemoWhisperListScrollBarInitialize(Sender: TObject);
begin
  DMemoWhisperListScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DMemoWhisperListScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DMemoWhisperListScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;
procedure TFrmDlg.DMemoXinFaHintDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  data, fdata, cmdstr, cmdparam: string;
  sx: integer;
  pcp: PTClickPoint;
  Color: TColor;
  sColor, cmdtitle, sTemp: string;
begin
  with DMemoXinFaHint do begin
    ElemCount:= (GHeight - 2) div LinesHeight;  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for I:= 0 to ElemCount - 1 do begin
      sx := 0;
      fdata := '';
      data := Lines.Strings[I+TopIndex];
      while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin  //如果是连接
        if data[1] <> '<' then begin
          data := '<' + GetValidStr3 (data, fdata, ['<']);
        end;
        data := ArrestStringEx (data, '<', '>', cmdstr);//得到"<"和">" 号之间的字   赋予给 cmdstr
        if cmdstr <> '' then begin
          cmdparam := GetValidStr3 (cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
        end;
        if fdata <> '' then begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, fdata);
          sx := sx + FrmMain.Canvas.TextWidth(fdata);
        end;
        if (cmdstr <> '') then begin
          if CompareLStr(cmdparam, 'FCOLOR=', length('FCOLOR=')) then begin
            sColor := GetValidStr3(cmdparam, sTemp, ['=']);
            Color := GetRGB(Lobyte(Str_ToInt(sColor, 255)));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), Color, clBlack, cmdstr)  //显示颜色文字
          end;
          FrmMain.Canvas.Font.Style := FrmMain.Canvas.Font.Style - [fsUnderline];
          sx := sx + FrmMain.Canvas.TextWidth(cmdstr);
        end;
      end;
      if data <> '' then
        AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, data);
    end;
  end;
end;

procedure TFrmDlg.DMemoXinFaHintInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with DMemoXinFaHint do begin
    DScroll := DMemoXinFaHintScrollBar;
    DScroll.Bar.GTop := 13;
    DScroll.BDown.GTop := DScroll.GHeight-13;
    DScroll.BUp.GTop := 2;
  end;
{$IFEND}
end;

procedure TFrmDlg.DMemoXinFaHintScrollBarDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   Rc:Trect;
begin
  with Sender as TAspDMemoScrollBar do begin
    d := g_WMain2Images.Images[291];
    if d <> nil then begin
      Rc := d.ClientRect;
      Rc.Bottom := GHeight;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, True);
      Rc := d.ClientRect;
      Rc.Top := d.Height-GHeight;
      Rc.Bottom := d.Height;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)+1, Rc, d, True);
    end;
  end;
end;

procedure TFrmDlg.DMemoXinFaHintScrollBarInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with DMemoXinFaHintScrollBar do begin
    Bar.SetImgIndex(g_WUI1Images, 1610);
    BUp.SetImgIndex(g_WUI1Images, 1613);
    BDown.SetImgIndex(g_WUI1Images, 1616);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWhisperCloseInitialize(Sender: TObject);
begin
  with Sender as TAspDButton do
    SetImgIndex(g_WMain3Images,233);
end;

procedure TFrmDlg.DWWhisperInitialize(Sender: TObject);
begin
  DWWhisper.SetImgIndex(g_WMainImages, 1150);
end;
{$ENDREGION}
{$REGION '英雄评定'}
procedure TFrmDlg.DHeroAssessSign1Initialize(Sender: TObject);
begin
  DHeroAssessSign1.SetImgIndex(g_WMainImages, 1546);
end;
procedure TFrmDlg.DHeroAssessClose1Initialize(Sender: TObject);
begin
  DHeroAssessClose1.SetImgIndex(g_WMainImages, 1546);
end;
procedure TFrmDlg.DHeroAssessSignInitialize(Sender: TObject);
begin
  DHeroAssessSign.SetImgIndex(g_WMainImages, 1542);
end;
procedure TFrmDlg.DHeroAssessCloseInitialize(Sender: TObject);
begin
  DHeroAssessClose.SetImgIndex(g_Wmain3Images,233);
end;
procedure TFrmDlg.DWHeroAssessInitialize(Sender: TObject);
begin
  DWHeroAssess.SetImgIndex(g_WMainImages, 1540);
end;
procedure TFrmDlg.DHeroAutoPraMapPrevInitialize(Sender: TObject);
begin
  DHeroAutoPraMapPrev.SetImgIndex(g_WMainImages, 1564);
end;
procedure TFrmDlg.DHeroAutoPraMapNextInitialize(Sender: TObject);
begin
  DHeroAutoPraMapNext.SetImgIndex(g_WMainImages, 1561);
end;
procedure TFrmDlg.DHeroAutoPraYDSPrevInitialize(Sender: TObject);
begin
  DHeroAutoPraYDSPrev.SetImgIndex(g_WMainImages, 1564);
end;
procedure TFrmDlg.DHeroAutoPraYDSNextInitialize(Sender: TObject);
begin
  DHeroAutoPraYDSNext.SetImgIndex(g_WMainImages, 1561);
end;
procedure TFrmDlg.DStartHeroAutoPraInitialize(Sender: TObject);
begin
  DStartHeroAutoPra.SetImgIndex(g_WmainImages,1548);
end;
procedure TFrmDlg.DHeroAutoPraCloseInitialize(Sender: TObject);
begin
  DHeroAutoPraClose.SetImgIndex(g_Wmain3Images,233);
end;
procedure TFrmDlg.DWHeroAutoPracticeInitialize(Sender: TObject);
begin
  DWHeroAutoPractice.SetImgIndex(g_WMainImages, 1570);
end;
{$ENDREGION}
{$REGION '商铺'}
procedure TFrmDlg.DShopPrevInitialize(Sender: TObject);
begin
  DShopPrev.SetImgIndex(g_WmainImages,388);
end;
procedure TFrmDlg.DShopNextInitialize(Sender: TObject);
begin
  DShopNext.SetImgIndex(g_WmainImages,387);
end;
procedure TFrmDlg.DShopBuyInitialize(Sender: TObject);
begin
  DShopBuy.SetImgIndex(g_Wmain3Images,304);
end;
procedure TFrmDlg.DShopPresentInitialize(Sender: TObject);
begin
  DShopPresent.SetImgIndex(g_Wmain3Images,305);
end;
procedure TFrmDlg.DShopClose1Initialize(Sender: TObject);
begin
  DShopClose1.SetImgIndex(g_Wmain3Images,306);
end;
procedure TFrmDlg.DShopCloseInitialize(Sender: TObject);
begin
  DShopClose.SetImgIndex(g_WmainImages,371);
end;
procedure TFrmDlg.DShopInitialize(Sender: TObject);
begin
  DShop.SetImgIndex (g_Wmain3Images,298);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '英雄状态栏'}
procedure TFrmDlg.DStateHeroInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DStateHero.SetImgIndex (g_WMainImages, 808);
    g_boNewHeroState := True;
  end else begin
    d := g_WMain3Images.Images[384];
    if d <> nil then begin
      DStateHero.SetImgIndex (g_WMain3Images, 384); //人物状态  4格图
    end;
    g_boNewHeroState := False;
  end;
end;
procedure TFrmDlg.DHeroStateWinPulseInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DHeroStateWinPulse.SetImgIndex(g_WMainImages, 820);
  end else DHeroStateWinPulse.Visible := False;
end;
procedure TFrmDlg.DHeroStateTabInitialize(Sender: TObject);
begin
  DHeroStateTab.SetImgIndex(g_WMain2Images, 746);
end;
procedure TFrmDlg.DCloseHeroStateInitialize(Sender: TObject);
begin
  DCloseHeroState.SetImgIndex (g_WMainImages, 371);
end;
procedure TFrmDlg.DHeroStateSsasInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DHeroStateSsas.SetImgIndex(g_WMainImages, 792);
  end else begin
    DHeroStateSsas.Visible := False;
  end;
end;
procedure TFrmDlg.DPrevStateHeroInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DPrevStateHero.Visible := False;
  end else begin
    d := g_WMain3Images.Images[384];
    if d <> nil then begin
      DPrevStateHero.SetImgIndex (g_WMainImages, 373);
    end;
  end;
end;
procedure TFrmDlg.DNextStateHeroInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DNextStateHero.Visible := False;
  end else begin
    d := g_WMain3Images.Images[384];
    if d <> nil then begin
      DNextStateHero.SetImgIndex (g_WMainImages, 372);
    end;
  end;
end;
procedure TFrmDlg.DSHPageUpInitialize(Sender: TObject);
begin
  DSHPageUp.SetImgIndex (g_WMainImages, 398);
end;
procedure TFrmDlg.DSHPageDownInitialize(Sender: TObject);
begin
  DSHPageDown.SetImgIndex (g_WMainImages, 396);
end;
procedure TFrmDlg.DHeroJQExpInitialize(Sender: TObject);
begin
  DHeroJQExp.SetImgIndex(g_WMain2Images, 577);
end;
procedure TFrmDlg.DBHeroQSSSeeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
DBHeroQSSSee.SetImgIndex(g_WUI1Images, 482);
{$IFEND}
end;
procedure TFrmDlg.DHeroLiquorProgressInitialize(Sender: TObject);
begin
  DHeroLiquorProgress.SetImgIndex(g_WMain2Images, 575);
end;
procedure TFrmDlg.DHeroBatterRandomInitialize(Sender: TObject);
begin
  DHeroBatterRandom.SetImgIndex(g_WMainImages, 901);
end;
procedure TFrmDlg.DHeroBatterComInitialize(Sender: TObject);
begin
  DHeroBatterCom.SetImgIndex(g_WMainImages, 911);
end;
procedure TFrmDlg.DHeroStateWinBatterInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DHeroStateWinBatter.SetImgIndex(g_WMainImages, 900);
  end else DHeroStateWinBatter.Visible := False;
end;
{$ENDREGION}
{$REGION '请酒'}
procedure TFrmDlg.DPDrink1Initialize(Sender: TObject);
begin
  DPDrink1.SetImgIndex(g_WMain2Images, 365);
end;
procedure TFrmDlg.DPDrink2Initialize(Sender: TObject);
begin
  DPDrink2.SetImgIndex(g_WMain2Images, 365);
end;
procedure TFrmDlg.DPleaseDrinkDrinkInitialize(Sender: TObject);
begin
  DPleaseDrinkDrink.SetImgIndex(g_WMain2Images, 354);
end;
procedure TFrmDlg.DPleaseDrinkExitInitialize(Sender: TObject);
begin
  DPleaseDrinkExit.SetImgIndex(g_WMain2Images, 356);
end;
procedure TFrmDlg.DWPleaseDrinkInitialize(Sender: TObject);
begin
  DWPleaseDrink.SetImgIndex (g_WMain2Images, 340);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
procedure TFrmDlg.DPleaseDrinkCloseInitialize(Sender: TObject);
begin
  DPleaseDrinkClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DDrink1Initialize(Sender: TObject);
begin
  DDrink1.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink2Initialize(Sender: TObject);
begin
  DDrink2.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink3Initialize(Sender: TObject);
begin
  DDrink3.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink4Initialize(Sender: TObject);
begin
  DDrink4.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink5Initialize(Sender: TObject);
begin
  DDrink5.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink6Initialize(Sender: TObject);
begin
  DDrink6.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DPlayDrinkCloseInitialize(Sender: TObject);
begin
  DPlayDrinkClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DPlayDrinkFistInitialize(Sender: TObject);
begin
  DPlayDrinkFist.SetImgIndex(g_WMain2Images, 348);
end;
procedure TFrmDlg.DPlayDrinkScissorsInitialize(Sender: TObject);
begin
  DPlayDrinkScissors.SetImgIndex(g_WMain2Images, 350);
end;
procedure TFrmDlg.DPlayDrinkClothInitialize(Sender: TObject);
begin
  DPlayDrinkCloth.SetImgIndex(g_WMain2Images, 352);
end;
procedure TFrmDlg.DPlayFistInitialize(Sender: TObject);
begin
  DPlayFist.SetImgIndex(g_WMain2Images, 358);
end;
procedure TFrmDlg.DPlayDrinkInitialize(Sender: TObject);
begin
  DPlayDrink.SetImgIndex (g_WMain2Images, 341);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '酿酒'}
procedure TFrmDlg.DMakeWineHelpInitialize(Sender: TObject);
begin
  DMakeWineHelp.SetImgIndex(g_WMain2Images, 590);
end;
procedure TFrmDlg.DMaterialMemoInitialize(Sender: TObject);
begin
  DMaterialMemo.SetImgIndex(g_WMain2Images, 590);
end;
procedure TFrmDlg.DStartMakeWineInitialize(Sender: TObject);
begin
  DStartMakeWine.SetImgIndex(g_WMain2Images, 590);
end;
procedure TFrmDlg.DMakeWineDeskCloseInitialize(Sender: TObject);
begin
  DMakeWineDeskClose.SetImgIndex (g_WMainImages, 371);
end;
procedure TFrmDlg.DWMakeWineDeskInitialize(Sender: TObject);
begin
  DWMakeWineDesk.SetImgIndex(g_WMain2Images, 584);
end;
{$ENDREGION}
{$REGION '恢复删除人物'}
procedure TFrmDlg.btnRecoverInitialize(Sender: TObject);
begin
  btnRecover.SetImgIndex(g_WMain3Images, 407);
end;
procedure TFrmDlg.btnRecvChrCloseInitialize(Sender: TObject);
begin
  btnRecvChrClose.SetImgIndex(g_WMainImages, 64);
end;
procedure TFrmDlg.dwRecoverChrInitialize(Sender: TObject);
begin
  dwRecoverChr.SetImgIndex(g_WMain3Images, 406);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
{$ENDREGION}
{$REGION '牛气'}
procedure TFrmDlg.DNQExpInitialize(Sender: TObject);
begin
  DNQExp.SetImgIndex(g_WMainImages,564);
end;
procedure TFrmDlg.DWNQStateInitialize(Sender: TObject);
begin
  DWNQState.SetImgIndex(g_WMainImages, 560);
end;
{$ENDREGION}
{$REGION '锻造金针'}
procedure TFrmDlg.DKimNeedleHelpInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleHelp.SetImgIndex(g_WMainImages, 776);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleMemoInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleMemo.SetImgIndex(g_WMainImages, 774);
{$IFEND}
end;
procedure TFrmDlg.DStartKimNeedleInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DStartKimNeedle.SetImgIndex(g_WMainImages, 770);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleLogoInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleLogo.SetImgIndex(g_WMainImages, 752);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleBarInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleBar.SetImgIndex(g_WMainImages, 756);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleCloseInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleClose.SetImgIndex(g_WMainImages, 371);
{$IFEND}
end;
procedure TFrmDlg.DWKimNeedleInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DWKimNeedle.SetImgIndex(g_WMainImages, 751);
{$IFEND}
end;
{$ENDREGION}
{$REGION '珍珑宝箱'}
procedure TFrmDlg.DJLBoxBelt1Initialize(Sender: TObject);
begin
  DJLBoxBelt1.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt2Initialize(Sender: TObject);
begin
  DJLBoxBelt2.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt3Initialize(Sender: TObject);
begin
  DJLBoxBelt3.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt4Initialize(Sender: TObject);
begin
  DJLBoxBelt4.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt5Initialize(Sender: TObject);
begin
  DJLBoxBelt5.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt6Initialize(Sender: TObject);
begin
  DJLBoxBelt6.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt7Initialize(Sender: TObject);
begin
  DJLBoxBelt7.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt8Initialize(Sender: TObject);
begin
  DJLBoxBelt8.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLChangeItemInitialize(Sender: TObject);
begin
  DJLChangeItem.SetImgIndex(g_WMainImages, 663);
end;
procedure TFrmDlg.DJLStartItemInitialize(Sender: TObject);
begin
  DJLStartItem.SetImgIndex(g_WMainImages, 663);
end;
procedure TFrmDlg.DJenniferLongBoxCloseInitialize(Sender: TObject);
begin
  DJenniferLongBoxClose.SetImgIndex(g_WMain2Images, 212);
end;
procedure TFrmDlg.DWJenniferLongBoxInitialize(Sender: TObject);
begin
end;
{$ENDREGION}
{$REGION '鉴定'}
procedure TFrmDlg.DBSignedItemInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedItem.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedChangeItemInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedChangeItem.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedMemo.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedChangeMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedChangeMemo.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedBelt1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedBelt1.SetImgIndex(g_WUI1Images, 922);
{$IFEND}
end;
procedure TFrmDlg.DBSignedBelt2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedBelt2.SetImgIndex(g_WUI1Images, 924);
{$IFEND}
end;
procedure TFrmDlg.DBSignedChangeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedChange.SetImgIndex(g_WUI1Images, 885);
{$IFEND}
end;
procedure TFrmDlg.DBOrdSignedInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBOrdSigned.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBHighSignedInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBHighSigned.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBSignedItemsCloseInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedItemsClose.SetImgIndex(g_WMain2Images, 148);
{$IFEND}
end;
procedure TFrmDlg.DWSignedItemsInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWSignedItems.SetImgIndex(g_WUI1Images, 880);
{$IFEND}
end;
{$ENDREGION}
{$REGION '鉴定品评'}
procedure TFrmDlg.DBJudgeItemInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeItem.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeItemMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeItemMemo.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeBelt1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeBelt1.SetImgIndex(g_WUI1Images, 1344);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeStartInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeStart.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeItemsCloseInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeItemsClose.SetImgIndex(g_WMain2Images, 148);
{$IFEND}
end;
procedure TFrmDlg.DWJudgeItemsInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWJudgeItems.SetImgIndex(g_WUI1Images, 880);
{$IFEND}
end;
{$ENDREGION}
{$REGION '鉴定解读'}
procedure TFrmDlg.DBMakeSignedReadInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedRead.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedMakeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedMake.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedReadMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedReadMemo.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedMakeMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedMakeMemo.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedExp1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedExp1.SetImgIndex(g_WUI1Images, 894);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedExp2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedExp2.SetImgIndex(g_WUI1Images, 895);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedBelt1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedBelt1.SetImgIndex(g_WUI1Images, 923);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedBelt2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
   DBMakeSignedBelt2.SetImgIndex(g_WUI1Images, 925);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedBelt3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedBelt3.SetImgIndex(g_WUI1Images, 926);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedReadStartInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedReadStart.SetImgIndex(g_WUI1Images, 885);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve1.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve2.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve3.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve4.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedCloseInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedClose.SetImgIndex(g_WMain2Images, 148);
{$IFEND}
end;
procedure TFrmDlg.DWMakeSignedInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWMakeSigned.SetImgIndex(g_WUI1Images, 880);
{$IFEND}
end;
{$ENDREGION}
{$REGION '内挂'}
procedure TFrmDlg.DWNewSdoAssistantInitialize(Sender: TObject);
begin
  DWNewSdoAssistant.SetImgIndex(g_qingqingImages, 4);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;
procedure TFrmDlg.DNewSdoAssistantCloseInitialize(Sender: TObject);
begin
  DNewSdoAssistantClose.SetImgIndex(g_WMain2Images, 279);
end;
procedure TFrmDlg.DNewSdoBasicInitialize(Sender: TObject);
begin
  DNewSdoBasic.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNewSdoFilterItemInitialize(Sender: TObject);
begin
  DNewSdoFilterItem.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNewSdoProtectInitialize(Sender: TObject);
begin
  DNewSdoProtect.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DBNewSdoProtect1Initialize(Sender: TObject);
begin
  DBNewSdoProtect1.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DBNewSHNecklaceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx, nWhere, ax, ay: integer;
  d: TAsphyreLockableTexture;
  wm: TAspWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  nWhere := -1;
  if Sender = DBNewSHNecklace then nWhere := U_NECKLACE;
  if Sender = DBNewSHLight then nWhere := U_RIGHTHAND;
  if Sender = DBNewSHArmRingR then nWhere := U_ARMRINGR;
  if Sender = DBNewSHArmRingL then nWhere := U_ARMRINGL;
  if Sender = DBNewSHRingR then nWhere := U_RINGR;
  if Sender = DBNewSHRingL then nWhere := U_RINGL;
  if Sender = DBNewSHBujuk then nWhere := U_BUJUK;
  if Sender = DBNewSHBelt then nWhere := U_BELT;
  if Sender = DBNewSHBoots then nWhere := U_BOOTS;
  if Sender = DBNewSHCharm then nWhere := U_CHARM;
  if Sender = DBNewSHDrum then nWhere := U_Drum;

  if nWhere >= 0 then begin
    if g_HeroItems[nWhere].ClientItem.S.Name <> '' then begin
      idx := g_HeroItems[nWhere].ClientItem.S.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx);
        if d <> nil then begin
          with TAspDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                          SurfaceY(GTop + (GHeight - d.Height) div 2),
                          d.ClientRect, d, TRUE);
            if g_HeroItems[nWhere].ClientEffec.btShapeCount > 0 then begin
              with g_HeroItems[nWhere].ClientEffec do begin
                if GetTickCount - g_DrawHeroUseItems[nWhere].dwDrawTick >= 150 then begin
                  g_DrawHeroUseItems[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawHeroUseItems[nWhere].nIndex);
                  if g_DrawHeroUseItems[nWhere].nIndex > btShapeCount-1 then g_DrawHeroUseItems[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d.ClientRect, d)
                  end;
                end;
              end;
            end else begin
              if g_HeroItems[nWhere].ClientItem.S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(GLeft-21), SurfaceY(GTop-23), d.ClientRect, d)
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSHWeaponClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  where, n, sel: integer;
  flag: Boolean;
  msg: TDefaultMessage;
  MovItem: TMovingItem;
  msgWho: Byte; //2-主人 4-英雄
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  //修补火龙之心
  if g_boHeroItemMoving or g_boItemMoving then begin
    if Sender = DBNewSHBujuk then begin
      if (g_HeroItems[U_BUJUK].ClientItem.S.Shape = 9) and (g_HeroItems[U_BUJUK].ClientItem.S.StdMode = 25) and (g_HeroItems[U_BUJUK].ClientItem.S.Name <> '') then begin//20090205
        if g_boHeroItemMoving then begin
          if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
          if (g_MovingHeroItem.Item.ClientItem.S.Name = '') or (g_WaitingHeroUseItem.Item.ClientItem.S.Name <> '') then exit;
          MovItem := g_MovingHeroItem;
          msgWho := 4;
        end else if g_boItemMoving then begin
          if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
          if (g_MovingItem.Item.ClientItem.S.Name = '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
          MovItem := g_MovingItem;
          msgWho := 2;
        end;
        if MovItem.Item.ClientItem.S.Name <> '' then begin
          case MovItem.Item.ClientItem.S.StdMode of
            42: begin
              msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.ClientItem.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);//20071231
              FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.ClientItem.S.Name));//20071231
            end;
            15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.ClientItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
              if (MovItem.Item.ClientItem.S.Source = 127) and (MovItem.Item.ClientItem.S.Stock > 0) then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.ClientItem.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.ClientItem.S.Name));
              end;
            end;
            4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.ClientItem.Source = 127时认为是可以修复火龙之心，
              if (MovItem.Item.ClientItem.S.Source = 127) and (MovItem.Item.ClientItem.S.Reserved > 0) then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.ClientItem.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.ClientItem.S.Name));
              end;
            end;
          end;
          Exit;
        end;
      end;
    end
  end;
  if g_boHeroItemMoving then begin
    flag := FALSE;
    if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
    if (g_MovingHeroItem.Item.ClientItem.S.Name = '') or (g_WaitingHeroUseItem.Item.ClientItem.S.Name <> '') then exit;
    where := GetTakeOnPosition (g_MovingHeroItem.Item.ClientItem.S.StdMode);
    if g_MovingHeroItem.Index >= 0 then begin
      case where of
        U_DRESS: begin
          if Sender = DBNewSHDress then begin
            if (g_HeroSelf.m_btSex = 0) and (g_MovingHeroItem.Item.ClientItem.S.StdMode <> 10) then Exit;//男衣服
            if (g_HeroSelf.m_btSex = 1) and (g_MovingHeroItem.Item.ClientItem.S.StdMode <> 11) then Exit;//女衣服
            flag := TRUE;
          end;
        end;
        U_WEAPON: if Sender = DBNewSHWeapon then flag := TRUE;
        U_NECKLACE: if Sender = DBNewSHNecklace then flag := TRUE;
        U_RIGHTHAND: if Sender = DBNewSHLight then flag := TRUE; //勋章
        U_HELMET: if Sender = DBNewSHHelmet then flag := TRUE; //头盔
        U_ZHULI: if Sender = DBNewSHHelmet then flag := True;//斗笠
        U_RINGR, U_RINGL: begin
          if Sender = DBNewSHRingL then begin
            where := U_RINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSHRingR then begin
            where := U_RINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGR: begin  //迫骂
          if Sender = DBNewSHArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSHArmRingR then begin
            where := U_ARMRINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGL: begin  //25,  刀啊风,迫骂
          if Sender = DBNewSHArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BUJUK: begin
          if Sender = DBNewSHBujuk then begin
            where := U_BUJUK;
            flag := TRUE;
          end;
          if Sender = DBNewSHArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BELT: begin
          if Sender = DBNewSHBelt then begin
            where := U_BELT;
            flag := TRUE;
          end;
        end;
        U_BOOTS: begin
          if Sender = DBNewSHBoots then begin
            where := U_BOOTS;
            flag := TRUE;
          end;
        end;
        U_DRUM: begin
          if Sender = DBNewSHDrum then begin
            where := U_DRUM;
            flag := TRUE;
          end;
        end;
        U_CHARM: begin
          if Sender = DBNewSHCharm then begin
            where := U_CHARM;
            flag := TRUE;
          end;
        end;
      end;
      if Sender = DBNewSHCharm then begin
        if (g_HeroItems[U_CHARM].ClientItem.S.Shape = 5) and (g_HeroItems[U_CHARM].ClientItem.S.StdMode = 7) and (g_HeroItems[U_CHARM].ClientItem.S.Name <> '') then begin//20090205
          case g_MovingHeroItem.Item.ClientItem.S.StdMode of
            7: begin
              if g_MovingHeroItem.Item.ClientItem.S.Shape = 3 then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 2, 0, 0, frmMain.m_nSendMsgCount);//20071231
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));//20071231
                Exit;
              end;
            end;
          end;
        end;
      end;
         //end;
    end else begin
      n := -(g_MovingHeroItem.Index+1);
      if n in [0..14] then begin
        ItemClickSound (g_MovingHeroItem.Item.ClientItem.S);
        g_HeroItems[n] := g_MovingHeroItem.Item;
        g_MovingHeroItem.Item.ClientItem.S.Name := '';
        g_boHeroItemMoving := FALSE;
      end;
    end;
    if flag then begin
      ItemClickSound (g_MovingHeroItem.Item.ClientItem.S);
      g_WaitingHeroUseItem := g_MovingHeroItem;
      g_WaitingHeroUseItem.Index := where;
      FrmMain.SendTakeOnHeroItem (where, g_MovingHeroItem.Item.ClientItem.MakeIndex, g_MovingHeroItem.Item.ClientItem.S.Name);
      g_MovingHeroItem.Item.ClientItem.S.Name := '';
      g_boHeroItemMoving := FALSE;
    end;
    if (Sender = DBNewSHBujuk) and (g_MovingHeroItem.Item.ClientItem.S.StdMode=25) and (g_MovingHeroItem.Item.ClientItem.S.Shape=9) and (g_boHeroItemMoving = FALSE) then begin
      DBHeroSpleenImg.Visible:=TRUE;
    end;   //20080319
  end else begin
    if g_boItemMoving then Exit;
    if (g_MovingHeroItem.Item.ClientItem.S.Name <> '') or (g_WaitingHeroUseItem.Item.ClientItem.S.Name <> '') then exit;
    Sel := -1;
    if Sender = DBNewSHDress then Sel := U_DRESS;
    if Sender = DBNewSHWeapon then Sel := U_WEAPON;
    if Sender = DBNewSHHelmet then begin//斗笠
      if g_HeroItems[U_ZHULI].ClientItem.S.Name <> '' then
        Sel := U_ZHULI
      else Sel := U_HELMET;
    end;
    if Sender = DBNewSHNecklace then Sel := U_NECKLACE;
    if Sender = DBNewSHLight then Sel := U_RIGHTHAND;
    if Sender = DBNewSHRingL then Sel := U_RINGL;
    if Sender = DBNewSHRingR then Sel := U_RINGR;
    if Sender = DBNewSHArmRingL then Sel := U_ARMRINGL;
    if Sender = DBNewSHArmRingR then Sel := U_ARMRINGR;
    if Sender = DBNewSHBujuk then Sel := U_BUJUK;
    if Sender = DBNewSHBelt then Sel := U_BELT;  //
    if Sender = DBNewSHBoots then Sel := U_BOOTS;
    if Sender = DBNewSHCharm then Sel := U_CHARM;
    if Sender = DBNewSHDrum then Sel := U_DRUM;

    if Sel >= 0 then begin
      if g_HeroItems[Sel].ClientItem.S.Name <> '' then begin
        ItemClickSound (g_HeroItems[Sel].ClientItem.S);
        g_MovingHeroItem.Index := -(Sel+1);
        g_MovingHeroItem.Item := g_HeroItems[Sel];
        g_HeroItems[Sel].ClientItem.S.Name := '';
        g_boHeroItemMoving := TRUE;
      end;
    end;
    if (Sender = DBNewSHBujuk) and (g_HeroItems[U_BUJUK].ClientItem.S.Shape = 9) and (g_boHeroItemMoving) then begin
      DBHeroSpleenImg.Visible:=FALSE;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSHWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  nHintX,nHintY:Integer;
  Sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  Butt:TAspDButton;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  Sel := -1;
  Butt:=TAspDButton(Sender);
  if Sender = DBNewSHDress then Sel := U_DRESS;
  if Sender = DBNewSHWeapon then Sel := U_WEAPON;
  if Sender = DBNewSHHelmet then Sel := U_HELMET;
  if Sender = DBNewSHNecklace then Sel := U_NECKLACE;
  if Sender = DBNewSHLight then Sel := U_RIGHTHAND;
  if Sender = DBNewSHRingL then Sel := U_RINGL;
  if Sender = DBNewSHRingR then Sel := U_RINGR;
  if Sender = DBNewSHArmRingL then Sel := U_ARMRINGL;
  if Sender = DBNewSHArmRingR then Sel := U_ARMRINGR;
  if Sender = DBNewSHBujuk then Sel := U_BUJUK;
  if Sender = DBNewSHBelt then Sel := U_BELT;
  if Sender = DBNewSHBoots then Sel := U_BOOTS;
  if Sender = DBNewSHCharm then Sel := U_CHARM;
  if Sender = DBNewSHDrum then Sel := U_Drum;

  if Sel >= 0 then begin
    g_HeroMouseStateItem := g_HeroItems[Sel];
    if (g_HeroItems[Sel].ClientItem.S.Name <> '') or (g_HeroItems[U_ZHULI].ClientItem.S.Name <> '') then begin
      if (Sel = U_HELMET) and (g_HeroItems[U_ZHULI].ClientItem.S.Name <> '') then begin
        g_HeroMouseItem := g_HeroItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
        if iname <> '' then begin
          if g_HeroItems[U_ZHULI].ClientItem.Dura = 0 then hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(g_HeroItems[Sel].ClientItem.S.Name, 2);
      if DWNewStateHero.GLeft >= 350 then
        nHintX:=DWNewStateHero.SurfaceX(DWNewStateHero.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DWNewStateHero.SurfaceX(DWNewStateHero.GLeft)+DWNewStateHero.GWidth;
      nHintY:=DWNewStateHero.SurfaceY(DWNewStateHero.GTop) +50;
      g_HeroMouseItem := g_HeroItems[Sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
      if (iname <> '') or (Lines <> '') then begin
        if g_HeroItems[Sel].ClientItem.Dura = 0 then hcolor := 'red'
        else hcolor := '';
        with Butt as TAspDButton do begin
          {if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, Get TzStateInfo(TzHintInfo,2)]), False
                                      );
          end;}
          //修改套装显示 By TasNat at: 2012-04-06 11:02:26
          DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          if TzHintInfo <> nil then begin

              DScreen.ShowTzItemHint(
                                      Format('<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,2)])
                                      );
          end;
        end;
      end;
      g_HeroMouseItem.ClientItem.S.Name := '';
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStateWinClose then
    DWNewStateWin.Visible := False
  else if Sender = DBNewStateHeroClose then
    DWNewStateHero.Visible := False
  else DWNewStateUser.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not Downed then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBNewStateHeroNGPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateHeroNGPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateHeroNGPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateHeroNGPage.ActivePage := 1;
    NewNGUpLevelState(True);
{$IF M2Version = 1}
  end else
  if (ly >= 91) and (ly <= 130) then begin
    ChangeHeroNGPointPage();
    DBNewHeroPointPage2.Visible := g_HeroHumanPulseArr[0].boOpenPulse;
    DBNewHeroPointPage3.Visible := g_HeroHumanPulseArr[1].boOpenPulse;
    DBNewHeroPointPage4.Visible := g_HeroHumanPulseArr[2].boOpenPulse;
    DPNewStateHeroNGPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateHeroNGPage.ActivePage := 3;
{$IFEND}
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroNGPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateHeroNGPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateHeroNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateHeroNGPage.ActivePage = 0 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $4AA6EF, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $4AA6EF, clBlack, '态', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $639ABD, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $639ABD, clBlack, '态', [fsBold]);
    end;
    if DPNewStateHeroNGPage.ActivePage = 1 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $4AA6EF, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $4AA6EF, clBlack, '能', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $639ABD, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $639ABD, clBlack, '能', [fsBold]);
    end;
    {$IF M2Version = 1}
    if DPNewStateHeroNGPage.ActivePage = 2 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $4AA6EF, clBlack, '经', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $4AA6EF, clBlack, '络', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $639ABD, clBlack, '经', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $639ABD, clBlack, '络', [fsBold]);
    end;
    if DPNewStateHeroNGPage.ActivePage = 3 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $4AA6EF, clBlack, '连', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $4AA6EF, clBlack, '击', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $639ABD, clBlack, '连', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $639ABD, clBlack, '击', [fsBold]);
    end;
    {$IFEND}
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroNGPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  {$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2240);
  {$ELSE}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2312);
  {$IFEND}
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateHeroPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateHeroPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateHeroPage.ActivePage := 1;
  end else
  if (ly >= 91) and (ly <= 130) then begin
    DPNewStateHeroPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateHeroPage.ActivePage := 3;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateHeroPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateHeroPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateHeroPage.ActivePage = 0 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '装', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '备', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '装', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '备', [fsBold]);
    end;
    if DPNewStateHeroPage.ActivePage = 1 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '态', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '态', [fsBold]);
    end;
    if DPNewStateHeroPage.ActivePage = 2 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $00A8D4E8, clBlack, '属', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $00A8D4E8, clBlack, '性', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $00708CA0, clBlack, '属', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $00708CA0, clBlack, '性', [fsBold]);
    end;
    if DPNewStateHeroPage.ActivePage = 3 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $00A8D4E8, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $00A8D4E8, clBlack, '能', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $00708CA0, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $00708CA0, clBlack, '能', [fsBold]);
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBNewStateHeroPage.SetImgIndex(g_WUI1Images, 2240);
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroTab1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if (Sender = DBNewStateTab1) or (Sender = DBNewStateTab2) or (Sender = DBNewStateTab3) then
    DPNewStateWinTab.ActivePage := TAspDButton(Sender).Tag
  else DPNewStateHeroTab.ActivePage := TAspDButton(Sender).Tag
{$IFEND}
end;

procedure TFrmDlg.DBNewStateTab1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if (Sender = DBNewStateTab1) or (Sender = DBNewStateTab2) or (Sender = DBNewStateTab3) then
    DPNewStateWinTab.ActivePage := TAspDButton(Sender).Tag
  else DPNewStateHeroTab.ActivePage := TAspDButton(Sender).Tag
{$IFEND}
end;

procedure TFrmDlg.DBNewStateUserPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateUserPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateUserPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateUserPage.ActivePage := 1;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateUserPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateUserPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateUserPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateUserPage.ActivePage = 0 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '装');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '备');
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '装');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '备');
    end;
    if DPNewStateUserPage.ActivePage = 1 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '称');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '号');
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '称');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '号');
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateUserPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBNewStateUserPage.SetImgIndex(g_WUI1Images, 2312);
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStateWinClose then
    DWNewStateWin.Visible := False
  else if Sender = DBNewStateHeroClose then
    DWNewStateHero.Visible := False
  else DWNewStateUser.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do
  begin
    if WLib <> nil then begin //20080701
      if not Downed then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBNewStateWinNGPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateWinNGPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateWinNGPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateWinNGPage.ActivePage := 1;
    NewNGUpLevelState(False);
{$IF M2Version = 1}
  end else
  if (ly >= 91) and (ly <= 130) then begin
    ChangeNGPointPage();
    DBNewWinPointPage2.Visible := g_HumanPulseArr[0].boOpenPulse;
    DBNewWinPointPage3.Visible := g_HumanPulseArr[1].boOpenPulse;
    DBNewWinPointPage4.Visible := g_HumanPulseArr[2].boOpenPulse;
    DPNewStateWinNGPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateWinNGPage.ActivePage := 3;
{$IFEND}
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinNGPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateWinNGPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateWinNGPage.ActivePage = 0 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $4AA6EF, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $4AA6EF, clBlack, '态', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $639ABD, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $639ABD, clBlack, '态', [fsBold]);
    end;
    if DPNewStateWinNGPage.ActivePage = 1 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $4AA6EF, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $4AA6EF, clBlack, '能', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $639ABD, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $639ABD, clBlack, '能', [fsBold]);
    end;
    {$IF M2Version = 1}
    if DPNewStateWinNGPage.ActivePage = 2 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $4AA6EF, clBlack, '经', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $4AA6EF, clBlack, '络', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $639ABD, clBlack, '经', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $639ABD, clBlack, '络', [fsBold]);
    end;
    if DPNewStateWinNGPage.ActivePage = 3 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $4AA6EF, clBlack, '连', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $4AA6EF, clBlack, '击', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $639ABD, clBlack, '连', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $639ABD, clBlack, '击', [fsBold]);
    end;
    {$IFEND}
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinNGPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  {$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2240);
  {$ELSE}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2312);
  {$IFEND}
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateWinPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateWinPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateWinPage.ActivePage := 1;
  end else
  if (ly >= 91) and (ly <= 130) then begin
    DPNewStateWinPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateWinPage.ActivePage := 3;
  end else
  if (ly >= 171) and (ly <= 210) then begin
    DPNewStateWinPage.ActivePage := 4;
  end else
  if (ly >= 211) and (ly <= 250) then begin
    DPNewStateWinPage.ActivePage := 5;
    DCheckNewDeputyHeroWarr.Checked := False;
    DCheckNewDeputyHeroWiz.Checked := False;
    DCheckNewDeputyHeroTaos.Checked := False;
    case m_btDeputyHeroJob of
      0: DCheckNewDeputyHeroWarr.Checked := True;
      1: DCheckNewDeputyHeroWiz.Checked := True;
      2: DCheckNewDeputyHeroTaos.Checked := True;
      else DCheckNewDeputyHeroWarr.Checked := True;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateWinPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateWinPage.ActivePage = 0 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '装', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '备', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '装', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '备', [fsBold]);
    end;
    if DPNewStateWinPage.ActivePage = 1 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '态', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '状', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '态', [fsBold]);
    end;
    if DPNewStateWinPage.ActivePage = 2 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $00A8D4E8, clBlack, '属', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $00A8D4E8, clBlack, '性', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $00708CA0, clBlack, '属', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $00708CA0, clBlack, '性', [fsBold]);
    end;
    if DPNewStateWinPage.ActivePage = 3 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $00A8D4E8, clBlack, '称', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $00A8D4E8, clBlack, '号', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $00708CA0, clBlack, '称', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $00708CA0, clBlack, '号', [fsBold]);
    end;
    if DPNewStateWinPage.ActivePage = 4 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+170, $00A8D4E8, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+183, $00A8D4E8, clBlack, '能', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+170, $00708CA0, clBlack, '技', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+183, $00708CA0, clBlack, '能', [fsBold]);
    end;
    if DPNewStateWinPage.ActivePage = 5 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+210, $00A8D4E8, clBlack, '出', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+223, $00A8D4E8, clBlack, '战', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+210, $00708CA0, clBlack, '出', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+223, $00708CA0, clBlack, '战', [fsBold]);
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBNewStateWinPage.SetImgIndex(g_WUI1Images, 2190);
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinXFPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateWinXFPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateWinXFPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateWinXFPage.ActivePage := 1;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinXFPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateWinXFPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinXFPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateWinXFPage.ActivePage = 0 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '心', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '法', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '心', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '法', [fsBold]);
    end;
    if DPNewStateWinXFPage.ActivePage = 1 then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '神', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '技', [fsBold]);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '神', [fsBold]);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '技', [fsBold]);
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinXFPageInitialize(Sender: TObject);
begin
  DBNewStateWinXFPage.SetImgIndex(g_WUI1Images, 2312);
end;

procedure TFrmDlg.DBNewStMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  i, idx: integer;
  selkey: word;
  keych: char;
  pm: PTClientMagic;
  icon :Integer;
  boChange: Boolean;
{$IFEND}
begin
{$IF M2Version <> 2}
  idx := _Max(TAspDButton(Sender).Tag + MagicPage * 5, 0);
  if (idx >= 0) and (idx < g_MagicList.Count) then begin
    pm := PTClientMagic (g_MagicList[idx]);
    selkey := word(pm.Key);
    GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
    if pm.Def.wMagicId <> 100 then begin //神秘解读
      SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey);
      keych := char(selkey);
      boChange := False;
      if g_MagicList.Count > 0 then //20080629
      for i:=0 to g_MagicList.Count-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if pm.Key = keych then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
           boChange := True;
        end;
      end;
      if not boChange then begin
        for i:=0 to g_XinFaMagic.Count-1 do begin
          pm := PTClientMagic (g_XinFaMagic[i]);
          if pm.Key = keych then begin
             pm.Key := #0;
             FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          end;
        end;
      end;
      pm := PTClientMagic (g_MagicList[idx]);
      pm.Key := keych;
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
    end else begin
      SetSkillMemoDlg(pm.Def.wMagicId, pm.Level, pm.Def.btEffect, pm.Def.sMagicName, '神秘解读');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
  wm: TAspWMImages;
  sKeyName: string;
  btKeyLeft: Byte;
  boPieceExp: Boolean;
const
  Num: array[0..9] of string[2] = ('零','一','二','三','四','五','六','七','八','九');
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    pm := nil;
    Idx := _Max(Tag + MagicPage * 5, 0);
    if Idx < g_MagicList.Count then begin
      pm := PTClientMagic (g_MagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
          end;
        end;
        sKeyName := '';
        case byte(pm.Key) of
          byte('1'): begin
            sKeyName := 'F1';
            btKeyLeft:= 15;
          end;
          byte('2'): begin
            sKeyName := 'F2';
            btKeyLeft:= 15;
          end;
          byte('3'): begin
            sKeyName := 'F3';
            btKeyLeft:= 15;
          end;
          byte('4'): begin
            sKeyName := 'F4';
            btKeyLeft:= 15;
          end;
          byte('5'): begin
            sKeyName := 'F5';
            btKeyLeft:= 15;
          end;
          byte('6'): begin
            sKeyName := 'F6';
            btKeyLeft:= 15;
          end;
          byte('7'): begin
            sKeyName := 'F7';
            btKeyLeft:= 15;
          end;
          byte('8'): begin
            sKeyName := 'F8';
            btKeyLeft:= 15;
          end;
          byte('E'): begin
            sKeyName := 'C+F1';
            btKeyLeft:= 5;
          end;
          byte('F'): begin
            sKeyName := 'C+F2';
            btKeyLeft:= 5;
          end;
          byte('G'): begin
            sKeyName := 'C+F3';
            btKeyLeft:= 5;
          end;
          byte('H'): begin
            sKeyName := 'C+F4';
            btKeyLeft:= 5;
          end;
          byte('I'): begin
            sKeyName := 'C+F5';
            btKeyLeft:= 5;
          end;
          byte('J'): begin
            sKeyName := 'C+F6';
            btKeyLeft:= 5;
          end;
          byte('K'): begin
            sKeyName := 'C+F7';
            btKeyLeft:= 5;
          end;
          byte('L'): begin
            sKeyName := 'C+F8';
            btKeyLeft:= 5;
          end;
        end;
        if sKeyName <> '' then
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+btKeyLeft, SurfaceY(GTop)+20, $00FF00,clBlack, sKeyName);
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, clSilver, clBlack, pm.Def.sMagicName);

        if not (pm.btLevelEx in [1..9]) then begin
          boPieceExp := pm.Def.wMagicId in [68, 71]; //显示经验条
          d := g_WMainImages.Images[112]; //lv
          if d <> nil then begin
            if boPieceExp then
              dsurface.Draw (SurfaceX(GLeft)+94, SurfaceY(GTop)-1, d.ClientRect, d, TRUE)
            else dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
          end;
          if not boPieceExp then begin
            d := g_WMainImages.Images[111]; //exp
            if d <> nil then begin
              dsurface.Draw(SurfaceX(GLeft)+71, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
            end;
          end;
          case pm.Def.wMagicId of
            68: begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+108, SurfaceY(GTop)-2, clSilver, clBlack, IntToStr(pm.Level));
              DBNewJQExp.GLeft := GLeft+37;
              DBNewJQExp.GTop := GTop+22;
              if not DBNewJQExp.Visible then DBNewJQExp.Visible := True;
            end;
            71: begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+108, SurfaceY(GTop)-2, clSilver, clBlack, IntToStr(pm.Level));
              DBNewHBExp.GLeft := GLeft+37;
              DBNewHBExp.GTop := GTop+22;
              if not DBNewHBExp.Visible then DBNewHBExp.Visible := True;
            end;
            95: begin//斗转星移
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
            end;
            100: begin//神秘解毒
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Level = 15 then
                AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-')
              else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]));
              DBNewJDSee.GLeft := GLeft+171;
              DBNewJDSee.GTop := GTop-1;
              if not DBNewJDSee.Visible then DBNewJDSee.Visible := True;
            end;
            103: begin//召唤巨魔
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
            end;
            104: begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Level = 100 then
                AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-')
              else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]));
            end;
            else begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              if not (pm.Level in [0..4]) then pm.Level := 0;
              if pm.Level < 3 then
                AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
              else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
            end;
          end;
        end else begin //强化技能
          if (pm.Def.wMagicId = 71) and DBNewHBExp.Visible then DBNewHBExp.Visible := False;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)+15, clSilver, clBlack, '强化'+Num[pm.btLevelEx]+'重');
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    pm := nil;
    idx := _Max(Tag + MagicPage * 5, 0);
    if idx < g_MagicList.Count then begin
      pm := PTClientMagic (g_MagicList[idx]);
      if pm <> nil then begin
        DScreen.ShowTzHint (SurfaceX(GLeft)+18,
                      SurfaceY(GTop)+31,
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y\(点击技能按钮设置快捷键)', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  Idx: Integer;
  pm: PTClientMagic;
  keych: Char;
{$IFEND}
begin
{$IF M2Version <> 2}
  Idx := _Max(TAspDButton(Sender).Tag + InternalForceMagicPage * 5, 0);
  if (Idx >= 0) and (Idx < g_InternalForceMagicList.Count) then begin
    pm := PTClientMagic (g_InternalForceMagicList[Idx]);
    if Word(pm.Key) = 0 then
      keych := Char(Word(1))
    else keych := Char(Word(0));
    pm.Key := keych;
    FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);

{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
  wm: TAspWMImages;
  Color: TColor;
{$IFEND}

begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    pm := nil;
    Idx := _Max(Tag + InternalForceMagicPage * 5, 0);
    if Idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx,Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
            if d <> nil then begin
              if word(pm.Key) <> 0 then begin
                {g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                DrawEffect(0, 0, g_ImgMixSurface, d, {ceGrayScale}{ceBlack);}
                dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True,124);
                //dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True); }
              end;
            end;
          end;
        end;
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        d := g_WMainImages.Images[111]; //exp
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
        if Word(pm.Key) = 0 then begin
          Color := clSilver;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName);
        end else begin
          Color := clGray;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName+'[关]');
        end;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+52, SurfaceY(GTop)+15, Color, clBlack, IntToStr(pm.Level));
        if pm.Level < 3 then
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
        else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    pm := nil;
    idx := _Max(Tag + InternalForceMagicPage * 5, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then begin
        if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
        else
          DScreen.ShowTzHint (SurfaceX(GLeft)-120, SurfaceY(GTop),
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStNGPageUp then begin
    if InternalForceMagicPage > 0 then begin
      Dec (InternalForceMagicPage);
      NewNGUpLevelState(False);
    end;
  end else begin
    if InternalForceMagicPage < (g_InternalForceMagicList.Count+4) div 5 - 1 then begin
      Inc (InternalForceMagicPage);
      NewNGUpLevelState(False);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStPageDownInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2203);
{$IFEND}
end;

procedure TFrmDlg.DBNewStPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStPageUp then begin
    if MagicPage > 0 then begin
      NewMagicBtnNotVisible;
      Dec (MagicPage);
    end;
  end else begin
    if MagicPage < (g_MagicList.Count+4) div 5 - 1 then begin
      NewMagicBtnNotVisible;
      Inc (MagicPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStPageUpInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 2200);
{$IFEND}
end;

procedure TFrmDlg.DBNewSUNecklaceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx, nWhere, ax, ay: integer;
  d: TAsphyreLockableTexture;
  wm: TAspWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  nWhere := -1;
  if Sender = DBNewSUNecklace then nWhere := U_NECKLACE;
  if Sender = DBNewSULight then nWhere := U_RIGHTHAND;
  if Sender = DBNewSUArmRingR then nWhere := U_ARMRINGR;
  if Sender = DBNewSUArmRingL then nWhere := U_ARMRINGL;
  if Sender = DBNewSURingR then nWhere := U_RINGR;
  if Sender = DBNewSURingL then nWhere := U_RINGL;
  if Sender = DBNewSUBujuk then nWhere := U_BUJUK;
  if Sender = DBNewSUBelt then nWhere := U_BELT;
  if Sender = DBNewSUBoots then nWhere := U_BOOTS;
  if Sender = DBNewSUCharm then nWhere := U_CHARM;
  if Sender = DBNewSUDrum then nWhere := U_Drum;

  if nWhere >= 0 then begin
    if UserState1.UseItems[nWhere].ClientItem.S.Name <> '' then begin
      idx := UserState1.UseItems[nWhere].ClientItem.S.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx);
        if d <> nil then begin
          with TAspDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft) + (GWidth - d.Width) div 2 + 2,
                          SurfaceY(GTop) + (GHeight - d.Height) div 2 + 1,
                          d.ClientRect, d, TRUE);
            if UserState1.UseItems[nWhere].ClientEffec.btShapeCount > 0 then begin
              with UserState1.UseItems[nWhere].ClientEffec do begin
                if GetTickCount - g_DrawUseItems1[nWhere].dwDrawTick >= 150 then begin
                  g_DrawUseItems1[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems1[nWhere].nIndex);
                  if g_DrawUseItems1[nWhere].nIndex > btShapeCount-1 then g_DrawUseItems1[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d.ClientRect, d);
                  end;
                end;
              end;
            end else begin
              if UserState1.UseItems[nWhere].ClientItem.S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(GLeft-21), SurfaceY(GTop-23), d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSUWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  sel := -1;
  Lines := '';
  if Sender = DBNewSUDress then sel := U_DRESS;
  if Sender = DBNewSUWeapon then sel := U_WEAPON;
  if Sender = DBNewSUHelmet then sel := U_HELMET;
  if Sender = DBNewSUNecklace then sel := U_NECKLACE;
  if Sender = DBNewSULight then sel := U_RIGHTHAND;
  if Sender = DBNewSURingL then sel := U_RINGL;
  if Sender = DBNewSURingR then sel := U_RINGR;
  if Sender = DBNewSUArmRingL then sel := U_ARMRINGL;
  if Sender = DBNewSUArmRingR then sel := U_ARMRINGR;

  if Sender = DBNewSUBujuk then sel := U_BUJUK;
  if Sender = DBNewSUBelt then sel := U_BELT;
  if Sender = DBNewSUBoots then sel := U_BOOTS;
  if Sender = DBNewSUCharm then sel := U_CHARM;
  if Sender = DBNewSUDrum then sel := U_DRUM;

  if sel >= 0 then begin
    g_MouseUserStateItem := UserState1.UseItems[sel];
    if (UserState1.UseItems[sel].ClientItem.S.Name <> '') or (UserState1.UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
      if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
        g_MouseItem := UserState1.UseItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1);
        if iname <> '' then begin
          if UserState1.UseItems[U_ZHULI].ClientItem.Dura = 0 then
            hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(UserState1.UseItems[sel].ClientItem.S.Name, 3);
      if DWNewStateUser.GLeft >= 350 then
        nHintX:=DWNewStateUser.SurfaceX(DWNewStateUser.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DWNewStateUser.SurfaceX(DWNewStateUser.GLeft)+DWNewStateUser.GWidth;
      nHintY:=DWNewStateUser.SurfaceY(DWNewStateUser.GTop) +50;
      g_MouseItem := UserState1.UseItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
      if (iname <> '') or (Lines <> '') then begin
        if UserState1.UseItems[sel].ClientItem.Dura = 0 then
          hcolor := 'Red'
        else hcolor := '';
        with Sender as TAspDButton do begin
          {if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, Get TzStateInfo(TzHintInfo,3)]), False
                                      );
          end;}
          //修改套装显示 By TasNat at: 2012-04-06 11:02:26
          DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          if TzHintInfo <> nil then begin

              DScreen.ShowTzItemHint(
                                      Format('<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,3)])
                                      );
          end;
        end;
      end;
      g_MouseItem.ClientItem.S.Name := '';
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSWBujukDblClick(Sender: TObject);
var
  msg: TDefaultMessage;
begin
  //存放罐物品的扩展   20080315
  if (g_UseItems[U_BUJUK].ClientItem.S.StdMode = 2) and (g_UseItems[U_BUJUK].ClientItem.S.AniCount = 21) then begin
    if Sender = DBNewSWBujuk then begin
      if g_UseItems[U_BUJUK].ClientItem.Dura < g_UseItems[U_BUJUK].ClientItem.DuraMax then begin
         msg := MakeDefaultMsg (aa(CM_DBLREPAIRDRAGON, frmMain.TempCertification),0, 0, 0, 0, frmMain.m_nSendMsgCount);//20071231
         FrmMain.SendSocket (EncodeMessage (msg));//20071231
       end;
    end;
  end;
end;

procedure TFrmDlg.DBNewSWNecklaceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx, nWhere, EffIdx: Integer;
  d: TAsphyreLockableTexture;
  wm: TAspWMImages;
  ax, ay: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  nWhere := -1;
  if Sender = DBNewSWNecklace then nWhere := U_NECKLACE;
  if Sender = DBNewSWLight then nWhere := U_RIGHTHAND;
  if Sender = DBNewSWArmRingR then nWhere := U_ARMRINGR;
  if Sender = DBNewSWArmRingL then nWhere := U_ARMRINGL;
  if Sender = DBNewSWRingR then nWhere := U_RINGR;
  if Sender = DBNewSWRingL then nWhere := U_RINGL;
  if Sender = DBNewSWBujuk then nWhere := U_BUJUK;
  if Sender = DBNewSWBelt then nWhere := U_BELT;
  if Sender = DBNewSWBoots then nWhere := U_BOOTS;
  if Sender = DBNewSWCharm then nWhere := U_CHARM;
  if Sender = DBNewSWDRUM then nWhere := U_DRUM;

  if nWhere >= 0 then begin
    if g_UseItems[nWhere].ClientItem.S.Name <> '' then begin
      idx := g_UseItems[nWhere].ClientItem.S.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx);
        if d <> nil then begin
          with TAspDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft) + (GWidth - d.Width) div 2 + 2,
                          SurfaceY(GTop) + (GHeight - d.Height) div 2 + 1,
                          d.ClientRect, d, TRUE);
            if g_UseItems[nWhere].ClientEffec.btShapeCount > 0 then begin
              with g_UseItems[nWhere].ClientEffec do begin
                if GetTickCount - g_DrawUseItems[nWhere].dwDrawTick >= 150 then begin
                  g_DrawUseItems[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems[nWhere].nIndex);
                  if g_DrawUseItems[nWhere].nIndex > btShapeCount-1 then g_DrawUseItems[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d.ClientRect, d);
                  end;
                end;
              end;
            end else begin
              if g_UseItems[nWhere].ClientItem.S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(GLeft-21), SurfaceY(GTop-23), d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSWWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: integer;
  flag: Boolean;
  msg: TDefaultMessage;
begin
  if g_MySelf = nil then exit;
  if g_boItemMoving (*or g_boRightItem{右键点物品}*) then begin
    flag := FALSE;
    if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.ClientItem.S.Name = '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
    where := GetTakeOnPosition (g_MovingItem.Item.ClientItem.S.StdMode);
    if g_MovingItem.Index >= 0 then begin
      //存放罐物品的扩展   20080315
      if ((g_UseItems[U_BUJUK].ClientItem.S.StdMode = 2) and (g_UseItems[U_BUJUK].ClientItem.S.AniCount = 21) and (Byte(g_UseItems[U_BUJUK].ClientItem.S.Source) = g_MovingItem.Item.ClientItem.S.Shape) and (g_UseItems[U_BUJUK].ClientItem.S.Shape = g_MovingItem.Item.ClientItem.S.StdMode)) and (not (g_MovingItem.Item.ClientItem.S.StdMode in [5,6,10,11])) then begin
        if Sender = DBNewSWBujuk then begin
          g_WaitingUseItem := g_MovingItem;
          g_MovingItem.Item.ClientItem.S.Name := '';
          g_boItemMoving := False;
          msg := MakeDefaultMsg (aa(CM_REPAIRDRAGON, frmMain.TempCertification),g_WaitingUseItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
          FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.ClientItem.S.Name));//20071231
          //Exit;
        end;
      end;
      //火云石修复
      if (g_UseItems[U_BUJUK].ClientItem.S.StdMode = 25) and (g_UseItems[U_BUJUK].ClientItem.S.Shape = 10) and (g_MovingItem.Item.ClientItem.S.StdMode = 43) and (g_MovingItem.Item.ClientItem.S.Shape = 1) then begin
        if Sender = DBNewSWBujuk then begin
          g_WaitingUseItem := g_MovingItem;
          g_MovingItem.Item.ClientItem.S.Name := '';
          g_boItemMoving := False;
          msg := MakeDefaultMsg (aa(CM_REPAIRFINEITEM, frmMain.TempCertification),g_WaitingUseItem.Item.ClientItem.MakeIndex, 0, 0, 0, frmMain.m_nSendMsgCount);//20080507
          FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.ClientItem.S.Name));//20080507
        end;
      end;
      case where of
        U_DRESS: begin//衣服
          if Sender = DBNewSWDress then begin
            if g_MySelf.m_btSex = 0 then //男的
              if g_MovingItem.Item.ClientItem.S.StdMode <> 10 then //10男式衣服
                Exit;
            if g_MySelf.m_btSex = 1 then //女的
              if g_MovingItem.Item.ClientItem.S.StdMode <> 11 then //11男式衣服
                Exit;
            flag := TRUE;
          end;
        end;
        U_WEAPON: begin//武器
          if Sender = DBNewSWWEAPON then flag := TRUE;
        end;
        U_NECKLACE: begin//项链
          if Sender = DBNewSWNecklace then flag := TRUE;
        end;
        U_RIGHTHAND: begin //蜡烛、火把、圣牌、勋章之类的
          if Sender = DBNewSWLight then flag := TRUE;
        end;
        U_HELMET: begin//头盔
          if Sender = DBNewSWHelmet then flag := TRUE;
        end;
        U_ZHULI: begin//斗笠
          if Sender = DBNewSWHelmet then flag := True;
        end;
        U_RINGR, U_RINGL: begin//戒指（左右都可以）
          if Sender = DBNewSWRingL then begin
            where := U_RINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSWRingR then begin
            where := U_RINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGR: begin//手镯、手套(左右都可以)
          if Sender = DBNewSWArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSWArmRingR then begin
            where := U_ARMRINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGL: begin//护身符、药粉之类的
          if Sender = DBNewSWArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BUJUK: begin //护身符、药粉之类的
          if Sender = DBNewSWBujuk then begin
            case g_MovingItem.Item.ClientItem.S.StdMode of
              2: begin //祝福罐，魔令包
                if (g_MovingItem.Item.ClientItem.S.StdMode = 2) and (g_MovingItem.Item.ClientItem.S.AniCount = 21) then begin
                  where := U_BUJUK;
                  flag := TRUE;
                end;
              end;
              25: begin //符
                where := U_BUJUK;
                flag := TRUE;
              end;
            end;
          end;
          if Sender = DBNewSWArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BELT: begin//腰带
          if Sender = DBNewSWBelt then begin
            where := U_BELT;
            flag := TRUE;
          end;
        end;
        U_BOOTS: begin//鞋子
          if Sender = DBNewSWBoots then begin
            where := U_BOOTS;
            flag := TRUE;
          end;
        end;
        U_Drum: begin//鞋子
          if Sender = DBNewSWDrum then begin
            where := U_Drum;
            flag := TRUE;
          end;
        end;
        U_CHARM: begin//宝石
          if Sender = DBNewSWCharm then begin
            where := U_CHARM;
            flag := TRUE;
          end;
        end;
      end;
      if Sender = DBNewSWCharm then begin
        if (g_UseItems[U_CHARM].ClientItem.S.Shape = 5) and (g_UseItems[U_CHARM].ClientItem.S.StdMode = 7) and (g_UseItems[U_CHARM].ClientItem.S.Name <> '') then begin//20090205
          case g_MovingItem.Item.ClientItem.S.StdMode of
            7: begin
              if g_MovingItem.Item.ClientItem.S.Shape = 3 then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingItem.Item.ClientItem.MakeIndex, 1, 0, 0, frmMain.m_nSendMsgCount);//20071231
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingItem.Item.ClientItem.S.Name));//20071231
                Exit;
              end;
            end;
          end;
        end;
      end;
    end else begin
      n := -(g_MovingItem.Index+1);
      if n in [0..14] then begin
        ItemClickSound (g_MovingItem.Item.ClientItem.S);
        g_UseItems[n] := g_MovingItem.Item;
        g_MovingItem.Item.ClientItem.S.Name := '';
        g_boItemMoving := FALSE;
      end;
    end;
    if flag then begin
      ItemClickSound (g_MovingItem.Item.ClientItem.S);
      g_WaitingUseItem := g_MovingItem;
      g_WaitingUseItem.Index := where;
      FrmMain.SendTakeOnItem (where, g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
      g_MovingItem.Item.ClientItem.S.Name := '';
      g_boItemMoving := FALSE;
    end;
  end else begin
    if g_boHeroItemMoving then Exit;
    if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
    sel := -1;
    if Sender = DBNewSWDress then sel := U_DRESS;
    if Sender = DBNewSWWeapon then sel := U_WEAPON;
    if Sender = DBNewSWHelmet then begin //斗笠
      if g_UseItems[U_ZHULI].ClientItem.S.Name <> '' then
         sel := U_ZHULI
      else sel := U_HELMET;
    end;
    if Sender = DBNewSWNecklace then sel := U_NECKLACE;
    if Sender = DBNewSWLight then sel := U_RIGHTHAND;
    if Sender = DBNewSWRingL then sel := U_RINGL;
    if Sender = DBNewSWRingR then sel := U_RINGR;
    if Sender = DBNewSWArmRingL then sel := U_ARMRINGL;
    if Sender = DBNewSWArmRingR then sel := U_ARMRINGR;
    if Sender = DBNewSWBujuk then sel := U_BUJUK;
    if Sender = DBNewSWBelt then sel := U_BELT;  //
    if Sender = DBNewSWBoots then sel := U_BOOTS;
    if Sender = DBNewSWCharm then sel := U_CHARM;
    if Sender = DBNewSWDrum then sel := U_DRUM;

    if sel >= 0 then begin
      if g_UseItems[sel].ClientItem.S.Name <> '' then begin
        ItemClickSound (g_UseItems[sel].ClientItem.S);
        g_MovingItem.Index := -(sel+1);
        g_MovingItem.Item := g_UseItems[sel];
        g_UseItems[sel].ClientItem.S.Name := '';
        g_boItemMoving := TRUE;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBNewSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  sel := -1;
  Lines := '';
  if Sender = DBNewSWDress then sel := U_DRESS;
  if Sender = DBNewSWWeapon then sel := U_WEAPON;
  if Sender = DBNewSWHelmet then sel := U_HELMET;
  if Sender = DBNewSWNecklace then sel := U_NECKLACE;
  if Sender = DBNewSWLight then sel := U_RIGHTHAND;
  if Sender = DBNewSWRingL then sel := U_RINGL;
  if Sender = DBNewSWRingR then sel := U_RINGR;
  if Sender = DBNewSWArmRingL then sel := U_ARMRINGL;
  if Sender = DBNewSWArmRingR then sel := U_ARMRINGR;

  if Sender = DBNewSWBujuk then sel := U_BUJUK;
  if Sender = DBNewSWBelt then sel := U_BELT;
  if Sender = DBNewSWBoots then sel := U_BOOTS;
  if Sender = DBNewSWCharm then sel := U_CHARM;
  if Sender = DBNewSWDRUM then sel := U_DRUM;

  if sel >= 0 then begin
    g_MouseStateItem := g_UseItems[sel];
    if (g_UseItems[sel].ClientItem.S.Name <> '') or (g_UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
      if (sel = U_HELMET) and (g_UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
        g_MouseItem := g_UseItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
        if iname <> '' then begin
          if g_UseItems[U_ZHULI].ClientItem.Dura = 0 then
            hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(g_UseItems[sel].ClientItem.S.Name, 1);
      if DWNewStateWin.GLeft >= 350 then
        nHintX:=DWNewStateWin.SurfaceX(DWNewStateWin.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DWNewStateWin.SurfaceX(DWNewStateWin.GLeft)+DWNewStateWin.GWidth;
      nHintY:=DWNewStateWin.SurfaceY(DWNewStateWin.GTop) +50;
      g_MouseItem := g_UseItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
      if (iname <> '') or (Lines <> '') then begin
        if g_UseItems[sel].ClientItem.Dura = 0 then
          hcolor := 'Red'
        else hcolor := '';
        with Sender as TAspDButton do begin
          {if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, Get TzStateInfo(TzHintInfo,1)]), False
                                      );
          end;}
          //修改套装显示 By TasNat at: 2012-04-06 11:02:26
          DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          if TzHintInfo <> nil then begin

              DScreen.ShowTzItemHint(
                                      Format('<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,1)])
                                      );
          end;
        end;
      end;
      g_MouseItem.ClientItem.S.Name := '';
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitle1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then Exit;
    idx := _Max(Tag + m_btTitlePage * 5, 0);
    if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('你确定要将'+g_ClientHumTitles.ClientHumTitles[idx].sTitleName+'设置为当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[idx].MakeIndex, 1);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewTitle1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      idx := _Max(Tag + m_btTitlePage * 5, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if g_ClientHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                {g_ImgMixSurface.SetSize(d.Width, d.Height);  // 要调整
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale); }
                dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect,d,True,124);
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                //dsurface.Draw(d,SurfaceX(GLeft), SurfaceY(GTop), 12,deBrightX);
                dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect,d,True,180);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
          AspTextureFont.TextOut(SurfaceX(GLeft) + 34, SurfaceY(GTop) + 15, $008200, g_ClientHumTitles.ClientHumTitles[idx].sTitleName);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitle1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
    SetImgIndex(g_WUI1Images, 675);
{$IFEND}
end;

procedure TFrmDlg.DBNewTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    if Sender = DBNewTitleMan then begin
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1], g_MouseTitleList, True), False);
        end;
      end;
    end else begin
      if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btTitlePage * 5, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(g_ClientHumTitles.ClientHumTitles[idx], g_MouseTitleList, True), False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitleManClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  if g_ClientHumTitles.nUseTitleIndex > 0 then begin
    if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('是否取消当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].MakeIndex, 0);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewTitleManDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
  nOldFontSize: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
            nOldFontSize := frmMain.Canvas.Font.Size;
            frmMain.Canvas.Font.Size := 12;
            frmMain.Canvas.Font.Style := [fsBold];
            AspTextureFont.TextOut(SurfaceX(GLeft)+40, SurfaceY(GTop)+20, clYellow, g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName);
            frmMain.Canvas.Font.Style := [];
            frmMain.Canvas.Font.Size := nOldFontSize;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitleManInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WUI1Images, 670);
{$IFEND}
end;

procedure TFrmDlg.DBNewUserPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(UserState1.wHumTitles.ClientHumTitles) to High(UserState1.wHumTitles.ClientHumTitles) do begin
      if UserState1.wHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBNewUserPrevTitle then begin
    if m_btUserTitlePage > 0 then Dec (m_btUserTitlePage);
  end else begin
    if m_btUserTitlePage < (GetTitleCount+3) div 4 -1 then
       Inc (m_btUserTitlePage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewUserTitle1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      idx := _Max(Tag + m_btUserTitlePage * 5, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        if UserState1.wHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if UserState1.wHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetUserTitlePageIdx-1 = Tag) and (GetUserTitlePageIdx <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                {g_ImgMixSurface.SetSize(d.Width, d.Height);  // 要调整
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale); }
                dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True,124);
                //dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);}
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
          AspTextureFont.TextOut(SurfaceX(GLeft) + 34, SurfaceY(GTop) + 15, $008200, UserState1.wHumTitles.ClientHumTitles[idx].sTitleName);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewUserTitle1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    if Sender = DBNewUserTitleMan then begin
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1], g_MouseUserTitleList, True), False);
        end;
      end;
    end else begin
      if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btTitlePage * 5, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[idx], g_MouseUserTitleList, True), False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewUserTitleManDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
  nOldFontSize: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
            nOldFontSize := frmMain.Canvas.Font.Size;
            frmMain.Canvas.Font.Size := 12;
            frmMain.Canvas.Font.Style := [fsBold];
            AspTextureFont.TextOut(SurfaceX(GLeft)+40, SurfaceY(GTop)+20, clYellow, UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName);
            frmMain.Canvas.Font.Style := [];
            frmMain.Canvas.Font.Size := nOldFontSize;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterComClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
begin
  if WinBatterComIndex <> - 1 then begin
    if g_WinBatterMagicList.Count - WinBatterComIndex > 0 then begin
      for I:=Low(g_WinBatterTopMagic) to High(g_WinBatterTopMagic) do begin
        if g_WinBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_WinBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_WinBatterTopMagic[BatterTopMagIndex] := pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^;
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 0;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_WinBatterMagicList[WinBatterComIndex]);
      pm.Key := Chr(BatterTopMagIndex + 1);
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, Chr(BatterTopMagIndex + 1), str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = 0 then begin//空
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = -1 then begin//随机
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 1;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end;
    DBNewWinBatterCom.Visible := False;
  end;
end;

procedure TFrmDlg.DBNewWinBatterComDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  I: Integer;
  btLine: Byte;
  sStr: string;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewWinBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if WinBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+WinBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+WinBatterComIndex*15+19), clNavy);
    end;
    btLine := _MIN(4, g_WinBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_WinBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_WinBatterMagicList.Items[I]).Def.sMagicName;
        if I = WinBatterComIndex then
          AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if WinBatterComIndex = btLine then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if WinBatterComIndex = btLine +1 then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  btLine: Byte;
  ss: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewWinBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_WinBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    WinBatterComIndex := ss;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  Icon: integer;
  d: TAsphyreLockableTexture;
  pm: PTClientMagic;
  trainlv: Byte;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TAspDButton do begin
    pm := nil;
    if Tag < g_WinBatterMagicList.Count then begin
      pm := PTClientMagic (g_WinBatterMagicList[Tag]);
      if pm <> nil then begin
        if pm.Def.sMagicName <> '' then begin
          Icon := GetBatterMagicIcon(pm.Def.btEffect);
          if Icon > -1 then begin
            if Downed then
              d := g_WMainImages.Images[Icon+1]
            else d := g_WMainImages.Images[Icon];
            if d <> nil then
              dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          d := g_WMainImages.Images[112]; //lv
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          if not (pm.Level in [0..5]) then pm.Level := 0;
          case pm.Def.btEffect of
            102..104: begin
              case Ord(pm.Key) of
                1:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+15%暴击');
                end;
                3: begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+25%暴击');
                end;
                4: begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+30%暴击');
                end;
                else
                AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%暴击');
              end;
            end;
            105..107: begin
              case Ord(pm.Key) of
                 1:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+10%暴击');
                 end;
                 2:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+15%暴击');
                 end;
                 3:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+25%暴击');
                 end;
                 4:begin
                    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+30%暴击');
                 end;
                 else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%暴击');
              end;
            end;
            108..110: begin
              case Ord(pm.Key) of
                1:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                   AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+30%暴击');
                end;
                else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%暴击');
              end;
            end;
            111..113: begin
              case Ord(pm.Key) of
                1:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+30%暴击');
                end;
                else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%暴击');
              end;
            end;
          end;
          if pm.Level in [0..3,5] then trainlv := pm.Level
          else if pm.Level = 4 then trainlv := 3
          else trainlv := 0;
          AspTextureFont.BoldTextOut (SurfaceX(GLeft)+52, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
          if pm.Def.MaxTrain[trainlv] > 0 then begin
             if trainlv < 5 then
                AspTextureFont.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
             else AspTextureFont.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  sLines: string;
{$IFEND}
begin
{$IF M2Version = 1}
  pm := nil;
  with TAspDButton(Sender) do begin
    if g_WinBatterMagicList.Count - 1 >= Tag then begin
      pm := PTClientMagic (g_WinBatterMagicList[Tag]);
      if pm <> nil then begin
        case pm.Def.btEffect of
          102: begin  //三绝杀
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          111: begin //横扫千军
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以自身为/c=Yellow>\<中心，对5*5范围内的目标造成/c=Yellow>\<伤害/c=Yellow>';
          end;
          105: begin //追心刺
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，冲撞单体/c=Yellow>\<目标，在迫使其后退的同时，造/c=Yellow>\<成伤害/c=Yellow>';
          end;
          108: begin //断岳斩
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对三步内/c=Yellow>\<的单体目标造成伤害/c=Yellow>';
          end;
          112, 113: begin //冰天雪地 万剑归宗
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以目标为/c=Yellow>\<中心，对5*5范围内造成持续伤/c=Yellow>\<害/c=Yellow>';
          end;
          else sLines := '';
        end;
        if sLines <> '' then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth, SurfaceY(GTop)+GHeight, sLines, False)
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterRandomInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 901);
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterTopMag1Click(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewWinBatterTopMag4 then begin
    if not g_boOpen4BatterSkill then Exit;
  end;
  if g_WinBatterMagicList.Count > 0 then begin
    DBNewWinBatterCom.GLeft := TAspDButton(Sender).GLeft-2;
    DBNewWinBatterCom.GTop := TAspDButton(Sender).GTop+TAspDButton(Sender).GHeight+1;
    BatterTopMagIndex := TAspDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
    WinBatterComIndex := -1;
    DBNewWinBatterCom.Visible := True;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  Icon: Integer;
begin
  {$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if Sender = DBNewWinBatterTopMag4 then begin
      if not g_boOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft-3), SurfaceY(GTop-5), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;
    if g_WinBatterMagicList.Count > 0 then begin
      if g_WinBatterTopMagic[Tag].Def.sMagicName <> '' then begin
        Icon := GetBatterMagicIcon(g_WinBatterTopMagic[Tag].Def.btEffect);
        if Icon > -1 then begin
          if Downed then
            d := g_WMainImages.Images[icon+1]
          else d := g_WMainImages.Images[icon];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        if Downed then begin
          if g_WinBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2+1];
          end;
        end else begin
          if g_WinBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if (g_WinBatterTopMagic[0].Def.sMagicName = '') and (g_WinBatterTopMagic[1].Def.sMagicName = '') and (g_WinBatterTopMagic[2].Def.sMagicName = '') and (g_WinBatterTopMagic[3].Def.sMagicName = '')
           and (g_WinBatterTopMagic[0].CurTrain <> 1) and (g_WinBatterTopMagic[1].CurTrain <> 1) and (g_WinBatterTopMagic[2].CurTrain <> 1) and (g_WinBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DBNewWinBatterTopMag1 then begin
            if (not Downed) and (not DBNewWinBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft)+10, SurfaceY(GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewWinBatterTopMag1 then begin
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterTopMag2 then begin
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterTopMag3 then begin
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterTopMag4 then begin
    if not g_boOpen4BatterSkill then Exit;
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterRandom then begin
    DScreen.ShowHint(DBNewWinBatterRandom.SurfaceX(DBNewWinBatterRandom.GLeft), DBNewWinBatterRandom.SurfaceY(DBNewWinBatterRandom.GTop+DBNewWinBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterSetKey then begin
    DScreen.ShowHint(DBNewWinBatterSetKey.SurfaceX(DBNewWinBatterSetKey.GLeft) - 60, DBNewWinBatterSetKey.SurfaceY(DBNewWinBatterSetKey.GTop+DBNewWinBatterSetKey.GHeight),
       '设置施展连击的快捷键'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewWinPointIcon1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if StatePulsePage = 4 then begin//奇经
      if TAspDControl(Sender).Tag = 0 then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenPulsePoint(StatePulsePage, 1);
        end else begin
          ShowQJPractice(False);
        end;
      end;
      frmMain.SendOpenPulsePoint(StatePulsePage, TAspDControl(Sender).Tag+1);
    end else begin
      frmMain.SendOpenPulsePoint(StatePulsePage, TAspDControl(Sender).Tag+1);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointIcon1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= Tag+1 then
      d := g_WMainImages.Images[851]
    else if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = Tag+1)) or (StatePulsePage = 4){奇经} then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

    if ((g_btPulseOriginPage = StatePulsePage) or (StatePulsePage = 4){奇经}) and (g_btPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;

    if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = Tag+1)) or ((StatePulsePage = 4) and (g_HumanPulseArr[StatePulsePage].nPulsePoint = 0) and (Tag = 0)){奇经} then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointIcon1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  sLines, sPointName, sPulsDesc: string;

  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwInternalForceLevel >= nlevel then Result := '~y';
  end;
{$IFEND}
begin
{$IF M2Version = 1}
  if StatePulsePage = 4 then begin
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= TAspDControl(Sender).Tag+1 then begin //已打通
      DScreen.ShowHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), '神冲穴: 已打通,点击可修炼\ \奇经穴位，通过奇经神冲丸\打通，可点击进行修炼，提\升斗转星移技能等级。' , clWhite, FALSE);
    end else begin
      DScreen.ShowTzHint (TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop),
                  '神冲穴:待打通'+'~y\', FALSE, FALSE, 0);
    end;
  end else begin
    sPointName := GetPulseName(StatePulsePage,TAspDControl(Sender).Tag);
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= TAspDControl(Sender).Tag+1 then begin //已打通
      if sPointName <> '' then begin
        sLines := Format('%s穴:已打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'已通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' +  sPulsDesc;
        DScreen.ShowHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), sLines, clYellow, FALSE);
      end;
    end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = TAspDControl(Sender).Tag+1) then begin //待打
      if sPointName <> '' then begin
        sLines := Format('%s穴:待打通~y\需要内功等级：%d',[sPointName, g_btPulseLevel])+GetRGB(g_btPulseLevel);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowTzHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), sLines, FALSE, FALSE, 0);
      end;
    end else begin
      if sPointName <> '' then begin
        sLines := Format('%s穴:目前不可打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowHint(TAspDControl(Sender).SurfaceX(TAspDControl(Sender).GLeft)+ TAspDControl(Sender).GWidth, TAspDControl(Sender).SurfaceY(TAspDControl(Sender).GTop), sLines, clRed, FALSE);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPage1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version =1}
  if StatePulsePage <> TAspDButton(Sender).Tag then begin
    StatePulsePage := TAspDButton(Sender).Tag;
    ChangeNGPointPage();
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPage1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if StatePulsePage = Tag then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    if StatePulsePage = Tag then
      Color := $73B2DE
    else Color := $5282A5;
    if not Downed then
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+4, SurfaceY(GTop)+5, Color, clBlack, Caption)
    else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+5, SurfaceY(GTop)+6, Color, clBlack, Caption);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPage1Initialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 812);
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPracticeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
      if g_HumanPulseArr[StatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendPracticePulse(StatePulsePage);
      end;
    end else begin
      case StatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HumanPulseArr[StatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(False);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPracticeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  btWidth, btHeight: Byte;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      btWidth := GWidth div 2 - FrmMain.Canvas.TextWidth(Caption) div 2;
      btHeight := GHeight div 2 - FrmMain.Canvas.TextHeight(Caption) div 2;
      if not Enabled then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight{+ 5}, $0099A8AC, clBlack, Caption);
        Exit;
      end;
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth+1, SurfaceY(GTop) + btHeight + 1{SurfaceY(GTop) + 6}, $0048A4E8, clBlack, Caption);
      end else begin
        if MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight, $00A8D4E8, clBlack, Caption);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight, $0088C4E8, clBlack, Caption);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPracticeInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDButton(Sender).SetImgIndex(g_WMainImages, 814);
{$IFEND}
end;

procedure TFrmDlg.DBNextTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
    SetImgIndex(g_WUI1Images, 686);
{$IFEND}
end;

procedure TFrmDlg.DNewSdoSkillInitialize(Sender: TObject);
begin
  DNewSdoSkill.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNewSdoKeyInitialize(Sender: TObject);
begin
  DNewSdoKey.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNedSdoHelpInitialize(Sender: TObject);
begin
  DNedSdoHelp.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DScrollBarProInitialize(Sender: TObject);
begin
  with DScrollBarPro do begin
    SetImgIndex(g_WMain2Images, 574);
    GHeight := 207;  //
    PrevImageIndex.Up := 292;
    PrevImageIndex.Down := 293;
    NextImageIndex.Up := 294;
    NextImageIndex.Down := 295;
    BarImageIndex.Up := 581;
    RemoveSize :=  DScrollBoxPro.GHeight;
    //MaxValue := 400;
  end;
end;

procedure TFrmDlg.DScrollBarFilterItemInitialize(Sender: TObject);
begin
  DScrollBarFilterItem.SetImgIndex(g_WMain2Images, 574);
  DScrollBarFilterItem.GHeight := 207;  //
  DScrollBarFilterItem.PrevImageIndex.Up := 292;
  DScrollBarFilterItem.PrevImageIndex.Down := 293;
  DScrollBarFilterItem.NextImageIndex.Up := 294;
  DScrollBarFilterItem.NextImageIndex.Down := 295;
  DScrollBarFilterItem.BarImageIndex.Up := 581;
  DScrollBarFilterItem.RemoveSize :=  DScrollBarFilterItem.ItemHeight * 8;
  DScrollBarFilterItem.MaxValue := DListViewFilterItem.Count * DScrollBarFilterItem.ItemHeight;
end;
procedure TFrmDlg.DScrollBarKeyInitialize(Sender: TObject);
begin
  with DScrollBarKey do begin
    SetImgIndex(g_WMain2Images, 574);
    GHeight := 207;  //
    PrevImageIndex.Up := 292;
    PrevImageIndex.Down := 293;
    NextImageIndex.Up := 294;
    NextImageIndex.Down := 295;
    BarImageIndex.Up := 581;
    RemoveSize :=  DScrollBoxKey.GHeight;
  end;
end;

procedure TFrmDlg.DListViewFilterItemInitialize(Sender: TObject);
var
  I: Integer;
  ShowItem: pTShowItem1;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
begin
  DListViewFilterItem.Clear;
  DListViewFilterItem.ColCount := 4;
  for I := 0 to g_ShowItemList.m_ShowItemList.Count - 1 do begin
    if g_ShowItemList.m_ShowItemList.Objects[I] = nil then Continue;
    ShowItem := pTShowItem1(g_ShowItemList.m_ShowItemList.Objects[I]);
    ListItem := DListViewFilterItem.Add;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Caption := ShowItem.SItemName;
    ViewItem.Data := ShowItem;
    ViewItem.Style := bsButton; //bsRadio;
    ViewItem.Color.Up.Color := clWhite;
    ViewItem.Color.Hot.Color := clRed; //clWhite;
    ViewItem.Color.Down.Color := clRed;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Style := bsCheckBox;
    ViewItem.ImageIndex.Up := 228;
    ViewItem.ImageIndex.Down := 229;
    ViewItem.Checked := ShowItem.boHintMsg;
    ViewItem.WLib := g_WMain2Images;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Style := bsCheckBox;
    ViewItem.ImageIndex.Up := 228;
    ViewItem.ImageIndex.Down := 229;
    ViewItem.Checked := ShowItem.boPickup;
    ViewItem.WLib := g_WMain2Images;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Style := bsCheckBox;
    ViewItem.ImageIndex.Up := 228;
    ViewItem.ImageIndex.Down := 229;
    ViewItem.Checked := ShowItem.boShowName;
    ViewItem.WLib := g_WMain2Images;
  end;
end;
procedure TFrmDlg.DCBFilterItemStdModeInitialize(Sender: TObject);
begin
 {  with DCBFilterItemStdMode.Items do begin
     Add('(全部分类)');
     Add('其他类');
     Add('药品类');
     Add('服装类');
     Add('武器类');
     Add('首饰类');
     Add('饰品类');
     Add('服饰类');
   end;     }
   DCBFilterItemStdMode.ItemIndex := 0;    
end;
procedure TFrmDlg.DCheckSdoStartKeyInitialize(Sender: TObject);
begin
  DCheckSdoStartKey.SetImgIndex(g_qingqingImages, 7);
end;
procedure TFrmDlg.DSdoMemoScrollBarInitialize(Sender: TObject);
begin
  DSdoMemoScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DSdoMemoScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DSdoMemoScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;
procedure TFrmDlg.DSdoMemoInitialize(Sender: TObject);
begin
  DSdoMemo.DScroll := DSdoMemoScrollBar;
  DSdoMemo.DScroll.GTop := -6;
  DSdoMemo.DScroll.GLeft := 361;
  DSdoMemo.DScroll.GHeight := 206;
  DSdoMemo.DScroll.GWidth := 16;
  DSdoMemo.DScroll.Bar.GTop := 17;
  DSdoMemo.DScroll.BDown.GTop := 189;
  DSdoMemo.DScroll.BUp.GTop := 2;
  if FileExists(g_ParamDir+'\Data\explain2.dat') then begin
    try
      DSdoMemo.Lines.LoadFromFile(g_ParamDir+'\Data\explain2.dat');
    except
    end;
  end;
end;
{$ENDREGION}
{$REGION '其他'}
procedure TFrmDlg.DBSkillMemoCloseInitialize(Sender: TObject);
begin
  DBSkillMemoClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DWSkillMemoInitialize(Sender: TObject);
begin
  DWSkillMemo.SetImgIndex(g_WUI1Images, 760);
end;
procedure TFrmDlg.DBHeroSkillMemoCloseInitialize(Sender: TObject);
begin
  DBHeroSkillMemoClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DWHeroSkillMemoInitialize(Sender: TObject);
begin
  DWHeroSkillMemo.SetImgIndex(g_WUI1Images, 760);
end;
procedure TFrmDlg.DWPetLogInitialize(Sender: TObject);
begin
	if g_WUI1Images.Images[1300] <> nil then
		DWPetLog.SetImgIndex(g_WUI1Images, 1300);
end;
procedure TFrmDlg.DBPetLogCloseInitialize(Sender: TObject);
begin
  DBPetLogClose.SetImgIndex(g_WMain2Images, 148);
end;
{$ENDREGION}
{$ENDREGION}

{------------------------------------------------------------------------}
//打开人物信息状态
procedure TFrmDlg.OpenMyStatus;
begin
  {$IF M2Version = 2}
  DStateWin.Visible := not DStateWin.Visible;
  {$ELSE}
  if g_boNewNewStateWin then begin
    DWNewStateWin.Visible := not DWNewStateWin.Visible;
    if DWNewStateWin.Visible then begin
      if (DPNewStateWinTab.ActivePage = 0) and (DPNewStateWinPage.ActivePage = 4) then begin
        NewMagicBtnNotVisible;
      end;
    end;
    //Exit;
  end else begin
    DStateWin.Visible := not DStateWin.Visible;
    DScreen.AddChatBoardString ('由于你的客户端资源过旧，强化技能、心法将无法使用，请更新最新资源！',clLime, clBlack);
  end;
  {$IFEND}

  {$IF M2Version <> 2}
  if StateTab = 0 then
   PageChanged
  else InternalForcePageChanged;
  {$ELSE}
  PageChanged;
  {$IFEND}

   {DStateWin.Visible := not DStateWin.Visible;
   {$IF M2Version <> 2}
   {if StateTab = 0 then
     PageChanged
   else InternalForcePageChanged;
   {$ELSE}
   {PageChanged;
   {{$IFEND}
end;

//显示玩加信息对话框
procedure TFrmDlg.OpenUserState (UserState: TUserStateInfo);
begin
  UserState1 := UserState;
  {$IF M2Version <> 2}
  m_btUserTitlePage := 0;
  if g_boNewNewStateWin then begin
    DLNewStateUserName.UpColor := UserState1.NameColor;
    DLNewStateUserName.Caption := UserState1.UserName;
    DLNewStateUserGuildName.UpColor := clSilver;
    case g_boUserIsWho of
      1: DLNewStateUserGuildName.Caption := UserState1.GuildName+' 的英雄';
      2: DLNewStateUserGuildName.Caption := UserState1.GuildName+' 的分身';
    else DLNewStateUserGuildName.Caption := UserState1.GuildName + ' ' + UserState1.GuildRankName;
    end;
    DBNewStateUserPage.Visible := g_boUserIsWho = 0;
    DPNewStateUserPage.ActivePage := 0;
    DWNewStateUser.Visible := True;
  end else begin
  {$IFEND}
    DUserState1.Visible := True;
  {$IF M2Version <> 2}
    DScreen.AddChatBoardString ('由于你的客户端资源过旧，强化技能、心法将无法使用，请更新最新资源！',clLime, clBlack);
  end;
  {$IFEND}

   {{$IF M2Version <> 2}
   {m_btUserTitlePage := 0;
   {$IFEND}
   {UserState1 := UserState;
   DUserState1.Visible := TRUE;}
end;

//显示/关闭物品对话框
procedure TFrmDlg.OpenItemBag;
begin
  DItemBag.Visible := not DItemBag.Visible;
  if DItemBag.Visible then ArrangeItemBag;
end;

//底部状态框
procedure TFrmDlg.ViewBottomBox (visible: Boolean);
begin
   //DBottom.Visible := visible;
  DWBottomLeft.Visible := Visible;
  DWBottomRight.Visible := Visible;
  DWBottomCenter.Visible := Visible;
  DChatMemo.Clear;
end;

// 取消英雄物品移动
procedure TFrmDlg.CancelHeroItemMoving;
var
   idx, n: integer;
begin
   if g_boHeroItemMoving then begin
      g_boHeroItemMoving := FALSE;
      idx := g_MovingHeroItem.Index;
      if idx < 0 then begin
        n := -(idx+1);
        if n in [0..14] then
          g_HeroItems[n].ClientItem := g_MovingHeroItem.Item.ClientItem;
      end else
         if idx in [0..MAXBAGITEM-1] then begin
            if g_HeroItemArr[idx].ClientItem.S.Name = '' then begin
               g_HeroItemArr[idx].ClientItem := g_MovingHeroItem.Item.ClientItem;
            end else begin
               AddHeroItemBag (g_MovingHeroItem.Item);
            end;
         end;
      g_MovingHeroItem.Item.ClientItem.S.Name := '';
   end;
   ArrangeHeroItemBag;
end;

// 取消物品移动
procedure TFrmDlg.CancelItemMoving;
var
   idx, n: integer;
begin
   if g_boItemMoving then begin
      g_boItemMoving := FALSE;
      idx := g_MovingItem.Index;
      if idx < 0 then begin
         if (idx <= -20) and (idx > -30) then begin
            AddDealItem (g_MovingItem.Item);
         end else begin
            n := -(idx+1);
            //showmessage(inttostr(n));
            if n in [0..14] then begin
               g_UseItems[n] := g_MovingItem.Item;
            end;
            if n in [40..42]then begin //淬炼物品返回 20080507
               g_ItemsUpItem[n-40] := g_MovingItem.Item;
            end;
            if n in [44..45] then begin  //请酒物品
               g_PDrinkItem[n-44] := g_MovingItem.Item;
            end;
            if n in [46..52] then begin  //普通酒物品
               g_WineItem[n-46] := g_MovingItem.Item;
            end;
            if n in [53..55] then begin  //药酒物品
               g_DrugWineItem[n-53] := g_MovingItem.Item;
            end;
            if n in [71..80] then begin  //摆摊物品
              g_ShopItems[n-71].Item := g_MovingItem.Item;
            end;
            {$IF M2Version <> 2}
            if n = 254 then begin //灵媒
              g_LingMeiBelt := g_MovingItem.Item;
            end;
            {$IFEND}
         end;
      end else
         if idx in [0..MAXBAGITEM-1] then begin
            if g_ItemArr[idx].Item.ClientItem.S.Name = '' then begin
               g_ItemArr[idx].Item := g_MovingItem.Item;
            end else begin
               AddItemBag (g_MovingItem.Item);
            end;
         end;
      g_MovingItem.Item.ClientItem.S.Name := '';
   end;
   ArrangeItemBag;
end;

//把移动的物品放下
procedure TFrmDlg.DropMovingItem;
begin
   if g_boItemMoving then begin
      g_boItemMoving := FALSE;
      if g_MovingItem.Item.ClientItem.S.Name <> '' then begin
         FrmMain.SendDropItem (g_MovingItem.Item.ClientItem.S.Name, g_MovingItem.Item.ClientItem.MakeIndex);
         AddDropItem (g_MovingItem.Item);
         g_MovingItem.Item.ClientItem.S.Name := '';
      end;
   end;
end;

procedure TFrmDlg.DropHeroMovingItem;//英雄往地上扔物品  2007.11.8
begin
   if g_boHeroItemMoving then begin
      g_boHeroItemMoving := FALSE;
      if g_MovingHeroItem.Item.ClientItem.S.Name <> '' then begin
         FrmMain.SendHeroDropItem (g_MovingHeroItem.Item.ClientItem.S.Name, g_MovingHeroItem.Item.ClientItem.MakeIndex);
         AddDropItem (g_MovingHeroItem.Item);
         g_MovingHeroItem.Item.ClientItem.S.Name := '';
      end;
   end;
end;

//打开属性调整对话框
procedure TFrmDlg.OpenAdjustAbility;
begin
   DAdjustAbility.GLeft := 0;
   DAdjustAbility.GTop := 0;
   g_nSaveBonusPoint := g_nBonusPoint;
   FillChar (g_BonusAbilChg, sizeof(TNakedAbility), #0);
   DAdjustAbility.Visible := TRUE;
end;

procedure TFrmDlg.DBackgroundBackgroundClick(Sender: TObject);
var
   dropgold: integer;
   valstr: string;
begin
   if g_boItemMoving then begin
      DBackground.WantReturn := TRUE;
      if g_MovingItem.Item.ClientItem.S.Name = g_sGoldName{'金币'} then begin
         g_boItemMoving := FALSE;
         g_MovingItem.Item.ClientItem.S.Name := '';
         //倔付甫 滚副 扒瘤 拱绢夯促.
         DialogSize := 1;
         DMessageDlg ('请输入 ' +g_sGoldName+ ' 数量?', [mbOk, mbAbort]);
         GetValidStrVal (DlgEditText, valstr, [' ']);
         dropgold := Str_ToInt (valstr, 0);
         //
         FrmMain.SendDropGold (dropgold);
      end;
      if g_MovingItem.Index >= 0 then //酒捞袍 啊规俊辑 滚赴巴父..
         DropMovingItem;
   end;
   if g_boHeroItemMoving then begin
      DBackground.WantReturn := TRUE;
      if g_MovingHeroItem.Index >= 0 then //酒捞袍 啊规俊辑 滚赴巴父..
      DropHeroMovingItem;
   end;
end;

procedure TFrmDlg.DBackgroundMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   if g_boItemMoving then begin
     DBackground.WantReturn := TRUE;
   end;
end;

procedure TFrmDlg.DBottomMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      if line[1]='[' then begin
        line := GetValidStr3 (line, line, [']']);
      end;
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':','[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
var
   n: integer;
begin
   ReleaseDFocus;
   PlayScene.EdChat.ReadOnly := False;
   //当鼠标点在底部状态栏的消息上时，
   if DScreen.TopChatStrs.Count > 0 then begin
     if (X >= 208) and (X <= 208+374) and (Y >= g_D3DConfig.wScreenHeight-130) and (Y <= g_D3DConfig.wScreenHeight-130 + 12*3) then begin
        n := (Y - (g_D3DConfig.wScreenHeight-130)) div 12;
        if (n < DScreen.TopChatStrs.Count) then begin
           if not PlayScene.EdChat.Visible then begin
              PlayScene.EdChat.Visible := TRUE;
              PlayScene.EdChat.SetFocus;
           end;
           if ssCtrl in shift then begin
              PlayScene.EdChat.Text :=DScreen.TopChatStrs[n];
           end else begin
              PlayScene.EdChat.Text := '/' + ExtractUserName (DScreen.TopChatStrs[n]) + ' ';
           end;
           PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
           PlayScene.EdChat.SelLength := 0;
        end else
           PlayScene.EdChat.Text := '';
     end;
   end;
   if (X >= 208) and (X <= 208+374) and (Y >= g_D3DConfig.wScreenHeight-130+DScreen.TopChatStrs.Count*12) and (Y <= (g_D3DConfig.wScreenHeight-130+DScreen.TopChatStrs.Count*12) + 12*(9-DScreen.TopChatStrs.Count)) then begin
      n := DScreen.ChatBoardTop + (Y - (g_D3DConfig.wScreenHeight-130+DScreen.TopChatStrs.Count*12)) div 12;
      if (n < DScreen.ChatStrs.Count) then begin
         if not PlayScene.EdChat.Visible then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.SetFocus;
         end;
         if ssCtrl in shift then begin
            PlayScene.EdChat.Text :=DScreen.ChatStrs[n];
         end else begin
            PlayScene.EdChat.Text := '/' + ExtractUserName (DScreen.ChatStrs[n]) + ' ';
         end;

         PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
         PlayScene.EdChat.SelLength := 0;
      end else
         PlayScene.EdChat.Text := '';
   end;
end;

{------------------------------------------------------------------------}
////显示通用对话框
// new copy by liuzhigang
function  TFrmDlg.DMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons; bClearEdit:Boolean): TModalResult;
const
   XBase = 324;
var
  I: Integer;
   lx, ly: integer;
   d: TAsphyreLockableTexture;

  procedure ShowDice();
  var
    I: Integer;
    bo05:Boolean;
  begin
    if m_nDiceCount = 1 then begin
      if m_Dice[0].n67C < 20 then begin
        if GetTickCount - m_Dice[0].dwPlayTick > 100 then begin
          if m_Dice[0].n67C div 5 = 4 then begin
            m_Dice[0].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[0].nPlayPoint:=m_Dice[0].n67C div 5 + 8;
          end;
          m_Dice[0].dwPlayTick:=GetTickCount();
          Inc(m_Dice[0].n67C);
        end;
        exit;
      end;//00491461
      m_Dice[0].nPlayPoint:= m_Dice[0].nDicePoint;
      if GetTickCount - m_Dice[0].dwPlayTick > 1500 then begin
        DMsgDlg.Visible:=False;
      end;
      exit;
    end;//004914AD

    bo05:=True;
    if m_nDiceCount > 0 then //20080629
    for I := 0 to m_nDiceCount - 1 do begin
      if m_Dice[I].n67C < m_Dice[I].n680 then begin
        if GetTickCount - m_Dice[I].dwPlayTick > 100 then begin
          if m_Dice[I].n67C div 5 = 4 then begin
            m_Dice[I].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[I].nPlayPoint:=m_Dice[I].n67C div 5 + 8;
          end;
          m_Dice[I].dwPlayTick:=GetTickCount();
          Inc(m_Dice[I].n67C);
        end;
        bo05:=False;
      end else begin  //004915E4
        m_Dice[I].nPlayPoint:= m_Dice[I].nDicePoint;
        if GetTickCount - m_Dice[I].dwPlayTick < 2000 then begin
          bo05:=False;
        end;
      end;
    end; //for
    if bo05 then begin
      DMsgDlg.Visible:=False;
    end;

  end;
begin

   lx := XBase;
   ly := 126;
   case DialogSize of
      0:  //小对话框(转骰子)
         begin
            d := g_WMainImages.Images[381];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 381);
               DMsgDlg.GLeft := (g_D3DConfig.wScreenWidth - d.Width) div 2;
               DMsgDlg.GTop := (g_D3DConfig.wScreenHeight - d.Height) div 2;
               msglx := 39;
               msgly := 38;
               lx := 90;
               ly := 36;
            end;
         end;
      1:  //大对话框（横）
         begin
            d := g_WMainImages.Images[360];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 360);
               DMsgDlg.GLeft := (g_D3DConfig.wScreenWidth - d.Width) div 2;
               DMsgDlg.GTop := (g_D3DConfig.wScreenHeight - d.Height) div 2;
               msglx := 39;
               msgly := 38;
               lx := XBase;
               ly := 126;
            end;
         end;
      2:  //大对话框（竖）
         begin
            d := g_WMainImages.Images[380];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 380);
               DMsgDlg.GLeft := (g_D3DConfig.wScreenWidth - d.Width) div 2;
               DMsgDlg.GTop := (g_D3DConfig.wScreenHeight - d.Height) div 2;
               msglx := 23;
               msgly := 20;
               lx := 90;
               ly := 305;
            end;
         end;
   end;
   MsgText := msgstr;
   ViewDlgEdit := FALSE;  //编辑框不可见
   DMsgDlg.Floating := TRUE; //允许鼠标移动
   DMsgDlgOk.Visible := FALSE;
   DMsgDlgYes.Visible := FALSE;
   DMsgDlgCancel.Visible := FALSE;
   DMsgDlgNo.Visible := FALSE;
   DMsgDlgGamePointBuy.Visible := False;
   DMsgDlgGameGoldBuy.Visible := False;
   DMsgDlg.GLeft := (g_D3DConfig.wScreenWidth - DMsgDlg.GWidth) div 2;
   DMsgDlg.GTop := (g_D3DConfig.wScreenHeight - DMsgDlg.GHeight) div 2;
   //调整按钮
   if m_nDiceCount > 0 then //20080629   //色子
   for I := 0 to m_nDiceCount - 1 do begin
     m_Dice[I].n67C:=0;
     m_Dice[I].n680:=Random(m_nDiceCount + 2) * 5 + 10;
     m_Dice[I].nPlayPoint:=1;
     m_Dice[I].dwPlayTick:=GetTickCount();
   end;

   if mbCancel in DlgButtons then begin
      DMsgDlgCancel.GLeft := lx;
      DMsgDlgCancel.GTop := ly;
      DMsgDlgCancel.Visible := TRUE;
      lx := lx - 110;
   end;
   if mbNo in DlgButtons then begin
      DMsgDlgNo.GLeft := lx;
      DMsgDlgNo.GTop := ly;
      DMsgDlgNo.Visible := TRUE;
      lx := lx - 110;
   end;
   if mbYes in DlgButtons then begin
      DMsgDlgYes.GLeft := lx;
      DMsgDlgYes.GTop := ly;
      DMsgDlgYes.Visible := TRUE;
      lx := lx - 110;
   end;
   if (mbOk in DlgButtons) or (lx = XBase) then begin    //只有确定
      DMsgDlgOk.GLeft := lx;
      DMsgDlgOk.GTop := ly;
      DMsgDlgOk.Visible := TRUE;
      lx := lx - 110;
   end;
   if (mbIgnore in DlgButtons) then begin //荣耀点购买
      DMsgDlgGamePointBuy.GLeft := lx;
      DMsgDlgGamePointBuy.GTop := ly;
      DMsgDlgGamePointBuy.Visible := TRUE;
      lx := lx - 110;
   end;
   if (mbRetry in DlgButtons) then begin //元宝购买
      DMsgDlgGameGoldBuy.GLeft := lx;
      DMsgDlgGameGoldBuy.GTop := ly;
      DMsgDlgGameGoldBuy.Visible := TRUE;
      lx := lx - 110;
   end;
   HideAllControls;
   DMsgDlg.ShowModal;
   if mbAbort in DlgButtons then begin
      ViewDlgEdit := TRUE; //显示编辑框.
      DMsgDlg.Floating := FALSE;
      with EdDlgEdit do begin
         if bClearEdit then Text := '';
         Width := DMsgDlg.GWidth - 70;
         Left := (g_D3DConfig.wScreenWidth - EdDlgEdit.Width) div 2;
         Top  := (g_D3DConfig.wScreenHeight - EdDlgEdit.Height) div 2 - 10;
      end;
   end;
   Result := mrOk;

   while TRUE do begin
      if not DMsgDlg.Visible then break;
      //FrmMain.DXTimerTimer (self, 0);
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;

      if m_nDiceCount > 0 then begin
        m_boPlayDice:=True;
        if m_nDiceCount > 0 then //20080629
        for I := 0 to m_nDiceCount - 1 do begin
          m_Dice[I].nX:=((DMsgDlg.GWidth div 2 + 6) - ((m_nDiceCount * 32 + m_nDiceCount) div 2)) + (I * 32 + I);
          m_Dice[I].nY:=DMsgDlg.GHeight div 2 - 14;
        end;

        ShowDice();

      end;

      if Application.Terminated then exit;
   end;

   EdDlgEdit.Visible := FALSE;
   RestoreHideControls;
   DlgEditText := EdDlgEdit.Text;
   if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
   ViewDlgEdit := FALSE;
   Result := DMsgDlg.DialogResult;
   DialogSize := 1; //扁夯惑怕
   m_nDiceCount:=0;
   m_boPlayDice:=False;
end;

// new copy by liuzhigang
procedure TFrmDlg.DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMsgDlgOk then DMsgDlg.DialogResult := mrOk;
   if Sender = DMsgDlgYes then DMsgDlg.DialogResult := mrYes;
   if Sender = DMsgDlgCancel then DMsgDlg.DialogResult := mrCancel;
   if Sender = DMsgDlgNo then DMsgDlg.DialogResult := mrNo;
   if Sender = DMsgDlgGameGoldBuy then DMsgDlg.DialogResult := mrRetry;
   if Sender = DMsgDlgGamePointBuy then DMsgDlg.DialogResult := mrIgnore;
   DMsgDlg.Visible := FALSE;
end;

// new copy by liuzhigang
procedure TFrmDlg.DMsgDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = 13 then begin
      if DMsgDlgOk.Visible and not (DMsgDlgYes.Visible {or DMsgDlgCancel.Visible 20080713} or DMsgDlgNo.Visible) then begin
         DMsgDlg.DialogResult := mrOk;
         DMsgDlg.Visible := FALSE;
      end;
      if DMsgDlgGameGoldBuy.Visible then begin
         DMsgDlg.DialogResult := mrRetry;
         DMsgDlg.Visible := FALSE;
      end;
      if DMsgDlgYes.Visible and not (DMsgDlgOk.Visible or DMsgDlgCancel.Visible{ or DMsgDlgNo.Visible 20091118}) then begin
         DMsgDlg.DialogResult := mrYes;
         DMsgDlg.Visible := FALSE;
      end;
   end;
   if Key = 27 then begin
      if DMsgDlgCancel.Visible then begin
         DMsgDlg.DialogResult := mrCancel;
         DMsgDlg.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.DMsgDlgOkDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  tStr:String;
  //{$if Version <> 1}
  nTextWidth, nTextHeight: Integer;
  //{$IFEND}
  //nStatus:Integer;
begin
//try
  d:=nil; //
   //nStatus:=-1;
   with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if not Downed then
          d := WLib.Images[FaceIndex]
        else d := WLib.Images[FaceIndex+1];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

      if (Name = 'DSServer1') and (g_ServerList.Count >= 1) then begin
        tStr:=g_ServerList.Strings[0];
        //nStatus:=Integer(g_ServerList.Objects[0]);
      end;
      if (Name = 'DSServer2') and (g_ServerList.Count >= 2) then begin
        tStr:=g_ServerList.Strings[1];
        //nStatus:=Integer(g_ServerList.Objects[1]);
      end;
      if (Name = 'DSServer3') and (g_ServerList.Count >= 3) then begin
        tStr:=g_ServerList.Strings[2];
        //nStatus:=Integer(g_ServerList.Objects[2]);
      end;
      if (Name = 'DSServer4') and (g_ServerList.Count >= 4) then begin
        tStr:=g_ServerList.Strings[3];
        //nStatus:=Integer(g_ServerList.Objects[3]);
      end;
      if (Name = 'DSServer5') and (g_ServerList.Count >= 5) then begin
        tStr:=g_ServerList.Strings[4];
        //nStatus:=Integer(g_ServerList.Objects[4]);
      end;
      if (Name = 'DSServer6') and (g_ServerList.Count >= 6) then begin
        tStr:=g_ServerList.Strings[5];
        //nStatus:=Integer(g_ServerList.Objects[5]);
      end;
      if d <> nil then begin
        Color:=$0093F4F2;
        AspTextureFonts.SetFont(g_sCurFontName, 12);
        //nTextWidth := frmMain.Canvas.TextExtent(tStr).cx;
        //nTextHeight := frmMain.Canvas.TextExtent(tStr).cy;
        nTextWidth := AspTextureFont.TextWidth(tStr);
        nTextHeight := AspTextureFont.TextHeight(tStr);
        if TAspDButton(Sender).Downed then begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + (d.Width - nTextWidth) div 2) + 2, SurfaceY(GTop + (d.Height -nTextHeight) div 2) + 2, tStr, Color, clBlack, [fsBold]);
        end else begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + (d.Width - nTextWidth) div 2), SurfaceY(GTop + (d.Height -nTextHeight) div 2), tStr, Color, clBlack, [fsBold]);
        end;
        AspTextureFonts.SetFont(g_sCurFontName, 9);
      end;
   end;
{except
  on e: Exception do begin
    ShowMessage(E.Message);
  end;
end; }
end;

procedure TFrmDlg.DMsgDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  I: Integer;
  d: TAsphyreLockableTexture;
  ly: integer;
  str, data: string;
  nX,nY:Integer;
begin
   with Sender as TAspDWindow do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

      if m_boPlayDice then begin
        if m_nDiceCount > 0 then //20080629
        for I := 0 to m_nDiceCount - 1 do begin
          d:=frmMain.GetBagItemImg(m_Dice[I].nPlayPoint + 376 - 1,nX,nY);
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft) + m_Dice[I].nX + nX - 14, SurfaceY(GTop) + m_Dice[I].nY + nY + 38, d.ClientRect, d, TRUE);
          end;
        end;
      end;
      ly := msgly;
      str := MsgText;
      while TRUE do begin
         if str = '' then break;
         str := GetValidStr3 (str, data, ['\']);
         if data <> '' then
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+msglx), SurfaceY(GTop+ly), data, clWhite, clBlack);
         ly := ly + 14;
      end;
   end;
   if ViewDlgEdit then begin
      if not EdDlgEdit.Visible then begin
         EdDlgEdit.Visible := TRUE;
         EdDlgEdit.SetFocus;
      end;
   end;
end;

procedure TFrmDlg.DMsgDlgGameGoldBuyInitialize(Sender: TObject);
begin
  DMsgDlgGameGoldBuy.SetImgIndex (g_qingqingImages, 26);
end;

procedure TFrmDlg.DMsgDlgGamePointBuyInitialize(Sender: TObject);
begin
  DMsgDlgGamePointBuy.SetImgIndex (g_qingqingImages, 28);
end;

{------------------------------------------------------------------------}

//肺弊牢 芒

procedure TFrmDlg.DLoginNewDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if TAspDButton(Sender).Downed then begin
         if WLib <> nil then begin //20080701
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         end;
      end;
   end;
end;

procedure TFrmDlg.DLoginNewClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewClick;
end;

procedure TFrmDlg.DLoginOkClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.OkClick;
end;

procedure TFrmDlg.DLoginOkDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  if (DLogIn.WLib <> nil) and (DLogIn.WLib.Images[DLogIn.FaceIndex] <> nil) then begin
   with Sender as TAspDButton do begin
      if TAspDButton(Sender).Downed then begin
         if WLib <> nil then begin //20080701
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         end;
      end;
   end;
  end else begin
    //如果素材不存在 就画个框 By TasNat at: 2012-03-26 13:31:32
    with Sender as TAspDButton do begin
      dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clWhite);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + GWidth div 2, SurfaceY(GTop) + GHeight div 2 - 8, clWhite, clBlack, '登陆');
    end;
  end;
end;

procedure TFrmDlg.DLoginCloseClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.Close;
end;

procedure TFrmDlg.DLoginChgPwClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.ChgPwClick;
end;



procedure TFrmDlg.DLoginNewClickSound(Sender: TObject;
  Clicksound: TClickSound);
begin
   case Clicksound of
      csNorm:  PlaySound (s_norm_button_click);
      csStone: PlaySound (s_rock_button_click);
      csGlass: PlaySound (s_glass_button_click);
   end;
end;

{------------------------------------------------------------------------}
//显示选择服务器对话框
procedure TFrmDlg.ShowSelectServerDlg;
begin
   case g_ServerList.Count of
     1:begin
         DSServer1.Visible:=True;
         DSServer1.GTop:=204;
         DSServer2.Visible:=False;
         DSServer3.Visible:=False;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     2:begin
         DSServer1.Visible:=True;
         DSServer1.GTop:=190;
         DSServer2.Visible:=True;
         DSServer2.GTop:=235;
         DSServer3.Visible:=False;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     3:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     4:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     5:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=False;
       end;
     6:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=True;
       end;
     else begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=True;
       end;
   end;
   DSelServerDlg.Visible:=TRUE;
end;
procedure TFrmDlg.DSServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
   svname := '';
   if Sender = DSServer1 then begin
     svname:=g_ServerList.Strings[0];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer2 then begin
     svname:=g_ServerList.Strings[1];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer3 then begin
     svname:=g_ServerList.Strings[2];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer4 then begin
     svname:=g_ServerList.Strings[3];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer5 then begin
     svname:=g_ServerList.Strings[4];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer6 then begin 
     svname:=g_ServerList.Strings[5];
     g_sServerMiniName:=svname;
   end;
   if svname <> '' then begin
      FrmMain.SendSelectServer (svname);
      DSelServerDlg.Visible := FALSE;
      g_sServerName := svname;
   end;
end;


procedure TFrmDlg.DSServer1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  tStr:String;
  nTextWidth, nTextHeight: Integer;
begin

  d:=nil;
   with Sender as TAspDButton do begin
     if g_ServerList.Count > Tag then begin
      if WLib <> nil then begin //20080701
        if not Downed then
          d := WLib.Images[FaceIndex]
        else d := WLib.Images[FaceIndex+1];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      //无素材就画一个框
      if d = nil then
        dsurface.FrameRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clWhite);


      tStr:=g_ServerList.Strings[Tag];


        Color:=$0093F4F2;
        AspTextureFonts.SetFont(g_sCurFontName, 12);
        //nTextWidth := frmMain.Canvas.TextExtent(tStr).cx;
        //nTextHeight := frmMain.Canvas.TextExtent(tStr).cy;
        nTextWidth := AspTextureFont.TextWidth(tStr);
        nTextHeight := AspTextureFont.TextHeight(tStr);
        if Downed then begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + (GWidth - nTextWidth) div 2) + 2, SurfaceY(GTop + (GHeight -nTextHeight) div 2) + 2, tStr, Color, clBlack, [fsBold]);
        end else begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + (GWidth - nTextWidth) div 2), SurfaceY(GTop + (GHeight -nTextHeight) div 2), tStr, Color, clBlack, [fsBold]);
        end;
        AspTextureFonts.SetFont(g_sCurFontName, 9);
      end;
   end;
end;

procedure TFrmDlg.DSSrvCloseClick(Sender: TObject; X, Y: Integer);
begin
   DSelServerDlg.Visible := FALSE;
   FrmMain.Close;
end;
{------------------------------------------------------------------------}
//新帐号
procedure TFrmDlg.DNewAccountOkClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewAccountOk;
end;

procedure TFrmDlg.DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewAccountClose;
end;

procedure TFrmDlg.DNewAccountDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   i: integer;
begin
  with DNewAccount do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  if NAHelps.Count > 0 then //20080629
  for i:=0 to NAHelps.Count-1 do AspTextureFont.TextOut(476, 186 + i*14, NAHelps[I], clSilver);
  AspTextureFont.BoldTextOut (362, 121, NewAccountTitle, clWhite, clBlack);
end;


{------------------------------------------------------------------------}
////Chg pw 冠胶

procedure TFrmDlg.DChgpwOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DChgpwOk then LoginScene.ChgpwOk;
   if Sender = DChgpwCancel then LoginScene.ChgpwCancel;
end;



{------------------------------------------------------------------------}
//某腐磐 急琶

procedure TFrmDlg.DscSelect1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if Downed and (WLib <> nil) then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (GLeft, GTop, d.ClientRect, d, TRUE);
      end;
   end;
end;



procedure TFrmDlg.DscSelect1Click(Sender: TObject; X, Y: Integer);
begin
   if Sender = DscSelect1 then SelectChrScene.SelChrSelect1Click;
   if Sender = DscSelect2 then SelectChrScene.SelChrSelect2Click;
   if Sender = DscStart then if DscStart.Enabled then SelectChrScene.SelChrStartClick;
   if Sender = DscNewChr then SelectChrScene.SelChrNewChrClick;
   if Sender = DscEraseChr then SelectChrScene.SelChrEraseChrClick;
   if Sender = DscCredits then SelectChrScene.SelChrCreditsClick;
   if Sender = DscExit then SelectChrScene.SelChrExitClick;
end;
{------------------------------------------------------------------------}
//货 某腐磐 父甸扁 芒

procedure TFrmDlg.DccCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if Downed then begin
         if WLib <> nil then begin //20080701
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         end;
      end else begin
         d := nil;
         if Sender = DccWarrior then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Job = 0 then d := WLib.Images[55];
         end;
         if Sender = DccWizzard then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Job = 1 then d := WLib.Images[56];
         end;
         if Sender = DccMonk then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Job = 2 then d := WLib.Images[57];
         end;
         if Sender = DccMale then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Sex = 0 then d := WLib.Images[58];
         end;
         if Sender = DccFemale then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Sex = 1 then d := WLib.Images[59];
         end;
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DccCloseClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DccClose then SelectChrScene.SelChrNewClose;
   if Sender = DccWarrior then SelectChrScene.SelChrNewJob (0);
   if Sender = DccWizzard then SelectChrScene.SelChrNewJob (1);
   if Sender = DccMonk then SelectChrScene.SelChrNewJob (2);
   if Sender = DccReserved then SelectChrScene.SelChrNewJob (3);
   if Sender = DccMale then SelectChrScene.SelChrNewm_btSex (0);
   if Sender = DccFemale then SelectChrScene.SelChrNewm_btSex (1);
   if Sender = DccLeftHair then SelectChrScene.SelChrNewPrevHair;
   if Sender = DccRightHair then SelectChrScene.SelChrNewNextHair;
   if Sender = DccOk then SelectChrScene.SelChrNewOk;
end;

//人物信息栏绘画 2007.10.20...
procedure TFrmDlg.DStateWinDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, l, m, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv: integer;
  pm: PTClientMagic;
  d: TAsphyreLockableTexture;
  old, keyimg: integer;
  rc: TRect;
  {$IF M2Version = 2}
  iname, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: Integer;
  {$IFEND}
  MagColor: TColor;
begin
  if g_MySelf = nil then exit;
  {$IF M2Version <> 2}
  DLiquorProgress.Visible := False;
  DBJDSee.Visible := False;
  {$IFEND}
  HBExp.Visible := False;
  JQExp.Visible := False;
  with DStateWin do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    {$IF M2Version <> 2}
    if not g_boIsInternalForce then begin
      if not g_boNewStateWin then begin
        d:=g_WUiMainImages.Images[29];
        if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end else begin
      if StateTab = 0 then begin
        d := g_WMain2Images.Images[744];
      end else begin
        d := g_WMain2Images.Images[745];
      end;
      if d <> nil then dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+31, d.ClientRect, d, TRUE);
    end;
    //侧边导航
    if DStateSsas.Visible then begin
      with DStateSsas do begin
        if WLib <> nil then begin //20080701
          if StateTab = 0 then begin
            d := WLib.Images[FaceIndex + StatePage];
          end else begin
            d := WLib.Images[FaceIndex + 10 + InternalForcePage];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if StateTab = 0 then begin
          if StatePage = 0 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $00A8D4E8, clBlack, '装', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+21, $00A8D4E8, clBlack, '备', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $00708CA0, clBlack, '装', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+21, $00708CA0, clBlack, '备', [fsBold]);
          end;
          if StatePage = 1 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+56, $00A8D4E8, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+69, $00A8D4E8, clBlack, '态', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+56, $00708CA0, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+69, $00708CA0, clBlack, '态', [fsBold]);
          end;
          if StatePage = 2 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+102, $00A8D4E8, clBlack, '属', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+115, $00A8D4E8, clBlack, '性', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+102, $00708CA0, clBlack, '属', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+115, $00708CA0, clBlack, '性', [fsBold]);
          end;
          if StatePage = 3 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+146, $00A8D4E8, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+159, $00A8D4E8, clBlack, '能', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+146, $00708CA0, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+159, $00708CA0, clBlack, '能', [fsBold]);
          end;
          if StatePage = 4 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+190, $00A8D4E8, clBlack, '出', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+203, $00A8D4E8, clBlack, '战', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+190, $00708CA0, clBlack, '出', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+203, $00708CA0, clBlack, '战', [fsBold]);
          end;
        end else begin
          if InternalForcePage = 0 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $0048A4E8, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+22, $0048A4E8, clBlack, '态', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $006098B8, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+22, $006098B8, clBlack, '态', [fsBold]);
          end;
          if InternalForcePage = 1 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+58, $0048A4E8, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+72, $0048A4E8, clBlack, '能', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+58, $006098B8, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+72, $006098B8, clBlack, '能', [fsBold]);
          end;
          {$IF M2Version = 1}
          if InternalForcePage = 2 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+105, $0048A4E8, clBlack, '经', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+119, $0048A4E8, clBlack, '络', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+105, $006098B8, clBlack, '经', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+119, $006098B8, clBlack, '络', [fsBold]);
          end;
          if InternalForcePage = 3 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+151, $0048A4E8, clBlack, '连', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+165, $0048A4E8, clBlack, '击', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+151, $006098B8, clBlack, '连', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+165, $006098B8, clBlack, '击', [fsBold]);
          end;
          {$IFEND}
        end;
      end;
    end;
    {$IFEND}

    case StateTab of
      0: begin
        case StatePage of
          0: begin //自己装备  2007.10.16 
            {$IF M2Version = 2} //1.76
            pgidx := 376;              //无4格
            if g_MySelf <> nil then
               if g_MySelf.m_btSex = 1 then pgidx := 377;  //女4格  2007.10.16 
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMainImages.Images[pgidx];
            {$ELSE}
            pgidx := 29;              //男4格  2007.10.16 
            if g_MySelf <> nil then
               if g_MySelf.m_btSex = 1 then pgidx := 30;  //女4格  2007.10.16 
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMain3Images.Images[pgidx];
            {$IFEND}
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx - 7;
            bby := bby + 44;
            if g_UseItems[U_DRESS].ClientItem.S.Name <> '' then begin //衣服
              idx := g_UseItems[U_DRESS].ClientItem.S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                case idx of
                  2420..2421: begin
                    d := FrmMain.GetWStateImg(idx+5,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2540,2542: begin  //传奇神甲
                    d := FrmMain.GetWStateImg(idx+1,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2592: begin //天外飞仙
                    if GetTickCount - g_DrawUseItems[U_DRESS].dwDrawTick >= 100 then begin
                      g_DrawUseItems[U_DRESS].dwDrawTick := GetTickCount;
                      Inc(g_DrawUseItems[U_DRESS].nIndex);
                      if g_DrawUseItems[U_DRESS].nIndex > 19 then g_DrawUseItems[U_DRESS].nIndex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2600+g_DrawUseItems[U_DRESS].nIndex,ax,ay);
                    if d <> nil then begin
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                    end;
                  end;
                end;
              end;
            end;
           //自己人物发型  2007.10.16 
            idx := 1799; 
            if g_MySelf.m_btSex = 1 then  idx := 2399;
            if g_MySelf.m_btSex = 0 then begin  //男
              if g_MySelf.m_btHair <> 0 then begin
                if idx > 0 then begin
                  d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                  if d <> nil then
                    dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end;
            end else if g_MySelf.m_btHair <> 1 then begin
              if idx > 0 then begin
                d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
              end;
            end else begin
              d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
            if g_UseItems[U_WEAPON].ClientItem.S.Name <> '' then begin
              idx := g_UseItems[U_WEAPON].ClientItem.S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                case idx of
                  1404: begin //金牛道剑
                    d := FrmMain.GetWStateImg(1403,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  1880: begin //倚天
                    if GetTickCount - WeaponTimeTick > 200 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 9 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(1890+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2423: begin //主宰神剑
                    d := FrmMain.GetWStateImg(2427,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2523: begin  //传奇神剑
                    if GetTickCount - WeaponTimeTick > 200 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 7 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2530+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2524: begin //传奇宝扇
                    if GetTickCount - WeaponTimeTick > 100 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 9 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2550+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2525: begin //传奇神剑
                    if GetTickCount - WeaponTimeTick > 100 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 9 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2560+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                end;
              end;
            end;
            //斗笠 20080417
            if g_UseItems[U_ZHULI].ClientItem.S.Name <> '' then begin
              if g_UseItems[U_ZHULI].ClientItem.S.Shape <> 2  then begin
                idx := g_UseItems[U_ZHULI].ClientItem.S.Looks;
                if idx >= 0 then begin
                  d := FrmMain.GetWStateImg(idx,ax,ay);
                  if d <> nil then
                     dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end else begin     //黑巾
                if (g_UseItems[U_HELMET].ClientItem.S.Looks = 103) or (g_UseItems[U_HELMET].ClientItem.S.Looks = 106) or (g_UseItems[U_HELMET].ClientItem.S.Looks = 344) or (g_UseItems[U_HELMET].ClientItem.S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
                  if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                    idx := g_UseItems[U_HELMET].ClientItem.S.Looks;
                    if idx >= 0 then begin
                      d := FrmMain.GetWStateImg(idx,ax,ay);
                      if d <> nil then
                        dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                  idx := g_UseItems[U_ZHULI].ClientItem.S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                end else begin
                  idx := g_UseItems[U_ZHULI].ClientItem.S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                    dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                  if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                    idx := g_UseItems[U_HELMET].ClientItem.S.Looks;
                    if idx >= 0 then begin
                      d := FrmMain.GetWStateImg(idx,ax,ay);
                      if d <> nil then
                         dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                end;

              end;
              if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //金牛头盔
                if g_UseItems[U_HELMET].ClientItem.S.Looks = 1685 then begin
                  d := g_WMainImages.Images[StateItemEffect(1) + 620];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+77), SurfaceY(bby-11), d);
                end else if g_UseItems[U_HELMET].ClientItem.S.Looks = 2133 then begin  //虎威
                  d := g_WUI1Images.GetCachedImage(StateItemEffect(2) + 220, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax+69), SurfaceY(bby+ay-16), d);
                end else if g_UseItems[U_HELMET].ClientItem.S.Looks = 2415 then begin  //主宰
                  d := g_WStateEffectImages.GetCachedImage(StateItemEffect(3) + 580, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax)+72, SurfaceY(bby+ay)-14, d);
                end;
              end;
            end else
            if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
              idx := g_UseItems[U_HELMET].ClientItem.S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                if g_UseItems[U_HELMET].ClientItem.S.Looks = 1685 then begin //金牛头盔
                  d := g_WMainImages.Images[StateItemEffect(1) + 620];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax+2), SurfaceY(bby+ay-1), d);
                end else if g_UseItems[U_HELMET].ClientItem.S.Looks = 2133 then begin //虎威
                  d := g_WUI1Images.GetCachedImage(StateItemEffect(2) + 220, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax+69), SurfaceY(bby+ay-16), d);
                end else if g_UseItems[U_HELMET].ClientItem.S.Looks = 2415 then begin  //主宰
                  d := g_WStateEffectImages.GetCachedImage(StateItemEffect(3) + 580, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax)+72, SurfaceY(bby+ay)-14, d);
                end;
              end;
            end;
          end;
          1: begin //状态值
            l := GLeft + 110; //66;
            m := GTop + 97;
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+0), IntToStr(LoWord(g_MySelf.m_Abil.AC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.AC)), clWhite, clBlack);
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+20), IntToStr(LoWord(g_MySelf.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MAC)), clWhite, clBlack);
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+40), IntToStr(LoWord(g_MySelf.m_Abil.DC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.DC)), clWhite, clBlack);
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+60), IntToStr(LoWord(g_MySelf.m_Abil.MC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MC)), clWhite, clBlack);
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+80), IntToStr(LoWord(g_MySelf.m_Abil.SC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.SC)), clWhite, clBlack);
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+100), IntToStr(g_MySelf.m_Abil.HP) + '/' + IntToStr(g_MySelf.m_Abil.MaxHP), clWhite, clBlack);
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+120), IntToStr(g_MySelf.m_Abil.MP) + '/' + IntToStr(g_MySelf.m_Abil.MaxMP), clWhite, clBlack);
            {$IF M2Version <> 2}
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+140), IntToStr(g_MySelf.m_Abil.MedicineValue) + '/' + IntToStr(g_MySelf.m_Abil.MaxMedicineValue), clWhite, clBlack);//20080624
            AspTextureFont.BoldTextOut(SurfaceX(l), SurfaceY(m+160), IntToStr(g_MySelf.m_Abil.MaxAlcohol), clWhite, clBlack);
            DLiquorProgress.Visible := True;
            {$IFEND}
          end;
          2: begin //人物属性数值
            bbx := GLeft + 38;
            bby := GTop + 52;
            {$IF M2Version = 2} //1.76
            d := g_WMainImages.Images[382];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx + 19;
            bby := bby + 2;
            mmx := bbx + 84;
            AspTextureFont.BoldTextOut (bbx, bby, '当前经验', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby, IntToStr(g_MySelf.m_Abil.Exp), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*1, '升级经验', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*1, IntToStr(g_MySelf.m_Abil.MaxExp), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*2, '背包重量', clSilver, clBlack);
            if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
              AspTextureFont.BoldTextOut (mmx, bby+13*2, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight), clRed, clBlack)
            else
            AspTextureFont.BoldTextOut (mmx, bby+13*2, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*3, '穿戴重量', clSilver, clBlack);
            if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
              AspTextureFont.BoldTextOut (mmx, bby+13*3, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight), clRed, clBlack)
            else
            AspTextureFont.BoldTextOut (mmx, bby+13*3, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*4, '腕力', clSilver, clBlack);
            if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
              AspTextureFont.BoldTextOut (mmx, bby+13*4, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight), clRed, clBlack)
            else
            AspTextureFont.BoldTextOut (mmx, bby+13*4, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*5, '精确度', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*5, IntToStr(g_nMyHitPoint), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*6, '敏捷度', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*6, IntToStr(g_nMySpeedPoint), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*7, '魔法防御', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*7, '+' + IntToStr(g_nMyAntiMagic * 10) + '%', clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*8, '中毒防御', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*8, '+' + IntToStr(g_nMyAntiPoison * 10) + '%', clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*9, '中毒恢复', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*9, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*9, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%', clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*10, '体力恢复', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*10, '+' + IntToStr(g_nMyHealthRecover * 10) + '%', clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*11, '魔法恢复', clSilver, clBlack);
            AspTextureFont.BoldTextOut (mmx, bby+13*11, '+' + IntToStr(g_nMySpellRecover * 10) + '%', clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*12, g_sGameDiaMond+'数', clSilver, clBlack); //金刚石
            AspTextureFont.BoldTextOut (mmx, bby+13*12, IntToStr(g_MySelf.m_nGameDiaMond), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*13, g_sGameGird+'数量', clSilver, clBlack); //灵符
            AspTextureFont.BoldTextOut (mmx, bby+13*13, IntToStr(g_MySelf.m_nGameGird), clSilver, clBlack);
            AspTextureFont.BoldTextOut (bbx, bby+13*14, clYellow, clBlack, g_sGameGoldName+'数量'); //元宝
            AspTextureFont.BoldTextOut (mmx, bby+13*14, clYellow, clBlack, IntToStr(g_MySelf.m_nGameGold));
            AspTextureFont.BoldTextOut (bbx, bby+13*15, clSilver, clBlack, g_sGamePointName+'数量'); //荣耀点
            AspTextureFont.BoldTextOut (mmx, bby+13*15, clSilver, clBlack, IntToStr(g_MySelf.m_nGamePoint));
            if g_dGamePointDate <> 32590 then
               AspTextureFont.BoldTextOut(bbx, bby+13*16, clYellow, clBlack, g_sGamePointName+'截止时间'+ FormatDateTime('mm月dd日24时', g_dGamePointDate));

            {$ELSE}
            d := g_WMain3Images.Images[32];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx + 19;
            bby := bby + 9;
            mmx := bbx + 84;
            AspTextureFont.BoldTextOut (bbx, bby, clSilver, clBlack, '当前经验');
            AspTextureFont.BoldTextOut (mmx, bby, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.Exp));
            AspTextureFont.BoldTextOut (bbx, bby+14*1, clSilver, clBlack, '升级经验');
            AspTextureFont.BoldTextOut (mmx, bby+14*1, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.MaxExp));
            AspTextureFont.BoldTextOut (bbx, bby+14*2, clSilver, clBlack, '背包重量');
            if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
              AspTextureFont.BoldTextOut (mmx, bby+14*2, clRed, clBlack, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight))
            else
            AspTextureFont.BoldTextOut (mmx, bby+14*2, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight));
            AspTextureFont.BoldTextOut (bbx, bby+14*3, clSilver, clBlack, '穿戴重量');
            if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
              AspTextureFont.BoldTextOut (mmx, bby+14*3, clRed, clBlack, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight))
            else
            AspTextureFont.BoldTextOut (mmx, bby+14*3, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight));
            AspTextureFont.BoldTextOut (bbx, bby+14*4, clSilver, clBlack, '腕力');
            if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
              AspTextureFont.BoldTextOut (mmx, bby+14*4, clRed, clBlack, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight))
            else
            AspTextureFont.BoldTextOut (mmx, bby+14*4, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight));
            AspTextureFont.BoldTextOut (bbx, bby+14*5, clSilver, clBlack, '精确度');
            AspTextureFont.BoldTextOut (mmx, bby+14*5, clSilver, clBlack, IntToStr(g_nMyHitPoint));
            AspTextureFont.BoldTextOut (bbx, bby+14*6, clSilver, clBlack, '敏捷度');
            AspTextureFont.BoldTextOut (mmx, bby+14*6, clSilver, clBlack, IntToStr(g_nMySpeedPoint));
            AspTextureFont.BoldTextOut (bbx, bby+14*7, clSilver, clBlack, '魔法防御');
            AspTextureFont.BoldTextOut (mmx, bby+14*7, clSilver, clBlack, '+' + IntToStr(g_nMyAntiMagic * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*8, clSilver, clBlack, '中毒防御');
            AspTextureFont.BoldTextOut (mmx, bby+14*8, clSilver, clBlack, '+' + IntToStr(g_nMyAntiPoison * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*9, clSilver, clBlack, '中毒恢复');
            AspTextureFont.BoldTextOut (mmx, bby+14*9, clSilver, clBlack, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');
            AspTextureFont.BoldTextOut (mmx, bby+14*9, clSilver, clBlack, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*10, clSilver, clBlack, '体力恢复');
            AspTextureFont.BoldTextOut (mmx, bby+14*10, clSilver, clBlack, '+' + IntToStr(g_nMyHealthRecover * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*11, clSilver, clBlack, '魔法恢复');
            AspTextureFont.BoldTextOut (mmx, bby+14*11, clSilver, clBlack, '+' + IntToStr(g_nMySpellRecover * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*12, clSilver, clBlack, g_sGameDiaMond+'数'); //金刚石
            AspTextureFont.BoldTextOut (mmx, bby+14*12, clSilver, clBlack, IntToStr(g_MySelf.m_nGameDiaMond));
            AspTextureFont.BoldTextOut (bbx, bby+14*13, clSilver, clBlack, g_sGameGird+'数量'); //灵符
            AspTextureFont.BoldTextOut (mmx, bby+14*13, clSilver, clBlack, IntToStr(g_MySelf.m_nGameGird));
            AspTextureFont.BoldTextOut (bbx, bby+14*14, clSilver, clBlack, g_sGameGoldName+'数量'); //元宝
            AspTextureFont.BoldTextOut (mmx, bby+14*14, clYellow, clBlack, IntToStr(g_MySelf.m_nGameGold));
            AspTextureFont.BoldTextOut (bbx, bby+14*15, clSilver, clBlack, g_sGamePointName+'数量'); //荣耀点
            AspTextureFont.BoldTextOut (mmx, bby+14*15, clSilver, clBlack, IntToStr(g_MySelf.m_nGamePoint));
            if g_dGamePointDate <> 32590 then
              AspTextureFont.BoldTextOut(mmx, bby+13*16, clYellow, clBlack, g_sGamePointName+'截止时间'+ FormatDateTime('mm月dd日24时', g_dGamePointDate));
            {$IFEND}
          end;
          3: begin //魔法背景
            bbx := GLeft + 38;
            bby := GTop + 52;
            //虐 钎矫, lv, exp
            {$IF M2Version = 2}
            d := g_WMainImages.Images[383];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            magtop := MagicPage * 5;
            magline := _MIN(MagicPage*5+5, g_MagicList.Count);
            {$ELSE}
            d := g_WMain3Images.Images[33];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
              dsurface.Draw(SurfaceX(bbx)+6, SurfaceY(bby)+190, Rect(6, 153, 39, 191), d, False);
            end;
            magtop := MagicPage * 6;
            magline := _MIN(MagicPage*6+6, g_MagicList.Count);
            {$IFEND}
            for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_MagicList[i]);
              m := i - magtop;
              keyimg := 0;
              case byte(pm.Key) of
                byte('1'): keyimg := 156;
                byte('2'): keyimg := 157;
                byte('3'): keyimg := 158;
                byte('4'): keyimg := 159;
                byte('5'): keyimg := 160;
                byte('6'): keyimg := 161;
                byte('7'): keyimg := 162;
                byte('8'): keyimg := 163;
                byte('E'): keyimg := 148;
                byte('F'): keyimg := 149;
                byte('G'): keyimg := 150;
                byte('H'): keyimg := 151;
                byte('I'): keyimg := 152;
                byte('J'): keyimg := 153;
                byte('K'): keyimg := 154;
                byte('L'): keyimg := 155;
              end;
              if keyimg > 0 then begin
                d := g_WMain3Images.Images[keyimg];
                if d <> nil then
                   dsurface.Draw (bbx + 145, bby+8+m*37, d.ClientRect, d, TRUE);
              end;
              d := g_WMainImages.Images[112]; //lv
              if d <> nil then begin
                if (pm.Def.wMagicId = 68) or (pm.Def.wMagicId = 71) then   //酒气护体,召唤圣兽
                  dsurface.Draw (bbx + 110, bby+15+m*37-7, d.ClientRect, d, TRUE)
                else dsurface.Draw (bbx + 48, bby+23+m*37, d.ClientRect, d, TRUE);
              end;
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then begin
                if (pm.Def.wMagicId <> 68) and (pm.Def.wMagicId <> 71)  then
                dsurface.Draw (bbx + 74, bby+23+m*37, d.ClientRect, d, TRUE);
              end;
              case pm.Def.wMagicId of
                68: begin
                  if (pm.Level < 100) then begin
                    JQExp.GLeft := 86;
                    JQExp.GTop := 79+m*37;
                    if not JQExp.Visible then JQExp.Visible := True;
                  end;
                end;
                71: begin
                  if (pm.Level < 100) then begin
                    HBExp.GLeft := 86;
                    HBExp.GTop := 79+m*37;
                    if not HBExp.Visible then HBExp.Visible := True;
                  end;
                end;
                {$IF M2Version <> 2}
                100: begin //神秘解读
                  DBJDSee.GLeft := 160;
                  DBJDSee.GTop := 60+m*37;
                  if not DBJDSee.Visible then DBJDSee.Visible := True;
                end;
                {$IFEND}
              end;
            end;

            for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_MagicList[i]);
              m := i - magtop;
              if not (pm.Def.wMagicId in [68,71,95,100,104])then
              if not (pm.Level in [0..4]) then pm.Level := 0;
              AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName);
              if pm.Def.wMagicId = 95 then begin //斗转星移
                AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
                Continue;//继续
              end else if pm.Def.wMagicId = 100 then begin //强身术
                trainlv := pm.Level;
                AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                if pm.Level = 15 then
                  AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-')
                else AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else if pm.Def.wMagicId = 103 then begin //召唤巨魔
                trainlv := pm.Level;
                AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
                Continue;//继续
              end else if pm.Def.wMagicId = 104 then begin
                AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                if pm.Level = 100 then
                  AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-')
                else AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else if (pm.Def.wMagicId = 68) or (pm.Def.wMagicId = 71) then begin
                trainlv := pm.Level;
                AspTextureFont.BoldTextOut (bbx + 125, bby + 15 + m*37-8, clSilver, clBlack, IntToStr(pm.Level));
              end else begin
                if pm.Level in [0..4] then trainlv := pm.Level
                else trainlv := 0;
                AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
              end;
              if trainlv = 4 then begin
                if (pm.Def.wMagicId <> 68) and (pm.Def.wMagicId <> 71) then
                AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
              end else
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if (pm.Def.wMagicId <> 68) and (pm.Def.wMagicId <> 71) then begin
                  if trainlv < 3 then
                    AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
                end;
              end;
            end;
          end;
          4: begin  //出战
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMain3Images.Images[32];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
          end;
        end;
      end;
      1: begin
        case InternalForcePage of
          0: begin
            d := g_WMain2Images.Images[741];
            if d<>nil then begin
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (SurfaceX(GLeft) + 38, SurfaceY(GTop) + 52, rc, d, False);
            end;
            d:=g_WMain2Images.Images[752];
            if d<>nil then
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 110, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 135, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 160, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 185, d.ClientRect, d, TRUE);

            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 210, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 235, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 260, d.ClientRect, d, TRUE);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 112, clSilver, clBlack, '当前内功等级');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 137, clSilver, clBlack, '当前内功经验');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 162, clSilver, clBlack, '升级内功经验');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 187, clSilver, clBlack, '内 力 值');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 212, clSilver, clBlack, '内功恢复速度');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 237, clSilver, clBlack, '内功伤害增加');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 262, clSilver, clBlack, '内功伤害减免');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 112, clSilver, clBlack, IntToStr(g_dwInternalForceLevel));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 137, clSilver, clBlack, IntToStr(g_dwExp69));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 162, clSilver, clBlack, IntToStr(g_dwMaxExp69));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 187, clSilver, clBlack, IntToStr(g_MySelf.m_Skill69NH)+'/'+IntToStr(g_MySelf.m_Skill69MaxNH));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 212, clSilver, clBlack, IntToStr(g_nInternalRecovery));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 237, clSilver, clBlack, IntToStr(g_nInternalHurtAdd));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 262, clSilver, clBlack, IntToStr(g_nInternalHurtRelief));
          end;
          1: begin
            d := g_WMain2Images.Images[743];
            if d<>nil then begin
              bbx := GLeft + 38;
              bby := GTop + 52;
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (bbx, bby, rc, d, False);

              //虐 钎矫, lv, exp
              magtop := InternalForceMagicPage * 6;
              magline := _MIN(InternalForceMagicPage*6+6, g_InternalForceMagicList.Count);
              for i:=magtop to magline-1 do begin
                pm := PTClientMagic (g_InternalForceMagicList[i]);
                m := i - magtop;
                {d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
                if d <> nil then
                  dsurface.Draw (bbx + 8, bby+7+m*37, d.ClientRect, d, TRUE);   }
                d := g_WMainImages.Images[112]; //lv
                if d <> nil then
                  dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);
                d := g_WMainImages.Images[111]; //exp
                if d <> nil then begin
                  if pm.Def.wMagicId <> 68 then
                  dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
                end;
              end;
              for i:=magtop to magline-1 do begin
                pm := PTClientMagic (g_InternalForceMagicList[i]);
                if word(pm.Key) = 0 then MagColor := clSilver else MagColor := clGray;
                m := i - magtop;
                if not (pm.Level in [0..30]) then pm.Level := 0;
                if word(pm.Key) = 0 then
                	AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName)
              	else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName+'[关]');
                if pm.Level in [0..30] then trainlv := pm.Level
                else trainlv := 0;
                AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < 3 then
                    AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, MagColor, clBlack, '-');
                end;
              end;
            end;
          end;
        end;
      end;
    end;

    {$IF M2Version <> 2} //not 1.76
    //本代码为显示人物身上所带物品信息，显示位置为人物下方
    if g_BatterDesc.sName <> '' then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309), clYellow, clBlack, g_BatterDesc.sName);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36 + AspTextureFont.TextWidth(g_BatterDesc.sName)), SurfaceY(GTop+309), clWhite, clBlack, g_BatterDesc.sLine1);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+AspTextureFont.TextHeight('A')+2), clWhite, clBlack, g_BatterDesc.sLine2);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+(AspTextureFont.TextHeight('A')+2)*2), clWhite, clBlack, g_BatterDesc.sLine3);
    end;
    (*{$ELSE}
    if g_MouseStateItem.ClientItem.S.Name <> '' then begin
      g_MouseItem := g_MouseStateItem;
      GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
      if iname <> '' then begin
        if g_MouseItem.Dura = 0 then hcolor := clRed
        else hcolor := clWhite;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272), clYellow, clBlack,iname);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft+36+ AspTextureFont.TextWidth(iname)), SurfaceY(GTop+272), hcolor, clBlack,d1);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272+AspTextureFont.TextHeight('A')+2), hcolor, clBlack,d2);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272+(AspTextureFont.TextHeight('A')+2)*2), hcolor, clBlack,d3);
      end;
      g_MouseItem.ClientItem.S.Name := '';
    end;  *)
    {$IFEND}
    if g_boIsInternalForce then begin
      AspTextureFont.TextOut(SurfaceX(GLeft + 122 - AspTextureFont.TextWidth(FrmMain.CharName) div 2),
                       SurfaceY(GTop + 16), g_MySelf.m_nNameColor, g_MySelf.m_sUserName)
    end else begin
      AspTextureFont.TextOut(SurfaceX(GLeft + 122 - AspTextureFont.TextWidth(FrmMain.CharName) div 2),
                       SurfaceY(GTop + 23), g_MySelf.m_nNameColor, g_MySelf.m_sUserName);
    end;
    if (StatePage = 0) and (StateTab = 0{基本页}) then begin
      AspTextureFont.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
               clSilver, g_sGuildName + ' ' + g_sGuildRankName);
    end;
  end;
end;

procedure TFrmDlg.DSWBujukDblClick(Sender: TObject);
var
  msg: TDefaultMessage;
begin
  //存放罐物品的扩展   20080315
  if (g_UseItems[U_BUJUK].ClientItem.S.StdMode = 2) and (g_UseItems[U_BUJUK].ClientItem.S.AniCount = 21) then begin
    if Sender = DSWBujuk then begin
      if g_UseItems[U_BUJUK].ClientItem.Dura < g_UseItems[U_BUJUK].ClientItem.DuraMax then begin
         msg := MakeDefaultMsg (aa(CM_DBLREPAIRDRAGON, frmMain.TempCertification),0, 0, 0, 0, frmMain.m_nSendMsgCount);//20071231
         FrmMain.SendSocket (EncodeMessage (msg));//20071231
       end;
    end;
  end;
end;

procedure TFrmDlg.DSWLightDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   idx, nWhere, EffIdx: integer;
   d: TAsphyreLockableTexture;
begin
  nWhere := -1;
  if (StateTab = 0{基本页}) and (StatePage = 0) then begin
    if Sender = DSWNecklace then nWhere := U_NECKLACE;
    if Sender = DSWLight then nWhere := U_RIGHTHAND;
    if Sender = DSWArmRingR then nWhere := U_ARMRINGR;
    if Sender = DSWArmRingL then nWhere := U_ARMRINGL;
    if Sender = DSWRingR then nWhere := U_RINGR;
    if Sender = DSWRingL then nWhere := U_RINGL;
    if Sender = DSWBujuk then nWhere := U_BUJUK;
    if Sender = DSWBelt then nWhere := U_BELT;
    if Sender = DSWBoots then nWhere := U_BOOTS;
    if Sender = DSWCharm then nWhere := U_CHARM;

    if nWhere >= 0 then begin
      if g_UseItems[nWhere].ClientItem.S.Name <> '' then begin
        idx := g_UseItems[nWhere].ClientItem.S.looks;
        if idx >= 0 then begin
          d := frmMain.GetWStateImg(idx);
          if d <> nil then begin
            with TAspDButton(Sender) do begin
              dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                            SurfaceY(GTop + (GHeight - d.Height) div 2),
                            d.ClientRect, d, TRUE);
              case idx of
                1680..1684, 1686: begin  //金牛效果
                  d := g_WMainImages.Images[StateItemEffect(0) + 640];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(GLeft-10), SurfaceY(GTop-10), d);
                end;
                2130..2132,2134..2136: begin //虎威
                  case idx of
                    2130: EffIdx := 100; //手镯
                    2131: EffIdx := 140; //戒指
                    2132: EffIdx := 180; //项链
                    2134: EffIdx := 260; //靴子
                    2135: EffIdx := 300; //腰带
                    2136: EffIdx := 340; //勋章
                    else EffIdx := 0;
                  end;
                  d := g_WUI1Images.Images[StateItemEffect(2) + EffIdx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(GLeft-8), SurfaceY(GTop-8), d);
                end;
                2410..2414, 2416: begin  //主宰
                  case idx of
                    2410: Effidx := 530; //戒指
                    2411: EffIdx := 540; //手镯
                    2412: EffIdx := 550; //项链
                    2413: EffIdx := 560; //靴子
                    2414: EffIdx := 570; //腰带
                    2416: EffIdx := 590; //勋章
                    else EffIdx := 0;
                  end;
                  d := g_WStateEffectImages.Images[StateItemEffect(3) + Effidx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(GLeft-4), SurfaceY(GTop-4), d);
                end;
                2623: begin
                  if GetTickCount - g_DrawUseItems[nWhere].dwDrawTick >= 100 then begin
                    g_DrawUseItems[nWhere].dwDrawTick := GetTickCount;
                    Inc(g_DrawUseItems[nWhere].nIndex);
                    if g_DrawUseItems[nWhere].nIndex > 14 then g_DrawUseItems[nWhere].nIndex := 0;
                  end;
                  d := FrmMain.GetWStateImg(2630+g_DrawUseItems[nWhere].nIndex);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)-8, SurfaceY(GTop)-14, d);
                  end;
                end;
                2624: begin
                  if GetTickCount - g_DrawUseItems[nWhere].dwDrawTick >= 100 then begin
                    g_DrawUseItems[nWhere].dwDrawTick := GetTickCount;
                    Inc(g_DrawUseItems[nWhere].nIndex);
                    if g_DrawUseItems[nWhere].nIndex > 14 then g_DrawUseItems[nWhere].nIndex := 0;
                  end;
                  d := FrmMain.GetWStateImg(2650+g_DrawUseItems[nWhere].nIndex);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)-10, SurfaceY(GTop)-14, d);
                  end;
                end
                else begin
                  if g_UseItems[nWhere].ClientItem.S.Reserved1 = 1 then begin
                    ItemLightTimeImg(); //物品发光变换函数 20080223
                    d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(GLeft-21), SurfaceY(GTop-23), d);
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateWinClick(Sender: TObject; X, Y: Integer);
begin
   if StatePage = 3 then begin
      X := DStateWin.LocalX (X) - DStateWin.GLeft;
      Y := DStateWin.LocalY (Y) - DStateWin.GTop;
      if (X >= 33) and (X <= 33+166) and (Y >= 55) and (Y <= 55+37*5) then begin
         magcur := (Y-55) div 37;
         if (magcur+magtop) >= g_MagicList.Count then
            magcur := (g_MagicList.Count-1) - magtop;
      end;
   end;
end;

procedure TFrmDlg.DCloseStateClick(Sender: TObject; X, Y: Integer);
begin
   DStateWin.Visible := FALSE;
end;

procedure TFrmDlg.DPrevStateDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if TAspDButton(Sender).Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.PageChanged;
{$IF M2Version <> 2}
var
  TitleVisible: Boolean;
{$IFEND}
begin
   DScreen.ClearHint;
   {$IF M2Version <> 2}
   TitleVisible := (StatePage = 0) and (StateTab = 0);
   DBTitleMan.Visible := TitleVisible;
   DBTitle1.Visible := TitleVisible;
   DBTitle2.Visible := TitleVisible;
   DBTitle3.Visible := TitleVisible;
   DBTitle4.Visible := TitleVisible;
   DBPrevTitle.Visible := TitleVisible;
   DBNextTitle.Visible := TitleVisible;
   DLNGUpLevel1.Visible := False;
   DLNGUpLevel2.Visible := False;
   DLNGUpLevel3.Visible := False;
   DLNGUpLevel4.Visible := False;
   DLNGUpLevel5.Visible := False;
   DLNGUpLevel6.Visible := False;
   {$IFEND}
   case StatePage of
      3: begin //魔法 惑怕芒
         DStMag1.Visible := TRUE;  DStMag2.Visible := TRUE;
         DStMag3.Visible := TRUE;  DStMag4.Visible := TRUE;
         DStMag5.Visible := TRUE;  {$IF M2Version <> 2}DStMag6.Visible := True;{$IFEND}
         DStPageUp.Visible := TRUE;
         DStPageDown.Visible := TRUE;
         MagicPage := 0;
          DCheckDeputyHeroWarr.Visible := FALSE;
          DCheckDeputyHeroWiz.Visible := FALSE;
          DCheckDeputyHeroTaos.Visible := FALSE;
      end;
      4: begin
         DStMag1.Visible := FALSE;  DStMag2.Visible := FALSE;
         DStMag3.Visible := FALSE;  DStMag4.Visible := FALSE;
         DStMag5.Visible := FALSE;  {$IF M2Version <> 2}DStMag6.Visible := False;{$IFEND}
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
        DCheckDeputyHeroWarr.Visible := True;
        DCheckDeputyHeroWiz.Visible := True;
        DCheckDeputyHeroTaos.Visible := True;

        DCheckDeputyHeroWarr.Checked := False;
        DCheckDeputyHeroWiz.Checked := False;
        DCheckDeputyHeroTaos.Checked := False;
        case m_btDeputyHeroJob of
          0: DCheckDeputyHeroWarr.Checked := True;
          1: DCheckDeputyHeroWiz.Checked := True;
          2: DCheckDeputyHeroTaos.Checked := True;
          else DCheckDeputyHeroWarr.Checked := True;
        end;
      end;
      else begin
         DStMag1.Visible := FALSE;  DStMag2.Visible := FALSE;
         DStMag3.Visible := FALSE;  DStMag4.Visible := FALSE;
         DStMag5.Visible := FALSE;  {$IF M2Version <> 2}DStMag6.Visible := False;{$IFEND}
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
          DCheckDeputyHeroWarr.Visible := FALSE;
          DCheckDeputyHeroWiz.Visible := FALSE;
          DCheckDeputyHeroTaos.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.InternalForcePageChanged;
begin
   DScreen.ClearHint;
   DStMag1.Visible := False;  DStMag2.Visible := False;
   DStMag3.Visible := False;  DStMag4.Visible := False;
   DStMag5.Visible := False;  {$IF M2Version <> 2}DStMag6.Visible := False;{$IFEND}
   DLNGUpLevel1.Visible := False;
   DLNGUpLevel2.Visible := False;
   DLNGUpLevel3.Visible := False;
   DLNGUpLevel4.Visible := False;
   DLNGUpLevel5.Visible := False;
   DLNGUpLevel6.Visible := False;
   DCheckDeputyHeroWarr.Visible := FALSE;
   DCheckDeputyHeroWiz.Visible := FALSE;
   DCheckDeputyHeroTaos.Visible := FALSE;
   case InternalForcePage of
      1: begin //魔法 惑怕芒
         DStPageUp.Visible := TRUE;
         DStPageDown.Visible := TRUE;
         InternalForceMagicPage := 0;
         DStateWinPulse.Visible := False;
         DStateWinBatter.Visible := False;
         DStMag1.Visible := TRUE;  DStMag2.Visible := TRUE;
         DStMag3.Visible := TRUE;  DStMag4.Visible := TRUE;
         DStMag5.Visible := TRUE;  {$IF M2Version <> 2}DStMag6.Visible := True;
         NGUpLevelState(False);{$IFEND}
      end;
      2: begin
        DStateWinPulse.Visible := True;
        DStPageUp.Visible := FALSE;
        DStPageDown.Visible := FALSE;
        DStateWinBatter.Visible := False;
      end;
      3: begin
        DStateWinPulse.Visible := False;
        DStPageUp.Visible := FALSE;
        DStPageDown.Visible := FALSE;
        DStateWinBatter.Visible := True;
      end;
      else begin
         DStateWinBatter.Visible := False;
         DStateWinPulse.Visible := False;
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.HeroInternalForcePageChanged;
begin
   DScreen.ClearHint;
   DCheckHeroDeputyHeroWarr.Visible := FALSE;
   DCheckHeroDeputyHeroWiz.Visible := FALSE;
   DCheckHeroDeputyHeroTaos.Visible := FALSE;
   DStMagHero1.Visible := FALSE;  DStMagHero2.Visible := FALSE;
   DStMagHero3.Visible := FALSE;  DStMagHero4.Visible := FALSE;
   DStMagHero5.Visible := FALSE;  DStMagHero6.Visible := FALSE;
   DLHeroNGUpLevel1.Visible := False;
   DLHeroNGUpLevel2.Visible := False;
   DLHeroNGUpLevel3.Visible := False;
   DLHeroNGUpLevel4.Visible := False;
   DLHeroNGUpLevel5.Visible := False;
   DLHeroNGUpLevel6.Visible := False;
   case HeroInternalForcePage of
      1: begin //魔法 惑怕芒
         DSHPageUp.Visible := TRUE;
         DSHPageDown.Visible := TRUE;
         HeroInternalForceMagicPage := 0;
         DHeroStateWinPulse.Visible := False;
         DHeroStateWinBatter.Visible := False;
         DStMagHero1.Visible := TRUE;  DStMagHero2.Visible := TRUE;
         DStMagHero3.Visible := TRUE;  DStMagHero4.Visible := TRUE;
         DStMagHero5.Visible := TRUE;  DStMagHero6.Visible := TRUE;
         {$IF M2Version <> 2}
         NGUpLevelState(True);
         {$IFEND}
      end;
      2: begin
        DHeroStateWinPulse.Visible := True;
        DSHPageUp.Visible := FALSE;
        DSHPageDown.Visible := FALSE;
        DHeroStateWinBatter.Visible := False;
         //DStPageUp.Visible := FALSE;
         //DStPageDown.Visible := FALSE;
      end;
      3: begin
        DHeroStateWinPulse.Visible := False;
        DSHPageUp.Visible := FALSE;
        DSHPageDown.Visible := FALSE;
        DHeroStateWinBatter.Visible := True;
         //DStPageUp.Visible := FALSE;
         //DStPageDown.Visible := FALSE;
      end;    
      else begin
         DHeroStateWinPulse.Visible := False;
         DSHPageUp.Visible := FALSE;
         DSHPageDown.Visible := FALSE;
         DHeroStateWinBatter.Visible := False;
      end;
   end;
end;

procedure TFrmDlg.DPrevStateClick(Sender: TObject; X, Y: Integer);
begin
  if StateTab = 0 then begin
    Dec (StatePage);
    if StatePage < 0 then
      StatePage := MAXSTATEPAGE-1;
    PageChanged;
  end else begin   //内功
    Dec (InternalForcePage);
    if InternalForcePage < 0 then
      InternalForcePage := 1;
    InternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DNextStateClick(Sender: TObject; X, Y: Integer);
begin
  if StateTab = 0 then begin
    Inc (StatePage);
    if StatePage > MAXSTATEPAGE-1 then
      StatePage := 0;
    PageChanged;
  end else begin //内功
    Inc (InternalForcePage);
    if InternalForcePage > 1 then
      InternalForcePage := 0;
    InternalForcePageChanged;
  end;
end;
//点击武器、衣服等装备
procedure TFrmDlg.DSWWeaponClick(Sender: TObject; X, Y: Integer);
var
   where, n, sel: integer;
   flag: Boolean;
   msg: TDefaultMessage;
begin
   if g_MySelf = nil then exit;
   (*if not g_boRightItem {如果不是右键穿戴物品} then*)  if (StateTab <> 0) or (StatePage <> 0) then exit;
   if g_boItemMoving (*or g_boRightItem{右键点物品}*) then begin
      flag := FALSE;
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Item.ClientItem.S.Name = '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
      where := GetTakeOnPosition (g_MovingItem.Item.ClientItem.S.StdMode);
      if g_MovingItem.Index >= 0 then begin

      //存放罐物品的扩展   20080315
      if ((g_UseItems[U_BUJUK].ClientItem.S.StdMode = 2) and (g_UseItems[U_BUJUK].ClientItem.S.AniCount = 21) and (Byte(g_UseItems[U_BUJUK].ClientItem.S.Source) = g_MovingItem.Item.ClientItem.S.Shape) and (g_UseItems[U_BUJUK].ClientItem.S.Shape = g_MovingItem.Item.ClientItem.S.StdMode)) and (not (g_MovingItem.Item.ClientItem.S.StdMode in [5,6,10,11])) then begin
         if Sender = DSWBujuk then begin
           g_WaitingUseItem := g_MovingItem;
           g_MovingItem.Item.ClientItem.S.Name := '';
           g_boItemMoving := False;
           msg := MakeDefaultMsg (aa(CM_REPAIRDRAGON, frmMain.TempCertification),g_WaitingUseItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
           FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.ClientItem.S.Name));//20071231
           //Exit;
         end;
      end;
      //火云石修复
      if (g_UseItems[U_BUJUK].ClientItem.S.StdMode = 25) and (g_UseItems[U_BUJUK].ClientItem.S.Shape = 10) and (g_MovingItem.Item.ClientItem.S.StdMode = 43) and (g_MovingItem.Item.ClientItem.S.Shape = 1) then begin
         if Sender = DSWBujuk then begin
            g_WaitingUseItem := g_MovingItem;
            g_MovingItem.Item.ClientItem.S.Name := '';
            g_boItemMoving := False;
            msg := MakeDefaultMsg (aa(CM_REPAIRFINEITEM, frmMain.TempCertification),g_WaitingUseItem.Item.ClientItem.MakeIndex, 0, 0, 0, frmMain.m_nSendMsgCount);//20080507
            FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.ClientItem.S.Name));//20080507
         end;
      end;
         case where of
            //衣服
            U_DRESS: begin
               if Sender = DSWDress then begin
                  if g_MySelf.m_btSex = 0 then //男的
                     if g_MovingItem.Item.ClientItem.S.StdMode <> 10 then //10男式衣服
                        exit;
                  if g_MySelf.m_btSex = 1 then //女的
                     if g_MovingItem.Item.ClientItem.S.StdMode <> 11 then //11男式衣服
                        exit;
                  flag := TRUE;
               end;
            end;
            //武器
            U_WEAPON: begin
               if Sender = DSWWEAPON then begin
                  flag := TRUE;
               end;
            end;
            //项链
            U_NECKLACE: begin
               if Sender = DSWNecklace then
                  flag := TRUE;
            end;
             //蜡烛、火把、圣牌、勋章之类的
            U_RIGHTHAND: begin
               if Sender = DSWLight then
                  flag := TRUE;
            end;
            U_HELMET: begin
            //头盔
               if Sender = DSWHelmet then  //原来代码
                  flag := TRUE;
            end;
            U_ZHULI: begin
            //斗笠
              if Sender = DSWHelmet then
                 flag := True;
            end;
            //戒指（左右都可以）
            U_RINGR, U_RINGL: begin
               if Sender = DSWRingL then begin
                  where := U_RINGL;
                  flag := TRUE;
               end;
               if Sender = DSWRingR then begin
                  where := U_RINGR;
                  flag := TRUE;
               end;
            end;
            //手镯、手套(左右都可以)
            U_ARMRINGR: begin  
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
               if Sender = DSWArmRingR then begin
                  where := U_ARMRINGR;
                  flag := TRUE;
               end;
            end;
            //护身符、药粉之类的
            U_ARMRINGL: begin  
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            //护身符、药粉之类的
            U_BUJUK: begin
               if Sender = DSWBujuk then begin
                 case g_MovingItem.Item.ClientItem.S.StdMode of
                   2: begin //祝福罐，魔令包
                     if (g_MovingItem.Item.ClientItem.S.StdMode = 2) and (g_MovingItem.Item.ClientItem.S.AniCount = 21) then
                     begin
                      where := U_BUJUK;
                      flag := TRUE;
                     end;
                   end;
                    25: begin //符
                      where := U_BUJUK;
                      flag := TRUE;
                    end;
                 end;
               end;
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            //腰带
            U_BELT: begin
               if Sender = DSWBelt then begin
                  where := U_BELT;
                  flag := TRUE;
               end;
            end;
            //鞋子
            U_BOOTS: begin
               if Sender = DSWBoots then begin
                  where := U_BOOTS;
                  flag := TRUE;
               end;
            end;
            //宝石
            U_CHARM: begin
               if Sender = DSWCharm then begin
                  where := U_CHARM;
                  flag := TRUE;
               end;
            end;
         end;
         if Sender = DSWCharm then begin
           if (g_UseItems[U_CHARM].ClientItem.S.Shape = 5) and (g_UseItems[U_CHARM].ClientItem.S.StdMode = 7) and (g_UseItems[U_CHARM].ClientItem.S.Name <> '') then begin//20090205
             case g_MovingItem.Item.ClientItem.S.StdMode of
               7: begin
                 if g_MovingItem.Item.ClientItem.S.Shape = 3 then begin
                   msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingItem.Item.ClientItem.MakeIndex, 1, 0, 0, frmMain.m_nSendMsgCount);//20071231
                   FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingItem.Item.ClientItem.S.Name));//20071231
                   Exit;
                 end;
               end;
             end;
           end;
         end;
      end else begin
         n := -(g_MovingItem.Index+1);
         if n in [0..14] then begin
            ItemClickSound (g_MovingItem.Item.ClientItem.S);
            g_UseItems[n].ClientItem := g_MovingItem.Item.ClientItem;
            g_MovingItem.Item.ClientItem.S.Name := '';
            g_boItemMoving := FALSE;
         end;
      end;
      if flag then begin
         ItemClickSound (g_MovingItem.Item.ClientItem.S);
         g_WaitingUseItem := g_MovingItem;
         g_WaitingUseItem.Index := where;
         FrmMain.SendTakeOnItem (where, g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
         g_MovingItem.Item.ClientItem.S.Name := '';
         g_boItemMoving := FALSE;
      end;
   end else begin
      if g_boHeroItemMoving then Exit;
      if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
      sel := -1;
      if Sender = DSWDress then sel := U_DRESS;
      if Sender = DSWWeapon then sel := U_WEAPON;

      //斗笠
      if Sender = DSWHelmet then begin
        if g_UseItems[U_ZHULI].ClientItem.S.Name <> '' then
         sel := U_ZHULI
        else sel := U_HELMET;
      end;

      if Sender = DSWNecklace then sel := U_NECKLACE;
      if Sender = DSWLight then sel := U_RIGHTHAND;
      if Sender = DSWRingL then sel := U_RINGL;
      if Sender = DSWRingR then sel := U_RINGR;
      if Sender = DSWArmRingL then sel := U_ARMRINGL;
      if Sender = DSWArmRingR then sel := U_ARMRINGR;

      if Sender = DSWBujuk then sel := U_BUJUK;
      if Sender = DSWBelt then sel := U_BELT;  //
      if Sender = DSWBoots then sel := U_BOOTS;
      if Sender = DSWCharm then sel := U_CHARM;

      if sel >= 0 then begin
         if g_UseItems[sel].ClientItem.S.Name <> '' then begin
            ItemClickSound (g_UseItems[sel].ClientItem.S);
            g_MovingItem.Index := -(sel+1);
            g_MovingItem.Item := g_UseItems[sel];
            g_UseItems[sel].ClientItem.S.Name := '';
            g_boItemMoving := TRUE;
         end;
      end;
   end;
end;

procedure TFrmDlg.DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  (*{$IF M2Version = 2}
  hcolor: Integer;
  {$ELSE} *)
  hcolor: string;
  //{$IFEND}
  Butt:TAspDButton;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
begin
   if (StateTab <> 0{不是基本页}) or (StatePage <> 0) then Exit;
   sel := -1;
   Lines := '';
   Butt:=TAspDButton(Sender);
   if Sender = DSWDress then sel := U_DRESS;
   if Sender = DSWWeapon then sel := U_WEAPON;
   if Sender = DSWHelmet then sel := U_HELMET;
   if Sender = DSWNecklace then sel := U_NECKLACE;
   if Sender = DSWLight then sel := U_RIGHTHAND;
   if Sender = DSWRingL then sel := U_RINGL;
   if Sender = DSWRingR then sel := U_RINGR;
   if Sender = DSWArmRingL then sel := U_ARMRINGL;
   if Sender = DSWArmRingR then sel := U_ARMRINGR;

   if Sender = DSWBujuk then sel := U_BUJUK;
   if Sender = DSWBelt then sel := U_BELT;
   if Sender = DSWBoots then sel := U_BOOTS;
   if Sender = DSWCharm then sel := U_CHARM;
   if sel >= 0 then begin
      g_MouseStateItem := g_UseItems[sel];
      g_BatterDesc.sName := '';
      if (g_UseItems[sel].ClientItem.S.Name <> '') or (g_UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
        if (sel = U_HELMET) and (g_UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
          g_MouseItem := g_UseItems[U_ZHULI];
          GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
          if iname <> '' then begin
            if g_UseItems[U_ZHULI].ClientItem.Dura = 0 then hcolor := 'Red'
            else hcolor := '';
            Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
          end;
        end;
        TzHintInfo := GetTzInfo(g_UseItems[sel].ClientItem.S.Name, 1);
        if DStateWin.GLeft >= 350 then
          nHintX:=DStateWin.SurfaceX(DStateWin.GLeft) - _Min(DScreen.HintWidth, 400)
        else nHintX:=DStateWin.SurfaceX(DStateWin.GLeft)+DStateWin.GWidth;
        nHintY:=DStateWin.SurfaceY(DStateWin.GTop) +50;
        g_MouseItem := g_UseItems[sel];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
        if (iname <> '') or (Lines <> '') then begin
          if g_UseItems[sel].ClientItem.Dura = 0 then hcolor := 'Red'
          else hcolor := '';
          with Butt as TAspDButton do begin
            {if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, Get TzStateInfo(TzHintInfo,1)]), False
                                      );
          end;}
          //修改套装显示 By TasNat at: 2012-04-06 11:02:26
          DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          if TzHintInfo <> nil then begin

              DScreen.ShowTzItemHint(
                                      Format('<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,1)])
                                      );
          end;
          end;
        end;
        g_MouseItem.ClientItem.S.Name := '';
      end;
   end;
  // {$IFEND}
end;

procedure TFrmDlg.DStateWinMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
  g_MouseStateItem.ClientItem.S.Name := '';
end;
//惑怕芒 : 魔法 其捞瘤

procedure TFrmDlg.DStMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   idx, icon: integer;
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   wm: TAspWMImages;
begin
  with Sender as TAspDButton do begin
    pm := nil;
    {$IF M2Version = 2} //1.76
    idx := _Max(Tag + MagicPage * 5, 0);
    if idx < g_MagicList.Count then begin
      pm := PTClientMagic (g_MagicList[idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[icon];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[icon+1];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end;
    {$ELSE}
    if StateTab = 0 then begin
      idx := _Max(Tag + MagicPage * 6, 0);
      if idx < g_MagicList.Count then begin
        pm := PTClientMagic (g_MagicList[idx]);
        if pm <> nil then begin
          wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, Icon);
          if wm <> nil then begin
            if icon >= 0 then begin
              if not Downed then begin
                d := wm.Images[icon];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := wm.Images[icon+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end else begin
      idx := _Max(Tag + InternalForceMagicPage * 6, 0);
      if idx < g_InternalForceMagicList.Count then begin
        pm := PTClientMagic (g_InternalForceMagicList[idx]);
        if pm <> nil then begin
          if not Downed then begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end else begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2+1];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          if word(pm.Key) <> 0 then begin
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
          end;
        end;
      end;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DStMag1Click(Sender: TObject; X, Y: Integer);
var
  i, idx: integer;
  selkey: word;
  keych: char;
  pm: PTClientMagic;
  icon :Integer;  
begin
	{$IF M2Version <> 2}
  if (StatePage = 3) or (InternalForcePage = 1) then begin
    if StateTab = 0 then begin
      idx := TAspDButton(Sender).Tag + magtop;
      if (idx >= 0) and (idx < g_MagicList.Count) then begin
        pm := PTClientMagic (g_MagicList[idx]);
        selkey := word(pm.Key);
        GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
        if pm.Def.wMagicId <> 100 then begin //神秘解读
          SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx,pm.Def.wMagicId, pm.Def.sMagicName, selkey); //护体神盾魔法拦的图标  20080229
          keych := char(selkey);

          if g_MagicList.Count > 0 then //20080629
          for i:=0 to g_MagicList.Count-1 do begin
            pm := PTClientMagic (g_MagicList[i]);
            if pm.Key = keych then begin
               pm.Key := #0;
               FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
            end;
          end;
          pm := PTClientMagic (g_MagicList[idx]);
          pm.Key := keych;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
        {$IF M2Version <> 2}
        end else begin
          SetSkillMemoDlg(pm.Def.wMagicId, pm.Level, pm.Def.btEffect, pm.Def.sMagicName, '神秘解读');
        {$IFEND}
        end;
      end;
    end else begin
      idx := TAspDButton(Sender).Tag + magtop;
      if (idx >= 0) and (idx < g_InternalForceMagicList.Count) then begin
        pm := PTClientMagic (g_InternalForceMagicList[idx]);
        if word(pm.Key) = 0 then
          keych := char(word(1))
        else keych := char(word(0));
        pm.Key := keych;
        FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
      end;
    end;
  end;
  {$ELSE}
  if StateTab = 0 then begin
    idx := TAspDButton(Sender).Tag + magtop;
    if (idx >= 0) and (idx < g_MagicList.Count) then begin
      pm := PTClientMagic (g_MagicList[idx]);
      selkey := word(pm.Key);
      GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
      SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey); //护体神盾魔法拦的图标  20080229
      keych := char(selkey);

      if g_MagicList.Count > 0 then //20080629
      for i:=0 to g_MagicList.Count-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if pm.Key = keych then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_MagicList[idx]);
      pm.Key := keych;
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStPageUpClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  if StateTab = 0 then begin
     if Sender = DStPageUp then begin
        if MagicPage > 0 then
           Dec (MagicPage);
     end else begin
        if MagicPage < (g_MagicList.Count+5) div 6 - 1 then
           Inc (MagicPage);
     end;
  end else begin
     if Sender = DStPageUp then begin
        if InternalForceMagicPage > 0 then begin
           Dec (InternalForceMagicPage);
           NGUpLevelState(False);
        end;
     end else begin
        if InternalForceMagicPage < (g_InternalForceMagicList.Count+5) div 6 - 1 then begin
           Inc (InternalForceMagicPage);
           NGUpLevelState(False);
        end;
     end;
  end;
  {$ELSE}
  if Sender = DStPageUp then begin
    if MagicPage > 0 then Dec (MagicPage);
  end else begin
    if MagicPage < (g_MagicList.Count+4) div 5 - 1 then Inc (MagicPage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DMyStateDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAspDButton;
   dd: TAsphyreLockableTexture;
begin
   if Sender is TAspDButton then begin
      d := TAspDButton(Sender);
      if d.WLib <> nil then begin //20080701
        if d.Downed then begin
           dd := d.WLib.Images[d.FaceIndex];
           if dd <> nil then
              dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DBotGroupDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAspDButton;
   dd: TAsphyreLockableTexture;
begin
  if Sender = DBotGroup then begin
    if Sender is TAspDButton then begin
      d := TAspDButton(Sender);
      if d.WLib <> nil then begin //20080701
        if g_boAllowGroup then begin
          dd := d.WLib.Images[d.FaceIndex];
          if dd <> nil then begin
            dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
            dsurface.DrawAlpha(d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd, 200, deBright);
          end;
        end else begin
          if d.WLib <> nil then begin //20080701
            if not d.Downed then begin
               dd := d.WLib.Images[d.FaceIndex];
               if dd <> nil then
                  dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
            end else begin
               dd := d.WLib.Images[d.FaceIndex+1];
               if dd <> nil then
                  dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
            end;
          end;
        end;
      end;
    end;
  end else begin
    if Sender is TAspDButton then begin
      d := TAspDButton(Sender);
      if d.WLib <> nil then begin //20080701
        if not d.Downed then begin
           dd := d.WLib.Images[d.FaceIndex];
           if dd <> nil then
              dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
        end else begin
           dd := d.WLib.Images[d.FaceIndex+1];
           if dd <> nil then
              dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBotPlusAbilDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAspDButton;
   dd: TAsphyreLockableTexture;
begin
   if Sender is TAspDButton then begin
      d := TAspDButton(Sender);
      if not d.Downed then begin
         if (BlinkCount mod 2 = 0) and (not DAdjustAbility.Visible) then dd := d.WLib.Images[d.FaceIndex]
         else dd := d.WLib.Images[d.FaceIndex + 2];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex+1];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
      end;

      if GetTickCount - BlinkTime >= 500 then begin
         BlinkTime := GetTickCount;
         Inc (BlinkCount);
         if BlinkCount >= 10 then BlinkCount := 0;
      end;
   end;
end;

procedure TFrmDlg.DMyStateClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DMyState then
  begin
    StatePage := 0;
    {$IF M2Version <> 2}
    DPNewStateWinTab.ActivePage := 0;
    DPNewStateWinPage.ActivePage := 0;
    {$IFEND}
    OpenMyStatus;
  end;
  if Sender = DMyBag then OpenItemBag;
  if Sender = DMyMagic then begin
    StateTab := 0;
    StatePage := 3;
    {$IF M2Version <> 2}
    DPNewStateWinTab.ActivePage := 0;
    DPNewStateWinPage.ActivePage := 4;
    FrmDlg.DStateWinPulse.Visible := False;
    FrmDlg.DStateWinBatter.Visible := False;
    {$IFEND}
    OpenMyStatus;
  end;
  if Sender = DOption then DOptionClick;
end;

procedure TFrmDlg.DOptionClick();
var
  Ini: TIniFile;
  sFileName: String;
begin
  g_boSound := not g_boSound;
  if g_boSound then begin
    DScreen.AddChatBoardString ('[音效 开]', clWhite, clBlack);
  end else begin
    DScreen.AddChatBoardString ('[音效 关]', clWhite, clBlack);
  end;
  if frmMain.CharName <> '' then sFileName := g_ParamDir+format(SDOCONFIGFILE,[g_sServerName,frmMain.CharName,'SdoAssistant'])
    else sFileName:=g_ParamDir+format(CONFIGFILE,['Assistant']);

  if not DirectoryExists(g_ParamDir+'config') then  CreateDir(g_ParamDir+'config');

  if not DirectoryExists(g_ParamDir+format('config\Ly%s_%s',[g_sServerName, frmMain.CharName])) then
    CreateDir(g_ParamDir+format('config\Ly%s_%s',[g_sServerName,frmMain.CharName]));

  Ini:=TIniFile.Create(sFileName);
  Ini.WriteBool('Misc', 'PlaySound', g_boSound);
  Ini.Free;
end;

{------------------------------------------------------------------------}

// 骇飘

{------------------------------------------------------------------------}


procedure TFrmDlg.DBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  idx, n: Integer;
  d: TAsphyreLockableTexture;
  sText:string;
begin
  with Sender as TAspDButton do begin
    idx := Tag;
    if idx in [0..5] then begin
      if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
        d := frmMain.GetBagItemImg(g_ItemArr[idx].Item.ClientItem.S.Looks);
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft+(GWidth-d.Width) div 2), SurfaceY(GTop+(GHeight-d.Height) div 2), d.ClientRect, d, TRUE);
        if (g_ItemArr[idx].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[idx].Item.ClientItem.S.Shape = 237) then begin
          sText := IntToStr(g_ItemArr[idx].Item.ClientItem.Dura);
          n := AspTextureFont.TextWidth(sText);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft+34)-n, SurfaceY(GTop), sText, clLime);
        end;
      end;
    end;
    PomiTextOut (dsurface, SurfaceX(GLeft+13), SurfaceY(GTop+19), IntToStr(idx+1));
  end;
end;

procedure TFrmDlg.DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := TAspDButton(Sender).Tag;
  if idx in [0..5] then begin
    if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
      g_MouseItem := g_ItemArr[idx].Item;
      with Sender as TAspDButton do
        ShowMouseItemInfo(SurfaceX(GLeft),
                          SurfaceY(GTop), '', 1, True);
    end;
  end;
end;

procedure TFrmDlg.DBFactionAddDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
	DWFactionAddDlg.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBFactionAddDlgCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   {with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            if g_boPlayDrink then begin
              dsurface.Draw(dsurface,SurfaceX(GLeft), // 这个地方时什么意思，可能以后才能明白
                  SurfaceY(GTop), d,0,0,d.Width,d.Height, 0, 150);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            if g_boPlayDrink then begin
              DrawBlendEx(dsurface,SurfaceX(GLeft),
                  SurfaceY(GTop), d,0,0,d.Width,d.Height, 0, 150);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
   end;}

    with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            if g_boPlayDrink then begin
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            if g_boPlayDrink then begin
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
   end;
end;

procedure TFrmDlg.DBFactionDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWFactionDlg.Visible := False;
  if g_FactionDlg.NoticeList <> nil then FreeAndNil(g_FactionDlg.NoticeList);
  FactionMemberListFree();
{$IFEND}
end;

procedure TFrmDlg.DBFactionDlgCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
    if WLib <> nil then begin   //20080701
      if not Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            if g_boPlayDrink then
            begin
              dsurface.DrawBlend(SurfaceX(GLeft),
                  SurfaceY(GTop), d.ClientRect, d);
            end else
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            if g_boPlayDrink then
            begin
              dsurface.DrawBlend(SurfaceX(GLeft),
                  SurfaceY(GTop), d.ClientRect, d);
            end else
              dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
   end;

   {with Sender as TAspDButton do
   begin
      if not Downed then
      begin
        if WLib <> nil then //20080701
        begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end; }
end;

procedure TFrmDlg.DBFactionDlgCloseInitialize(Sender: TObject);
begin
	with Sender as TAspDButton do
  SetImgIndex(g_WMain3Images,233);
end;

procedure TFrmDlg.DBFactionDlgEditNoticeCloseClick(Sender: TObject; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DWFactionDlgEditNotice.Visible := FALSE;
  Memo.Visible := FALSE;
  DMsgDlg.DialogResult := mrCancel;
{$IFEND}
end;

procedure TFrmDlg.DBGloryDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   rc : TRect;
begin
  with DBGlory do begin
   d := g_WUiMainImages.Images[31];
    if d <> nil then begin
      rc := d.ClientRect;
      Windows.OffsetRect(rc, SurfaceX(GLeft), SurfaceY(GTop));
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      //dsurface.FrameRect(rc, cColor4(cColor1(clLime)));
    end;
     AspTextureFont.TextOut (SurfaceX(GLeft) + 50 - frmMain.Canvas.TextWidth(IntToStr(g_btGameGlory)) div 2, SurfaceY(GTop) + 4, clWhite, IntToStr(g_btGameGlory));
  end;
end;

procedure TFrmDlg.DBelt1Click(Sender: TObject; X, Y: Integer);
var
   idx: integer;
   temp: TClientEffecItem;
begin
  idx := TAspDButton(Sender).Tag;
  if idx in [0..5] then begin
    if not g_boItemMoving then begin
       if g_boHeroItemMoving then Exit;
       if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
          ItemClickSound (g_ItemArr[idx].Item.ClientItem.S);
          g_boItemMoving := TRUE;
          g_MovingItem.Index := idx;
          g_MovingItem.Item := g_ItemArr[idx].Item;
          g_ItemArr[idx].Item.ClientItem.S.Name := '';
       end;
    end else begin
       if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
       if (g_MovingItem.Item.ClientItem.S.StdMode <= 3) or ((g_MovingItem.Item.ClientItem.S.StdMode = 60) and (g_MovingItem.Item.ClientItem.S.Shape <> 0)) or ((g_MovingItem.Item.ClientItem.S.StdMode = 17) and (g_MovingItem.Item.ClientItem.S.Shape = 237)) then begin 
          if (g_MovingItem.Item.ClientItem.S.StdMode = 2) and (g_MovingItem.Item.ClientItem.S.Need = 1) then Exit;  //不允许放入的物品 20080331
          if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
             temp := g_ItemArr[idx].Item;
             g_ItemArr[idx].Item := g_MovingItem.Item;
             g_MovingItem.Index := idx;
             g_MovingItem.Item := temp;
          end else begin
            if (g_MovingItem.Index < 0) and (g_MovingItem.Index >= -14 {-9}) then begin  //装备物品
              //惑怕芒俊辑 啊规栏肺
              g_WaitingUseItem := g_MovingItem;
              FrmMain.SendTakeOffItem (-(g_MovingItem.Index+1), g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
            end else begin
              g_ItemArr[idx].Item := g_MovingItem.Item;
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
            end;
          end;
       end;
    end;
  end;
end;

procedure TFrmDlg.DBelt1DblClick(Sender: TObject);
var
   idx: integer;
begin
   idx := TAspDButton(Sender).Tag;
   if idx in [0..5] then begin
      if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
         if (g_ItemArr[idx].Item.ClientItem.S.StdMode <= 4) or (g_ItemArr[idx].Item.ClientItem.S.StdMode = 31) or
         ((g_ItemArr[idx].Item.ClientItem.S.StdMode = 60) and (g_ItemArr[idx].Item.ClientItem.S.Shape <> 0)) or
         ((g_ItemArr[idx].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[idx].Item.ClientItem.S.Shape = 237)) then begin //荤侩且 荐 乐绰 酒捞袍
             FrmMain.EatItem (idx);
         end;
      end else begin
         if g_boItemMoving and (g_MovingItem.Index = idx) and
           (g_MovingItem.Item.ClientItem.S.StdMode <= 4) or (g_MovingItem.Item.ClientItem.S.StdMode = 31) or
           ((g_ItemArr[idx].Item.ClientItem.S.StdMode = 60) and (g_ItemArr[idx].Item.ClientItem.S.Shape <> 0)) or
           ((g_ItemArr[idx].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[idx].Item.ClientItem.S.Shape = 237))
         then begin
            if (g_ItemArr[idx].Item.ClientItem.S.StdMode = 2) and (g_ItemArr[idx].Item.ClientItem.S.Shape in [10..12]) then Exit;
            g_BeltIdx := idx; //双击 自动防药IDX 20080229
            FrmMain.EatItem (-1);
         end;
      end;
   end;
end;


{----------------------------------------------------------}
//物品信息   2007.10.17    
{----------------------------------------------------------}
procedure TFrmDlg.GetMouseItemInfo (var iname, iname1, line1, line2, line3, line4, line5, sUnKnow1, sUnKnow2: string; var useable: boolean; Who: Integer{1为主人,2为英雄}); // 2007.12.15 支持英雄

   function GetDuraStr (dura, maxdura: integer): string;
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura/1000)) + '/' + IntToStr(Round(maxdura/1000))
      else
         Result := IntToStr(Round(dura/1000));
   end;

   function GetDuraX10Str (dura, maxdura: integer): string;   //20080306 作用： 直接把两个整数返回STRING
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura*10)) + '/' + IntToStr(Round(maxdura*10))
      else
         Result := IntToStr(Round(dura*10));
   end;

   function GetDura100Str (dura, maxdura: integer): string;
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura/100)) + '/' + IntToStr(Round(maxdura/100))
      else
         Result := IntToStr(Round(dura/100));
   end;

   function GetDuraShowStr (dura, maxdura: integer): string;   //20080306 作用： 直接把两个整数返回STRING
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura)) + '/' + IntToStr(Round(maxdura))
      else
         Result := IntToStr(Round(dura));
   end;
var
  sWgt, str:String;
  MouseItem : TClientEffecItem; //20080222
begin
  case Who of
    1:begin
      if g_MySelf = nil then exit;
      MouseItem := g_MouseItem;
    end;
    2:begin
      if g_HeroSelf = nil then exit;
      MouseItem := g_HeroMouseItem;
    end;
  end;
  iname := '';
  iname1 := '';
  line1 := '';
  line2 := '';
  line3 := '';
  line4 := '';
  line5 := '';
  sUnKnow1 := '';
  sUnKnow2 := '';
  useable := TRUE;

  if MouseItem.ClientItem.S.Name <> '' then
  begin
    iname := MouseItem.ClientItem.S.Name + ' ';
    sWgt := '重量';
    case MouseItem.ClientItem.S.StdMode of
      0: begin //药品
        if MouseItem.ClientItem.S.Shape <> 3 then begin
          if MouseItem.ClientItem.S.AC > 0 then line1 := '+' + IntToStr(MouseItem.ClientItem.S.AC) + 'HP ';
          if MouseItem.ClientItem.S.MAC > 0 then line1 := line1 + '+' + IntToStr(MouseItem.ClientItem.S.MAC) + 'MP';
        end;
        line1 := line1 + '重量' + IntToStr(MouseItem.ClientItem.S.Weight);
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
        end;
      end;

      1..3: begin
        case MouseItem.ClientItem.S.AniCount of
          9: begin
            line1 := line1 + '重量' +  IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := '可累计修复持久'+ IntToStr(Round(MouseItem.ClientItem.Dura / 100))+'点';
          end;
          21: begin
            if (MouseItem.ClientItem.S.StdMode= 2) and (MouseItem.ClientItem.S.Reserved = 56) then begin  //泉水罐 20080624
              line1 := line1 + '重量' +  IntToStr(MouseItem.ClientItem.S.Weight);
              line2 := '容量 '+ GetDura100Str(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
            end else begin
              line1 := line1 + '重量' +  IntToStr(MouseItem.ClientItem.S.Weight);
              line2 := '容量 '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
            end;
          end;
          22: begin
            line1 := line1 + '重量' +  IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := '容量 '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
          end;
        else line1 := line1 + '重量' +  IntToStr(MouseItem.ClientItem.S.Weight);
        end;

        if MouseItem.ClientItem.S.StdMode = 2 then begin
          if (MouseItem.ClientItem.S.Reserved <> 56) and (MouseItem.ClientItem.S.Shape in [0..2]) then begin
            line2 := '使用 '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' 次';
          end else if MouseItem.ClientItem.S.Shape in [4..5,10..12] then begin
            line1 := line1+' 使用 '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' 次';
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line2, ['\']);
              str := GetValidStr3 (str, line3, ['\']);
            end;
          {$IF M2Version <> 2}
          end else if MouseItem.ClientItem.S.Shape = 255 then begin
            line2 := Format('使用 %s 次', [GetDura100Str(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)]);//灵气神水
          end else if MouseItem.ClientItem.S.Shape in [253..254] then begin
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line2, ['\']);
              str := GetValidStr3 (str, line3, ['\']);
            end;
          {$IFEND}
          end;

        end else if MouseItem.ClientItem.S.StdMode = 3 then begin
          if MouseItem.ClientItem.S.Shape in [13,14] then begin
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line2, ['\']);
            end;
          end;
        end;
      end;

      51: begin
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
        case MouseItem.ClientItem.S.Shape of
         0: begin//聚灵珠
            if MouseItem.ClientItem.Dura = MouseItem.ClientItem.DuraMax then begin
              line2 := '经验值已蓄满('+IntToStr(MouseItem.ClientItem.DuraMax)+'万)  双击释放';
            end else begin
              if MouseItem.ClientItem.S.Need = 0 then begin
                line2 := '累积经验 ' +  IntToStr(MouseItem.ClientItem.Dura)+'/'+IntToStr(MouseItem.ClientItem.DuraMax)+'万';
                line3 := IntToStr(MouseItem.ClientItem.S.AniCount * 24)+'小时后停止累积经验';
              end else begin
                line2 := '累积经验 ' +  IntToStr(MouseItem.ClientItem.Dura  + g_nBeadWinExp)+'/'+IntToStr(MouseItem.ClientItem.DuraMax)+'万';
                line3 := IntToStr(MouseItem.ClientItem.S.Need)+'小时后停止累积经验';
              end;
            end;
          end;
          1: begin//内功珠
            if MouseItem.ClientItem.Dura = MouseItem.ClientItem.DuraMax then begin
              line2 := '内功经验值已蓄满('+FloatToStrFixFmt (MouseItem.ClientItem.DuraMax/10, 4, 1)+'万)  双击释放';
            end else begin
              line2 := '累积内功经验 ' +  FloatToStrFixFmt (MouseItem.ClientItem.Dura/10, 4, 1)+'/'+FloatToStrFixFmt (MouseItem.ClientItem.DuraMax/10, 4, 1)+'万'; //IntToStr(MouseItem.ClientItem.Dura)+'/'+IntToStr(MouseItem.ClientItem.DuraMax)+'万';
            end;
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line3, ['\']);
            end;
          end;
          2: begin//英雄聚灵珠
            if MouseItem.ClientItem.Dura = MouseItem.ClientItem.DuraMax then begin
              line2 := '经验值已蓄满('+FloatToStrFixFmt (MouseItem.ClientItem.DuraMax, 4, 1)+'万)  双击释放';
            end else begin
              line2 := '累积经验 ' +  FloatToStrFixFmt (MouseItem.ClientItem.Dura, 4, 1)+'/'+FloatToStrFixFmt (MouseItem.ClientItem.DuraMax, 4, 1)+'万'; //IntToStr(MouseItem.ClientItem.Dura)+'/'+IntToStr(MouseItem.ClientItem.DuraMax)+'万';
            end;
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line3, ['\']);
            end;
          end;
          3: begin //主宰者灵珠
            if MouseItem.ClientItem.Dura / 10000 > 1 then begin //亿
              line2 := '放在英雄包裹中双击开启，可获得'+ FloatToStrFixFmt (MouseItem.ClientItem.Dura/10000, 4, 1) +'亿英雄经验';
            end else begin
              line2 := '放在英雄包裹中双击开启，可获得'+ IntToStr(MouseItem.ClientItem.Dura) +'万英雄经验';
            end;
            if MouseItem.ClientItem.S.AniCount > 0 then begin //需要元宝
              if MouseItem.ClientItem.Dura / 10000 > 1 then begin //亿
               // line3 := '放到英雄包裹中双击花费15元宝获得1.8亿英雄经验，英雄200级以上也可使用';
                line3 := Format('放到英雄包裹中双击花费%d%s获得%s亿经验', [MouseItem.ClientItem.S.AniCount, g_sGameGoldName, FloatToStrFixFmt (MouseItem.ClientItem.Dura/10000, 4, 1)]);
              end else begin
                line3 := Format('放到英雄包裹中双击花费%d%s获得%d万经验', [MouseItem.ClientItem.S.AniCount, g_sGameGoldName, MouseItem.ClientItem.DuraMax]);
              end;
            end;
            if MouseItem.ClientItem.S.NeedLevel <> 0 then begin
              if MouseItem.ClientItem.S.Need = 0 then begin    //Need =0 等级达到NeedLevel后可使用
                if MouseItem.ClientItem.S.AniCount > 0 then begin //需要元宝
                  line3 := line3 + '，英雄'+IntToStr(MouseItem.ClientItem.S.NeedLevel)+'级以上也可使用';
                end else begin
                  line3 := '英雄'+IntToStr(MouseItem.ClientItem.S.NeedLevel)+'级以上也可使用';
                end;
              end else if MouseItem.ClientItem.S.Need = 1 then begin //Need =1 等级小于NeedLevel后可使用
                if MouseItem.ClientItem.S.AniCount > 0 then begin //需要元宝
                  line3 := line3 + '，英雄'+IntToStr(MouseItem.ClientItem.S.NeedLevel)+'级以下才可使用';
                end else begin
                  line3 := '英雄'+IntToStr(MouseItem.ClientItem.S.NeedLevel)+'级以下才可使用';
                end;
              end;
            end;
          end;
        end;
      end;
      31: begin //解包和触发物品
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      4: begin //技能书
        line1 := line1 + '重量' +  IntToStr(MouseItem.ClientItem.S.Weight);
        case MouseItem.ClientItem.S.AniCount of
          0: begin
            line3 := '需要等级' + IntToStr(MouseItem.ClientItem.S.DuraMax);
            useable := FALSE;
            case MouseItem.ClientItem.S.Shape of
              0: begin
                line2 := '武士秘籍';
                case Who of
                  1: if (g_MySelf.m_btJob = 0) and (g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                  2: if (g_HeroSelf.m_btJob = 0) and (g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                end;
              end;
              1: begin
                line2 := '魔法书';
                case Who of
                  1: if (g_MySelf.m_btJob = 1) and (g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                  2: if (g_HeroSelf.m_btJob = 1) and (g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                end;
              end;
              2: begin
                line2 := '道士秘籍';
                case Who of
                  1: if (g_MySelf.m_btJob = 2) and (g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                  2: if (g_HeroSelf.m_btJob = 2) and (g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                end;
              end;
              3: begin
                //if g_MouseItem.ClientItem.S.AniCount in [60..65] then begin
                line2 := '合击秘籍';
                case Who of
                  1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax then useable := TRUE;
                  2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.DuraMax then useable := TRUE;
                end;
                //end;
              end;
            end;
          end;
          1: begin
            line3 := '需要内功等级' + IntToStr(MouseItem.ClientItem.S.DuraMax);
            useable := FALSE;
            case MouseItem.ClientItem.S.Shape of
              0: begin
                line2 := '武术秘籍';
                case Who of
                  1: if (g_MySelf.m_btJob = 0) and (g_dwInternalForceLevel >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                  2: if (g_HeroSelf.m_btJob = 0) and (g_dwHeroInternalForceLevel >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                end;
              end;
              1: begin
                line2 := '魔法书';
                case Who of
                  1: if (g_MySelf.m_btJob = 1) and (g_dwInternalForceLevel >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                  2: if (g_HeroSelf.m_btJob = 1) and (g_dwHeroInternalForceLevel >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                end;
              end;
              2: begin
                line2 := '道术秘籍';
                case Who of
                  1: if (g_MySelf.m_btJob = 2) and (g_dwInternalForceLevel >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                  2: if (g_HeroSelf.m_btJob = 2) and (g_dwHeroInternalForceLevel >= MouseItem.ClientItem.S.DuraMax) then useable := TRUE;
                end;
              end;
              99: begin
                line2 := '战士、魔法师、道士均可学习';
                case Who of
                  1: if g_dwInternalForceLevel >= MouseItem.ClientItem.S.DuraMax then useable := TRUE;
                  2: if g_dwHeroInternalForceLevel >= MouseItem.ClientItem.S.DuraMax then useable := TRUE;
                end;
              end;
            end;
          end;
        end;
      end;
      5..6: begin //武器
        useable := FALSE;
        If MouseItem.ClientItem.s.nHP> 0 then
          Line3:=Line3+'\体力值 +'+IntToStr(MouseItem.ClientItem.s.nHP)+' ';
        If MouseItem.ClientItem.s.nMP> 0 Then
          Line3:=Line3+'\魔法值 +'+IntToStr(MouseItem.ClientItem.s.nMP)+' ';
        if MouseItem.ClientItem.S.Reserved and $01 <> 0 then
          iname := '(*)' + iname;
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight) + ' 持久'+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
        if MouseItem.ClientItem.S.DC > 0 then line2 := '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
        //if MouseItem.ClientItem.btValue[0]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[0])+')/c=lime> ';
        if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
        //if MouseItem.ClientItem.btValue[1]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[1])+')/c=lime> ';
        if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
        //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';

        if ((MouseItem.ClientItem.S.Source - 1 - 10) < 0) and (MouseItem.ClientItem.S.Source > 0) then line2 := line2 + '强度+' + IntToStr(MouseItem.ClientItem.S.Source)+' ';
        if (MouseItem.ClientItem.S.Source <= -1) and (MouseItem.ClientItem.S.Source >= -50) then line2 := line2 + '神圣+' + IntToStr(-MouseItem.ClientItem.S.Source)+' ';
        if (MouseItem.ClientItem.S.Source <= -51) and (MouseItem.ClientItem.S.Source >= -100) then line2 := line2 + '神圣-' + IntToStr(-MouseItem.ClientItem.S.Source - 50)+' ';
        if HiWord(MouseItem.ClientItem.S.AC) > 0 then line3 := line3 + '\准确+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC))+' ';
        if HiWord(MouseItem.ClientItem.S.MAC) > 0 then begin
          if HiWord(MouseItem.ClientItem.S.MAC) > 10 then
            line3 := line3 + ' 攻击速度+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)-10) + ' '
          else line3 := line3 + ' 攻击速度-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
        end;
        if LoWord(MouseItem.ClientItem.S.AC) > 0 then line3 := line3 + '\幸运+' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + ' ';
        if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line3 := line3 + '\诅咒+' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
        case MouseItem.ClientItem.S.Need of
          0, 14: begin
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          1, 15: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          2, 16: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          3, 17: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          4: begin
            useable := TRUE;
            line3 := line3 + '需要转生等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          40: begin
            useable := TRUE;
            line3 := line3 + '需要转生&等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          41: begin
            useable := TRUE;
            line3 := line3 + '需要转生&攻击' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          42: begin
            useable := TRUE;
            line3 := line3 + '需要转生&魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          43: begin
            useable := TRUE;
            line3 := line3 + '需要转生&精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          44: begin
            useable := TRUE;
            line3 := line3 + '需要转生&声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          5: begin
            useable := TRUE;
            line3 := line3 + '需要声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
          end;
          6: begin
            useable := TRUE;
            line3 := line3 + '行会成员专用' + ' ';
          end;
          60: begin
            useable := TRUE;
            line3 := line3 + '行会掌门专用' + ' ';
          end;
          7: begin
            useable := TRUE;
            line3 := line3 + '沙城成员专用' + ' ';
          end;
          70: begin
            useable := TRUE;
            line3 := line3 + '沙城城主专用';
          end;
          8: begin
            useable := TRUE;
            line3 := line3 + '会员专用' + ' ';
          end;
          81: begin
            useable := TRUE;
            line3 := line3 + '会员类型 =' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel)) + ' ';
          end;
          82: begin
            useable := TRUE;
            line3 := line3 + '会员类型 >=' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel)) + ' ';
          end;
          //----内功相关
          18,22: begin//20090331  需等级  22为不带%号
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                if MouseItem.ClientItem.S.Need = 18 then str := '需要等级%d 内力恢复速度+%d%%'
                else str := '需要等级%d 内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                if MouseItem.ClientItem.S.Need = 18 then str := '内力恢复速度+%d%%'
                else str := '内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          19, 23: begin //需攻击力  23为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                if MouseItem.ClientItem.S.Need = 19 then str := '需要攻击%d 内力恢复速度+%d%%'
                else str := '需要攻击%d 内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                if MouseItem.ClientItem.S.Need = 19 then str := '内力恢复速度+%d%%'
                else str := '内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          20, 24: begin //需魔法 24为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                if MouseItem.ClientItem.S.Need = 20 then str := '需要魔法力%d 内力恢复速度+%d%%'
                else str := '需要魔法力%d 内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                if MouseItem.ClientItem.S.Need = 20 then str := '内力恢复速度+%d%%'
                else str := '内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          21, 25: begin //需道术 25为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                if MouseItem.ClientItem.S.Need = 21 then str := '需要精神力%d 内力恢复速度+%d%%'
                else str := '需要精神力%d 内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                if MouseItem.ClientItem.S.Need = 21 then str := '内力恢复速度+%d%%'
                else str := '内力恢复速度+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //---防爆相关
          26: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          27: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          28: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          29: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '防爆+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //虎威吸血
          30: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
              end else begin
                str := '吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock])
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          31: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          32: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          33: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '吸血0-%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //内伤等级
          34: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          35: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          36: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          37: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '内伤等级+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //麻痹抗性
          45: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          46: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          47: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          48: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //暴击等级   英雄物品,即主体不能使用
          49, 53: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要等级%d ',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          50, 54: begin  //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          51, 55: begin  //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          52, 56: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          61: begin
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then
            line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          62: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          63: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          64: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          //目标爆率
          65: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          66: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          67: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          68: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
        end;
        {$IF M2Version <> 2}
        if MouseItem.ClientItem.S.NeedIdentify > 0 then line3 := line3 + Format(' 暴击等级%d',[MouseItem.ClientItem.S.NeedIdentify]);//武器暴击等级 20100708
        if g_boOpenLeiMei then begin
          case MouseItem.ClientItem.btUnKnowValue[0] of  //是否可鉴定(无星  1－可鉴定 2－一鉴 3-二鉴  4-三鉴 1星: 11-可鉴定 12-一鉴 13-二鉴 14-三鉴..)
            1,11,21,31,41,51: begin //可鉴定
              line4 := '可鉴定';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                11: line5 := '*1';
                21: line5 := '*2';
                31: line5 := '*3';
                41: line5 := '*4';
                51: line5 := '*5';
              end;
            end;
            2,12,22,32,42,52: begin//一鉴
              line4 := '一鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                12: line5 := '*1';
                22: line5 := '*2';
                32: line5 := '*3';
                42: line5 := '*4';
                52: line5 := '*5';
              end;
            end;
            3,13,23,33,43,53: begin;//二鉴
              line4 := '二鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                13: line5 := '*1';
                23: line5 := '*2';
                33: line5 := '*3';
                43: line5 := '*4';
                53: line5 := '*5';
              end;
            end;
            4,14,24,34,44,54: begin //三鉴
              line4 := '三鉴';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                14: line5 := '*1';
                24: line5 := '*2';
                34: line5 := '*3';
                44: line5 := '*4';
                54: line5 := '*5';
              end;
            end;
          end;
          sUnKnow1 := GetAppendItemValue(MouseItem.ClientItem);
          sUnKnow2 := GetSecretItemValue(MouseItem.ClientItem);
        end;
        {$IFEND}
      end;

      7:begin
        case MouseItem.ClientItem.S.Shape of
          0,4 :begin  //千里传音, 传音筒
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := '次数 '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' 次';
          end;
          1:begin
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := 'HP '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' 万';
          end;
          2:begin
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := 'MP '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' 万';
          end;
          3:begin
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := 'HPMP '+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' 万';
          end;
          {$Region '天龙印'}
          5: begin
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := 'HPMP '+ GetDuraX10Str(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
            if MouseItem.ClientItem.Dura > 0 then
            begin
              
              if MouseItem.ClientItem.S.DC > 0 then line3 := '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
              //if (MouseItem.ClientItem.btValue[2]>0) and  then Line3:=Line3+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
              if MouseItem.ClientItem.S.MC > 0 then line3 := line3 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
              //if MouseItem.ClientItem.btValue[3]>0 then Line3:=Line3+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
              if MouseItem.ClientItem.S.SC > 0 then line3 := line3 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
              //if MouseItem.ClientItem.btValue[4]>0 then Line3:=Line3+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';

              case MouseItem.ClientItem.S.Need of
                0, 14: begin
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.NeedLevel > 0 then
                  line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                1, 15: begin
                  case Who of
                    1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                2, 16: begin
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                3, 17: begin
                  case Who of
                    1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                4: begin
                  useable := TRUE;
                  line3 := line3 + '需要转生等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                40: begin
                  useable := TRUE;
                  line3 := line3 + '需要转生&等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                41: begin
                  useable := TRUE;
                  line3 := line3 + '需要转生&攻击' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                42: begin
                  useable := TRUE;
                  line3 := line3 + '需要转生&魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                43: begin
                  useable := TRUE;
                  line3 := line3 + '需要转生&精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                44: begin
                  useable := TRUE;
                  line3 := line3 + '需要转生&声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                5: begin
                  useable := TRUE;
                  line3 := line3 + '需要声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel) + ' ';
                end;
                6: begin
                  useable := TRUE;
                  line3 := line3 + '行会成员专用' + ' ';
                end;
                60: begin
                  useable := TRUE;
                  line3 := line3 + '行会掌门专用' + ' ';
                end;
                7: begin
                  useable := TRUE;
                  line3 := line3 + '沙城成员专用' + ' ';
                end;
                70: begin
                  useable := TRUE;
                  line3 := line3 + '沙城城主专用';
                end;
                8: begin
                  useable := TRUE;
                  line3 := line3 + '会员专用' + ' ';
                end;
                81: begin
                  useable := TRUE;
                  line3 := line3 + '会员类型 =' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel)) + ' ';
                end;
                82: begin
                  useable := TRUE;
                  line3 := line3 + '会员类型 >=' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel)) + ' ';
                end;
                //----内功相关
                18,22: begin//20090331  需等级  22为不带%号
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      if MouseItem.ClientItem.S.Need = 18 then str := '需要等级%d \内力恢复速度+%d%%'
                      else str := '需要等级%d \内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      if MouseItem.ClientItem.S.Need = 18 then str := '内力恢复速度+%d%%'
                      else str := '内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                19, 23: begin //需攻击力  23为不带%号
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      if MouseItem.ClientItem.S.Need = 19 then str := '需要攻击%d \内力恢复速度+%d%%'
                      else str := '需要攻击%d \内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      if MouseItem.ClientItem.S.Need = 19 then str := '内力恢复速度+%d%%'
                      else str := '内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                20, 24: begin //需魔法 24为不带%号
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      if MouseItem.ClientItem.S.Need = 20 then str := '需要魔法力%d \内力恢复速度+%d%%'
                      else str := '需要魔法力%d \内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      if MouseItem.ClientItem.S.Need = 20 then str := '内力恢复速度+%d%%'
                      else str := '内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                21, 25: begin //需道术 25为不带%号
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      if MouseItem.ClientItem.S.Need = 21 then str := '需要精神力%d \内力恢复速度+%d%%'
                      else str := '需要精神力%d \内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      if MouseItem.ClientItem.S.Need = 21 then str := '\内力恢复速度+%d%%'
                      else str := '\内力恢复速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                //---防爆相关
                26: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要等级%d \防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                27: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要攻击%d \防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                28: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要魔法力%d \防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                29: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要精神力%d \防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\防爆+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                //虎威吸血
                30: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要等级%d \吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
                    end else begin
                      str := '\吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock])
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                31: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要攻击%d \吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                32: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要魔法力%d \吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                33: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要精神力%d \吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\吸血0-%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                //内伤等级
                34: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要等级%d \内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                35: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要攻击%d \内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                36: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要魔法力%d \内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                37: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要精神力%d \内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\内伤等级+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                //麻痹抗性
                45: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要等级%d \麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                46: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要攻击%d \麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                47: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要魔法力%d \麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                48: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要精神力%d \麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\麻痹抗性+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;

                //暴击等级   英雄物品,即主体不能使用
                49, 53: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + Format('需要等级%d ',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                50, 54: begin  //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                51, 55: begin  //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                52, 56: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                61: begin
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then
                  line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
                end;
                62: begin
                  case Who of
                    1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                    2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                  end;
                  line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
                end;
                63: begin
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                  end;
                  line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
                end;
                64: begin
                  case Who of
                    1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                    2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
                  end;
                  line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
                end;
                //目标爆率
                65: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要等级%d 目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                66: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要攻击%d 目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                67: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要魔法力%d 目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                68: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then
                  begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then
                    begin
                      str := '需要精神力%d 目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else
                    begin
                      str := '目标爆率+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else
                    line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                //麻痹强化
                72: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                      str := '需要等级%d \麻痹强化+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                          line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight) + ' 持久'+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' ';
                  //if MouseItem.ClientItem.S.AC > 0 then line2 := '防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
                  //if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
                  if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
                  //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
                  if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
                  //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
                  if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
                  //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';
                  If MouseItem.ClientItem.s.Stock>0 Then Line2 := line2 + '\麻痹强化 +'+IntToStr(MouseItem.ClientItem.s.Stock)+' ';
                  If MouseItem.ClientItem.s.NeedLevel>0 Then
                    Line3 :=line3 + '需要等级'+IntToStr(MouseItem.ClientItem.s.NeedLevel)+' ';
                end;
                73: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                      str := '需要攻击%d \麻痹强化+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                  //if MouseItem.ClientItem.S.AC > 0 then line2 := '防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
                  //if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
                  if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
                  //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
                  if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
                  //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
                  if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
                  //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';
                  If MouseItem.ClientItem.s.Stock>0 Then line2 := line2 + '\麻痹强化 +'+IntToStr(MouseItem.ClientItem.s.Stock)+' ';
                  {??
                  If MouseItem.ClientItem.s.NeedLevel>0 Then
                    Line3 :=line3 + '需要等级'+IntToStr(MouseItem.ClientItem.s.NeedLevel)+' ';}
                end;
                74: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                      str := '需要魔法力%d \麻痹强化+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                  //if MouseItem.ClientItem.S.AC > 0 then line2 := '防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
                  //if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
                  if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
                  //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
                  if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
                  //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
                  if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
                  //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';
                  If MouseItem.ClientItem.s.Stock>0 Then line2 := line2 + '\麻痹强化 +'+IntToStr(MouseItem.ClientItem.s.Stock)+' ';
                  {??
                  If MouseItem.ClientItem.s.NeedLevel>0 Then
                    Line6 :=line6 + '需要等级'+IntToStr(MouseItem.ClientItem.s.NeedLevel)+' '; }
                end;
                75: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                      str := '需要精神力%d \麻痹强化+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                  //if MouseItem.ClientItem.S.AC > 0 then line2 := '防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
                  //if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
                  if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
                  //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
                  if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
                  //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
                  if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
                  //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';
                  If MouseItem.ClientItem.s.Stock>0 Then line2 := line2 + '\麻痹强化 +'+IntToStr(MouseItem.ClientItem.s.Stock)+' ';
                  //If MouseItem.ClientItem.s.NeedLevel>0 Then Line6 :=line6 + '需要等级'+IntToStr(MouseItem.ClientItem.s.NeedLevel)+' ';
                end;
                //攻击速度
                91: begin //需等级
                  case Who of
                    1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要等级%d \攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                92: begin //需攻击力
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要攻击%d \攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                93: begin //需魔法
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要魔法力%d \攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
                94: begin //需道术
                  case Who of
                    1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                    2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
                  end;
                  if MouseItem.ClientItem.S.Stock > 0 then begin
                    if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                      str := '需要精神力%d \攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
                    end else begin
                      str := '\攻击速度+%d';
                      line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
                    end;
                  end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
                end;
              end;
            end;
            str:=GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then line3 := line3 + ' ' + str;
          end;
          {$EndRegion}
        end;
      end;

      8: begin  //制酒材料 20080622
        line1 := line1 + '品质' + IntToStr(MouseItem.ClientItem.S.AC);
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      9: begin  //酿酒水材料
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);;
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      12: begin //酒器
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);;
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      13: begin //酒曲
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);;
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      14: begin //酿酒药材
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);;
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      60: begin //酒和烧酒
        if MouseItem.ClientItem.S.Shape <> 0 then begin
          line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight) + ' 容量' + GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
          if MouseItem.ClientItem.S.NeedLevel > 0 then line2 := line2 + '等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel)+' ';
          line2 := line2 + '品质' + IntToStr(MouseItem.ClientItem.S.AC) + ' 酒精度' + IntToStr(MouseItem.ClientItem.S.MAC) + '°';
        end else line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
        case MouseItem.ClientItem.S.Shape of
          1: line3 := '白酒，酒体醇厚，口感绵长，多为豪侠所喜';
          2: line3 := '白酒，略带甘甜，带有浓厚的乡土气息';
          3: line3 := '白酒，带有高原的独特风情，口感醇和';
          4: line3 := '白酒，以果味入酒，不经意间催人入醉乡';
          5: line3 := '黄酒，酒性柔和，橙黄清亮，有暖胃之功效';
          6: line3 := '黄酒，红曲作引，入口甘甜却无粘稠之感';
          7: line3 := '黄酒，酒色红褐，盈盅不溢，多流传于民间';
          8: line3 := '有强筋健骨之用，需酒量'+IntToStr(MouseItem.ClientItem.S.Need)+'方可饮用';
          9: line3 := '此酒可养心和血，需酒量'+IntToStr(MouseItem.ClientItem.S.Need)+'方可饮用';
          10: line3 := '可使人身手更为灵活，需酒量'+IntToStr(MouseItem.ClientItem.S.Need)+'方可饮用';
          11: line3 := '可坚筋骨，耐寒暑，需酒量'+IntToStr(MouseItem.ClientItem.S.Need)+'方可饮用';
          12: line3 := '可益气补肾，需酒量'+IntToStr(MouseItem.ClientItem.S.Need)+'方可饮用';
          13..16:begin//20100411 增加
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then str := GetValidStr3 (str, line3, ['\']);
          end;
        end;
      end;

      10, 11: begin //男衣服, 女衣服
        useable := FALSE;
        If MouseItem.ClientItem.s.nHP>0 then Line3:=Line3+'\体力值 +'+IntToStr(MouseItem.ClientItem.s.nHP)+' ';
        If MouseItem.ClientItem.s.nMP>0 Then Line3:=Line3+'\魔法值 +'+IntToStr(MouseItem.ClientItem.s.nMP)+' ';
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight) + ' 持久'+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
        if MouseItem.ClientItem.S.AC > 0 then line2 := '\防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
        if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '\魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
        if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
        //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
        if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
        //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
        if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
        //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';

        if LoByte(MouseItem.ClientItem.S.Source) > 0 then line3 := line3 + '\幸运+' + IntToStr(LoByte(MouseItem.ClientItem.S.Source)) + ' ';
        if HiByte(MouseItem.ClientItem.S.Source) > 0 then line3 := line3 + '\诅咒+' + IntToStr(HiByte(MouseItem.ClientItem.S.Source)) + ' ';

        case MouseItem.ClientItem.S.Need of
          0, 14: begin
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
            end;
            line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          1, 15: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
            end;
            line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          2, 16: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
            end;
            line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          3, 17: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then
                 useable := TRUE;
            end;
            line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          4: begin
            useable := TRUE;
            line3 := line3 + '需要转生等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          40: begin
            useable := TRUE;
            line3 := line3 + '需要转生&等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          41: begin
            useable := TRUE;
            line3 := line3 + '需要转生&攻击力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          42: begin
            useable := TRUE;
            line3 := line3 + '需要转生&魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          43: begin
            useable := TRUE;
            line3 := line3 + '需要转生&精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          44: begin
            useable := TRUE;
            line3 := line3 + '需要转生&声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          5: begin
            useable := TRUE;
            line3 := line3 + '需要声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          6: begin
            useable := TRUE;
            line3 := line3 + '行会成员专用';
          end;
          60: begin
            useable := TRUE;
            line3 := line3 + '行会掌门专用';
          end;
          7: begin
            useable := TRUE;
            line3 := line3 + '沙城成员专用';
          end;
          70: begin
            useable := TRUE;
            line3 := line3 + '沙城城主专用';
          end;
          8: begin
            useable := TRUE;
            line3 := line3 + '会员专用';
          end;
          81: begin
            useable := TRUE;
            line3 := line3 + '会员类型 =' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel));
          end;
          82: begin
            useable := TRUE;
            line3 := line3 + '会员类型 >=' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel));
          end;
          //----内功相关
          18,22: begin//20090331  需等级  22为不带%号
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin

              if MouseItem.ClientItem.S.Need = 18 then str := '需要等级%d 内力恢复速度+%d%%'
              else str := '需要等级%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          19, 23: begin //需攻击力  23为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 19 then str := '需要攻击%d 内力恢复速度+%d%%'
              else str := '需要攻击%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          20, 24: begin //需魔法 24为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 20 then str := '需要魔法力%d 内力恢复速度+%d%%'
              else str := '需要魔法力%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          21, 25: begin //需道术 25为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 21 then str := '需要精神力%d 内力恢复速度+%d%%'
              else str := '需要精神力%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //---防爆相关
          26: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要等级%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          27: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要攻击%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          28: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要魔法力%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          29: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要精神力%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //虎威吸血
          30: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要等级%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          31: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要攻击%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          32: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要魔法力%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          33: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要精神力%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //内伤等级
          34: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要等级%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          35: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要攻击%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          36: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要魔法力%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          37: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要精神力%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //麻痹抗性
          45: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要等级%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          46: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要攻击%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          47: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要魔法力%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          48: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要精神力%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //英雄物品,即主体不能使用
          53: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要等级%d ',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          54: begin  //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          55: begin  //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          56: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          61: begin
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then
            line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          62: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          63: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          64: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          //目标爆率
          65: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          66: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          67: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          68: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
        end;
        {$IF M2Version <> 2}
        if g_boOpenLeiMei then begin
          case MouseItem.ClientItem.btUnKnowValue[0] of  //是否可鉴定(无星  1－可鉴定 2－一鉴 3-二鉴  4-三鉴 1星: 11-可鉴定 12-一鉴 13-二鉴 14-三鉴..)
            1,11,21,31,41,51: begin //可鉴定
              line4 := '可鉴定';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                11: line5 := '*1';
                21: line5 := '*2';
                31: line5 := '*3';
                41: line5 := '*4';
                51: line5 := '*5';
              end;
            end;
            2,12,22,32,42,52: begin//一鉴
              line4 := '一鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                12: line5 := '*1';
                22: line5 := '*2';
                32: line5 := '*3';
                42: line5 := '*4';
                52: line5 := '*5';
              end;
            end;
            3,13,23,33,43,53: begin;//二鉴
              line4 := '二鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                13: line5 := '*1';
                23: line5 := '*2';
                33: line5 := '*3';
                43: line5 := '*4';
                53: line5 := '*5';
              end;
            end;
            4,14,24,34,44,54: begin //三鉴
              line4 := '三鉴';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                14: line5 := '*1';
                24: line5 := '*2';
                34: line5 := '*3';
                44: line5 := '*4';
                54: line5 := '*5';
              end;
            end;
          end;
          sUnKnow1 := GetAppendItemValue(MouseItem.ClientItem);
          sUnKnow2 := GetSecretItemValue(MouseItem.ClientItem);
        end;
       (* if MouseItem.ClientItem.btUnKnowValue[6] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[6] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[6]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[6]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;
        if MouseItem.ClientItem.btUnKnowValue[7] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[7] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[7]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[7]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;
        if MouseItem.ClientItem.btUnKnowValue[8] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[8] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[8]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[8]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;
        if MouseItem.ClientItem.btUnKnowValue[9] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[9] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[9]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[9]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;   *)
        {$IFEND}
      end;
      
      15,30,16,     //头盔,照明物,斗笠
      19,20,21,28,29,  //项链 20100513增加27,28分类  20100628 增加29分类
      22,23,27,  //戒指
      24,26, //手镯
      52,62,   //鞋
      53,63,//宝石
      54,64: begin  //腰带
        useable := FALSE;
        If MouseItem.ClientItem.s.nHP>0 then Line3:=Line3+'\体力值 +'+IntToStr(MouseItem.ClientItem.s.nHP)+' ';
        If MouseItem.ClientItem.s.nMP>0 Then Line3:=Line3+'\魔法值 +'+IntToStr(MouseItem.ClientItem.s.nMP)+' ';
        if (MouseItem.ClientItem.S.Shape = 188) and (MouseItem.ClientItem.S.Reserved > 0) then line1 := '等级' + IntToStr(MouseItem.ClientItem.S.Reserved) + ' ';
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight) + ' 持久'+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
        case MouseItem.ClientItem.S.StdMode of
          19,53{宝石}: begin//项链
            if MouseItem.ClientItem.S.AC > 0 then line2 := line2 + '\魔法躲避+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC) * 10) + '% ';
            if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\诅咒+' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
            if HiWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\幸运+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
          20, 24, 27: begin//项链 及 手镯: MaxAC -> Hit,  MaxMac -> Speed
            if MouseItem.ClientItem.S.AC > 0 then line2 := line2 + '\准确 +' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
            if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '\敏捷+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
          21: begin //项链
            if HiWord(MouseItem.ClientItem.S.AC) > 0 then line2 := line2 + '\体力恢复+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC) * 10) + '% ';
            if HiWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\魔法恢复+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC) * 10) + '% ';
            if LoWord(MouseItem.ClientItem.S.AC) > 0 then line2 := line2 + '\攻击速度+' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + ' ';
            if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\攻击速度-' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
          23: begin //戒指
            if HiWord(MouseItem.ClientItem.S.AC) > 0 then line2 := line2 + '\毒物躲避+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC) * 10) + '% ';
            if HiWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\中毒恢复+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC) * 10) + '% ';
            if LoWord(MouseItem.ClientItem.S.AC) > 0 then line2 := line2 + '\攻击速度+' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + ' ';
            if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\攻击速度-' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
          28: begin//准确幸运型项链 20100513
            if MouseItem.ClientItem.S.AC > 0 then line2 := line2 + '\准确+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
            if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\诅咒+' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
            if HiWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\幸运+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
          29: begin//20100628 敏捷幸运型项链
            if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\诅咒+' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
            if HiWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\幸运+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
            if MouseItem.ClientItem.S.AC > 0 then line2 := line2 + '\敏捷+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
          end;
          (*28,27{腰带}: begin //靴子  20100513 注释
                if MouseItem.ClientItem.S.AC > 0 then
                   line2 := line2 + '防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
                if MouseItem.ClientItem.S.MAC > 0 then
                   line2 := line2 + '魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;   *)
          52,54: begin//腰带，靴子负重 20080325
            if MouseItem.ClientItem.S.AC > 0 then line2 := line2 + '\防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
            if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '\魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
            if MouseItem.ClientItem.S.AniCount > 0 then line2 := line2 + '\负重+' + IntToStr(MouseItem.ClientItem.S.AniCount) + ' ';
          end;
          63: begin //Charm
            if LoWord(MouseItem.ClientItem.S.AC) > 0 then line2 := line2 + '\HP+' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + ' ';
            if HiWord(MouseItem.ClientItem.S.AC) > 0 then line2 := line2 + '\MP+' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
            if LoWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\诅咒+' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + ' ';
            if HiWord(MouseItem.ClientItem.S.MAC) > 0 then line2 := line2 + '\幸运+' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
          else begin
            if MouseItem.ClientItem.S.AC > 0 then line2 := line2 + '\防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
            if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '\魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
          end;
        end;
        if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
        //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
        if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
        //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
        if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
        //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';
        if (MouseItem.ClientItem.S.Source <= -1) and (MouseItem.ClientItem.S.Source >= -50) then line2 := line2 + '神圣+' + IntToStr(-MouseItem.ClientItem.S.Source)+' ';
        if (MouseItem.ClientItem.S.Source <= -51) and (MouseItem.ClientItem.S.Source >= -100) then line2 := line2 + '神圣-' + IntToStr(-MouseItem.ClientItem.S.Source - 50)+' ';

        case MouseItem.ClientItem.S.Need of
          0, 14: begin
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.NeedLevel > 0 then
            line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          1, 15: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要攻击力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          2, 16: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          3, 17: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          4: begin
            useable := TRUE;
            line3 := line3 + '需要转生等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          40: begin
            useable := TRUE;
            line3 := line3 + '需要转生&等级' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          41: begin
            useable := TRUE;
            line3 := line3 + '需要转生&攻击' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          42: begin
            useable := TRUE;
            line3 := line3 + '需要转生&魔法力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          43: begin
            useable := TRUE;
            line3 := line3 + '需要转生&精神力' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          44: begin
            useable := TRUE;
            line3 := line3 + '需要转生&声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          5: begin
            useable := TRUE;
            line3 := line3 + '需要声望点' + IntToStr(MouseItem.ClientItem.S.NeedLevel);
          end;
          6: begin
            useable := TRUE;
            line3 := line3 + '行会成员专用';
          end;
          60: begin
            useable := TRUE;
            line3 := line3 + '行会掌门专用';
          end;
          7: begin
            useable := TRUE;
            line3 := line3 + '沙城成员专用';
          end;
          70: begin
            useable := TRUE;
            line3 := line3 + '沙城城主专用';
          end;
          8: begin
            useable := TRUE;
            line3 := line3 + '会员专用';
          end;
          81: begin
            useable := TRUE;
            line3 := line3 + '会员类型=' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel));
          end;
          82: begin
            useable := TRUE;
            line3 := line3 + '会员类型>=' + IntToStr(LoWord(MouseItem.ClientItem.S.NeedLevel)) + '会员等级 >=' + IntToStr(HiWord(MouseItem.ClientItem.S.NeedLevel));
          end;
          //----内功相关
          18,22: begin//20090331  需等级  22为不带%号
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 18 then str := '需要等级%d 内力恢复速度+%d%%'
              else str := '需要等级%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          19, 23: begin //需攻击力  23为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 19 then str := '需要攻击%d 内力恢复速度+%d%%'
              else str := '需要攻击%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          20, 24: begin //需魔法 24为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 20 then str := '需要魔法力%d 内力恢复速度+%d%%'
              else str := '需要魔法力%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          21, 25: begin //需道术 25为不带%号
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.Need = 21 then str := '需要精神力%d 内力恢复速度+%d%%'
              else str := '需要精神力%d 内力恢复速度+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //---防爆相关
          26: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要等级%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          27: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要攻击%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          28: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要魔法力%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          29: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要精神力%d 防爆+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //虎威吸血
          30: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要等级%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          31: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要攻击%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          32: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要魔法力%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          33: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要精神力%d 吸血0-%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //内伤等级
          34: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要等级%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          35: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要攻击%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          36: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要魔法力%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          37: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              str := '需要精神力%d 内伤等级+%d';
              line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock])
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //麻痹抗性
          45: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要等级%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          46: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要攻击%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          47: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要魔法力%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          48: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
                str := '需要精神力%d 麻痹抗性+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          //英雄物品,即主体不能使用
          53: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要等级%d ',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          54: begin  //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          55: begin  //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          56: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          61: begin
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then
            line3 := line3 + '需要等级' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          62: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要攻击' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          63: begin
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要魔法力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          64: begin
            case Who of
              1: if HiWord (g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
              2: if HiWord (g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.Stock then useable := TRUE;
            end;
            line3 := line3 + '需要精神力' + IntToStr(MouseItem.ClientItem.S.Stock) + ' ';
          end;
          //目标爆率
          65: begin //需等级
            case Who of
              1: if g_MySelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if g_HeroSelf.m_Abil.Level >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要等级%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要等级%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          66: begin //需攻击力
            case Who of
              1: if HiWord(g_MySelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.DC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要攻击%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要攻击%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          67: begin //需魔法
            case Who of
              1: if HiWord(g_MySelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.MC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要魔法力%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要魔法力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
          68: begin //需道术
            case Who of
              1: if HiWord(g_MySelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
              2: if HiWord(g_HeroSelf.m_Abil.SC) >= MouseItem.ClientItem.S.NeedLevel then useable := TRUE;
            end;
            if MouseItem.ClientItem.S.Stock > 0 then begin
              if MouseItem.ClientItem.S.NeedLevel > 0 then begin
                str := '需要精神力%d 目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.NeedLevel,MouseItem.ClientItem.S.Stock]);
              end else begin
                str := '目标爆率+%d';
                line3 := line3 + Format(str,[MouseItem.ClientItem.S.Stock]);
              end;
            end else line3 := line3 + Format('需要精神力%d',[MouseItem.ClientItem.S.NeedLevel]);
          end;
        end;
        if (MouseItem.ClientItem.S.Shape = 188) or (MouseItem.ClientItem.S.Shape = 203) then begin
          if MouseItem.ClientItem.S.Source > 0 then line3 := line3 + ' 伤害吸收' + IntToStr(MouseItem.ClientItem.S.Source) + '%';
        end;
        {$IF M2Version <> 2}
        if g_boOpenLeiMei then begin
          case MouseItem.ClientItem.btUnKnowValue[0] of  //是否可鉴定(无星  1－可鉴定 2－一鉴 3-二鉴  4-三鉴 1星: 11-可鉴定 12-一鉴 13-二鉴 14-三鉴..)
            1,11,21,31,41,51: begin //可鉴定
              line4 := '可鉴定';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                11: line5 := '*1';
                21: line5 := '*2';
                31: line5 := '*3';
                41: line5 := '*4';
                51: line5 := '*5';
              end;
            end;
            2,12,22,32,42,52: begin//一鉴
              line4 := '一鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                12: line5 := '*1';
                22: line5 := '*2';
                32: line5 := '*3';
                42: line5 := '*4';
                52: line5 := '*5';
              end;
            end;
            3,13,23,33,43,53: begin;//二鉴
              line4 := '二鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                13: line5 := '*1';
                23: line5 := '*2';
                33: line5 := '*3';
                43: line5 := '*4';
                53: line5 := '*5';
              end;
            end;
            4,14,24,34,44,54: begin //三鉴
              line4 := '三鉴';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                14: line5 := '*1';
                24: line5 := '*2';
                34: line5 := '*3';
                44: line5 := '*4';
                54: line5 := '*5';
              end;
            end;
          end;
          sUnKnow1 := GetAppendItemValue(MouseItem.ClientItem);
          sUnKnow2 := GetSecretItemValue(MouseItem.ClientItem);
        end;

       (* if MouseItem.ClientItem.btUnKnowValue[6] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[6] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[6]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[6]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;
        if MouseItem.ClientItem.btUnKnowValue[7] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[7] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[7]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[7]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;
        if MouseItem.ClientItem.btUnKnowValue[8] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[8] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[8]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[8]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;
        if MouseItem.ClientItem.btUnKnowValue[9] > 0 then begin
          if MouseItem.ClientItem.btUnKnowValue[9] in [231..250] then begin
            if MouseItem.Aura > 0 then begin
              line7 := line7 + Format('<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[9]-230){值}) , MouseItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else begin
              line7 := line7 + Format('<宝物灵媒 品质%d/c=Yellow> <灵气值%d/%d/c=Red>', [Round(11.4 * (MouseItem.ClientItem.btUnKnowValue[9]-230){值}) , 0, MouseItem.ClientItem.MaxAura]);
            end;
          end;
        end;  *)
        {$IFEND}
      end;

      25: begin//护身符及毒药
        case MouseItem.ClientItem.S.Shape of
          9: begin  //火龙之心
            line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := '容量 '+ IntToStr(MouseItem.ClientItem.Dura) +'/'+ IntToStr(MouseItem.ClientItem.DuraMax);
          end;
          10..11: begin
            line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := '持久 '+ GetDura100Str(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
          end;
        else begin
          line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
          line2 := '数量 '+ GetDura100Str(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
        end;
        end;
      end;
      40: begin //肉
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight) + ' 品质'+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax);
      end;
      41: begin//特殊证书
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      42: begin//药材
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight) + ' 药材';
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      end;
      43: begin//矿石
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight) + ' 纯度'+ IntToStr(Round(MouseItem.ClientItem.Dura/1000));
      end;
      {$IF M2Version <> 2}
      44: begin //特种物品
        case MouseItem.ClientItem.S.Shape of
          253: begin //灵媒
            line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line2, ['\']);
              str := GetValidStr3 (str, line3, ['\']);
            end;
            if MouseItem.ClientItem.Aura > 0 then begin
              line5 := Format('\ \<一鉴/c=Yellow>\ \<附加基础属性/c=Yellow>\ \<宝物灵媒 品质%d 灵气值%d/%d/c=Yellow>', [MouseItem.ClientItem.S.Reserved{值} , MouseItem.ClientItem.Aura, MouseItem.ClientItem.MaxAura]);
            end else line5 := Format('\ \<一鉴/c=Yellow>\ \<附加基础属性/c=Yellow>\ \<宝物灵媒 品质%d/c=Yellow>< 灵气值%d/%d/c=Red>', [MouseItem.ClientItem.S.Reserved{值} ,0,MouseItem.ClientItem.MaxAura]);
          end;
          255: begin //神秘卷轴
            line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := line2 +  '等级'+ IntToStr(MouseItem.ClientItem.S.NeedIdentify) + '\' + '熟练度'+IntToStr(MouseItem.ClientItem.DuraMax);
          end;
          else begin
            str := GetItemDesc(MouseItem.ClientItem.S.Name);
            if str <> '' then begin
              str := GetValidStr3 (str, line2, ['\']);
              str := GetValidStr3 (str, line3, ['\']);
            end;
            line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
          end;
        end;
      end;
      {$IFEND}
      48,49: begin
        case MouseItem.ClientItem.S.StdMode of
          48: begin
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
          end;
          49: begin
            line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
            line2 := ' ';
            line3 := '开启宝箱钥匙，移动到宝箱内即可';
          end;
        end;
      end;
      17: begin //叠加物品
        if MouseItem.ClientItem.S.Shape = 237 then begin
          if MouseItem.ClientItem.S.AC > 0 then line1 := '+' + IntToStr(MouseItem.ClientItem.S.AC) + 'HP ';
          if MouseItem.ClientItem.S.MAC > 0 then line1 := line1 + '+' + IntToStr(MouseItem.ClientItem.S.MAC) + 'MP ';
        end;
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
        if MouseItem.ClientItem.S.Source = 0 then begin
          line1 := line1 + '数量'+ IntToStr(MouseItem.ClientItem.Dura) + ' ' +sWgt + IntToStr(MouseItem.ClientItem.S.Weight);
        end else line1 := line1 + '数量'+ IntToStr(MouseItem.ClientItem.Dura);
      end;
      18: begin //单独物品 读游戏目录的物品注释文件
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
        line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
      end;

      55: begin
      {$IF M2Version <> 2}
        if g_boOpenLeiMei then begin
          case MouseItem.ClientItem.btUnKnowValue[0] of  //是否可鉴定(无星  1－可鉴定 2－一鉴 3-二鉴  4-三鉴 1星: 11-可鉴定 12-一鉴 13-二鉴 14-三鉴..)
            1,11,21,31,41,51: begin //可鉴定
              line4 := '可鉴定';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                11: line5 := '*1';
                21: line5 := '*2';
                31: line5 := '*3';
                41: line5 := '*4';
                51: line5 := '*5';
              end;
            end;
            2,12,22,32,42,52: begin//一鉴
              line4 := '一鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                12: line5 := '*1';
                22: line5 := '*2';
                32: line5 := '*3';
                42: line5 := '*4';
                52: line5 := '*5';
              end;
            end;
            3,13,23,33,43,53: begin;//二鉴
              line4 := '二鉴 (仍可鉴定)';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                13: line5 := '*1';
                23: line5 := '*2';
                33: line5 := '*3';
                43: line5 := '*4';
                53: line5 := '*5';
              end;
            end;
            4,14,24,34,44,54: begin //三鉴
              line4 := '三鉴';
              case MouseItem.ClientItem.btUnKnowValue[0] of
                14: line5 := '*1';
                24: line5 := '*2';
                34: line5 := '*3';
                44: line5 := '*4';
                54: line5 := '*5';
              end;
            end;
          end;
          sUnKnow1 := GetAppendItemValue(MouseItem.ClientItem);
          sUnKnow2 := GetSecretItemValue(MouseItem.ClientItem);
        end;
        {$IFEND}
        line1 := line1 + sWgt + IntToStr(MouseItem.ClientItem.S.Weight) + ' 持久'+ GetDuraStr(MouseItem.ClientItem.Dura, MouseItem.ClientItem.DuraMax)+' ';
        //if MouseItem.ClientItem.S.AC > 0 then line2 := '防御' + IntToStr(LoWord(MouseItem.ClientItem.S.AC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.AC)) + ' ';
        //if MouseItem.ClientItem.S.MAC > 0 then line2 := line2 + '魔御' + IntToStr(LoWord(MouseItem.ClientItem.S.MAC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MAC)) + ' ';
        if MouseItem.ClientItem.S.DC > 0 then line2 := line2 + '\攻击' + IntToStr(LoWord(MouseItem.ClientItem.S.DC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.DC))+' ';
        //if MouseItem.ClientItem.btValue[2]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[2])+')/c=lime> ';
        if MouseItem.ClientItem.S.MC > 0 then line2 := line2 + '\魔法' + IntToStr(LoWord(MouseItem.ClientItem.S.MC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.MC))+' ';
        //if MouseItem.ClientItem.btValue[3]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[3])+')/c=lime> ';
        if MouseItem.ClientItem.S.SC > 0 then line2 := line2 + '\道术' + IntToStr(LoWord(MouseItem.ClientItem.S.SC)) + '-' + IntToStr(HiWord(MouseItem.ClientItem.S.SC))+' ';
        //if MouseItem.ClientItem.btValue[4]>0 then Line2:=Line2+'<(+'+IntToStr(MouseItem.ClientItem.btValue[4])+')/c=lime> ';
        If MouseItem.ClientItem.s.Stock>0 Then line2 := line2 + '\麻痹强化 +'+IntToStr(MouseItem.ClientItem.s.Stock)+' ';
        If MouseItem.ClientItem.s.NeedLevel>0 Then
          Line3 :=line3 + '需要等级'+IntToStr(MouseItem.ClientItem.s.NeedLevel)+' ';
      end;

    else  begin
        str := GetItemDesc(MouseItem.ClientItem.S.Name);
        if str <> '' then begin
          str := GetValidStr3 (str, line2, ['\']);
          str := GetValidStr3 (str, line3, ['\']);
        end;
      line1 := line1 + sWgt +  IntToStr(MouseItem.ClientItem.S.Weight);
    end;
    end;

    If MouseItem.ClientItem.s.nHP>0 then Line5:=Line5+'体力值 +'+IntToStr(MouseItem.ClientItem.s.nHP)+' ';
    If MouseItem.ClientItem.s.nMP>0 Then Line5:=Line5+'魔法值 +'+IntToStr(MouseItem.ClientItem.s.nMP)+' ';

    case MouseItem.ClientItem.BindValue of
      1..3: begin
        if MouseItem.ClientItem.BindValue = 1 then begin
          line3 := line3 +'\'+'截止时间：'+ FormatDateTime('yyyy年mm月dd日', MouseItem.ClientItem.MaxDate){FormatDateTime('dddddd',MouseItem.MaxDate)};{DateToStr(MouseItem.MaxDate)};
        end;
        iname1 := '(绑定)';
      end;
    end;
  end;

end;

//绘画人物背包
procedure TFrmDlg.DItemBagDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d0, d1, d2, d3, d4, d5, d6, d7: string;
   n: integer;
   useable: Boolean;
   d: TAsphyreLockableTexture;
begin
   if g_MySelf = nil then exit;
   with DItemBag do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;


         {$IF M2Version = 2} //1.76
         //GetMouseItemInfo (d0, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
         AspTextureFont.BoldTextOut (SurfaceX(GLeft+64), SurfaceY(GTop+184), clWhite, clBlack,GetGoldStr(g_MySelf.m_nGold));
         if g_MouseItem.ClientItem.S.Name = '' then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215), clWhite, clBlack,'ALT  + R 键刷新包裹');
         end;
         {$ELSE}
         AspTextureFont.BoldTextOut (SurfaceX(GLeft+69), SurfaceY(GTop+210), clWhite, clBlack,GetGoldStr(g_MySelf.m_nGold));
         if (g_MouseItem.ClientItem.S.Name <> '元宝信息') and (g_MouseItem.ClientItem.MakeIndex <> 3000)
            and (g_MouseItem.ClientItem.Dura <> 3000) and (g_MouseItem.ClientItem.DuraMax <> 3000) then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+240), clWhite, clBlack,'ALT  + R 键刷新包裹');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+254), clWhite, clBlack,'Ctrl + 点击物品 放入英雄包裹');
         end;
         {$IFEND}
         {$IF M2Version <> 2} //not 1.76
         if (g_MouseItem.ClientItem.S.Name = '元宝信息') and (g_MouseItem.ClientItem.MakeIndex = 3000)
            and (g_MouseItem.ClientItem.Dura = 3000) and (g_MouseItem.ClientItem.DuraMax = 3000) then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+242), clWhite, clBlack,g_sGameGoldName+'数量 ' + IntToStr(g_MySelf.m_nGameGold));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+242+14), clWhite, clBlack,g_sGameGird+'数量 ' + IntToStr(g_MySelf.m_nGameGird));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+242+14*2), clWhite, clBlack,g_sGameDiaMond+'数量 ' + IntToStr(g_MySelf.m_nGameDiaMond));
            d0 := '';
         end;
         {$IFEND}

         (*{$IF M2Version = 2}
         if d0 <> '' then begin
            n := AspTextureFont.TextWidth (d0);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215), clYellow, clBlack,d0);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+70) + n, SurfaceY(GTop+215), clWhite, clBlack,d1);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215+14), clWhite, clBlack,d2);
            if not useable then
              AspTextureFont.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215+14*2), clRed, clBlack,d3)
            else AspTextureFont.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215+14*2), clWhite, clBlack,d3);
         end;
         {$IFEND} *)
   end;
end;

procedure TFrmDlg.DItemsUpButDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with DItemsUpBut do begin
      if WLib <> nil then begin //20080701
        if DItemsUpBut.Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DCloseBagDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with DCloseBag do begin
      if WLib <> nil then begin //20080701
        if DCloseBag.Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DCloseBagClick(Sender: TObject; X, Y: Integer);
begin
   DItemBag.Visible := FALSE;
end;

// new copy by liuzhigang
procedure TFrmDlg.DItemGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  iname, d1, d2, d3, d4, d5 , d6, d7, hcolor: string;
  useable: Boolean;
  int: Byte;
begin
  DScreen.ClearHint;
   if ssRight in Shift then begin
      if g_boItemMoving then
         DItemGridGridSelect (self, ACol, ARow, Shift);
   end else begin
      idx := ACol + ARow * DItemGrid.ColCount + 6;
      if idx in [6..MAXBAGITEM-1] then begin
         if (g_ItemArr[idx].Item.ClientItem.S.StdMode = 17) and (ssShift in Shift) and (ssLeft in Shift) then begin//拆分物品 20090615
           if g_ItemArr[idx].Item.ClientItem.Dura > 1 then begin
             int := 0;
             DMessageDlg ('要拆分多少?', [mbOk, mbAbort]);
             if DlgEditText = '' then int := 1;
             if length(DlgEditText) > 5 then begin
               int := 3;
             end else begin
                if not IsStringNumber(DlgEditText) then int := 2;
             end;
             if int = 0 then begin
               if StrToInt(DlgEditText) >= g_ItemArr[idx].Item.ClientItem.Dura then int := 4;//输入大于等于数量时，不做处理
             end;
             case int of
               0: frmMain.SendItemNumUpdateValue(g_ItemArr[idx].Item.ClientItem.MakeIndex, StrToInt(DlgEditText), 0);
               1: DMessageDlg ('内容不能为空！', [mbOk]);
               2: DMessageDlg ('输入错误', [mbOk]);
               3: DMessageDlg ('数量不能超过5位', [mbOk]);
             end;
           end;
         end else begin
           g_MouseItem := g_ItemArr[idx].Item;
           //{$IF M2Version <> 2}
           with DItemGrid do
             ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                               SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
           //{$IFEND}
         end;
      end;
   end;
end;

// new copy by liuzhigang
procedure TFrmDlg.DItemGridGridSelect(Sender: TObject; ACol, ARow: Integer;
  Shift: TShiftState);
var
   idx, mi: integer;
   temp: TClientEffecItem;
   TempIdx: Integer;
begin
  //20080803修正 英雄装备拿下点主人包里 物品重叠
  if (g_boHeroItemMoving) and (-g_MovingHeroItem.Index in [1..14]) then Exit;
{-------------------------------------------------------}
//从英雄包裹到主人包裹  2007.10.24
   if g_boHeroItemMoving then begin
     if g_MovingHeroItem.Item.ClientItem.S.Name <> '' then begin
      TempIdx := -(g_MovingHeroItem.Index);
       if not (TempIdx in [1..14]) then begin
         g_WaitingHeroUseItem := g_MovingHeroItem;
         FrmMain.SendItemToMasterBag(-(g_MovingHeroItem.Index+1), g_MovingHeroItem.Item.ClientItem.MakeIndex, g_MovingHeroItem.Item.ClientItem.S.Name);
         g_boHeroItemMoving := FALSE;
         g_MovingHeroItem.Item.ClientItem.S.Name:='';
         Exit; //20080331
       end;
     end;
   end;   
{-------------------------------------------------------------}
  idx := ACol + ARow * DItemGrid.ColCount + 6{骇飘傍埃};
  if idx in [6..MAXBAGITEM-1] then begin
    if ssCtrl in Shift then begin
      if (g_ItemArr[idx].Item.ClientItem.S.Name <> '') and not g_boItemMoving and (g_HeroSelf <> nil) then begin
        if g_ItemArr[idx].boLockItem then Exit;
        g_WaitingUseItem.Item := g_ItemArr[idx].Item;
        FrmMain.SendItemToHeroBag(idx, g_ItemArr[idx].Item.ClientItem.MakeIndex, g_ItemArr[idx].Item.ClientItem.S.Name);
        g_ItemArr[idx].Item.ClientItem.S.Name := '';
      end;
    end else begin
      if not g_boItemMoving then begin
        if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
          if g_ItemArr[idx].boLockItem then Exit;
          g_boItemMoving := TRUE;
          g_MovingItem.Index := idx;
          g_MovingItem.Item := g_ItemArr[idx].Item;
          g_ItemArr[idx].Item.ClientItem.S.Name := '';
          ItemClickSound (g_ItemArr[idx].Item.ClientItem.S);
        end;
      end else begin
         mi := g_MovingItem.Index;
         if mi > 0 then begin
           if g_ItemArr[idx].boLockItem then Exit;
         end;
         if (mi = -97) or (mi = -98) then Exit; //金币...
         if (mi < 0) and (mi >= -15 ) then begin  //装备物品
            g_WaitingUseItem := g_MovingItem;
            FrmMain.SendTakeOffItem (-(g_MovingItem.Index+1), g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
            g_MovingItem.Item.ClientItem.S.name := '';
            g_boItemMoving := FALSE;
         end else begin
            if (mi <= -20) and (mi > -30) then //交易
               DealItemReturnBag (g_MovingItem.Item);
            if (mi <= -57) and (mi > -63) then //挑战物品
               ChallengeItemReturnBag (g_MovingItem.Item);
            if (mi <= -30) and (mi > -40) then //元宝寄售 20080316
               SellOffItemReturnBag (g_MovingItem.Item);
            if (mi <= -41) and (mi > -44) then begin//粹练返回包裹 20080506
               g_ItemsUpItem[(-mi-41)].ClientItem.S.Name := '';
            end;
            if (g_MovingItem.Index <= -72) and (g_MovingItem.Index > -82) then begin  //摆摊
              DelItemBagLock(g_MovingItem.Item.ClientItem);
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
              Exit;
            end;
            {$IF M2Version <> 2}
            if g_MovingItem.Index = -255 then begin //灵媒
              g_WaitingUseItem := g_MovingItem;
              FrmMain.SendTakeOffLingMei (g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
              Exit;
            end;
            {$IFEND}
            if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
               temp := g_ItemArr[idx].Item;
               g_ItemArr[idx].Item := g_MovingItem.Item;
               g_MovingItem.Index := idx;
               g_MovingItem.Item := temp;
            end else begin
               g_ItemArr[idx].Item := g_MovingItem.Item;
               g_MovingItem.Item.ClientItem.S.name := '';
               g_boItemMoving := FALSE;
            end;
         end;
         if (g_MovingItem.Item.ClientItem.S.StdMode = 17) and (g_ItemArr[idx].Item.ClientItem.S.StdMode = 17) and (g_MovingItem.Item.ClientItem.MakeIndex <> g_ItemArr[idx].Item.ClientItem.MakeIndex) then begin
           if (g_MergerItem.ClientItem.S.Name <> '') and (GetTickCount - g_dwMergerTime > 5000) then g_MergerItem.ClientItem.S.Name := '';
           if g_MergerItem.ClientItem.S.Name = '' then begin
             g_MergerItem := g_MovingItem.Item;
             g_MovingItem.Item.ClientItem.S.Name := '';
             g_dwMergerTime := GetTickCount;
             g_boItemMoving := False;
             frmMain.SendItemMakeOne(g_MergerItem.ClientItem.MakeIndex, g_ItemArr[idx].Item.ClientItem.MakeIndex, 0);
           end;
         end;
      end;
    end;
  end;
  ArrangeItemBag;
end;

// new copy by liuzhigang
procedure TFrmDlg.DItemGridDblClick(Sender: TObject);
var
   idx, where, I: integer;
   keyvalue: TKeyBoardState;
   cu: TClientEffecItem;
begin
    g_BeltIdx := 50;  //20080305
   idx := DItemGrid.Col + DItemGrid.Row * DItemGrid.ColCount + 6;
   if idx in [6..MAXBAGITEM-1] then begin
      if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
         FillChar(keyvalue, sizeof(TKeyboardState), #0);
         GetKeyboardState (keyvalue);
         if keyvalue[VK_CONTROL] = $80 then begin
            cu := g_ItemArr[idx].Item;
            g_ItemArr[idx].Item.ClientItem.S.Name := '';
            AddItemBag (cu);
         end else
            if (g_ItemArr[idx].Item.ClientItem.S.StdMode <= 4) or (g_ItemArr[idx].Item.ClientItem.S.StdMode = 31) then begin
               if g_ItemArr[idx].boLockItem then Exit;
               FrmMain.EatItem (idx);
            end;
      end else begin
         if g_boItemMoving and (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index <> -98{20080320 防止复制装备}) then begin
            FillChar(keyvalue, sizeof(TKeyboardState), #0);
            GetKeyboardState (keyvalue);
            if keyvalue[VK_CONTROL] = $80 then begin
               cu := g_MovingItem.Item;
               g_MovingItem.Item.ClientItem.S.Name := '';
               g_boItemMoving := FALSE;
               AddItemBag (cu);
            end else
            {$IF M2Version = 1}
            if (g_MovingItem.Index = idx) and (g_MovingItem.Item.ClientItem.S.StdMode = 17) and (g_MovingItem.Item.ClientItem.S.Shape in [253..255]) then begin
              DScreen.AddChatBoardString('请放到英雄包裹使用！', GetRGB(219), ClWhite);
            end else
            {$IFEND}
            if (g_MovingItem.Index = idx) and
               (g_MovingItem.Item.ClientItem.S.StdMode <= 4) or (g_ItemArr[idx].Item.ClientItem.S.StdMode = 31)  or (g_MovingItem.Item.ClientItem.S.StdMode = 48{宝箱 2008.01.16}) or (g_MovingItem.Item.ClientItem.S.StdMode = 51{聚灵珠 2008.02.21}) or ((g_MovingItem.Item.ClientItem.S.StdMode = 60) and (g_MovingItem.Item.ClientItem.S.Shape <> 0))
            then begin
              if (g_ItemArr[idx].Item.ClientItem.S.StdMode = 2) and (g_ItemArr[idx].Item.ClientItem.S.Shape in [10..12]) then
              else  FrmMain.EatItem (-1);
            end else if (g_MovingItem.Index = idx) and (g_MovingItem.Item.ClientItem.S.StdMode in [17..18]) then begin
               if (g_ItemArr[idx].Item.ClientItem.Dura > 1) or //20110526 修改
                 ((g_ItemArr[idx].Item.ClientItem.Dura = 1) and (g_MovingItem.Item.ClientItem.S.StdMode = 17) and (g_MovingItem.Item.ClientItem.S.Shape = 237)) then begin
                 if g_MovingItem.Item.ClientItem.S.StdMode = 17 then FrmMain.EatItem (-1);
               end else if (g_ItemArr[idx].Item.ClientItem.Dura = 1) and (DWKimNeedle.Visible) and (not DStartKimNeedle.ShowHint) and (not DKimNeedleHelp.ShowHint) then begin
                 if g_MovingItem.Item.ClientItem.S.StdMode = 17 then begin
                   for I:=0 to 4 do begin
                     if (g_KimNeedleItem[I].ClientItem.S.Name = '') or (g_MovingItem.Item.ClientItem.S.Shape <> g_btKimItemOneLevel) then begin
                       case I of
                        0: DKimNeedle1Click(DKimNeedle1, 0, 0);
                        1: DKimNeedle1Click(DKimNeedle2, 0, 0);
                        2: DKimNeedle1Click(DKimNeedle3, 0, 0);
                        3: DKimNeedle1Click(DKimNeedle4, 0, 0);
                        4: DKimNeedle1Click(DKimNeedle5, 0, 0);
                       end;
                       Break;
                     end;
                   end;
                 end else begin
                   for I:=5 to 7 do begin
                     if (g_KimNeedleItem[I].ClientItem.S.Name = '') or (g_MovingItem.Item.ClientItem.S.Shape <> g_btKimItemOneLevel) then begin
                       case I of
                        5: DKimNeedle1Click(DKimNeedle6, 0, 0);
                        6: DKimNeedle1Click(DKimNeedle7, 0, 0);
                        7: DKimNeedle1Click(DKimNeedle8, 0, 0);
                       end;
                       Break;
                     end;
                   end;
                 end;
               end;
            end else begin
              //双击穿装备
              where := GetTakeOnPosition(g_MovingItem.Item.ClientItem.S.StdMode);
              if (where <> -1) then begin
                if where = U_RINGR then begin
                  if g_UseItems[U_RINGR].ClientItem.S.Name = '' then begin
                    where := U_RINGR;
                  end else
                  if g_UseItems[U_RINGL].ClientItem.S.Name = '' then begin
                    where := U_RINGL;
                  end else
                  if not g_boRightItemRingEmpty then begin
                    where := U_RINGR;
                    g_boRightItemRingEmpty := True;
                  end else begin
                    where := U_RINGL;
                    g_boRightItemRingEmpty := False;
                  end;
                end;
                if where = U_ARMRINGR then begin
                  if g_UseItems[U_ARMRINGR].ClientItem.S.Name = '' then begin
                    where := U_ARMRINGR;
                  end else
                  if g_UseItems[U_ARMRINGL].ClientItem.S.Name = '' then begin
                    where := U_ARMRINGL;
                  end else
                  if not g_boRightItemArmRingEmpty then begin
                    where := U_ARMRINGR;
                    g_boRightItemArmRingEmpty := True;
                  end else begin
                    where := U_ARMRINGL;
                    g_boRightItemArmRingEmpty := False;
                  end;
                end;
                g_WaitingUseItem.Item := g_MovingItem.Item;
                g_WaitingUseItem.Index := where;
                FrmMain.SendTakeOnItem(where, g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
                DelItemBag(g_MovingItem.Item.ClientItem.S.Name, g_MovingItem.Item.ClientItem.MakeIndex);
                g_MovingItem.Item.ClientItem.S.Name := '';
              end;
            end;
         end;
      end;
   end;
end;

// new copy by liuzhigang
procedure TFrmDlg.DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
var
  idx, ax, ay: integer;
  d: TAsphyreLockableTexture;
  wm: TAspWMImages;
begin
  idx := ACol + ARow * DItemGrid.ColCount + 6;
  if idx in [6..MAXBAGITEM-1] then begin
    if g_ItemArr[idx].Item.ClientItem.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_ItemArr[idx].Item.ClientItem.S.Looks);
      if d <> nil then begin
        with DItemGrid do  begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                         SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                         d.ClientRect, d, TRUE);
          if g_ItemArr[idx].Item.ClientItem.S.Name = '铁剑' then
          asm
            nop;
          end;

          // 受这个文件的控制是否发光 EffectItemList.txt
          if g_ItemArr[idx].Item.ClientEffec.btBagCount > 0 then begin
            with g_ItemArr[idx].Item.ClientEffec do begin
              if GetTickCount - g_DrawBagItemsArr[idx].dwDrawTick >= 150 then begin
                g_DrawBagItemsArr[idx].dwDrawTick := GetTickCount;
                Inc(g_DrawBagItemsArr[idx].nIndex);
                if g_DrawBagItemsArr[idx].nIndex > btBagCount-1 then g_DrawBagItemsArr[idx].nIndex := 0;
              end;
              wm := GetItemEffectWil(btBagWilIndex);
              if wm <> nil then begin
                d := wm.GetCachedImage(wBagIndex+g_DrawBagItemsArr[idx].nIndex, ax, ay);
                if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(Rect.Left)+ax+nBagX, SurfaceY(Rect.Top)+ay+nBagY, d);
                end;
              end;
            end;
          end else begin
            if g_ItemArr[idx].Item.ClientItem.S.Reserved1 = 1 then begin //发光 20080223
              ItemLightTimeImg();
              d := g_WMain2Images.Images[ItemLightImgIdx + 260];
              if d <> nil then
                dsurface.DrawBlend(SurfaceX(Rect.Left-21), SurfaceY(Rect.Top-23), d);
            end;
          end;
          if g_ItemArr[idx].Item.ClientItem.S.StdMode = 17 then
               AspTextureFont.TextOut(SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_ItemArr[idx].Item.ClientItem.Dura))), SurfaceY(Rect.Top+20), clWhite, InttoStr(g_ItemArr[idx].Item.ClientItem.Dura));
          if g_ItemArr[idx].boLockItem then begin
            d := g_WMainImages.Images[758];
            if d <> nil then begin
              dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                             SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                             d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end;
  end;
end;


procedure TFrmDlg.DGoldClick(Sender: TObject; X, Y: Integer);
begin
   if g_MySelf = nil then exit;
   if not g_boItemMoving then begin
      if g_MySelf.m_nGold > 0 then begin
         PlaySound (s_money);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -98; //捣
         g_MovingItem.Item.ClientItem.S.Name := g_sGoldName{'金币'};
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin //捣父..
         g_boItemMoving := FALSE;
         g_MovingItem.Item.ClientItem.S.Name := '';
         if g_MovingItem.Index = -97 then begin //背券芒俊辑 颗
            DealZeroGold;
         end;
      end;
   end;
end;

{------------------------------------------------------------------------}

//惑牢 措拳 芒

{------------------------------------------------------------------------}
procedure TFrmDlg.ShowMDlg (face: integer; mname, msgstr: string);
var
   i: integer;
begin
   DMerchantDlg.GLeft := 0;  //扁夯 困摹
   DMerchantDlg.GTop := 0;
   MerchantFace := face;
   MerchantName := mname;
   MDlgStr := msgstr;
   DMerchantDlg.Visible := TRUE;
   DHeroIcon.Visible:=false;//如果NPC对话框显示 那么英雄图标隐藏
   {$IF M2Version = 2} //1.76
   DItemBag.GLeft := 475;  //啊规困摹 函版
   DItemBag.GTop := 0;//20090304修改
   {$ELSE}
   DItemBag.GLeft := 440;  //啊规困摹 函版
   DItemBag.GTop := {-25}3;//20090304修改
   {$IFEND}
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (pTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   RequireAddPoints := TRUE;
   LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowMBigDlg (face: integer; mname, msgstr: string);
var
   i: integer;
begin
   DBigMerchantDlg.GLeft := 0;  //扁夯 困摹
   DBigMerchantDlg.GTop := 0;
   MerchantFace := face;
   MerchantName := mname;
   MDlgStr := msgstr;
   DBigMerchantDlg.Visible := TRUE;
   DHeroIcon.Visible:=false;//如果NPC对话框显示 那么英雄图标隐藏
   {$IF M2Version = 2} //1.76
   DItemBag.GLeft := 475;  //啊规困摹 函版
   DItemBag.GTop := 0;//20090304修改
   {$ELSE}
   DItemBag.GLeft := 440;  //啊规困摹 函版
   DItemBag.GTop := {-25}3;//20090304修改
   {$IFEND}
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (pTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   RequireAddPoints := TRUE;
   LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowMouseItemInfo(X, Y: Integer; AddLine: string; who:Byte; DrawUp: Boolean);
var
  hcolor, iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  sItemInfo: string;
  ClientItem:TClientItem;
  CurLevelValue:Integer;

  procedure DoItemInfoText(FindStr:string);
  var I,P1,P2:Integer;
      Src,Dst:string;
      C:Char;
  begin
    P1:=Pos(FindStr,sItemInfo);
    if P1<1 then Exit;
    P2:=0;
    for I := P1+Length(FindStr) to Length(sItemInfo) do
    begin
      if sItemInfo[I] in [' ','\'] then
      begin
        P2:=I;
        Break;
      end;
    end;
    if P2<1 then Exit;

    Src:=Copy(sItemInfo,P1,P2-P1);
    Dst:='<'+Src+'/c=red>';
    sItemInfo:=ReplaceText(sItemInfo,Src,Dst);
  end;

const
  sItemInfoFormat = '<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s';
begin   
  GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, who);
  case who of
    1: g_MouseItem.ClientItem.S.Name := '';
    2: g_HeroMouseItem.ClientItem.S.Name := '';
  end;
  
  if iname <> '' then begin
    if who=1 then ClientItem:=g_MouseItem.ClientItem else ClientItem:=g_HeroMouseItem.ClientItem;
    hcolor := '';
    sItemInfo := Format(sItemInfoFormat, [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]);

    case ClientItem.s.Need of
      0: // 需要等级
      begin
        if who=1 then CurLevelValue:=g_MySelf.m_Abil.Level else CurLevelValue:=g_HeroSelf.m_Abil.Level;
        if ClientItem.s.NeedLevel>CurLevelValue then DoItemInfoText('需要等级');
      end;
      1: // 需要攻击力
      begin
        if who=1 then CurLevelValue:=HiWord(g_MySelf.m_Abil.DC) else CurLevelValue:=HiWord(g_HeroSelf.m_Abil.DC);
        if ClientItem.s.NeedLevel>CurLevelValue then DoItemInfoText('需要攻击');
      end;
      2: // 需要魔法力
      begin
        if who=1 then CurLevelValue:=HiWord(g_MySelf.m_Abil.MC) else CurLevelValue:=HiWord(g_HeroSelf.m_Abil.MC);
        if ClientItem.s.NeedLevel>CurLevelValue then DoItemInfoText('需要魔法');
      end;
      3: // 需要道术
      begin
        if who=1 then CurLevelValue:=HiWord(g_MySelf.m_Abil.SC) else CurLevelValue:=HiWord(g_HeroSelf.m_Abil.SC);
        if ClientItem.s.NeedLevel>CurLevelValue then DoItemInfoText('需要道术');
      end;
    else      
      if not useable then hcolor := 'red' else hcolor := '';
      sItemInfo := Format(sItemInfoFormat, [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]);
    end;     

    if AddLine <> '' then sItemInfo := sItemInfo + AddLine;
    DScreen.ShowSpecialHint(X, Y, sItemInfo, DrawUp);
  end;
end;

procedure TFrmDlg.DWRefineDrumInitialize(Sender: TObject);
var
  d: TAsphyreLockableTexture;
begin
   d := g_WMainImages.Images[1420];
   if d <> nil then DWRefineDrum.SetImgIndex (g_WMainImages, 1420)
end;


procedure TFrmDlg.RefineBtn1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
   butt: TAspDButton;
   sel: Integer;
begin
   butt := TAspDButton(Sender);
   sel := 0;
   if not g_boItemMoving then begin
      if g_RefineDrumItem[butt.Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_RefineDrumItem[butt.Tag].ClientItem.s);
         if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingItemUp.Item.ClientItem.S.Name <> '') then exit;
         sel := -1;
         {if Sender = DItemsUpBelt1 then sel := 0;
         if Sender = DItemsUpBelt2 then sel := 1;
         if Sender = DItemsUpBelt3 then sel := 2;}
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(sel + 41);
         g_MovingItem.Item := g_RefineDrumItem[butt.Tag];
         g_RefineDrumItem[butt.Tag].ClientItem.s.Name := '';
      end;
   end else begin
      //if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;
      //if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -41) or (g_MovingItem.Index = -42) or
      //   (g_MovingItem.Index = -43) then
      begin
         ItemClickSound (g_MovingItem.Item.ClientItem.S);
         if g_RefineDrumItemName[butt.Tag+1]='' then Exit;
         if g_RefineDrumItemName[butt.Tag+1]<>g_MovingItem.Item.ClientItem.s.Name then Exit;

         if g_RefineDrumItem[butt.Tag].ClientItem.s.Name <> '' then begin //磊府俊 乐栏搁
            temp := g_RefineDrumItem[butt.Tag];
            g_RefineDrumItem[butt.Tag] := g_MovingItem.Item;
            g_MovingItem.Index := -(sel + 41);
            g_MovingItem.Item := temp
         end else begin
            g_RefineDrumItem[butt.Tag] := g_MovingItem.Item;
            g_MovingItem.Item.ClientItem.S.name := '';
            g_boItemMoving := FALSE;
         end;
      end;
   end;
end;

procedure TFrmDlg.RefineBtn1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  btn:TAspDButton;
  Str:string;
begin
  btn:=TAspDButton(Sender);
  if Sender = RefineBtn6 then
  begin
    if g_RefineDrumItem[g_RefineDrumCount-1].ClientItem.s.Name <> '' then
    begin
      idx := g_RefineDrumItem[g_RefineDrumCount-1].ClientItem.s.Looks;
      if idx >= 0 then d := frmMain.GetBagItemImg(idx);
    end else
      d := g_WUI1Images.Images[1653];
    if d <> nil then
      dsurface.Draw (btn.SurfaceX(btn.GLeft),
                     btn.SurfaceY(btn.GTop ),
                     d.ClientRect, d, TRUE);
  end else
  begin
    if g_RefineDrumItem[btn.Tag].ClientItem.s.Name <> '' then
    begin
      idx := g_RefineDrumItem[btn.Tag].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
      end;
    end else
    begin
      Str:=g_RefineDrumItemName[btn.Tag+1]; // 存放的辅助材料数量
      if Str<>'' then
        d := g_WUI1Images.Images[1651] else d := g_WUI1Images.Images[1652];
    end;
    if d <> nil then
      dsurface.Draw (btn.SurfaceX(btn.GLeft),
                   btn.SurfaceY(btn.GTop),
                   d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.RefineBtn1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
   idx: integer;
begin
   idx := TAspDButton(Sender).Tag;
   if idx in [0..5] then begin
      if g_RefineDrumItem[idx].ClientItem.s.Name <> '' then begin
         g_MouseItem := g_ItemsUpItem[idx];
      end;
   end;
end;

procedure TFrmDlg.ResetMenuDlg;
var
   i: integer;
begin
   CloseDSellDlg;
   if g_MenuItemList.Count > 0 then //20080629
   for i:=0 to g_MenuItemList.Count-1 do  //技何 皋春档 努府绢 窃.
      Dispose(PTClientEffectItem(g_MenuItemList[i]));
   g_MenuItemList.Clear;

   if MenuList.Count > 0 then //20080629
   for i:=0 to MenuList.Count-1 do
      Dispose (PTClientGoods(MenuList[i]));
   MenuList.Clear;
   MenuIndex := -1;
   MenuTopLine := 0;
   BoDetailMenu := False;
   BoStorageMenu := False;
   BoMakeDrugMenu := False;

   DSellDlg.Visible := False;
   DMenuDlg.Visible := False;
   DWSellOffList.Visible := False; //元宝寄售列表不可见 20080318
   g_SellOffItemIndex := 200;
end;

procedure TFrmDlg.ShowShopMenuDlg;
begin
   MenuIndex := -1;
   if WinType=1 then
   begin
     DMerchantDlg.GLeft := 0;
     DMerchantDlg.GTop := 0;
     DMerchantDlg.Visible := TRUE;
     DSellDlg.Visible := FALSE;
     DMenuDlg.GLeft := 0;
     DMenuDlg.GTop  := 176;
   end else
   begin
     DBigMerchantDlg.GLeft := 0;
     DBigMerchantDlg.GTop := 0;
     DBigMerchantDlg.Visible := TRUE;
     DSellDlg.Visible := FALSE;
     DMenuDlg.GLeft := 0;
     DMenuDlg.GTop  := DBigMerchantDlg.GHeight+1;
   end;
   DMenuDlg.Visible := TRUE;
   MenuTop := 0;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 475;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := 440;
   DItemBag.GTop := -25;
   {$IFEND}
   DItemBag.Visible := TRUE;
   LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowShopSellDlg;
begin
   if WinType=1 then
   begin
     DSellDlg.GLeft := 260;
     DSellDlg.GTop := 176;
   end else
   begin
     DSellDlg.GLeft := 260;
     DSellDlg.GTop := DBigMerchantDlg.GHeight+1;
   end;
   DSellDlg.Visible := TRUE;
   DMenuDlg.Visible := FALSE;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 475;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := 440;
   DItemBag.GTop := -25;
   {$IFEND}
   DItemBag.Visible := TRUE;
   LastestClickTime := GetTickCount;
   g_sSellPriceStr := '';
end;

procedure TFrmDlg.CloseMDlg;
var
   i: integer;
begin
   if not DMerchantDlg.Visible then Exit;
   MDlgStr := '';
   DMerchantDlg.Visible := FALSE;
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (PTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 0;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := -5;
   DItemBag.GTop := {-25}69;//20090304修改
   {$IFEND}
   DMenuDlg.Visible := FALSE;
   CloseDSellDlg;
   DWSellOffList.Visible := False; //元宝寄售列表不可见 20080318
   DWSellOff.Visible := False;
   if g_HeroSelf <> nil then DHeroIcon.Visible := TRUE;//如果NPC对话框关闭 那么英雄图标显示
{******************************************************************************}
//酒馆
   DWiGetHero.Visible := False;
   DPlayDrink.Visible := False;

   DWPleaseDrink.Visible := False;
   if g_PDrinkItem[0].ClientItem.s.Name <> '' then begin
     AddItemBag(g_PDrinkItem[0]);
     g_PDrinkItem[0].ClientItem.s.Name := '';
   end;
   if g_PDrinkItem[1].ClientItem.s.Name <> '' then begin
     AddItemBag(g_PDrinkItem[1]);
     g_PDrinkItem[1].ClientItem.s.Name := '';
   end;
end;

procedure TFrmDlg.CloseMBigDlg;
var
   i: integer;
begin
   if not DBigMerchantDlg.Visible then Exit;
   MDlgStr := '';
   DBigMerchantDlg.Visible := FALSE;
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (PTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 0;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := -5;
   DItemBag.GTop := {-25}69;//20090304修改
   {$IFEND}
   DMenuDlg.Visible := FALSE;
   CloseDSellDlg;
   DWSellOffList.Visible := False; //元宝寄售列表不可见 20080318
   DWSellOff.Visible := False;
   if g_HeroSelf <> nil then DHeroIcon.Visible := TRUE;//如果NPC对话框关闭 那么英雄图标显示
{******************************************************************************}
//酒馆
   DWiGetHero.Visible := False;
   DPlayDrink.Visible := False;

   DWPleaseDrink.Visible := False;
   if g_PDrinkItem[0].ClientItem.s.Name <> '' then begin
     AddItemBag(g_PDrinkItem[0]);
     g_PDrinkItem[0].ClientItem.s.Name := '';
   end;
   if g_PDrinkItem[1].ClientItem.s.Name <> '' then begin
     AddItemBag(g_PDrinkItem[1]);
     g_PDrinkItem[1].ClientItem.s.Name := '';
   end;
end;

procedure TFrmDlg.CreateParams(var Params: TCreateParams);
  function RandomGetPass():string;
  var
    s,s1:string;
    I,i0:Byte;
  begin
    s:='123456789ABCDEFGHIJKLMNPQRSTUVWXYZ';
    s1:='';
    Randomize(); //随机种子
    for i:=0 to 5 do begin
      i0:=random(35);
      s1:=s1+copy(s,i0,1);
    end;
    Result := s1;
  end;
begin
  inherited CreateParams(Params);
  strpcopy(pChar(@Params.WinClassName),RandomGetPass);
end;

procedure TFrmDlg.CloseDSellDlg;
begin
  DSellDlg.Visible := FALSE;
  if g_SellDlgItem.ClientItem.S.Name <> '' then
    AddItemBag (g_SellDlgItem);
  g_SellDlgItem.ClientItem.S.Name := '';
end;

procedure TFrmDlg.DMerchantDlgShowText(Sender: TObject;
  Msg, SelectStr: string; X, Y: Word;
  Points: TList; var AddPoints: Boolean);
var
  str, data, fdata, cmdstr, cmdparam, cxmdtitle: string;
  lx, ly, sx: integer;
  pcp: PTClickPoint;
  Color: TColor;
  sColor, cmdtitle, sTemp: string;
begin
  lx := X;
  ly := Y;
  str := Msg;
  with Sender as TAspDWindow do begin
    while TRUE do begin
      if str = '' then break;
      str := GetValidStr3 (str, data, ['\']);
      if data <> '' then begin
        sx := 0;
        while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin
          fdata := '';
          if data[1] <> '<' then begin
            data := '<' + GetValidStr3 (data, fdata, ['<']);
          end;
          data := ArrestStringEx (data, '<', '>', cmdstr);//得到"<"和">" 号之间的字   赋予给 cmdstr

           //fdata + cmdstr + data
          if cmdstr <> '' then begin
            if Uppercase(cmdstr) = 'C' then begin
              continue;
            end;
            if UpperCase(cmdstr) = '/C' then begin
              continue;
            end;
            cmdparam := GetValidStr3 (cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
          end else begin
            DMenuDlg.Visible := FALSE;
            DSellDlg.Visible := FALSE;
          end;

          if fdata <> '' then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clWhite, clBlack, fdata);
            sx := sx + AspTextureFont.TextWidth(fdata);
          end;
          if (cmdstr <> '') then begin
            if (cmdparam <> '') then begin
              if CompareLStr(cmdparam, 'FCOLOR=', length('FCOLOR=')) then begin
                sColor := GetValidStr3(cmdparam, sTemp, ['=']);
                Color := GetRGB(Lobyte(Str_ToInt(sColor, 255)));
                AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), Color, clBlack, cmdstr)  //显示颜色文字
              end else begin
              	cmdtitle := '';
                if Pos('|', cmdparam) > 0 then begin
                  sTemp := GetValidStr3(cmdparam, cmdparam, ['|']);
                  if CompareLStr(sTemp, 'TITLE=', length('TITLE=')) then begin
                    cmdtitle := GetValidStr3(sTemp, sTemp, ['=']);
                  end;
                end;
                if AddPoints then begin
                  new (pcp);
                  pcp.rc := Rect (lx+sx, ly, lx+sx + AspTextureFont.TextWidth(cmdstr), ly + 14);
                  pcp.RStr := cmdparam;
                  pcp.TStr := cmdtitle;
                  Points.Add (pcp);
                end;
                if SelectStr = cmdparam  then begin
                  AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clRed, clBlack, cmdstr, [fsUnderline]);
                end else AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clYellow, clBlack, cmdstr, [fsUnderline]);
            	end;
          	end else begin
              if SelectStr = cmdparam  then begin
                AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clRed, clBlack, cmdstr, [fsUnderline]);
              end else AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clYellow, clBlack, cmdstr, [fsUnderline]);
            end;
            sx := sx + AspTextureFont.TextWidth(cmdstr);
          end;
        end;
        if data <> '' then
           AspTextureFont.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clWhite, clBlack, data);
      end;
      ly := ly + 16;
    end;
  end;
  AddPoints := FALSE;
end;


(*******************************************************************************
作用 :NPC脚本文字{功能}显示位置
过程 :
参数 :
*******************************************************************************)
procedure TFrmDlg.DMerchantDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TAspDWindow do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  DMerchantDlgShowText(Sender, MDlgStr, SelectMenuStr, 30, 20,
    MDlgPoints, RequireAddPoints);
end;

procedure TFrmDlg.DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseMDlg;
end;

procedure TFrmDlg.DMenuDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  function SX(x: integer): integer;
  begin
      Result := DMenuDlg.SurfaceX (DMenuDlg.GLeft + x);
  end;
  function SY(y: integer): integer;
  begin
      Result := DMenuDlg.SurfaceY (DMenuDlg.GTop + y);
  end;
var
   i, lh,  m, menuline: integer;
   d: TAsphyreLockableTexture;
   pg: PTClientGoods;
   str: string;
   Color: TColor;
begin
      with DMenuDlg do begin
        if DMenuDlg.WLib <> nil then begin //20080701
         d := DMenuDlg.WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
      //title
      Color := clWhite;
      if not BoStorageMenu then begin
         AspTextureFont.TextOut (19,  SY(11), Color, '物品列表');
         AspTextureFont.TextOut (SX(156), SY(11), Color, '价格');
         AspTextureFont.TextOut (SX(245), SY(11), Color, '持久');
         lh := LISTLINEHEIGHT;
         menuline := _MIN(MAXMENU, MenuList.Count-MenuTop);
         //惑前 府胶飘
         for i:=MenuTop to MenuTop+menuline-1 do begin
            m := i-MenuTop;
            if i = MenuIndex then begin
              Color := clRed;
               AspTextureFont.TextOut (SX(12),  SY(32 + m*lh), Color, char(7));
            end else Color := clWhite;
            pg := PTClientGoods (MenuList[i]);
            AspTextureFont.TextOut (SX(19),  SY(32 + m*lh), Color, pg.Name);
            //if pg.SubMenu >= 1 then
            //   ClFunc.TextOut (SX(137), SY(32 + m*lh), Font.Color, #31);
            AspTextureFont.TextOut (SX(156), SY(32 + m*lh), Color, IntToStr(pg.Price) + ' ' + g_sGoldName{金币'});
            str := '';
            if pg.Grade = -1 then str := '-'
            else AspTextureFont.TextOut (SX(245), SY(32 + m*lh), Color,IntToStr(pg.Grade));
         end;
      end else begin
         AspTextureFont.TextOut (SX(19),  SY(11), Color, '托管物品列表('+IntToStr(MenuList.Count)+'/44件)');
         AspTextureFont.TextOut (SX(156), SY(11), Color, '持久');
         //ClFunc.TextOut (SX(245), SY(11), Font.Color, '');
         lh := LISTLINEHEIGHT;
         menuline := _MIN(MAXMENU, MenuList.Count-MenuTop);
         //惑前 府胶飘
         for i:=MenuTop to MenuTop+menuline-1 do begin
            m := i-MenuTop;
            if i = MenuIndex then begin
               Color := clRed;
               AspTextureFont.TextOut (SX(12),  SY(32 + m*lh), Color, char(7));
            end else Color := clWhite;
            pg := PTClientGoods (MenuList[i]);
            AspTextureFont.TextOut (SX(19),  SY(32 + m*lh), Color, pg.Name);
            AspTextureFont.TextOut (SX(156), SY(32 + m*lh), Color, IntToStr(pg.Stock) + '/' + IntToStr(pg.Grade));
         end;
      end;
end;

procedure TFrmDlg.DMenuDlgClick(Sender: TObject; X, Y: Integer);
var
   lx, ly, idx: integer;
   iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
   useable: Boolean;
begin
   DScreen.ClearHint;
   lx := DMenuDlg.LocalX (X) - DMenuDlg.GLeft;
   ly := DMenuDlg.LocalY (Y) - DMenuDlg.GTop;
   if (lx >= 14) and (lx <= 279) and (ly >= 32) and (ly <= 160){ 2008.02.13} then begin
      idx := (ly-32) div LISTLINEHEIGHT + MenuTop;
      if idx < MenuList.Count then begin
         PlaySound (s_glass_button_click);
         MenuIndex := idx;
      end;
   end;

   if BoStorageMenu then begin
      if (MenuIndex >= 0) and (MenuIndex < g_SaveItemList.Count) then begin
         g_MouseItem := PTClientEffectItem(g_SaveItemList[MenuIndex])^;
         lx := 240;
         ly := 32+(MenuIndex-MenuTop) * LISTLINEHEIGHT;
         with Sender as TAspDButton do
         	ShowMouseItemInfo(SurfaceX(GLeft)+lx, SurfaceY(GTop)+ly, '', 1, False);
      end;
   end else begin
      if (MenuIndex >= 0) and (MenuIndex < g_MenuItemList.Count) and (PTClientGoods (MenuList[MenuIndex]).SubMenu = 0) then begin
         g_MouseItem := PTClientEffectItem(g_MenuItemList[MenuIndex])^;
         BoNoDisplayMaxDura := TRUE;
         GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
         BoNoDisplayMaxDura := FALSE;
         if iname <> '' then begin
            lx := 240;
            ly := 32+(MenuIndex-MenuTop) * LISTLINEHEIGHT;
            with Sender as TAspDButton do
               DScreen.ShowSpecialHint(SurfaceX(GLeft + lx),
                                 SurfaceY(GTop + ly),
                                 Format('<%s/c=Yellow>%s\%s\%s',[iname, d1,d2,d3]), FALSE);
         end;
         g_MouseItem.ClientItem.S.Name := '';
      end;
   end;
end;

procedure TFrmDlg.DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
   with DMenuDlg do
      if (X < SurfaceX(GLeft+10)) or (X > SurfaceX(GLeft+GWidth-20)) or (Y < SurfaceY(GTop+30)) or (Y > SurfaceY(GTop+GHeight-50)) then begin
         DScreen.ClearHint;
      end;
end;

procedure TFrmDlg.DMenuBuyClick(Sender: TObject; X, Y: Integer);
var
   pg: PTClientGoods;
begin
   if GetTickCount < LastestClickTime then exit; 
   if (MenuIndex >= 0) and (MenuIndex < MenuList.Count) then begin
      pg := PTClientGoods (MenuList[MenuIndex]);
      LastestClickTime := GetTickCount + 5000;
      if pg.SubMenu > 0 then begin
         FrmMain.SendGetDetailItem (g_nCurMerchant, 0, pg.Name);
         MenuTopLine := 0;
         CurDetailItem := pg.Name;
      end else begin
         if BoStorageMenu then begin
            FrmMain.SendTakeBackStorageItem (g_nCurMerchant, pg.Price{MakeIndex}, pg.Name);
            exit;
         end;
         if BoMakeDrugMenu then begin
            FrmMain.SendMakeDrugItem (g_nCurMerchant, pg.Name);
            exit;
         end;
         FrmMain.SendBuyItem (g_nCurMerchant, pg.Stock, pg.Name)
      end;
   end;
end;

procedure TFrmDlg.DMenuPrevClick(Sender: TObject; X, Y: Integer);
begin
   if not BoDetailMenu then begin
      if MenuTop > 0 then Dec (MenuTop, MAXMENU-1);
      if MenuTop < 0 then MenuTop := 0;
   end else begin
      if MenuTopLine > 0 then begin
         MenuTopLine := _MAX(0, MenuTopLine-10);
         FrmMain.SendGetDetailItem (g_nCurMerchant, MenuTopLine, CurDetailItem);
      end;
   end;
end;

procedure TFrmDlg.DMenuNextClick(Sender: TObject; X, Y: Integer);
begin
   if not BoDetailMenu then begin
      if MenuTop + MAXMENU < MenuList.Count then Inc (MenuTop, MAXMENU-1);
   end else begin
      MenuTopLine := MenuTopLine + 10;
      FrmMain.SendGetDetailItem (g_nCurMerchant, MenuTopLine, CurDetailItem);
   end;      
end;

procedure TFrmDlg.SoldOutGoods (itemserverindex: integer);
var
   i: integer;
   pg: PTClientGoods;
begin
   if MenuList.Count > 0 then //20080629
   for i:=0 to MenuList.Count-1 do begin
      pg := PTClientGoods (MenuList[i]);
      if (pg.Grade >= 0) and (pg.Stock = itemserverindex) then begin
         Dispose (pg);
         MenuList.Delete (i);
         if i < g_MenuItemList.Count then g_MenuItemList.Delete (i);
         if MenuIndex > MenuList.Count-1 then MenuIndex := MenuList.Count-1;
         break;
      end;
   end;
end;

procedure TFrmDlg.DelStorageItem (itemserverindex: integer);
var
   i: integer;
   pg: PTClientGoods;
begin
   if MenuList.Count > 0 then //20080629
   for i:=0 to MenuList.Count-1 do begin
      pg := PTClientGoods (MenuList[i]);
      if (pg.Price = itemserverindex) then begin //焊包格废牢版款 Price = ItemServerIndex烙.
         Dispose (pg);
         MenuList.Delete (i);
         if i < g_SaveItemList.Count then g_SaveItemList.Delete (i);
         if MenuIndex > MenuList.Count-1 then MenuIndex := MenuList.Count-1;
         break;
      end;
   end;
end;

procedure TFrmDlg.DMenuCloseClick(Sender: TObject; X, Y: Integer);
begin
   DMenuDlg.Visible := FALSE;
end;

function TFrmDlg.DMerchantDlgSelect(const RStr, sTitle: string;
  var LStr: string): Boolean;
var
  msg: TDefaultMessage;
  param: string;
  I: Integer;
  ssTitle: string;
begin
  Result := False;
  LStr := RStr;
  {$IF M2Version <> 2}
  if CompareText(LStr, '@^SHOWKAMPODLG') = 0 then begin
    if g_boOpenLeiMei then begin
      m_btSignedItemsPage := 0;
      DBSignedBelt1.Visible := True;
      DBSignedBelt2.Visible := True;
      DBOrdSigned.Visible := True;
      DBHighSigned.Visible := True;
      DBSignedChange.Visible := False;
      DWSignedItems.Visible := True;
    end;
  end else if CompareText(LStr, '@^OPENMAKEANDSCROLLDLG') = 0 then begin
    if g_boOpenLeiMei then begin
      if not DWMakeSigned.Visible then begin
        msg := MakeDefaultMsg (aa(CM_OPENSCROLLFRM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket(EncodeMessage (msg));
        DWMakeSigned.Visible := True;
      end;
    end;
  end else begin{$IFEND}
    param := '';
    if sTitle = '' then ssTitle := '输入信息' else ssTitle := sTitle;
    if Length(LStr) >= 2 then begin  //颇扼皋鸥啊 鞘夸茄 版快啊 乐澜.
      if (LStr[1] = '@') and (LStr[2] = '@') then begin
        if LStr = '@@buildguildnow' then begin
          FrmDlg.DMessageDlg ('请输入建立这个行会名称.', [mbOk, mbAbort]);
        end else
        {$IF M2Version <> 2}
        if LStr = '@@buildDivisionnow' then begin//20110730
          FrmDlg.DMessageDlg ('请输入建立师门名称.', [mbOk, mbAbort]);
        end else
        {$IFEND}
        if Pos('@@InPutString',LStr) > 0 then begin
        	EdDlgEdit.MaxLength := 80;
          if mrOk = FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort, mbCancel]) then begin
            EdDlgEdit.MaxLength := 30;
            if (Trim (FrmDlg.DlgEditText) = '') then begin
              FrmDlg.DMessageDlg ('信息不能为空！', [mbOk]);
              Exit;
            end;
            for I:=1 to length(FrmDlg.DlgEditText) do begin
              if FrmDlg.DlgEditText[i] in ['/','\'] then begin
                FrmDlg.DMessageDlg ('输入数据中包含了非法符号，请重新输入！', [mbOk]);
                Exit;
              end;
            end;
          end else begin
            EdDlgEdit.MaxLength := 30;
            Exit;
          end;
        end else
        if Pos('@@InPutInteger',LStr) > 0 then begin
          if mrCancel = FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort, mbCancel]) then Exit;
          if (Trim (FrmDlg.DlgEditText) = '') then begin
            FrmDlg.DMessageDlg ('信息不能为空！', [mbOk]);
            Exit;
          end;
          for I:=1 to length(FrmDlg.DlgEditText) do begin
            if not (FrmDlg.DlgEditText[i] in ['0'..'9']) then begin
              FrmDlg.DMessageDlg ('输入数据中包含了非法符号，请重新输入！', [mbOk]);
              Exit;
            end;
          end;
          if (StrToInt(FrmDlg.DlgEditText) > 2147483646) then begin
            FrmDlg.DMessageDlg ('输入数字范围必须在0到21亿之间，请重新输入！', [mbOk]);
            Exit;
          end;
        end else
        if Pos('@@SendMsg',LStr) > 0 then begin
        	EdDlgEdit.MaxLength := 80;
          if mrOk = FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort, mbCancel]) then begin
          	EdDlgEdit.MaxLength := 30;
            if (Trim (FrmDlg.DlgEditText) = '') then begin
              FrmDlg.DMessageDlg ('信息不能为空！', [mbOk]);
              Exit;
            end;
            for I:=1 to length(FrmDlg.DlgEditText) do begin
              if FrmDlg.DlgEditText[i] in ['/','\'] then begin
                FrmDlg.DMessageDlg ('输入数据中包含了非法符号，请重新输入！', [mbOk]);
                Exit;
              end;
            end;
          end else begin
          	EdDlgEdit.MaxLength := 30;
            Exit;
          end;
        end else FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort]);
        param := Trim (FrmDlg.DlgEditText);
        LStr := LStr + #13 + param;
      end;
    end;
    Result := True;
  {$IF M2Version <> 2}
  end;
  {$IFEND}
end;

procedure TFrmDlg.DMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  msg: TDefaultMessage;
  sData: string;
begin
   if GetTickCount < LastestClickTime then exit;
   L := DMerchantDlg.GLeft;
   T := DMerchantDlg.GTop;
   with DMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            PlaySound (s_glass_button_click);
            if DMerchantDlgSelect(p.RStr, p.TStr, sData) then FrmMain.SendMerchantDlgSelect(g_nCurMerchant, sData);
            LastestClickTime := GetTickCount + 2000; //20080803修改 以前为5000
            break;
         end;
      end;
end;

procedure TFrmDlg.DMerchantDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   if GetTickCount < LastestClickTime then exit; 
   SelectMenuStr := '';
   L := DMerchantDlg.GLeft;
   T := DMerchantDlg.GTop;
   with DMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
   if DHeroIcon.Visible then DHeroIcon.Visible := False;  //20080521
end;

procedure TFrmDlg.DMerchantDlgMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   SelectMenuStr := '';
end;

procedure TFrmDlg.DSellDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   actionname: string;
begin
   with DSellDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         actionname := '';
         case SpotDlgMode of
            dmSell:   actionname := '出售: ';
            dmRepair: actionname := '修理: ';
            dmStorage: actionname := ' 保管物品';
            dmPlayDrink: actionname := '请酒';  //20080515
            {$IF M2Version <> 2}
            dmArmsTear: actionname := '拆分: ';//20100708
            {$IFEND}
         end;
         AspTextureFont.TextOut (SurfaceX(GLeft+8), SurfaceY(GTop+6), clWhite, actionname + g_sSellPriceStr);
   end;
end;

procedure TFrmDlg.DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseDSellDlg;
end;

procedure TFrmDlg.DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
begin
   g_sSellPriceStr := '';
   if not g_boItemMoving then begin
      if g_SellDlgItem.ClientItem.S.Name <> '' then begin
         ItemClickSound (g_SellDlgItem.ClientItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -99; //sell 芒俊辑 唱咳..
         g_MovingItem.Item := g_SellDlgItem;
         g_SellDlgItem.ClientItem.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -99) then begin //啊规,骇飘俊辑 柯巴父
         ItemClickSound (g_MovingItem.Item.ClientItem.S);
         if g_SellDlgItem.ClientItem.S.Name <> '' then begin //磊府俊 乐栏搁
            temp := g_SellDlgItem;
            g_SellDlgItem := g_MovingItem.Item;
            g_MovingItem.Index := -99; //sell 芒俊辑 唱咳..
            g_MovingItem.Item := temp
         end else begin
            g_SellDlgItem := g_MovingItem.Item;
            g_MovingItem.Item.ClientItem.S.name := '';
            g_boItemMoving := FALSE;
         end;
         g_boQueryPrice := TRUE;
         g_dwQueryPriceTime := GetTickCount;
      end;
   end;
end;

procedure TFrmDlg.DSellDlgSpotDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   if g_SellDlgItem.ClientItem.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_SellDlgItem.ClientItem.S.Looks);
      if d <> nil then
         with DSellDlgSpot do
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
   end;
end;

//卖物品时放物品的那个框框
procedure TFrmDlg.DSellDlgSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   g_MouseItem := g_SellDlgItem;
end;

//卖物品的确定按钮
procedure TFrmDlg.DSellDlgOkClick(Sender: TObject; X, Y: Integer);
begin
   if (g_SellDlgItem.ClientItem.S.Name = '') and (g_SellDlgItemSellWait.ClientItem.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit; 
   case SpotDlgMode of
      dmSell: FrmMain.SendSellItem (g_nCurMerchant, g_SellDlgItem.ClientItem.MakeIndex, g_SellDlgItem.ClientItem.S.Name);
      dmRepair: FrmMain.SendRepairItem (g_nCurMerchant, g_SellDlgItem.ClientItem.MakeIndex, g_SellDlgItem.ClientItem.S.Name);
      dmStorage: FrmMain.SendStorageItem (g_nCurMerchant, g_SellDlgItem.ClientItem.MakeIndex, g_SellDlgItem.ClientItem.S.Name);
      dmPlayDrink: FrmMain.SendPlayDrinkItem(g_nCurMerchant, g_SellDlgItem.ClientItem.MakeIndex, g_SellDlgItem.ClientItem.S.Name);
      {$IF M2Version <> 2}
      dmArmsTear: FrmMain.SendArmsTear(g_nCurMerchant, g_SellDlgItem.ClientItem.MakeIndex, g_SellDlgItem.ClientItem.S.Name);//20100708
      dmArmsExchange: begin
        if mrOk = FrmDlg.DMessageDlg ('你确定要把这件装备兑换成卷轴碎片吗？兑换成功后，你的这件装备将消\失 ，不可赎回！', [mbOk, mbCancel]) then begin
          frmMain.SendArmsExchange(g_nCurMerchant, g_SellDlgItem.ClientItem.MakeIndex, g_SellDlgItem.ClientItem.S.Name);
        end else Exit;
      end;
      {$IFEND}
   end;
   g_SellDlgItemSellWait := g_SellDlgItem;
   g_SellDlgItem.ClientItem.S.Name := '';
   LastestClickTime := GetTickCount + 5000;
   g_sSellPriceStr := '';
end;

procedure TFrmDlg.SetMagicKeyDlg (icon: integer; Effect, Level,LevelEx: Byte; MagID: Word; magname: string; var curkey: word);
begin
   MagKeyIcon := icon;
   MagKeyMagName := magname;
   MagKeyCurKey := curkey;
   MagKeyEffect := Effect;
   MagKeyID := MagID;
   MagKeyLevel := Level;
   MagKeyLevelEx := LevelEx;
   HideAllControls;
   DKeySelDlg.ShowModal;
   DKeySelDlg.GLeft := (g_D3DConfig.wScreenWidth - DKeySelDlg.GWidth) div 2;
   DKeySelDlg.GTop  := (g_D3DConfig.wScreenHeight - DKeySelDlg.GHeight) div 2;    

   while TRUE do begin
      if not DKeySelDlg.Visible then break;
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then exit;
   end;

   RestoreHideControls;
   curkey := MagKeyCurKey;
end;

procedure TFrmDlg.DKeySelDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with DKeySelDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      AspTextureFont.TextOut (SurfaceX(GLeft + 95), SurfaceY(GTop + 38), clSilver ,MagKeyMagName + '  快捷键盘被设置为.');
   end;
end;



procedure TFrmDlg.DKsIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   wm: TAspWMImages;
begin
   with DksIcon do begin
      wm := GetMagicIcon(MagKeyEffect, MagKeyLevel, MagKeyID, MagKeyLevelEx, MagKeyIcon);
      if wm <> nil then begin
        d := wm.Images[MagKeyIcon];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;



procedure TFrmDlg.DKsF1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   b: TAspDButton;
   d: TAsphyreLockableTexture;
begin
   case MagKeyCurKey of
      word('1'): b := DKsF1;
      word('2'): b := DKsF2;
      word('3'): b := DKsF3;
      word('4'): b := DKsF4;
      word('5'): b := DKsF5;
      word('6'): b := DKsF6;
      word('7'): b := DKsF7;
      word('8'): b := DKsF8;
      word('E'): b := DKsConF1;
      word('F'): b := DKsConF2;
      word('G'): b := DKsConF3;
      word('H'): b := DKsConF4;
      word('I'): b := DKsConF5;
      word('J'): b := DKsConF6;
      word('K'): b := DKsConF7;
      word('L'): b := DKsConF8;
      else b := DKsNone;
   end;
   if b = Sender then begin
      with b do begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex+1];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
   with Sender as TAspDButton do begin
      if Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;



procedure TFrmDlg.DKsOkClick(Sender: TObject; X, Y: Integer);
begin
   DKeySelDlg.Visible := FALSE;
end;





procedure TFrmDlg.DKsF1Click(Sender: TObject; X, Y: Integer);
begin
   if Sender = DKsF1 then MagKeyCurKey := integer('1');
   if Sender = DKsF2 then MagKeyCurKey := integer('2');
   if Sender = DKsF3 then MagKeyCurKey := integer('3');
   if Sender = DKsF4 then MagKeyCurKey := integer('4');
   if Sender = DKsF5 then MagKeyCurKey := integer('5');
   if Sender = DKsF6 then MagKeyCurKey := integer('6');
   if Sender = DKsF7 then MagKeyCurKey := integer('7');
   if Sender = DKsF8 then MagKeyCurKey := integer('8');
   if Sender = DKsConF1 then MagKeyCurKey := integer('E');
   if Sender = DKsConF2 then MagKeyCurKey := integer('F');
   if Sender = DKsConF3 then MagKeyCurKey := integer('G');
   if Sender = DKsConF4 then MagKeyCurKey := integer('H');
   if Sender = DKsConF5 then MagKeyCurKey := integer('I');
   if Sender = DKsConF6 then MagKeyCurKey := integer('J');
   if Sender = DKsConF7 then MagKeyCurKey := integer('K');
   if Sender = DKsConF8 then MagKeyCurKey := integer('L');
   if Sender = DKsNone then MagKeyCurKey := 0;
end;

procedure TFrmDlg.DBotMiniMapClick(Sender: TObject; X, Y: Integer);
begin
  if not g_boViewMiniMap then begin
    if GetTickCount > g_dwQueryMsgTick then begin
       g_dwQueryMsgTick := GetTickCount + 3000;
       FrmMain.SendWantMiniMap;
       g_nViewMinMapLv:=1;
       DWMiniMap.GLeft := g_D3DConfig.wScreenWidth - 120; //20080323
       DWMiniMap.GWidth := 120; //20080323
       DWMiniMap.GHeight:= 120; //20080323
    end;
  end else begin
   if g_nViewMinMapLv >= 2 then begin
     g_nViewMinMapLv:=0;
     g_boViewMiniMap := FALSE;
     DWMiniMap.Visible := False; //20080323
   end else begin
     Inc(g_nViewMinMapLv);
     DWMiniMap.GLeft := g_D3DConfig.wScreenWidth - 200; //20080323
     DWMiniMap.GWidth := 200; //20080323
     DWMiniMap.GHeight:= 200; //20080323
   end;
  end;
end;

procedure TFrmDlg.DBotTradeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendDealTry;
   end;
end;

procedure TFrmDlg.DBotGuildClick(Sender: TObject; X, Y: Integer);
begin
   if DGuildDlg.Visible then begin
      DGuildDlg.Visible := FALSE;
   end else
      if GetTickCount > g_dwQueryMsgTick then begin
         g_dwQueryMsgTick := GetTickCount + 3000;
         FrmMain.SendGuildDlg;
      end;
end;

procedure TFrmDlg.DBotGroupClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowGroupDlg;
end;

procedure TFrmDlg.ToggleShowGroupDlg;
begin
   DGroupDlg.Visible := not DGroupDlg.Visible;
end;

procedure TFrmDlg.DGridFactionApplySelGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_qingqingImages <> nil then begin
    idx := ARow;
    if (idx in [0..4]) and (g_FactionApplyManageNameList.Count > idx) then begin
      if ACol = 0 then begin
        if g_FactionApplyManageSel[idx] then
          d := g_qingqingImages.Images[8]
        else d := g_qingqingImages.Images[7];
        if d <> nil then begin
          with DGridFactionApplySel do begin
             dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                            d.ClientRect,
                            d, TRUE);
          end;
        end;
      end else begin
        with DGridFactionApplySel do
         AspTextureFont.TextOut(SurfaceX(Rect.Left)+ 16, SurfaceY(Rect.Top)+6, clWhite, g_FactionApplyManageNameList.Strings[idx]);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridFactionApplySelGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
{$IF M2Version <> 2}
var
   idx: integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if ACol = 0 then begin
    idx := ARow;
    if (idx in [0..4]) and (g_FactionApplyManageNameList.Count > idx) then begin
      g_FactionApplyManageSel[idx] := not g_FactionApplyManageSel[idx];
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridLingWuXinFaKeyGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DGridLingWuXinFaKey do begin
    idx := ACol + ARow * ColCount;
    if idx in [0..19] then begin
      d := g_WUI1Images.Images[2326];
      if d <> nil then
        dsurface.Draw(SurfaceX(Rect.Left), SurfaceY(Rect.Top), d.ClientRect, d, True);
      if g_LingWuXinFa.nKeySelIndex-1 = idx then
        d := g_WUI1Images.Images[2341+50*g_LingWuXinFa.btKeyPage+idx*2]
      else d := g_WUI1Images.Images[2340+50*g_LingWuXinFa.btKeyPage+idx*2];
      if d <> nil then
        dsurface.Draw(SurfaceX(Rect.Left)+7, SurfaceY(Rect.Top)+10, d.ClientRect, d, True);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridLingWuXinFaKeyGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
{$IF M2Version <> 2}
const
  KeyName: array [0..19, 0..2] of string[2] = (
    ('百', '地', '步'), ('断', '风', '刺'), ('飞', '凤', '刀'),
    ('焚', '光', '赋'), ('幻', '虎', '动'), ('击', '火', '击'),
    ('狂', '间', '剑'), ('裂', '金', '脚'), ('凌', '雷', '诀'),
    ('猛', '麟', '破'), ('千', '龙', '气'), ('神', '木', '拳'),
    ('十', '日', '扫'), ('万', '蛇', '闪'), ('翔', '水', '手'),
    ('玄', '天', '术'), ('一', '烟', '行'), ('御', '岩', '跃'),
    ('斩', '雨', '斩'), ('逐', '月', '纵')
  );
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DGridLingWuXinFaKey do begin
    with g_LingWuXinFa do begin
      nKeySelIndex := ACol + ARow * ColCount+1;
      sKeySelCaption := sKeySelCaption + KeyName[nKeySelIndex-1, btKeyPage];
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGroupDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   lx, ly, n: integer;
begin
   with DGroupDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if g_GroupMembers.Count > 0 then begin
        lx := SurfaceX(28) + GLeft;
        ly := SurfaceY(80) + GTop;
        AspTextureFont.TextOut (lx, ly, clSilver, g_GroupMembers[0]);
        if g_GroupMembers.Count > 0 then //20080629
        for n:=1 to g_GroupMembers.Count-1 do begin
           lx := SurfaceX(28) + GLeft + ((n-1) mod 2) * 100;
           ly := SurfaceY(80 + 16) + GTop + ((n-1) div 2) * 16;
           AspTextureFont.TextOut (lx, ly, clSilver, g_GroupMembers[n]);
        end;
      end;
   end;
end;

procedure TFrmDlg.DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   DGroupDlg.Visible := FALSE;
end;

procedure TFrmDlg.DGrpAllowGroupDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if Downed then begin
           d := WLib.Images[FaceIndex-1];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           if g_boAllowGroup then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then
                 dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
           end;
        end;
      end;
   end;
end;

procedure TFrmDlg.DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChangeGroupModeTick then begin
      g_boAllowGroup := not g_boAllowGroup;
      g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
      FrmMain.SendGroupMode (g_boAllowGroup);
   end;
end;

procedure TFrmDlg.DGrpCreateClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count = 0) then begin
      DialogSize := 1;
      DMessageDlg ('输入想加入编组人物名称.', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
         FrmMain.SendCreateGroup (Trim (DlgEditText));
      end;
   end;
end;

procedure TFrmDlg.DGrpAddMemClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count > 0) then begin
      DialogSize := 1;
      DMessageDlg ('输入想加入编组人物名称.', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
         FrmMain.SendAddGroupMember (Trim (DlgEditText));
      end;
   end;
end;

procedure TFrmDlg.DGrpDelMemClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count > 0) then begin
      DialogSize := 1;
      DMessageDlg ('输入想退出编组人物名称.', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
         FrmMain.SendDelGroupMember (Trim (DlgEditText));
      end;
   end;
end;

procedure TFrmDlg.DBotLogoutClick(Sender: TObject; X, Y: Integer);
begin
   //强行退出
   g_dwLatestStruckTick:=GetTickCount() + 10001;
   g_dwLatestMagicTick:=GetTickCount() + 10001;
   g_dwLatestHitTick:=GetTickCount() + 10001;
               //
   if (GetTickCount - g_dwLatestStruckTick > 10000) and
      (GetTickCount - g_dwLatestMagicTick > 10000) and
      (GetTickCount - g_dwLatestHitTick > 10000) or
      (g_MySelf.m_boDeath) then begin
      FrmMain.AppLogOut(True);
   end else
      DScreen.AddChatBoardString ('攻击状态不能退出游戏.', clYellow, clRed);
end;

procedure TFrmDlg.DBotExitClick(Sender: TObject; X, Y: Integer);
begin
 {              //强行退出
               g_dwLatestStruckTick:=GetTickCount() + 10001;
               g_dwLatestMagicTick:=GetTickCount() + 10001;
               g_dwLatestHitTick:=GetTickCount() + 10001;
               //
   if (GetTickCount - g_dwLatestStruckTick > 10000) and
      (GetTickCount - g_dwLatestMagicTick > 10000) and
      (GetTickCount - g_dwLatestHitTick > 10000) or
      (g_MySelf.m_boDeath) then begin
      FrmMain.AppExit;
   end else
      DScreen.AddChatBoardString ('攻击状态不能退出游戏.', clYellow, clRed); }
   frmMain.Close;
end;

procedure TFrmDlg.DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
begin
   FrmDlg.OpenAdjustAbility;
end;

{******************************************************************************}
//打开交易对话框
procedure TFrmDlg.OpenDealDlg;
begin
   DDealRemoteDlg.GLeft := g_D3DConfig.wScreenWidth-236-100;
   DDealRemoteDlg.GTop := 0;
   DDealDlg.GLeft := g_D3DConfig.wScreenWidth-236-100;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 0;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := -5; //475;
   DItemBag.GTop := {-25}69;//20090304修改
   {$IFEND}
   DItemBag.Visible := TRUE;
   DDealRemoteDlg.Visible := TRUE;
   DDealDlg.GTop  := DDealRemoteDlg.GHeight-15;
   DDealDlg.Visible := TRUE;


   FillCHar (g_DealItems, sizeof(TClientEffecItem)*10, #0);
   FillCHar (g_DealRemoteItems, sizeof(TClientEffecItem)*20, #0);
   g_nDealGold := 0;
   g_nDealRemoteGold := 0;
   g_boDealEnd := FALSE;
   ArrangeItembag;
end;
{******************************************************************************}
//打开挑战对话框
procedure TFrmDlg.OpenChallengeDlg;
begin
   DWChallenge.GLeft := 544;
   DWChallenge.GTop := 0;
   DItemBag.GLeft := -5; //475;
   DItemBag.GTop := {-25}69;//20090304修改
   DItemBag.Visible := TRUE;
   DWChallenge.Visible := TRUE;

   FillCHar (g_ChallengeItems, sizeof(TClientEffecItem)*4, #0);
   FillCHar (g_ChallengeRemoteItems, sizeof(TClientEffecItem)*4, #0);
   g_nChallengeGold := 0;
   g_nChallengeRemoteGold := 0;
   g_nChallengeDiamond := 0;
   g_nChallengeRemoteDiamond := 0;
   g_boChallengeEnd := FALSE;
   ArrangeItembag;
end;
procedure TFrmDlg.CloseChallengeDlg;
begin
   DWChallenge.Visible := FALSE;
   ArrangeItembag;
end;
{******************************************************************************}
procedure TFrmDlg.CloseDealDlg;
begin
   DDealDlg.Visible := FALSE;
   DDealRemoteDlg.Visible := FALSE;
   ArrangeItembag;
end;

procedure TFrmDlg.DDealOkClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
   if GetTickCount > g_dwDealActionTick then begin
      //CloseDealDlg;
      FrmMain.SendDealEnd;
      g_dwDealActionTick := GetTickCount + 4000;
      g_boDealEnd := TRUE;
      if g_boItemMoving then begin
         mi := g_MovingItem.Index;
         if (mi <= -20) and (mi > -30) then begin
            AddDealItem (g_MovingItem.Item);
            g_boItemMoving := FALSE;
            g_MovingItem.Item.ClientItem.S.name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DDealCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwDealActionTick then begin
      CloseDealDlg;
      FrmMain.SendCancelDeal;
   end;
end;

procedure TFrmDlg.DDealRemoteDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
   with DDealRemoteDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         AspTextureFont.TextOut (SurfaceX(GLeft+64), SurfaceY(GTop+196-65), clWhite, GetGoldStr(g_nDealRemoteGold));
         AspTextureFont.TextOut (SurfaceX(GLeft+59 + (106-AspTextureFont.TextWidth(g_sDealWho)) div 2), SurfaceY(GTop+3)+3, clWhite, g_sDealWho);
   end;
end;

procedure TFrmDlg.DDealDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
   with DDealDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         AspTextureFont.TextOut (SurfaceX(GLeft+64), SurfaceY(GTop+196-65), clWhite, GetGoldStr(g_nDealGold));
         AspTextureFont.TextOut (SurfaceX(GLeft+59 + (106-AspTextureFont.TextWidth(FrmMain.CharName)) div 2), SurfaceY(GTop+3)+3, clWhite, FrmMain.CharName);
   end;
end;

procedure TFrmDlg.DealItemReturnBag (mitem: TClientEffecItem);
begin
   if not g_boDealEnd then begin
      g_DealDlgItem := mitem;
      FrmMain.SendDelDealItem (g_DealDlgItem);
      g_dwDealActionTick := GetTickCount + 4000;
   end;
end;
//挑战物品返回包裹 20080705
procedure TFrmDlg.ChallengeItemReturnBag (mitem: TClientEffecItem);
begin
   if not g_boChallengeEnd then begin
      g_ChallengeDlgItem := mitem;
      FrmMain.SendDelChallengeItem (g_ChallengeDlgItem);
      g_dwChallengeActionTick := GetTickCount + 4000;
   end;
end;

procedure TFrmDlg.ChangeProPage(nPage: Byte);
begin
  case nPage of
    0: begin
      //DScrollBoxPro.DScroll.First;
      DCBBookHPMan.GTop := 37-DScrollBoxPro.DScroll.Position;
      DCBBookMPMan.GTop := 61-DScrollBoxPro.DScroll.Position;
      if not DScrollBoxPro.InSuItem(DCBBookHPMan) then
      DScrollBoxPro.AddSuItem(DScrollBoxPro.Add, DCBBookHPMan);
      if not DScrollBoxPro.InSuItem(DCBBookMPMan) then
      DScrollBoxPro.AddSuItem(DScrollBoxPro.Add, DCBBookMPMan);

      DCheckBoxBookHPPro.Enabled := not ClientConf.boNoUseProtection;
      DEdtBookHPPro.Enabled := not ClientConf.boNoUseProtection;
      DCBBookHPMan.Enabled := not ClientConf.boNoUseProtection;
      DCheckBoxBookMPPro.Enabled := not ClientConf.boNoUseProtection;
      DEdtBookMPPro.Enabled := not ClientConf.boNoUseProtection;
      DCBBookMPMan.Enabled := not ClientConf.boNoUseProtection;

      DCBBookHPMan.Visible := True;
      DCBBookMPMan.Visible := True;
      DLabel3.Caption := '时使用';
      DLabel4.Caption := '时使用';
      DCheckBoxBookHPPro.Checked := g_Config.boHp1Chk;
      DEdtBookHPPro.Text := IntToStr(g_Config.wHp1Hp);
      DCBBookHPMan.ItemIndex := g_Config.btHp1Man;
      DCheckBoxBookMPPro.Checked := g_Config.boMp1Chk;
      DEdtBookMPPro.Text := IntToStr(g_Config.wMp1Mp);
      DCBBookMPMan.ItemIndex := g_Config.btMp1Man;
      DCheckBoxRenewHP.Checked := g_Config.boRenewHPIsAuto;
      DEdtRenewHP.Text := IntToStr(g_Config.wRenewHPPercent);
      DEdtRenewHPTime.Text := IntToStr(g_Config.wRenewHPTime);
      DCheckBoxRenewMP.Checked := g_Config.boRenewMPIsAuto;
      DEdtRenewMP.Text := IntToStr(g_Config.wRenewMPPercent);
      DEdtRenewMPTime.Text := IntToStr(g_Config.wRenewMPTime);
      DCheckBoxRenewHPSpecial.Checked := g_Config.boRenewSpecialHPIsAuto;
      DEdtRenewHPSpecial.Text := IntToStr(g_Config.wRenewSpecialHPPercent);
      DEdtRenewHPSpecialTime.Text := IntToStr(g_Config.wRenewSpecialHPTime);
      DCheckBoxRenewMpSpecial.Checked := g_Config.boRenewSpecialMpIsAuto;
      DEdtRenewMpSpecial.Text := IntToStr(g_Config.wRenewSpecialMpPercent);
      DEdtRenewMpSpecialTime.Text := IntToStr(g_Config.wRenewSpecialMpTime);
      DCheckBoxUseSuperMedica.Checked := g_Config.BoUseSuperMedica;

      DCheckBoxUseSuperMedicaItemName1.Checked := g_Config.SuperMedicaUses[0];
      DCheckBoxUseSuperMedicaItemName2.Checked := g_Config.SuperMedicaUses[1];
      DCheckBoxUseSuperMedicaItemName3.Checked := g_Config.SuperMedicaUses[2];
      DCheckBoxUseSuperMedicaItemName4.Checked := g_Config.SuperMedicaUses[3];
      DCheckBoxUseSuperMedicaItemName5.Checked := g_Config.SuperMedicaUses[4];
      DCheckBoxUseSuperMedicaItemName6.Checked := g_Config.SuperMedicaUses[5];
      DCheckBoxUseSuperMedicaItemName7.Checked := g_Config.SuperMedicaUses[6];
      DCheckBoxUseSuperMedicaItemName8.Checked := g_Config.SuperMedicaUses[7];
      DCheckBoxUseSuperMedicaItemName9.Checked := g_Config.SuperMedicaUses[8];
      DCheckBoxUseSuperMedicaItemName10.Checked := g_Config.SuperMedicaUses[9];
      DCheckBoxUseSuperMedicaItemName11.Checked := g_Config.SuperMedicaUses[10];
      DCheckBoxUseSuperMedicaItemName12.Checked := g_Config.SuperMedicaUses[11];
      DCheckBoxUseSuperMedicaItemName13.Checked := g_Config.SuperMedicaUses[12];
      DCheckBoxUseSuperMedicaItemName14.Checked := g_Config.SuperMedicaUses[13];

      DEditSuperMedicaHP1.Text := IntToStr(g_Config.SuperMedicaHPs[0]);
      DEditSuperMedicaHP2.Text := IntToStr(g_Config.SuperMedicaHPs[1]);
      DEditSuperMedicaHP3.Text := IntToStr(g_Config.SuperMedicaHPs[2]);
      DEditSuperMedicaHP4.Text := IntToStr(g_Config.SuperMedicaHPs[3]);
      DEditSuperMedicaHP5.Text := IntToStr(g_Config.SuperMedicaHPs[4]);
      DEditSuperMedicaHP6.Text := IntToStr(g_Config.SuperMedicaHPs[5]);
      DEditSuperMedicaHP7.Text := IntToStr(g_Config.SuperMedicaHPs[6]);
      DEditSuperMedicaHP8.Text := IntToStr(g_Config.SuperMedicaHPs[7]);
      DEditSuperMedicaHP9.Text := IntToStr(g_Config.SuperMedicaHPs[8]);
      DEditSuperMedicaHP10.Text := IntToStr(g_Config.SuperMedicaHPs[9]);
      DEditSuperMedicaHP11.Text := IntToStr(g_Config.SuperMedicaHPs[10]);
      DEditSuperMedicaHP12.Text := IntToStr(g_Config.SuperMedicaHPs[11]);
      DEditSuperMedicaHP13.Text := IntToStr(g_Config.SuperMedicaHPs[12]);
      DEditSuperMedicaHP14.Text := IntToStr(g_Config.SuperMedicaHPs[13]);

      DEditSuperMedicaHPTime1.Text := IntToStr(g_Config.SuperMedicaHPTimes[0]);
      DEditSuperMedicaHPTime2.Text := IntToStr(g_Config.SuperMedicaHPTimes[1]);
      DEditSuperMedicaHPTime3.Text := IntToStr(g_Config.SuperMedicaHPTimes[2]);
      DEditSuperMedicaHPTime4.Text := IntToStr(g_Config.SuperMedicaHPTimes[3]);
      DEditSuperMedicaHPTime5.Text := IntToStr(g_Config.SuperMedicaHPTimes[4]);
      DEditSuperMedicaHPTime6.Text := IntToStr(g_Config.SuperMedicaHPTimes[5]);
      DEditSuperMedicaHPTime7.Text := IntToStr(g_Config.SuperMedicaHPTimes[6]);
      DEditSuperMedicaHPTime8.Text := IntToStr(g_Config.SuperMedicaHPTimes[7]);
      DEditSuperMedicaHPTime9.Text := IntToStr(g_Config.SuperMedicaHPTimes[8]);
      DEditSuperMedicaHPTime10.Text := IntToStr(g_Config.SuperMedicaHPTimes[9]);
      DEditSuperMedicaHPTime11.Text := IntToStr(g_Config.SuperMedicaHPTimes[10]);
      DEditSuperMedicaHPTime12.Text := IntToStr(g_Config.SuperMedicaHPTimes[11]);
      DEditSuperMedicaHPTime13.Text := IntToStr(g_Config.SuperMedicaHPTimes[12]);
      DEditSuperMedicaHPTime14.Text := IntToStr(g_Config.SuperMedicaHPTimes[13]);

      DEditSuperMedicaMP1.Text := IntToStr(g_Config.SuperMedicaMPs[0]);
      DEditSuperMedicaMP2.Text := IntToStr(g_Config.SuperMedicaMPs[1]);
      DEditSuperMedicaMP3.Text := IntToStr(g_Config.SuperMedicaMPs[2]);
      DEditSuperMedicaMP4.Text := IntToStr(g_Config.SuperMedicaMPs[3]);
      DEditSuperMedicaMP5.Text := IntToStr(g_Config.SuperMedicaMPs[4]);
      DEditSuperMedicaMP6.Text := IntToStr(g_Config.SuperMedicaMPs[5]);
      DEditSuperMedicaMP7.Text := IntToStr(g_Config.SuperMedicaMPs[6]);
      DEditSuperMedicaMP8.Text := IntToStr(g_Config.SuperMedicaMPs[7]);
      DEditSuperMedicaMP9.Text := IntToStr(g_Config.SuperMedicaMPs[8]);
      DEditSuperMedicaMP10.Text := IntToStr(g_Config.SuperMedicaMPs[9]);
      DEditSuperMedicaMP11.Text := IntToStr(g_Config.SuperMedicaMPs[10]);
      DEditSuperMedicaMP12.Text := IntToStr(g_Config.SuperMedicaMPs[11]);
      DEditSuperMedicaMP13.Text := IntToStr(g_Config.SuperMedicaMPs[12]);
      DEditSuperMedicaMP14.Text := IntToStr(g_Config.SuperMedicaMPs[13]);

      DEditSuperMedicaMPTime1.Text := IntToStr(g_Config.SuperMedicaMPTimes[0]);
      DEditSuperMedicaMPTime2.Text := IntToStr(g_Config.SuperMedicaMPTimes[1]);
      DEditSuperMedicaMPTime3.Text := IntToStr(g_Config.SuperMedicaMPTimes[2]);
      DEditSuperMedicaMPTime4.Text := IntToStr(g_Config.SuperMedicaMPTimes[3]);
      DEditSuperMedicaMPTime5.Text := IntToStr(g_Config.SuperMedicaMPTimes[4]);
      DEditSuperMedicaMPTime6.Text := IntToStr(g_Config.SuperMedicaMPTimes[5]);
      DEditSuperMedicaMPTime7.Text := IntToStr(g_Config.SuperMedicaMPTimes[6]);
      DEditSuperMedicaMPTime8.Text := IntToStr(g_Config.SuperMedicaMPTimes[7]);
      DEditSuperMedicaMPTime9.Text := IntToStr(g_Config.SuperMedicaMPTimes[8]);
      DEditSuperMedicaMPTime10.Text := IntToStr(g_Config.SuperMedicaMPTimes[9]);
      DEditSuperMedicaMPTime11.Text := IntToStr(g_Config.SuperMedicaMPTimes[10]);
      DEditSuperMedicaMPTime12.Text := IntToStr(g_Config.SuperMedicaMPTimes[11]);
      DEditSuperMedicaMPTime13.Text := IntToStr(g_Config.SuperMedicaMPTimes[12]);
      DEditSuperMedicaMPTime14.Text := IntToStr(g_Config.SuperMedicaMPTimes[13]);
    end;
  end;

end;

//元宝寄售返回包裹 20080316
procedure TFrmDlg.SellOffItemReturnBag(mitem: TClientEffecItem);
begin
  g_SellOffDlgItem := mitem;
  FrmMain.SendDelSellOffItem (g_SellOffDlgItem);
end;

procedure TFrmDlg.DDGridGridSelect(Sender: TObject; ACol, ARow: Integer;
  Shift: TShiftState);
var
   mi, idx: integer;
begin
   if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
      if not g_boItemMoving then begin
         idx := ACol + ARow * DDGrid.ColCount;
         if idx in [0..9] then
            if g_DealItems[idx].ClientItem.s.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 20;
               g_MovingItem.Item := g_DealItems[idx];
               g_DealItems[idx].ClientItem.s.Name := '';
               ItemClickSound (g_MovingItem.Item.ClientItem.S);
            end;
      end else begin
         mi := g_MovingItem.Index;
         if (mi >= 0) or (mi <= -20) and (mi > -30) then begin //啊规,俊辑 柯巴父
            ItemClickSound (g_MovingItem.Item.ClientItem.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
               g_DealDlgItem := g_MovingItem.Item; //辑滚俊 搬苞甫 扁促府绰悼救 焊包
               FrmMain.SendAddDealItem (g_DealDlgItem);
               g_dwDealActionTick := GetTickCount + 4000;
            end else
               AddDealItem (g_MovingItem.Item);
            g_MovingItem.Item.ClientItem.S.name := '';
         end;
         if mi = -98 then DDGoldClick (self, 0, 0);
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then begin
    if g_DealItems[idx].ClientItem.s.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_DealItems[idx].ClientItem.s.Looks);
      if d <> nil then begin
        with DDGrid do begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_DealItems[idx].ClientItem.s.StdMode = 17 then begin
             AspTextureFont.TextOut (SurfaceX(Rect.Left+35-AspTextureFont.TextWidth(IntToStr(g_DealItems[idx].ClientItem.Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_DealItems[idx].ClientItem.Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DDGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
  Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_DealItems[idx];
    with DDGrid do
    	ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                        SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then begin
    if g_DealRemoteItems[idx].ClientItem.s.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_DealRemoteItems[idx].ClientItem.s.Looks);
      if d <> nil then begin
        with DDRGrid do begin
           dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_DealRemoteItems[idx].ClientItem.s.StdMode = 17 then begin
             AspTextureFont.TextOut (SurfaceX(Rect.Left+35-AspTextureFont.TextWidth(IntToStr(g_DealRemoteItems[idx].ClientItem.Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_DealRemoteItems[idx].ClientItem.Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DDRGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then begin
    g_MouseItem := g_DealRemoteItems[idx];
    with DDRGrid do
    	ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                        SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DealZeroGold;
begin
   if not g_boDealEnd and (g_nDealGold > 0) then begin
      g_dwDealActionTick := GetTickCount + 4000;
      FrmMain.SendChangeDealGold (0);
   end;
end;

procedure TFrmDlg.DDGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then exit;
   if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
      if not g_boItemMoving then begin
         if g_nDealGold > 0 then begin
            PlaySound (s_money);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := -97;
            g_MovingItem.Item.ClientItem.S.Name := g_sGoldName{'金币'};
         end;
      end else begin
         if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
            if (g_MovingItem.Index = -98) then begin
               if g_MovingItem.Item.ClientItem.S.Name = g_sGoldName{'金币'} then begin
                  DialogSize := 1;
                  g_boItemMoving := FALSE;
                  g_MovingItem.Item.ClientItem.S.Name := '';
                  DMessageDlg ('请输入 ' +g_sGoldName+ ' 数量', [mbOk, mbAbort]);
                  GetValidStrVal (DlgEditText, valstr, [' ']);
                  dgold := Str_ToInt (valstr, 0);
                  if (dgold <= (g_nDealGold+g_MySelf.m_nGold)) and (dgold > 0) then begin
                     FrmMain.SendChangeDealGold (dgold);
                     g_dwDealActionTick := GetTickCount + 4000;
                  end;
               end;
            end;
            g_boItemMoving := FALSE;
            g_MovingItem.Item.ClientItem.S.Name := '';
         end;
      end;
   end;
end;

{--------------------人物装备那栏2007.10.16----------------------}
procedure TFrmDlg.DUserState1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   pgidx, bbx, bby, idx, ax, ay, sex, hair: integer;
   d: TAsphyreLockableTexture;
   {$IF M2Version = 2}
   iname, d1, d2, d3, d4, d5, d6, d7: string;
   useable: Boolean;
   hcolor: Integer;
   {$IFEND}
begin
   with DUserState1 do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

      //观察别人的装备4格那
      sex := UserState1.Feature.nDress mod 2;    //性别
      hair := UserState1.Feature.btHair;
      {$IF M2Version = 2}
      if sex = 1 then pgidx := 377   //咯磊
      else pgidx := 376;     //巢磊
      bbx := GLeft + 38;
      bby := GTop + 52;
      d := g_WMainImages.Images[pgidx];
      {$ELSE}
      if sex = 1 then pgidx := 30{377}   //女
      else pgidx := 29{376};     //男
      bbx := GLeft + 38;
      bby := GTop + 52;
      d := g_WMain3Images.Images[pgidx];
      {$IFEND}
      if d <> nil then
         dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
      bbx := bbx - 7;
      bby := bby + 44;
      if UserState1.UseItems[U_DRESS].ClientItem.S.Name <> '' then begin
        idx := UserState1.UseItems[U_DRESS].ClientItem.S.Looks;
        if idx >= 0 then begin
          d := FrmMain.GetWStateImg(idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          case idx of
            2420..2421: begin //主宰衣服翅膀
             d := FrmMain.GetWStateImg(idx+5,ax,ay);
             if d <> nil then
               dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
            end;
            2540,2542: begin //传奇神甲
             d := FrmMain.GetWStateImg(idx+1,ax,ay);
             if d <> nil then
               dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
            end;
            2592: begin //天外飞仙
              if GetTickCount - g_DrawUseItems1[U_DRESS].dwDrawTick >= 100 then begin
                g_DrawUseItems1[U_DRESS].dwDrawTick := GetTickCount;
                Inc(g_DrawUseItems1[U_DRESS].nIndex);
                if g_DrawUseItems1[U_DRESS].nIndex > 19 then g_DrawUseItems1[U_DRESS].nIndex := 0;
              end;
              d := FrmMain.GetWStateImg(2600+g_DrawUseItems1[U_DRESS].nIndex,ax,ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
              end;
            end;
          end;
        end;
      end;
      //观察别人人物发型2007.10.16 
      idx := 1799;
      if sex = 1 then idx := 2399;//480 + hair div 2;
     if sex = 0 then begin   //男
      if hair <> 0 then
        if idx > 0 then begin
           d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
           if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
     end else if hair <> 1 then begin
        if idx > 0 then begin
           d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
           if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
     end else begin
           d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
           if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
     end;

      if UserState1.UseItems[U_WEAPON].ClientItem.S.Name <> '' then begin
         idx := UserState1.UseItems[U_WEAPON].ClientItem.S.Looks;
         if idx >= 0 then begin
            d := FrmMain.GetWStateImg(idx,ax,ay);
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
           case idx of
             1404: begin //金牛道剑
               d := FrmMain.GetWStateImg(1403,ax,ay);
               if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
             end;
             1880: begin //倚天
               if GetTickCount - WeaponTimeTick > 200 then begin
                 WeaponTimeTick := GetTickCount;
                 Inc(WeaponImginsex);
                 if WeaponImginsex > 9 then WeaponImginsex := 0;
               end;
               d := FrmMain.GetWStateImg(1890+WeaponImginsex,ax,ay);
               if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
             end;
             2423: begin //主宰神剑
               d := FrmMain.GetWStateImg(2427,ax,ay);
               if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
             end;
             2523: begin //传奇之剑
               if GetTickCount - WeaponTimeTick > 200 then begin
                 WeaponTimeTick := GetTickCount;
                 Inc(WeaponImginsex);
                 if WeaponImginsex > 7 then WeaponImginsex := 0;
               end;
               d := FrmMain.GetWStateImg(2530+WeaponImginsex,ax,ay);
               if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
             end;
            2524: begin //传奇宝扇
              if GetTickCount - WeaponTimeTick > 100 then begin
                WeaponTimeTick := GetTickCount;
                Inc(WeaponImginsex);
                if WeaponImginsex > 9 then WeaponImginsex := 0;
              end;
              d := FrmMain.GetWStateImg(2550+WeaponImginsex,ax,ay);
              if d <> nil then
                dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
            end;
            2525: begin //传奇神剑
              if GetTickCount - WeaponTimeTick > 100 then begin
                WeaponTimeTick := GetTickCount;
                Inc(WeaponImginsex);
                if WeaponImginsex > 9 then WeaponImginsex := 0;
              end;
              d := FrmMain.GetWStateImg(2560+WeaponImginsex,ax,ay);
              if d <> nil then
                dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
            end;
           end;
         end;
      end;
      //斗笠 20080417
      if UserState1.UseItems[U_ZHULI].ClientItem.S.Name <> '' then begin
         if UserState1.UseItems[U_ZHULI].ClientItem.S.Shape <> 2  then begin
           idx := UserState1.UseItems[U_ZHULI].ClientItem.S.Looks;
           if idx >= 0 then begin
              d := FrmMain.GetWStateImg(idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
           end;
         end else begin     //黑巾
           if (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 103) or (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 106) or (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 344) or (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
             if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                idx := UserState1.UseItems[U_HELMET].ClientItem.S.Looks;
                if idx >= 0 then begin
                   d := FrmMain.GetWStateImg(idx,ax,ay);
                   if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
             end;
             idx := UserState1.UseItems[U_ZHULI].ClientItem.S.Looks;
             if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
             end;
           end else begin
             idx := UserState1.UseItems[U_ZHULI].ClientItem.S.Looks;
             if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
             end;
             if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                idx := UserState1.UseItems[U_HELMET].ClientItem.S.Looks;
                if idx >= 0 then begin
                   d := FrmMain.GetWStateImg(idx,ax,ay);
                   if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
             end;
           end;

         end;
         if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            if UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 1685 then begin
              d := g_WMainImages.Images[StateItemEffect(1) + 620];
              if d <> nil then
                dsurface.DrawBlend(SurfaceX(bbx+77), SurfaceY(bby-11), d);
            end else if UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 2133 then begin  //虎威
              d := g_WUI1Images.GetCachedImage(StateItemEffect(2) + 220, ax, ay);
              if d <> nil then
                dsurface.DrawBlend(SurfaceX(bbx+ax+69), SurfaceY(bby+ay-16), d);
            end else if UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 2415 then begin  //主宰
              d := g_WStateEffectImages.GetCachedImage(StateItemEffect(3) + 580, ax, ay);
               if d <> nil then
                dsurface.DrawBlend(SurfaceX(bbx+ax)+72, SurfaceY(bby+ay)-14, d);
            end;
         end
      end else
      if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
         idx := UserState1.UseItems[U_HELMET].ClientItem.S.Looks;
         if idx >= 0 then begin
            d := FrmMain.GetWStateImg(idx,ax,ay);
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            if UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 1685 then begin
              d := g_WMainImages.Images[StateItemEffect(1) + 620];
              if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax+2), SurfaceY(bby+ay-1), d);
            end else if UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 2133 then begin  //虎威
              d := g_WUI1Images.GetCachedImage(StateItemEffect(2) + 220, ax, ay);
              if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax+69), SurfaceY(bby+ay-16), d);
            end else if UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 2415 then begin  //主宰
               d := g_WStateEffectImages.GetCachedImage(StateItemEffect(3) + 580, ax, ay);
               if d <> nil then
                 dsurface.DrawBlend(SurfaceX(bbx+ax)+72, SurfaceY(bby+ay)-14, d);
              end;
         end;
      end;

      (*{$IF M2Version = 2}
      if g_MouseUserStateItem.ClientItem.S.Name <> '' then begin
         g_MouseItem := g_MouseUserStateItem;
         GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable,1);
         if iname <> '' then begin
            if g_MouseItem.ClientItem.Dura = 0 then hcolor := clRed
            else hcolor := clWhite;
               AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272), clYellow, clBlack,iname);
               AspTextureFont.BoldTextOut (SurfaceX(GLeft+36+AspTextureFont.TextWidth(iname)), SurfaceY(GTop+272), hcolor, clBlack, d1);
               AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272+AspTextureFont.TextHeight('A')+2), hcolor, clBlack, d2);
               AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272+(AspTextureFont.TextHeight('A')+2)*2), hcolor, clBlack, d3);
         end;
         g_MouseItem.ClientItem.S.Name := '';
      end;  
      {$IFEND} *)
      //名字和行会
         if g_nUserSelectName = 1 then //20080302
          Font.Color := clSilver
         else if g_nUserSelectName = 3 then Font.Color := clRed else
         Font.Color := UserState1.NameColor;
         AspTextureFont.TextOut (SurfaceX(GLeft + 122 - AspTextureFont.TextWidth(UserState1.UserName) div 2),
                  SurfaceY(GTop + 23), Font.Color, UserState1.UserName);
         if g_nUserSelectName = 2 then  //20080302
           Font.Color := clWhite
         else if g_nUserSelectName = 4 then Font.Color := clRed else
         Font.Color := clSilver;
         case g_boUserIsWho of
          1: AspTextureFont.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
                     font.Color, UserState1.GuildName+' 的英雄');
          2: AspTextureFont.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
                     Font.Color, UserState1.GuildName+' 的分身');
         else
            AspTextureFont.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
                     Font.Color, UserState1.GuildName + ' ' + UserState1.GuildRankName);
         end;
   end;
end;

procedure TFrmDlg.DUserState1MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  lx,ly:integer;
begin
   lx := DUserState1.LocalX (X) - DUserState1.GLeft;
   ly := DUserState1.LocalY (Y) - DUserState1.GTop;
   if (lx >= 56) and (lx <= 180) and (ly >= 22) and (ly <= 35) then begin
      g_nUserSelectName := 3;
      g_boSelectText := True;
   end;
   if (lx >= 42) and (lx <= 201) and (ly >= 56) and (ly <= 69) then begin
      g_nUserSelectName := 4;
      g_boSelectText := True;
   end;
end;

procedure TFrmDlg.DUserState1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  lx,ly:integer;
begin
  DScreen.ClearHint;
  g_MouseUserStateItem.ClientItem.S.Name := '';
   if not g_boSelectText then 
      g_nUserSelectName := 0;   //20080302
   lx := DUserState1.LocalX (X) - DUserState1.GLeft;
   ly := DUserState1.LocalY (Y) - DUserState1.GTop;
   if (lx >= 56) and (lx <= 180) and (ly >= 22) and (ly <= 35) then begin
         if not g_boSelectText then
           g_nUserSelectName := 1;  //20080302
        if ssLeft in Shift then begin
          PlayScene.EdChat.Visible := TRUE;
          PlayScene.EdChat.Text := '/'+ UserState1.UserName+' ';
          PlayScene.EdChat.SetFocus;
          SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
          PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
        end;
   end;
   if (lx >= 42) and (lx <= 201) and (ly >= 56) and (ly <= 69) then begin
       if not g_boSelectText then
          g_nUserSelectName := 2;  //20080302
       if ssLeft in Shift then begin
          PlayScene.EdChat.Visible := TRUE;
          PlayScene.EdChat.Text := '/'+ UserState1.GuildName+' ';
          PlayScene.EdChat.SetFocus;
          SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
          PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
        end;
   end;


end;

procedure TFrmDlg.DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   sel: integer;
   iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
   useable: Boolean;
   (*{$IF M2Version = 2}
   hcolor: Integer;
   {$ELSE}*)
   hcolor: string;
   //{$IFEND}
   nHintX,nHintY: Integer;
   TzHintInfo: pTTzHintInfo;
   Butt: TAspDButton;
   Lines: string;
begin
  try
    sel := -1;
    Butt:=TAspDButton(Sender);
    if Sender = DDressUS1 then sel := U_DRESS;
    if Sender = DWeaponUS1 then sel := U_WEAPON;
    if Sender = DHelmetUS1 then sel := U_HELMET;
    if Sender = DNecklaceUS1 then sel := U_NECKLACE;
    if Sender = DLightUS1 then sel := U_RIGHTHAND;
    if Sender = DRingLUS1 then sel := U_RINGL;
    if Sender = DRingRUS1 then sel := U_RINGR;
    if Sender = DArmRingLUS1 then sel := U_ARMRINGL;
    if Sender = DArmRingRUS1 then sel := U_ARMRINGR;

    if Sender = DBujukUS1 then sel := U_BUJUK;
    if Sender = DBeltUS1 then sel := U_BELT;
    if Sender = DBootsUS1 then sel := U_BOOTS;
    if Sender = DCharmUS1 then sel := U_CHARM;
    if sel >= 0 then begin
      g_MouseUserStateItem := UserState1.UseItems[sel];
      if (UserState1.UseItems[sel].ClientItem.S.Name <> '') or (UserState1.UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
        if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].ClientItem.S.Name <> '') then begin
          g_MouseItem := UserState1.UseItems[U_ZHULI];
          GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
          if iname <> '' then begin
            if UserState1.UseItems[U_ZHULI].ClientItem.Dura = 0 then hcolor := 'Red'
            else hcolor := '';
            //Lines := iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~Y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
            Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]);
          end;
        end;
        TzHintInfo := GetTzInfo(UserState1.UseItems[sel].ClientItem.S.Name, 3);
        if DUserState1.GLeft >= 350 then
          nHintX:=DUserState1.SurfaceX(DUserState1.GLeft) - _Min(DScreen.HintWidth, 400)
        else nHintX:=DUserState1.SurfaceX(DUserState1.GLeft)+DUserState1.GWidth;
        nHintY:=DUserState1.SurfaceY(DUserState1.GTop) + 50;
        g_MouseItem := UserState1.UseItems[sel];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
        if (iname <> '') or (Lines <> '') then begin
          if UserState1.UseItems[sel].ClientItem.Dura = 0 then hcolor := 'red'
          else hcolor := '';
          with Butt as TAspDButton do begin
            {if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, Get TzStateInfo(TzHintInfo,3)]), False
                                      );
          end;}
          //修改套装显示 By TasNat at: 2012-04-06 11:02:26
          DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          if TzHintInfo <> nil then begin

              DScreen.ShowTzItemHint(
                                      Format('<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,3)])
                                      );
          end;
          end;
        end;
        g_MouseItem.ClientItem.S.Name := '';
      end;
    end;
    //{$IFEND}
  except
    DeBugOutStr('TFrmDlg.DWeaponUS1MouseMove');
  end;
end;

procedure TFrmDlg.DCloseUS1Click(Sender: TObject; X, Y: Integer);
begin
   DUserState1.Visible := FALSE;
end;

procedure TFrmDlg.DNecklaceUS1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  Idx, EffIdx: Integer;
  d: TAsphyreLockableTexture;
  nWhere: Integer;
begin
  nWhere := -1;
  if Sender = DNecklaceUS1 then nWhere := U_NECKLACE;
  if Sender = DLightUS1 then nWhere := U_RIGHTHAND;
  if Sender = DArmringRUS1 then nWhere := U_ARMRINGR;
  if Sender = DArmringLUS1 then nWhere := U_ARMRINGL;
  if Sender = DRingRUS1 then nWhere := U_RINGR;
  if Sender = DRingLUS1 then nWhere := U_RINGL;
  if Sender = DBujukUS1 then nWhere := U_BUJUK;
  if Sender = DBeltUS1 then nWhere := U_BELT;
  if Sender = DBootsUS1 then nWhere := U_BOOTS;
  if Sender = DCharmUS1 then nWhere := U_CHARM;

  if nWhere >= 0 then begin
    if UserState1.UseItems[nWhere].ClientItem.S.Name <> '' then begin
      Idx := UserState1.UseItems[nWhere].ClientItem.S.looks;
      if Idx >= 0 then begin
        d := frmMain.GetWStateImg(Idx);
        if d <> nil then begin
          with TAspDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                          SurfaceY(GTop + (GHeight - d.Height) div 2),
                          d.ClientRect, d, TRUE);
            case idx of
              1680..1684, 1686: begin  //金牛效果
                d := g_WMainImages.Images[StateItemEffect(0) + 640];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(GLeft-10), SurfaceY(GTop-10), d);
              end;
              2130..2132,2134..2136: begin //虎威
                case idx of
                  2130: EffIdx := 100; //手镯
                  2131: EffIdx := 140; //戒指
                  2132: EffIdx := 180; //项链
                  2134: EffIdx := 260; //靴子
                  2135: EffIdx := 300; //腰带
                  2136: EffIdx := 340; //勋章
                  else EffIdx := 0;
                end;
                d := g_WUI1Images.Images[StateItemEffect(2) + EffIdx];
                if d <> nil then
                  dsurface.DrawBlend( SurfaceX(GLeft-8), SurfaceY(GTop-8), d);
              end;
              2410..2414, 2416: begin  //主宰
                case idx of
                  2410: Effidx := 530; //戒指
                  2411: EffIdx := 540; //手镯
                  2412: EffIdx := 550; //项链
                  2413: EffIdx := 560; //靴子
                  2414: EffIdx := 570; //腰带
                  2416: EffIdx := 590; //勋章
                  else EffIdx := 0;
                end;
                d := g_WStateEffectImages.Images[StateItemEffect(3) + Effidx];
                if d <> nil then
                  dsurface.DrawBlend(SurfaceX(GLeft-4), SurfaceY(GTop-4), d);
              end;
              2623: begin
                if GetTickCount - g_DrawUseItems1[nWhere].dwDrawTick >= 100 then begin
                  g_DrawUseItems1[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems1[nWhere].nIndex);
                  if g_DrawUseItems1[nWhere].nIndex > 14 then g_DrawUseItems1[nWhere].nIndex := 0;
                end;
                d := FrmMain.GetWStateImg(2630+g_DrawUseItems1[nWhere].nIndex);
                if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(GLeft)-8, SurfaceY(GTop)-14, d);
                end;
              end;
              2624: begin
                if GetTickCount - g_DrawUseItems1[nWhere].dwDrawTick >= 100 then begin
                  g_DrawUseItems1[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems1[nWhere].nIndex);
                  if g_DrawUseItems1[nWhere].nIndex > 14 then g_DrawUseItems1[nWhere].nIndex := 0;
                end;
                d := FrmMain.GetWStateImg(2650+g_DrawUseItems1[nWhere].nIndex);
                if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(GLeft)-10, SurfaceY(GTop)-14, d);
                end;
              end
              else begin
                if g_UseItems[nWhere].ClientItem.S.Reserved1 = 1 then begin
                  ItemLightTimeImg(); //物品发光变换函数 20080223
                  d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(GLeft-21), SurfaceY(GTop-23), d);
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowGuildDlg;
begin
   DGuildDlg.Visible := TRUE;  //not DGuildDlg.Visible;
   DGuildDlg.GTop := -3;
   DGuildDlg.GLeft := 0;
   if DGuildDlg.Visible then begin
      if GuildCommanderMode then begin
         DGDAddMem.Visible := TRUE;
         DGDDelMem.Visible := TRUE;
         DGDEditNotice.Visible := TRUE;
         DGDEditGrade.Visible := TRUE;
         DGDAlly.Visible := TRUE;
         DGDBreakAlly.Visible := TRUE;
         DGDWar.Visible := TRUE;
         DGDCancelWar.Visible := TRUE;
      end else begin
         DGDAddMem.Visible := FALSE;
         DGDDelMem.Visible := FALSE;
         DGDEditNotice.Visible := FALSE;
         DGDEditGrade.Visible := FALSE;
         DGDAlly.Visible := FALSE;
         DGDBreakAlly.Visible := FALSE;
         DGDWar.Visible := FALSE;
         DGDCancelWar.Visible := FALSE;
      end;

   end;
   GuildTopLine := 0;
end;

procedure TFrmDlg.ShowGuildEditNotice;
var
   d: TAsphyreLockableTexture;
   i: integer;
   data: string;
begin
   with DGuildEditNotice do begin
      if g_WMainImages <> nil then begin //20080701
        d := g_WMainImages.Images[204];
        if d <> nil then begin
           GLeft := (g_D3DConfig.wScreenWidth - d.Width) div 2;
           GTop := (g_D3DConfig.wScreenHeight - d.Height) div 2;
        end;
      end;
      HideAllControls;
      DGuildEditNotice.ShowModal;

      Memo.Left := SurfaceX(GLeft+16);
      Memo.Top  := SurfaceY(GTop+36);
      Memo.Width := 571;
      Memo.Height := 246;
      Memo.Lines.Assign (GuildNotice);
      Memo.Visible := TRUE;

      while TRUE do begin
         if not DGuildEditNotice.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DGuildEditNotice.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
         data := '';
         if Memo.Lines.Count > 0 then //20080629
         for i:=0 to Memo.Lines.Count-1 do begin
            if Memo.Lines[i] = '' then
               data := data + Memo.Lines[i] + ' '#13
            else data := data + Memo.Lines[i] + #13;
         end;
         if Length(data) > 4000 then begin
            data := Copy (data, 1, 4000);
            DMessageDlg ('公告内容超过限制大小，公告内容将被截短！', [mbOk]);
         end;
         FrmMain.SendGuildUpdateNotice (data);
      end;
   end;
end;

procedure TFrmDlg.ShowGuildEditGrade;
var
   d: TAsphyreLockableTexture;
   data: string;
   i: integer;
begin
   if GuildMembers.Count <= 0 then begin
      DMessageDlg ('请先打开成员列表。', [mbOk]);
      Exit;
   end;

   with DGuildEditNotice do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
           GLeft := (g_D3DConfig.wScreenWidth - d.Width) div 2;
           GTop := (g_D3DConfig.wScreenHeight - d.Height) div 2;
        end;
      end;
      HideAllControls;
      DGuildEditNotice.ShowModal;

      Memo.Left := SurfaceX(GLeft+16);
      Memo.Top  := SurfaceY(GTop+36);
      Memo.Width := 571;
      Memo.Height := 246;
      Memo.Lines.Assign (GuildMembers);
      Memo.Visible := TRUE;

      while TRUE do begin
         if not DGuildEditNotice.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DGuildEditNotice.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
         data := '';
         if Memo.Lines.Count > 0 then //20080629
         for i:=0 to Memo.Lines.Count-1 do begin
            data := data + Memo.Lines[i] + #13;
         end;
         if Length(data) > 5000 then begin
            data := Copy (data, 1, 5000);
            DMessageDlg ('内容超过限制大小，内容将被截短', [mbOk]);
         end;
         FrmMain.SendGuildUpdateGrade (data);
      end;
   end;
end;

procedure TFrmDlg.DGuildDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  i, n, bx, by: integer;
begin
   with DGuildDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

         Font.Color := clWhite;
         AspTextureFont.TextOut (GLeft+320, GTop+13, {Font.Color}clWhite, Guild); //行会名

         bx := GLeft + 24;
         by := GTop + 41;
         if GuildStrs.Count > 0 then //20080629
         for i:=GuildTopLine to GuildStrs.Count-1 do begin
            n := i-GuildTopLine;
            if n*14 > 356 then break;
            if Integer(GuildStrs.Objects[i]) <> 0 then Font.Color := TColor(GuildStrs.Objects[i])
            else begin
               if BoGuildChat then Font.Color := GetRGB (2)
               else Font.Color := clSilver;
            end;
            AspTextureFont.TextOut (bx, by + n*14, Font.Color, GuildStrs[i]);
         end;

   end;
end;

procedure TFrmDlg.DGDUpClick(Sender: TObject; X, Y: Integer);
begin
   if GuildTopLine > 0 then Dec (GuildTopLine, 3);
   if GuildTopLine < 0 then GuildTopLine := 0;
end;

procedure TFrmDlg.DGDDownClick(Sender: TObject; X, Y: Integer);
begin
   if GuildTopLine+12 < GuildStrs.Count then Inc (GuildTopLine, 3);
end;

procedure TFrmDlg.DGDCloseClick(Sender: TObject; X, Y: Integer);
begin
   DGuildDlg.Visible := FALSE;
   BoGuildChat := FALSE;
end;

procedure TFrmDlg.DGDHomeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendGuildHome;
      BoGuildChat := FALSE;
   end;
end;

procedure TFrmDlg.DGDListClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendGuildMemberList;
      BoGuildChat := FALSE;
   end;
end;

procedure TFrmDlg.DGDAddMemClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('请输入想加入' + Guild + '的人物名称：', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendGuildAddMem (DlgEditText);
end;

procedure TFrmDlg.DGDDelMemClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('请输入想要开除的人物名称：', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendGuildDelMem (DlgEditText);
end;

procedure TFrmDlg.DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
   GuildEditHint := '[修改行会通告内容]';
   ShowGuildEditNotice;
end;

procedure TFrmDlg.DGDEditGradeClick(Sender: TObject; X, Y: Integer);
begin
   GuildEditHint := '[修改行会成员的等级和职位。 # 警告 : 不能增加行会成员/删除行会成员]';
   ShowGuildEditGrade;
end;

//结盟
procedure TFrmDlg.DGDAllyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if mrOk = DMessageDlg ('对方结盟行会必需在 [允许结盟]状态下。\' +
                  '而且二个行会的管理者必须面对面。\' +
                  '是否确认行会结盟？', [mbOk, mbCancel])
  then begin
    msg := MakeDefaultMsg(aa(CM_GUILDALLY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg));
  end;
end;

//解除结盟
procedure TFrmDlg.DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  DMessageDlg ('请输入您想取消结盟的行会的名字.', [mbOk, mbAbort]);
  if DlgEditText <> '' then begin
    msg := MakeDefaultMsg(aa(CM_GUILDBREAKALLY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg)+EncodeString(DlgEditText));
  end;
end;

procedure TFrmDlg.DGuildEditNoticeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with DGuildEditNotice do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

         AspTextureFont.TextOut (GLeft+18, GTop+291, clSilver, GuildEditHint);
   end;
end;

procedure TFrmDlg.DGECloseClick(Sender: TObject; X, Y: Integer);
begin
   DGuildEditNotice.Visible := FALSE;
   Memo.Visible := FALSE;
   DMsgDlg.DialogResult := mrCancel;
end;

procedure TFrmDlg.DGEOkClick(Sender: TObject; X, Y: Integer);
begin
   DGECloseClick (self, 0, 0);
   DMsgDlg.DialogResult := mrOk;
end;

procedure TFrmDlg.AddGuildChat (str: string);
var
   i: integer;
begin
   GuildChats.Add (str);
   if GuildChats.Count > 500 then begin
      for i:=0 to 100 do GuildChats.Delete(0);
   end;
   if BoGuildChat then
      GuildStrs.Assign (GuildChats);
end;

procedure TFrmDlg.DGDChatClick(Sender: TObject; X, Y: Integer);
begin
   BoGuildChat := not BoGuildChat;
   if BoGuildChat then begin
      GuildStrs2.Assign (GuildStrs);
      GuildStrs.Assign (GuildChats);
   end else
      GuildStrs.Assign (GuildStrs2);
end;

procedure TFrmDlg.DGoldDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
   if g_MySelf = nil then exit;
   with DGold do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
begin
   DAdjustAbility.Visible := FALSE;
   g_nBonusPoint := g_nSaveBonusPoint;
end;

procedure TFrmDlg.DAdjustAbilityDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
   procedure AdjustAb (abil: byte; val: word; var lov, hiv: Word);
   var
      lo, hi: byte;
      i: integer;
   begin
      lo := Lobyte(abil);
      hi := Hibyte(abil);
      lov := 0; hiv := 0;
      for i:=1 to val do begin
         if lo+1 < hi then begin Inc(lo); Inc(lov);
         end else begin Inc(hi); Inc(hiv); end;
      end;
   end;
var
   d: TAsphyreLockableTexture;
   l, m, adc, amc, asc, aac, amac: integer;
   ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
   Color: TColor;
begin
  if g_MySelf = nil then exit;
  with DAdjustAbility do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  Color := clSilver;
  l := DAdjustAbility.SurfaceX(DAdjustAbility.GLeft) + 36;
  m := DAdjustAbility.SurfaceY(DAdjustAbility.GTop) + 22;
  AspTextureFont.TextOut (l, m,   Color,   '恭喜你已经到了下一个等级.');
  AspTextureFont.TextOut (l, m+14, Color,   '选择你想提高的能力');
  AspTextureFont.TextOut (l, m+14*2, Color, '这样的选择你只可以做一次');
  AspTextureFont.TextOut (l, m+14*3, Color, '最好能很小心地选择.');
  Color := clWhite;

  l := DAdjustAbility.SurfaceX(DAdjustAbility.GLeft) + 100; //66;
  m := DAdjustAbility.SurfaceY(DAdjustAbility.GTop) + 101;
  adc := (g_BonusAbilChg.DC) div g_BonusTick.DC;
  amc := (g_BonusAbilChg.MC) div g_BonusTick.MC;
  asc := (g_BonusAbilChg.SC) div g_BonusTick.SC;
  aac := (g_BonusAbilChg.AC) div g_BonusTick.AC;
  amac := (g_BonusAbilChg.MAC) div g_BonusTick.MAC;
  AdjustAb (g_NakedAbil.DC, adc, ldc, hdc);
  AdjustAb (g_NakedAbil.MC, amc, lmc, hmc);
  AdjustAb (g_NakedAbil.SC, asc, lsc, hsc);
  AdjustAb (g_NakedAbil.AC, aac, lac, hac);
  AdjustAb (g_NakedAbil.MAC, amac, lmac, hmac);
  AspTextureFont.TextOut (l, m+0, Color, IntToStr(LoWord(g_MySelf.m_Abil.DC)+ldc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.DC) + hdc));
  AspTextureFont.TextOut (l, m+20, Color, IntToStr(LoWord(g_MySelf.m_Abil.MC)+lmc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MC) + hmc));
  AspTextureFont.TextOut (l, m+40, Color, IntToStr(LoWord(g_MySelf.m_Abil.SC)+lsc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.SC) + hsc));
  AspTextureFont.TextOut (l, m+60, Color, IntToStr(LoWord(g_MySelf.m_Abil.AC)+lac) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.AC) + hac));
  AspTextureFont.TextOut (l, m+80, Color, IntToStr(LoWord(g_MySelf.m_Abil.MAC)+lmac) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MAC) + hmac));
  AspTextureFont.TextOut (l, m+100, Color, IntToStr(g_MySelf.m_Abil.MaxHP + (g_BonusAbil.HP + g_BonusAbilChg.HP) div g_BonusTick.HP));
  AspTextureFont.TextOut (l, m+120, Color, IntToStr(g_MySelf.m_Abil.MaxMP + (g_BonusAbil.MP + g_BonusAbilChg.MP) div g_BonusTick.MP));
  AspTextureFont.TextOut (l, m+140, Color, IntToStr(g_nMyHitPoint + (g_BonusAbil.Hit + g_BonusAbilChg.Hit) div g_BonusTick.Hit));
  AspTextureFont.TextOut (l, m+160, Color, IntToStr(g_nMySpeedPoint + (g_BonusAbil.Speed + g_BonusAbilChg.Speed) div g_BonusTick.Speed));
  Color := clYellow;
  AspTextureFont.TextOut (l, m+180, Color, IntToStr(g_nBonusPoint));
  Color := clWhite;
  l := DAdjustAbility.SurfaceX(DAdjustAbility.GLeft) + 155; //66;
  m := DAdjustAbility.SurfaceY(DAdjustAbility.GTop) + 101;
  if g_BonusAbilChg.DC > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m, Color, IntToStr(g_BonusAbilChg.DC + g_BonusAbil.DC) + '/' + IntToStr(g_BonusTick.DC));
  if g_BonusAbilChg.MC > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+20, Color, IntToStr(g_BonusAbilChg.MC + g_BonusAbil.MC) + '/' + IntToStr(g_BonusTick.MC));
  if g_BonusAbilChg.SC > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+40, Color, IntToStr(g_BonusAbilChg.SC + g_BonusAbil.SC) + '/' + IntToStr(g_BonusTick.SC));
  if g_BonusAbilChg.AC > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+60, Color, IntToStr(g_BonusAbilChg.AC + g_BonusAbil.AC) + '/' + IntToStr(g_BonusTick.AC));
  if g_BonusAbilChg.MAC > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+80, Color, IntToStr(g_BonusAbilChg.MAC + g_BonusAbil.MAC) + '/' + IntToStr(g_BonusTick.MAC));
  if g_BonusAbilChg.HP > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+100, Color, IntToStr(g_BonusAbilChg.HP + g_BonusAbil.HP) + '/' + IntToStr(g_BonusTick.HP));
  if g_BonusAbilChg.MP > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+120, Color, IntToStr(g_BonusAbilChg.MP + g_BonusAbil.MP) + '/' + IntToStr(g_BonusTick.MP));
  if g_BonusAbilChg.Hit > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+140, Color, IntToStr(g_BonusAbilChg.Hit + g_BonusAbil.Hit) + '/' + IntToStr(g_BonusTick.Hit));
  if g_BonusAbilChg.Speed > 0 then Color := clWhite
  else Color := clSilver;
  AspTextureFont.TextOut (l, m+160, Color, IntToStr(g_BonusAbilChg.Speed + g_BonusAbil.Speed) + '/' + IntToStr(g_BonusTick.Speed));
end;

procedure TFrmDlg.DPlusDCClick(Sender: TObject; X, Y: Integer);
var
   incp: integer;
begin
   if g_nBonusPoint > 0 then begin
      if IsKeyPressed (VK_CONTROL) and (g_nBonusPoint > 10) then incp := 10
      else incp := 1;
      Dec(g_nBonusPoint, incp);
      if Sender = DPlusDC then Inc (g_BonusAbilChg.DC, incp);
      if Sender = DPlusMC then Inc (g_BonusAbilChg.MC, incp);
      if Sender = DPlusSC then Inc (g_BonusAbilChg.SC, incp);
      if Sender = DPlusAC then Inc (g_BonusAbilChg.AC, incp);
      if Sender = DPlusMAC then Inc (g_BonusAbilChg.MAC, incp);
      if Sender = DPlusHP then Inc (g_BonusAbilChg.HP, incp);
      if Sender = DPlusMP then Inc (g_BonusAbilChg.MP, incp);
      if Sender = DPlusHit then Inc (g_BonusAbilChg.Hit, incp);
      if Sender = DPlusSpeed then Inc (g_BonusAbilChg.Speed, incp);
   end;
end;

procedure TFrmDlg.DMinusDCClick(Sender: TObject; X, Y: Integer);
var
   decp: integer;
begin
   if IsKeyPressed (VK_CONTROL) and (g_nBonusPoint-10 > 0) then decp := 10
   else decp := 1;
   if Sender = DMinusDC then
      if g_BonusAbilChg.DC >= decp then begin
         Dec(g_BonusAbilChg.DC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMC then
      if g_BonusAbilChg.MC >= decp then begin
         Dec(g_BonusAbilChg.MC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusSC then
      if g_BonusAbilChg.SC >= decp then begin
         Dec(g_BonusAbilChg.SC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusAC then
      if g_BonusAbilChg.AC >= decp then begin
         Dec(g_BonusAbilChg.AC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMAC then
      if g_BonusAbilChg.MAC >= decp then begin
         Dec(g_BonusAbilChg.MAC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusHP then
      if g_BonusAbilChg.HP >= decp then begin
         Dec(g_BonusAbilChg.HP, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMP then
      if g_BonusAbilChg.MP >= decp then begin
         Dec(g_BonusAbilChg.MP, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusHit then
      if g_BonusAbilChg.Hit >= decp then begin
         Dec(g_BonusAbilChg.Hit, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusSpeed then
      if g_BonusAbilChg.Speed >= decp then begin
         Dec(g_BonusAbilChg.Speed, decp);
         Inc (g_nBonusPoint, decp);
      end;
end;

procedure TFrmDlg.DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.SendAdjustBonus(g_nBonusPoint, g_BonusAbilChg);
   DAdjustAbility.Visible := FALSE;
end;

procedure TFrmDlg.DAdjustAbilityMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, lx, ly: integer;
   flag: Boolean;
begin
   with DAdjustAbility do begin
      lx := LocalX (X - GLeft);
      ly := LocalY (Y - GTop);
      flag := FALSE;
      if (lx >= 50) and (lx < 150) then
         for i:=0 to 8 do begin
            if (ly >= 98 + i*20) and (ly < 98 + (i+1)*20) then begin
               DScreen.ShowHint (SurfaceX(GLeft) + lx + 10,
                                 SurfaceY(GTop) + ly + 5,
                                 AdjustAbilHints[i],
                                 clWhite,
                                 FALSE);
               flag := TRUE;
               break;
            end;
         end;
      if not flag then
         DScreen.ClearHint;
   end;
end;

procedure TFrmDlg.DFrdFriendDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if not TAspDButton(Sender).Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           d := WLib.Images[FaceIndex + 1];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DBotFactionClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if DWFactionDlg.Visible then
  begin
  	DWFactionDlg.Visible := FALSE;
  end else if GetTickCount > g_dwQueryMsgTick then
  begin
    //DWFactionApplyManage.Visible := False;
  	//g_dwQueryMsgTick := GetTickCount + 3000;
  	FrmMain.SendFactionDlg;
  end;

{$IFEND}
end;

procedure TFrmDlg.DBotFactionClickSound(Sender: TObject;
  Clicksound: TClickSound);
begin
   case Clicksound of
      csNorm:  PlaySound (s_norm_button_click);
      csStone: PlaySound (s_rock_button_click);
      csGlass: PlaySound (s_glass_button_click);
   end;
end;

procedure TFrmDlg.DBotFactionInitialize(Sender: TObject);
begin
  DBotFaction.SetImgIndex(g_WUI1Images, 2500);
  with TAspDControl(Sender) do begin
    GLeft := DBotLogout.GLeft - 5 - GWidth;
  end;
end;

procedure TFrmDlg.DBotFactionMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TAspDButton;
  sMsg:String;
  Int: Integer;
begin
  if g_MySelf = nil then Exit;
  Butt:=TAspDButton(Sender);
  if Sender = DBotMiniMap then sMsg:= '小地图\全景地图(TAB)';
  if Sender = DBotTrade then sMsg:= '物品交易';
  if Sender = DBotGuild then sMsg:= '行会信息';
  if Sender = DBotGroup then sMsg:= '组队控制/右键开关';
  if Sender = DBotPlusAbil then sMsg:= '属性点';
  {$IF M2Version <> 2}
  if Sender = DBotFaction then sMsg:= '师门';
  if (Sender = DBXinfaExpAbsorb) and g_boXinFaType then sMsg := '点击吸收心法经验进入丹田之中.';
  if Sender = DBNewHeroLiquorProgress then sMsg := '酒量提升进度%d';
  {$IFEND}
  if Sender = DBotFriend then sMsg:= '关系系统';
  if Sender = DBotLogout then sMsg:= '小退(Alt+X)';
  if Sender = DBotExit then sMsg:= '退出(Alt+Q)';
  if Sender = DBotMemo then sMsg:= '商铺(Ctrl+B)';
  if Sender = DMyState then sMsg:= '状态信息(F10)';
  if Sender = DMyBag then sMsg:= '包裹物品(F9)';
  if Sender = DMyMagic then sMsg:= '技能信息(F11)';
  if Sender = DOption then sMsg:= '音效开关';
  if Sender = DBRefusePublicChat then sMsg:= '拒绝所有公聊信息';
  if Sender = DBRefuseCRY then sMsg:= '拒绝所有喊话信息';
  if Sender = DBRefuseWHISPER then sMsg:= '拒绝所有私聊信息';
  if Sender = DBRefuseguild then sMsg:= '拒绝行会聊天信息';
  if Sender = DBAutoCRY then sMsg:= '自动喊话开关';
  if Sender = DBCommand then sMsg := '特殊命令';
  if Sender = DBInternet then sMsg:= '热点';
  if Sender = DDrunkScale then sMsg := '醉酒度: %d';
  if Sender = DLiquorProgress then sMsg := '酒量提升进度%d';
  if Sender = DBNewLiquorProgress then sMsg := '酒量提升进度%d';
  if Sender = DHeroLiquorProgress then sMsg := '酒量提升进度%d';
  if Sender = DNQBoxs then sMsg:= '每满一个节点槽，可开启宝箱一次\每亮起一棵灯，宝箱中的奖励就更好';
  {$IF M2Version = 1}
  if Sender = DBatterShowImg then begin
    if g_WinBatterMagicList.Count = 0 then Exit;
    if g_boCanUseBatter then
      sMsg:= '当前可以释放连击'
    else sMsg:= '当前连击技处于冷却时间';
    with Butt as TAspDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop), sMsg , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
  if (Sender = DLiquorProgress) or (Sender = DBNewLiquorProgress) then begin
    Int := _MAX(0, 100 * g_MySelf.m_Abil.Alcohol div g_MySelf.m_Abil.MaxAlcohol);
    with Butt as TAspDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop + Butt.GHeight), Format(sMsg ,[Int]) + '%' , clWhite, FALSE);
    Exit;
  end;

  if Sender = DDrunkScale then begin
    Int := _MAX(0, 100 * g_MySelf.m_Abil.WineDrinkValue div g_MySelf.m_Abil.MaxAlcohol);
    with Butt as TAspDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft)-Canvas.TextWidth(sMsg) + 36, Butt.SurfaceY(Butt.GTop + Butt.GHeight), Format(sMsg,[Int]) + '%', clWhite, FALSE);
    Exit;
  end;

  if (Sender = DHeroLiquorProgress) or (Sender = DBNewHeroLiquorProgress) then begin
    Int := _MAX(0, 100 * g_HeroSelf.m_Abil.Alcohol div g_HeroSelf.m_Abil.MaxAlcohol);
    with Butt as TAspDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop + Butt.GHeight), Format(sMsg ,[Int]) + '%' , clWhite, FALSE);
    Exit;
  end;

  if (Sender = DBRefusePublicChat) or (Sender = DBRefuseCRY) or
     (Sender = DBRefuseWHISPER) or (Sender = DBRefuseguild) or (Sender = DBAutoCRY) or (Sender = DBCommand) then begin
    with Butt as TAspDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft)-Canvas.TextWidth(sMsg)-8, Butt.SurfaceY(Butt.GTop), sMsg, clWhite, FALSE);
    Exit;
  end;

  if Sender = DBCallHero then sMsg:= '召唤/收回英雄';
  if Sender = DBHeroState then sMsg:= '英雄状态信息';
  if Sender = DBHeroPackage then sMsg:= '英雄包裹';
  if Sender = DBCallDeputyHero then sMsg:= '召唤副将英雄';
  if Sender = Challenge then sMsg:= '挑战';
  if Sender = CharacterSranking then sMsg:= '人物排行';
  if Sender = DBWhisper then sMsg := '私聊记录';
  if Sender = DBotStall then sMsg := '摆摊';
  (*if Sender = DBottom then begin
    g_nUserSelectName := 0;
    {$IF M2Version = 1}
    if ((X>=42) and (X<=60)) and ((Y>=423) and (Y<=461)) then begin
      if g_MySelf.m_Abil.MaxTransferValue <= 0 then Exit;
      sMsg := IntToStr(g_MySelf.m_Abil.TransferValue)+ '/' + IntToStr(g_MySelf.m_Abil.MaxTransferValue);
      nHintX := 12;
      nHintY := 414;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end else
    {$IFEND}
    if ((X >= g_D3DConfig.wScreenWidth - 135) and (X <= g_D3DConfig.wScreenWidth - 96)) and ((Y >= g_D3DConfig.wScreenHeight - 108) and (Y <= g_D3DConfig.wScreenHeight - 92)) then begin
      sMsg := '当前等级';
      nHintX := g_D3DConfig.wScreenWidth - 135;
      nHintY := g_D3DConfig.wScreenHeight - 92+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end
    else if ((X >= g_D3DConfig.wScreenWidth - 135) and (X <= g_D3DConfig.wScreenWidth - 55)) and ((Y >= g_D3DConfig.wScreenHeight - 77) and (Y <= g_D3DConfig.wScreenHeight - 63)) then begin
      sMsg := '当前经验';
      nHintX := g_D3DConfig.wScreenWidth - 135;
      nHintY := g_D3DConfig.wScreenHeight - 63+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg+FloatToStrFixFmt(100 * (g_MySelf.m_Abil.Exp / g_MySelf.m_Abil.MaxExp), 3, 2) +'%', clWhite, TRUE);
      Exit;
    end
    else if ((X >= g_D3DConfig.wScreenWidth - 135) and (X <= g_D3DConfig.wScreenWidth - 55)) and ((Y >= g_D3DConfig.wScreenHeight - 44) and (Y <= g_D3DConfig.wScreenHeight - 28)) then begin
      sMsg := format('包裹负重%d/%d',[g_MySelf.m_Abil.Weight,g_MySelf.m_Abil.MaxWeight]);
      nHintX := g_D3DConfig.wScreenWidth - 135;
      nHintY := g_D3DConfig.wScreenHeight - 28+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end;
  end;   *)
  if pos('\',sMsg) > 0 then
    nLocalY := 12
  else nLocalY := 0;

  with Butt as TAspDButton do
    DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop - 20 -nLocalY ), sMsg, clWhite, FALSE);
end;

procedure TFrmDlg.DBotFriendClick(Sender: TObject; X, Y: Integer);
begin
  OpenFriendDlg();
end;
procedure TFrmDlg.DBotFriendInitialize(Sender: TObject);
begin
  DBotFriend.SetImgIndex (g_WMain3Images,34);  //关系系统
end;

procedure TFrmDlg.OpenFriendDlg();
begin
  DFriendDlg.Visible:=not DFriendDlg.Visible;
end;

procedure TFrmDlg.DFrdCloseClick(Sender: TObject; X, Y: Integer);
begin
  OpenFriendDlg();
end;

procedure TFrmDlg.DChgGamePwdDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d:TAsphyreLockableTexture;
begin
  with Sender as TAspDWindow do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft+14), SurfaceY(GTop+12), clWhite, clBlack, 'GamePoint');
    AspTextureFont.BoldTextOut (SurfaceX(GLeft+11), SurfaceY(GTop+189), clYellow, clBlack, 'GameGold', [fsUnderline]);
  end;
end;

//关闭英雄信息栏
procedure TFrmDlg.DCloseHeroStateClick(Sender: TObject; X, Y: Integer); //$008 2007.10.21
begin
  DStateHero.Visible:=FALSE;
end;

//英雄装备栏绘制
procedure TFrmDlg.DStateHeroDirectPaint(Sender: TObject;     //$007 2007.10.21
  dsurface: TAsphyreCanvas);
var
   i, l, m, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv: integer;
   pm: PTClientMagic;
   d: TAsphyreLockableTexture;
   old, MagColor: integer;
   rc: TRect;
begin
  if g_HeroSelf = nil then exit;
  DHeroLiquorProgress.Visible := False;
  DHeroJQExp.Visible := False;
  {$IF M2Version <> 2}
  DBHeroQSSSee.Visible := False;
  {$IFEND}
  with DStateHero do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_boIsHeroInternalForce then begin
      if HeroStateTab = 0 then
        d := g_WMain2Images.Images[746]
      else d := g_WMain2Images.Images[747];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+31, d.ClientRect, d, TRUE);
    end;
    if DHeroStateSsas.Visible then begin
      with DHeroStateSsas do begin
        if WLib <> nil then begin //20080701
          if HeroStateTab = 0 then begin
            d := WLib.Images[FaceIndex + HeroStatePage];
          end else begin
            d := WLib.Images[FaceIndex + 10 + HeroInternalForcePage];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if HeroStateTab = 0 then begin
          if HeroStatePage = 0 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $00A8D4E8, clBlack, '装', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+21, $00A8D4E8, clBlack, '备', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $00708CA0, clBlack, '装', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+21, $00708CA0, clBlack, '备', [fsBold]);
          end;
          if HeroStatePage = 1 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+56, $00A8D4E8, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+69, $00A8D4E8, clBlack, '态', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+56, $00708CA0, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+69, $00708CA0, clBlack, '态', [fsBold]);
          end;
          if HeroStatePage = 2 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+102, $00A8D4E8, clBlack, '属', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+115, $00A8D4E8, clBlack, '性', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+102, $00708CA0, clBlack, '属', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+115, $00708CA0, clBlack, '性', [fsBold]);
          end;
          if HeroStatePage = 3 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+146, $00A8D4E8, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+159, $00A8D4E8, clBlack, '能', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+146, $00708CA0, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+159, $00708CA0, clBlack, '能', [fsBold]);
          end;
          if HeroStatePage = 4 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+190, $00A8D4E8, clBlack, '出', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+203, $00A8D4E8, clBlack, '战', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+190, $00708CA0, clBlack, '出', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+203, $00708CA0, clBlack, '战', [fsBold]);
          end;
        end else begin
          if HeroInternalForcePage = 0 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $0048A4E8, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+22, $0048A4E8, clBlack, '态', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $006098B8, clBlack, '状', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+22, $006098B8, clBlack, '态', [fsBold]);
          end;
          if HeroInternalForcePage = 1 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+58, $0048A4E8, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+72, $0048A4E8, clBlack, '能', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+58, $006098B8, clBlack, '技', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+72, $006098B8, clBlack, '能', [fsBold]);
          end;
          {$IF M2Version = 1}
          if HeroInternalForcePage = 2 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+105, $0048A4E8, clBlack, '经', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+119, $0048A4E8, clBlack, '络', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+104, $006098B8, clBlack, '经', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+118, $006098B8, clBlack, '络', [fsBold]);
          end;
          if HeroInternalForcePage = 3 then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+150, $0048A4E8, clBlack, '连', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+164, $0048A4E8, clBlack, '击', [fsBold]);
          end else begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+150, $006098B8, clBlack, '连', [fsBold]);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+164, $006098B8, clBlack, '击', [fsBold]);
          end;
          {$IFEND}
        end;
      end;
    end;
    case HeroStateTab of
      0: begin
        case HeroStatePage of
          0: begin //自己装备  2007.10.16 
            pgidx := 380{376};              //男4格  2007.10.16 
            if g_HeroSelf <> nil then
               if g_HeroSelf.m_btSex = 1 then
               pgidx := 381{377};  //女4格  2007.10.16 
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMain3Images.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx - 7;
            bby := bby + 44;
            if g_HeroItems[U_DRESS].ClientItem.S.Name <> '' then begin
              idx := g_HeroItems[U_DRESS].ClientItem.S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                case idx of
                  2420..2421: begin //主宰衣服翅膀
                    d := FrmMain.GetWStateImg(idx+5,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2540,2542: begin //传奇神甲
                    d := FrmMain.GetWStateImg(idx+1,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2592: begin //天外飞仙
                    if GetTickCount - g_DrawHeroUseItems[U_DRESS].dwDrawTick >= 100 then begin
                      g_DrawHeroUseItems[U_DRESS].dwDrawTick := GetTickCount;
                      Inc(g_DrawHeroUseItems[U_DRESS].nIndex);
                      if g_DrawHeroUseItems[U_DRESS].nIndex > 19 then g_DrawHeroUseItems[U_DRESS].nIndex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2600+g_DrawHeroUseItems[U_DRESS].nIndex,ax,ay);
                    if d <> nil then begin
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                    end;
                  end;
                end;
              end;
            end;
            //自己人物发型  2007.10.16 
            idx := 1799;
            if g_HeroSelf.m_btSex = 1 then idx := 2399;
            if g_HeroSelf.m_btSex = 0 then begin  //男
              if g_HeroSelf.m_btHair <> 0 then begin
                if idx > 0 then begin
                  d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                  if d <> nil then
                     dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end;
            end else if g_HeroSelf.m_btHair <> 1 then begin
              if idx > 0 then begin
                d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
              end;
            end else begin
              d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
            if g_HeroItems[U_WEAPON].ClientItem.S.Name <> '' then begin
              idx := g_HeroItems[U_WEAPON].ClientItem.S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                case idx of
                  1404: begin //金牛道剑
                    d := FrmMain.GetWStateImg(1403,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  1880: begin //倚天
                    if GetTickCount - WeaponTimeTick > 200 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 9 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(1890+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2423: begin //主宰神剑
                    d := FrmMain.GetWStateImg(2427,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2523: begin //传奇神剑
                    if GetTickCount - WeaponTimeTick > 200 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 7 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2530+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2524: begin //传奇宝扇
                    if GetTickCount - WeaponTimeTick > 100 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 9 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2550+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                  2525: begin //传奇神剑
                    if GetTickCount - WeaponTimeTick > 100 then begin
                      WeaponTimeTick := GetTickCount;
                      Inc(WeaponImginsex);
                      if WeaponImginsex > 9 then WeaponImginsex := 0;
                    end;
                    d := FrmMain.GetWStateImg(2560+WeaponImginsex,ax,ay);
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(bbx+ax), SurfaceY(bby+ay), d);
                  end;
                end;
              end;
            end;
                //斗笠 20080417
            if g_HeroItems[U_ZHULI].ClientItem.S.Name <> '' then begin
              if g_HeroItems[U_ZHULI].ClientItem.S.Shape <> 2  then begin
                idx := g_HeroItems[U_ZHULI].ClientItem.S.Looks;
                if idx >= 0 then begin
                  d := FrmMain.GetWStateImg(idx,ax,ay);
                  if d <> nil then
                    dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end else begin     //黑巾
                if (g_HeroItems[U_HELMET].ClientItem.S.Looks = 103) or (g_HeroItems[U_HELMET].ClientItem.S.Looks = 106) or (g_HeroItems[U_HELMET].ClientItem.S.Looks = 344) or (g_HeroItems[U_HELMET].ClientItem.S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
                  if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                    idx := g_HeroItems[U_HELMET].ClientItem.S.Looks;
                    if idx >= 0 then begin
                      d := FrmMain.GetWStateImg(idx,ax,ay);
                      if d <> nil then
                        dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                  idx := g_HeroItems[U_ZHULI].ClientItem.S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                end else begin
                  idx := g_HeroItems[U_ZHULI].ClientItem.S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                  if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                    idx := g_HeroItems[U_HELMET].ClientItem.S.Looks;
                    if idx >= 0 then begin
                       d := FrmMain.GetWStateImg(idx,ax,ay);
                       if d <> nil then
                          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                end;

              end;
              if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
                if g_HeroItems[U_HELMET].ClientItem.S.Looks = 1685 then begin
                  StateItemEffect(1);
                  d := g_WMainImages.Images[JNHelmetLightImgIdx + 620];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+77), SurfaceY(bby-11), d);
                end else if g_HeroItems[U_HELMET].ClientItem.S.Looks = 2133 then begin  //虎威
                  d := g_WUI1Images.GetCachedImage(StateItemEffect(2) + 220, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax+69), SurfaceY(bby+ay-16), d);
                end else if g_HeroItems[U_HELMET].ClientItem.S.Looks = 2415 then begin  //主宰
                  d := g_WStateEffectImages.GetCachedImage(StateItemEffect(3) + 580, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax)+72, SurfaceY(bby+ay)-14, d);
                end;
              end;
            end else
            if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
              if g_HeroItems[U_HELMET].ClientItem.S.Looks = 1685 then StateItemEffect(1);
              idx := g_HeroItems[U_HELMET].ClientItem.S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                if g_HeroItems[U_HELMET].ClientItem.S.Looks = 1685 then begin
                 d := g_WMainImages.Images[JNHelmetLightImgIdx + 620];
                 if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax+2), SurfaceY(bby+ay-1), d);
                end else if g_HeroItems[U_HELMET].ClientItem.S.Looks = 2133 then begin  //虎威
                  d := g_WUI1Images.GetCachedImage(StateItemEffect(2) + 220, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax+69), SurfaceY(bby+ay-16), d);
                end else if g_HeroItems[U_HELMET].ClientItem.S.Looks = 2415 then begin  //主宰
                  d := g_WStateEffectImages.GetCachedImage(StateItemEffect(3) + 580, ax, ay);
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(bbx+ax)+72, SurfaceY(bby+ay)-14, d);
                end;
              end;
            end;
            AspTextureFont.TextOut (SurfaceX(GLeft + 122 - AspTextureFont.TextWidth(g_HeroSelf.m_sUserName) div 2),
                              SurfaceY(GTop + 52), clWhite, g_HeroSelf.m_sUserName);
          end;
          1: begin //瓷仿摹
            bbx := GLeft + 38;
            bby := GTop + 52;
            d:=g_WUiMainImages.Images[30];
            if d<>nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            l := GLeft + 110; //66;
            m := GTop + 97;
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+0), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.AC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.AC)));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+20), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.MAC)));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+40), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.DC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.DC)));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+60), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.MC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.MC)));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+80), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.SC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.SC)));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+100), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.HP) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxHP));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+120), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.MP) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxMP));
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+140), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.MedicineValue) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxMedicineValue));//20080624
            AspTextureFont.BoldTextOut (SurfaceX(l), SurfaceY(m+160), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.MaxAlcohol));
            DHeroLiquorProgress.Visible := True;
          end;
          2: begin //人物属性数值
            bbx := GLeft + 57;
            bby := GTop + 61;
            mmx := bbx + 85;
            AspTextureFont.BoldTextOut (bbx, bby, clSilver, clBlack, '当前经验');
            AspTextureFont.BoldTextOut (mmx, bby, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.Exp));
            AspTextureFont.BoldTextOut (bbx, bby+14*1, clSilver, clBlack, '升级经验');
            AspTextureFont.BoldTextOut (mmx, bby+14*1, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.MaxExp));
            AspTextureFont.BoldTextOut (bbx, bby+14*2, clSilver, clBlack, '背包重量');
            if g_HeroSelf.m_Abil.Weight > g_HeroSelf.m_Abil.MaxWeight then
              AspTextureFont.BoldTextOut (mmx, bby+14*2, clRed, clBlack, IntToStr(g_HeroSelf.m_Abil.Weight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWeight))
            else AspTextureFont.BoldTextOut (mmx, bby+14*2, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.Weight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWeight));
            AspTextureFont.BoldTextOut (bbx, bby+14*3, clSilver, clBlack, '穿戴重量');
            if g_HeroSelf.m_Abil.WearWeight > g_HeroSelf.m_Abil.MaxWearWeight then
              AspTextureFont.BoldTextOut (mmx, bby+14*3, clRed, clBlack, IntToStr(g_HeroSelf.m_Abil.WearWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWearWeight))
            else AspTextureFont.BoldTextOut (mmx, bby+14*3, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.WearWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWearWeight));
            AspTextureFont.BoldTextOut (bbx, bby+14*4, clSilver, clBlack, '腕力');
            if g_HeroSelf.m_Abil.HandWeight > g_HeroSelf.m_Abil.MaxHandWeight then
              AspTextureFont.BoldTextOut (mmx, bby+14*4, clRed, clBlack, IntToStr(g_HeroSelf.m_Abil.HandWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxHandWeight))
            else AspTextureFont.BoldTextOut (mmx, bby+14*4, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.HandWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxHandWeight));
            AspTextureFont.BoldTextOut (bbx, bby+14*5, clSilver, clBlack, '精确度');
            AspTextureFont.BoldTextOut (mmx, bby+14*5, clSilver, clBlack, IntToStr(g_nHeroHitPoint));
            AspTextureFont.BoldTextOut (bbx, bby+14*6, clSilver, clBlack, '敏捷度');
            AspTextureFont.BoldTextOut (mmx, bby+14*6, clSilver, clBlack, IntToStr(g_nHeroSpeedPoint));
            AspTextureFont.BoldTextOut (bbx, bby+14*7, clSilver, clBlack, '魔法防御');
            AspTextureFont.BoldTextOut (mmx, bby+14*7, clSilver, clBlack, '+' + IntToStr(g_nHeroAntiMagic * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*8, clSilver, clBlack, '中毒防御');
            AspTextureFont.BoldTextOut (mmx, bby+14*8, clSilver, clBlack, '+' + IntToStr(g_nHeroAntiPoison * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*9, clSilver, clBlack, '中毒恢复');
            AspTextureFont.BoldTextOut (mmx, bby+14*9, clSilver, clBlack, '+' + IntToStr(g_nHeroPoisonRecover * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*10, clSilver, clBlack, '体力恢复');
            AspTextureFont.BoldTextOut (mmx, bby+14*10, clSilver, clBlack, '+' + IntToStr(g_nHeroHealthRecover * 10) + '%');
            AspTextureFont.BoldTextOut (bbx, bby+14*11, clSilver, clBlack, '魔法恢复');
            AspTextureFont.BoldTextOut (mmx, bby+14*11, clSilver, clBlack, '+' + IntToStr(g_nHeroSpellRecover * 10) + '%');
          end;
          3: begin //魔法背景
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMain3Images.Images[382];
            if d <> nil then begin
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
              dsurface.Draw(SurfaceX(bbx)+5, SurfaceY(bby)+190, Rect(5, 153, 41, 191), d, False);
            end;
            HeroMagTop := HeroMagicPage * 6;
            magline := _MIN(HeroMagicPage*6+6, g_HeroMagicList.Count);
            for i:=HeroMagTop to magline-1 do begin
              pm := PTClientMagic (g_HeroMagicList[i]);
              m := i - HeroMagTop;
              d := g_WMainImages.Images[112]; //lv
              if d <> nil then begin
                if pm.Def.wMagicId = 68 then   //酒气护体
                  dsurface.Draw (bbx + 110, bby+15+m*37-7, d.ClientRect, d, TRUE)
                else dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);
              end;
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then begin
                if pm.Def.wMagicId <> 68 then
                  dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
              end;
              case pm.Def.wMagicId of
                68: begin
                  if pm.Level < 100 then begin
                    DHeroJQExp.GLeft := 86;
                    DHeroJQExp.GTop := 79+m*37;
                    if not DHeroJQExp.Visible then DHeroJQExp.Visible := True;
                  end;
                end;
                {$IF M2Version <> 2}
                99: begin //强身术
                  DBHeroQSSSee.GLeft := 160;
                  DBHeroQSSSee.GTop := 60+m*37;
                  if not DBHeroQSSSee.Visible then DBHeroQSSSee.Visible := True;
                end;
                {$IFEND}
              end;
              {if (pm.Def.wMagicId = 68) and (pm.Level < 100) then begin
                DHeroJQExp.GLeft := 38 + 48;
                DHeroJQExp.GTop := 52+27+m*37;
                if not DHeroJQExp.Visible then DHeroJQExp.Visible := True;
              end;}
            end;
            for i:=HeroMagTop to magline-1 do begin
              pm := PTClientMagic (g_HeroMagicList[i]);
              if word(pm.Key) = 0 then MagColor := clSilver
                else MagColor := clGray;
              m := i - HeroMagTop;                                         
              if not (pm.Def.wMagicId in [68,95,99,104]) then
              if not (pm.Level in [0..4]) then pm.Level := 0;//20080111 技能等级显示

              if word(pm.Key) = 0 then
                AspTextureFont.BoldTextOut (bbx + 47, bby + 7 + m*37, MagColor, clBlack, pm.Def.sMagicName)
              else AspTextureFont.BoldTextOut (bbx + 47, bby + 7 + m*37, MagColor, clBlack, pm.Def.sMagicName+'[关]');
              if pm.Def.wMagicId = 68 then begin
                trainlv := pm.Level;
                AspTextureFont.BoldTextOut (bbx + 123, bby + 14 + m*37-7, clSilver, clBlack, IntToStr(pm.Level));
              end else if pm.Def.wMagicId = 95 then begin //斗转星移
                AspTextureFont.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-');
                Continue; //继续
              end else if pm.Def.wMagicId = 99 then begin  //强身术
                trainlv := pm.Level;
                AspTextureFont.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Level = 99 then
                  AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-')
                else AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else if pm.Def.wMagicId = 104 then begin  
                AspTextureFont.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Level = 100 then
                  AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-')
                else AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else begin
                if pm.Level in [0..4] then trainlv := pm.Level//20080111 技能等级显示
                else trainlv := 0;
                AspTextureFont.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
              end;
              if trainlv = 4 then begin
                if (pm.Def.wMagicId <> 68) then
                AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-');
              end else
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if (pm.Def.wMagicId <> 68) then begin
                  if trainlv < 3 then
                    AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else AspTextureFont.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-');
                end;
              end;
            end;
          end;
        end;
      end;
      1: begin
        case HeroInternalForcePage of
          0: begin
            d := g_WMain2Images.Images[749];
            if d<>nil then begin
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (SurfaceX(GLeft) + 38, SurfaceY(GTop) + 52, rc, d, False);
            end;
            d:=g_WMain2Images.Images[752];
            if d<>nil then
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 109, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 134, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 159, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 184, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 209, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 234, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 259, d.ClientRect, d, TRUE);

            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 111, clSilver, clBlack, '当前内功等级');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 136, clSilver, clBlack, '当前内功经验');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 161, clSilver, clBlack, '升级内功经验');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 186, clSilver, clBlack, '内 力 值');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 211, clSilver, clBlack, '内功恢复速度');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 236, clSilver, clBlack, '内功伤害增加');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 261, clSilver, clBlack, '内功伤害减免');

            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 111, clSilver, clBlack, IntToStr(g_dwHeroInternalForceLevel));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 136, clSilver, clBlack, IntToStr(g_dwHeroExp69));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 161, clSilver, clBlack, IntToStr(g_dwHeroMaxExp69));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 186, clSilver, clBlack, IntToStr(g_HeroSelf.m_Skill69NH)+'/'+IntToStr(g_HeroSelf.m_Skill69MaxNH));

            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 211, clSilver, clBlack, IntToStr(g_nHeroInternalRecovery));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 236, clSilver, clBlack, IntToStr(g_nHeroInternalHurtAdd));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 261, clSilver, clBlack, IntToStr(g_nHeroInternalHurtRelief));
          end;
          1: begin
            d := g_WMain2Images.Images[751];
            if d<>nil then begin
              bbx := GLeft + 38;
              bby := GTop + 52;
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (SurfaceX(GLeft) + 38, SurfaceY(GTop) + 52, rc, d, False);

              HeroMagTop := HeroInternalForceMagicPage * 6;
              magline := _MIN(HeroInternalForceMagicPage*6+6, g_HeroInternalForceMagicList.Count);
              for i:=HeroMagTop to magline-1 do begin
                pm := PTClientMagic (g_HeroInternalForceMagicList[i]);
                m := i - HeroMagTop;
                {d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
                if d <> nil then
                    dsurface.Draw (bbx + 8, bby+7+m*37, d.ClientRect, d, TRUE); }
                d := g_WMainImages.Images[112]; //lv
                if d <> nil then
                    dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);
                d := g_WMainImages.Images[111]; //exp
                if d <> nil then begin
                  if pm.Def.wMagicId <> 68 then
                    dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
                end;
              end;
              for i:=HeroMagTop to magline-1 do begin
                pm := PTClientMagic (g_HeroInternalForceMagicList[i]);
                if word(pm.Key) = 0 then MagColor := clSilver else MagColor := clGray;
                m := i - HeroMagTop;
                if not (pm.Level in [0..30]) then pm.Level := 0;
                if word(pm.Key) = 0 then
                  AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName)
                else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName+'[关]');
                if pm.Level in [0..30] then trainlv := pm.Level
                else trainlv := 0;
                AspTextureFont.BoldTextOut (bbx + 64, bby + 23 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < 3 then
                    AspTextureFont.BoldTextOut (bbx + 94, bby + 23 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else AspTextureFont.BoldTextOut (bbx + 94, bby + 23 + m*37, MagColor, clBlack, '-');
                end;
              end;
            end;
          end;
        end;
      end;
    end;
    //本代码为显示人物身上所带物品信息，显示位置为人物下方
    if g_HeroBatterDesc.sName <> '' then begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309), clYellow, clBlack, g_HeroBatterDesc.sName);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36+ AspTextureFont.TextWidth(g_HeroBatterDesc.sName)), SurfaceY(GTop+309), clWhite, clBlack, g_HeroBatterDesc.sLine1);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+AspTextureFont.TextHeight('A')+2), clWhite, clBlack, g_HeroBatterDesc.sLine2);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+(AspTextureFont.TextHeight('A')+2)*2), clWhite, clBlack, g_HeroBatterDesc.sLine3);
    end;
  end;
end;

procedure TFrmDlg.DCloseHeroStateDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

//鼠标在装备栏某个装备上移动显示过程
procedure TFrmDlg.DSHWeaponMouseMove(Sender: TObject; Shift: TShiftState;   //$006 2007.10.21
  X, Y: Integer);
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  Butt:TAspDButton;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
begin
  if (HeroStateTab <> 0) or (HeroStatePage <> 0) then exit;
  sel := -1;
  Butt:=TAspDButton(Sender);
  if Sender = DSHDress then sel := U_DRESS;
  if Sender = DSHWeapon then sel := U_WEAPON;
  if Sender = DSHHelmet then sel := U_HELMET;
  if Sender = DSHNecklace then sel := U_NECKLACE;
  if Sender = DSHLight then sel := U_RIGHTHAND;
  if Sender = DSHRingL then sel := U_RINGL;
  if Sender = DSHRingR then sel := U_RINGR;
  if Sender = DSHArmRingL then sel := U_ARMRINGL;
  if Sender = DSHArmRingR then sel := U_ARMRINGR;
  if Sender = DSHBujuk then sel := U_BUJUK;
  if Sender = DSHBelt then sel := U_BELT;
  if Sender = DSHBoots then sel := U_BOOTS;
  if Sender = DSHCharm then sel := U_CHARM;

  if sel >= 0 then begin
    g_HeroMouseStateItem := g_HeroItems[sel];
    g_HeroBatterDesc.sName := '';
    if (g_HeroItems[sel].ClientItem.S.Name <> '') or (g_HeroItems[U_ZHULI].ClientItem.S.Name <> '') then begin
      if (sel = U_HELMET) and (g_HeroItems[U_ZHULI].ClientItem.S.Name <> '') then begin
        g_HeroMouseItem := g_HeroItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
        {if iname <> '' then begin
          if g_HeroItems[U_ZHULI].ClientItem.Dura = 0 then hcolor := '~r'
          else hcolor := '';
          Lines := iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~Y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;}
        if iname <> '' then begin
          if g_HeroItems[U_ZHULI].ClientItem.Dura = 0 then hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(g_HeroItems[sel].ClientItem.S.Name, 2);
      if DStateHero.GLeft >= 350 then
        nHintX:=DStateHero.SurfaceX(DStateHero.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DStateHero.SurfaceX(DStateHero.GLeft)+DStateHero.GWidth;
      nHintY:=DStateHero.SurfaceY(DStateHero.GTop) +50;
      g_HeroMouseItem := g_HeroItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
      if (iname <> '') or (Lines <> '') then begin
        if g_HeroItems[sel].ClientItem.Dura = 0 then hcolor := 'red'
        else hcolor := '';
        with Butt as TAspDButton do begin
          {if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, Get TzStateInfo(TzHintInfo,2)]), False
                                      );
          end;}
          //修改套装显示 By TasNat at: 2012-04-06 11:02:26
          DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          if TzHintInfo <> nil then begin

              DScreen.ShowTzItemHint(
                                      Format('<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s',
                                      [TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,2)])
                                      );
          end;
        end;
      end;
      g_HeroMouseItem.ClientItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.HeroPackageClick(Sender: TObject; X, Y: Integer);
begin
   if g_HeroSelf = nil then exit;
   DHeroItemBag.Visible := not DHeroItemBag.Visible;
   if DHeroItemBag.Visible then
   ArrangeHeroItemBag;
end;

//英雄显示装备
procedure TFrmDlg.DSHLightDirectPaint(Sender: TObject;  // $011 2007.10.21
  dsurface: TAsphyreCanvas);
var
   idx, nWhere, EffIdx: integer;
   d: TAsphyreLockableTexture;
begin
  nWhere := -1;
  if (HeroStateTab = 0{基本页}) and (HeroStatePage = 0) then begin
    if Sender = DSHNecklace then nWhere := U_NECKLACE;
    if Sender = DSHLight then nWhere := U_RIGHTHAND;
    if Sender = DSHArmRingR then nWhere := U_ARMRINGR;
    if Sender = DSHArmRingL then nWhere := U_ARMRINGL;
    if Sender = DSHRingR then nWhere := U_RINGR;
    if Sender = DSHRingL then nWhere := U_RINGL;
    if Sender = DSHBujuk then nWhere := U_BUJUK;
    if Sender = DSHBelt then nWhere := U_BELT;
    if Sender = DSHBoots then nWhere := U_BOOTS;
    if Sender = DSHCharm then nWhere := U_CHARM;

    if nWhere >= 0 then begin
      if g_HeroItems[nWhere].ClientItem.S.Name <> '' then begin
        idx := g_HeroItems[nWhere].ClientItem.S.looks;
        if idx >= 0 then begin
          d := frmMain.GetWStateImg(idx);
          if d <> nil then begin
            with TAspDButton(Sender) do begin
              dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                            SurfaceY(GTop + (GHeight - d.Height) div 2),
                            d.ClientRect, d, TRUE);
              case idx of
                1680..1684, 1686: begin  //金牛效果
                  d := g_WMainImages.Images[StateItemEffect(0) + 640];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(GLeft-10), SurfaceY(GTop-10), d);
                end;
                2130..2132,2134..2136: begin //虎威
                  case idx of
                    2130: EffIdx := 100; //手镯
                    2131: EffIdx := 140; //戒指
                    2132: EffIdx := 180; //项链
                    2134: EffIdx := 260; //靴子
                    2135: EffIdx := 300; //腰带
                    2136: EffIdx := 340; //勋章
                    else EffIdx := 0;
                  end;
                  d := g_WUI1Images.Images[StateItemEffect(2) + EffIdx];
                  if d <> nil then
                    dsurface.DrawBlend( SurfaceX(GLeft-8), SurfaceY(GTop-8), d);
                end;
                2410..2414, 2416: begin  //主宰
                  case idx of
                    2410: Effidx := 530; //戒指
                    2411: EffIdx := 540; //手镯
                    2412: EffIdx := 550; //项链
                    2413: EffIdx := 560; //靴子
                    2414: EffIdx := 570; //腰带
                    2416: EffIdx := 590; //勋章
                    else EffIdx := 0;
                  end;
                  d := g_WStateEffectImages.Images[StateItemEffect(3) + Effidx];
                  if d <> nil then
                    dsurface.DrawBlend(SurfaceX(GLeft-4), SurfaceY(GTop-4), d);
                end;
                2623: begin
                  if GetTickCount - g_DrawHeroUseItems[nWhere].dwDrawTick >= 100 then begin
                    g_DrawHeroUseItems[nWhere].dwDrawTick := GetTickCount;
                    Inc(g_DrawHeroUseItems[nWhere].nIndex);
                    if g_DrawHeroUseItems[nWhere].nIndex > 14 then g_DrawHeroUseItems[nWhere].nIndex := 0;
                  end;
                  d := FrmMain.GetWStateImg(2630+g_DrawHeroUseItems[nWhere].nIndex);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)-8, SurfaceY(GTop)-14, d);
                  end;
                end;
                2624: begin
                  if GetTickCount - g_DrawHeroUseItems[nWhere].dwDrawTick >= 100 then begin
                    g_DrawHeroUseItems[nWhere].dwDrawTick := GetTickCount;
                    Inc(g_DrawHeroUseItems[nWhere].nIndex);
                    if g_DrawHeroUseItems[nWhere].nIndex > 14 then g_DrawHeroUseItems[nWhere].nIndex := 0;
                  end;
                  d := FrmMain.GetWStateImg(2650+g_DrawHeroUseItems[nWhere].nIndex);
                  if d <> nil then begin
                    dsurface.DrawBlend(SurfaceX(GLeft)-10, SurfaceY(GTop)-14, d);
                  end;
                end
                else begin
                  if g_UseItems[nWhere].ClientItem.S.Reserved1 = 1 then begin
                    ItemLightTimeImg(); //物品发光变换函数 20080223
                    d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                    if d <> nil then
                      dsurface.DrawBlend(SurfaceX(GLeft-21), SurfaceY(GTop-23), d);
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;


procedure TFrmDlg.DHeroItemBagDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   //d0, d1, d2, d3, d4, d5: string;
   {n,} HitY: integer;
   //useable: Boolean;
   d: TAsphyreLockableTexture;
begin
   if g_HeroSelf = nil then Exit;
      with DHeroItemBag do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         //GetMouseItemInfo (d0, d1, d2, d3, d4, d5, useable, 2{英雄});
         case g_HeroBagCount of
            10: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 375);
              DHeroItemGrid.RowCount:= 2;
              DHeroItemGrid.GHeight:= 63;
            end;
            20: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 376);
              DHeroItemGrid.RowCount:= 4;
              DHeroItemGrid.GHeight:= 126;
            end;
            30: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 377);
              DHeroItemGrid.RowCount:= 6;
              DHeroItemGrid.GHeight:= 192;
            end;
            35: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 378);
              DHeroItemGrid.RowCount:= 7;
              DHeroItemGrid.GHeight:= 224;
            end;
            40: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 379);
              DHeroItemGrid.RowCount:= 8;
              DHeroItemGrid.GHeight:= 255;
            end;
         end;

          HitY := DHeroItemGrid.GHeight+41;

          //提示语句   20080222
         //if g_HeroMouseItem.ClientItem.S.Name = '' then begin
            AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+HitY), clWhite, 'ALT  + R 键刷新包裹');
            AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+HitY)+14, clWhite, 'Ctrl + 点击物品 放入人物包裹');
         //end;
          
         //盛大物品栏
         (* if d0 <> '' then begin
            n := FrmMain.Canvas.TextWidth (d0);
            AspTextureFont.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY), clYellow, clBlack,d0);
            AspTextureFont.BoldTextOut (SurfaceX(Left+13) + n, SurfaceY(Top+HitY), clWhite, clBlack,d1);
            AspTextureFont.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY+14), clWhite, clBlack,d2);

            if not useable then
            AspTextureFont.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY+14*2), clRed, clBlack,d3)
            else AspTextureFont.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY+14*2), clWhite, clBlack,d3);
          end;    *)
   end;           
end;

//英雄包裹绘制
procedure TFrmDlg.DHeroItemGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
   idx: integer;
   d: TAsphyreLockableTexture;
   wm: TAspWMImages;
   ax, ay: Integer;
begin
  idx := ACol + ARow * DHeroItemGrid.ColCount;
  if idx in [0..g_HeroBagCount-1] then begin
    if g_HeroItemArr[idx].ClientItem.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_HeroItemArr[idx].ClientItem.S.Looks);
      if d <> nil then begin
        with DHeroItemGrid do begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 -1),
                         SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                         d.ClientRect, d, TRUE);
          if g_HeroItemArr[idx].ClientEffec.btBagCount > 0 then begin
            with g_HeroItemArr[idx].ClientEffec do begin
              if GetTickCount - g_DrawHeroBagItemsArr[idx].dwDrawTick >= 150 then begin
                g_DrawHeroBagItemsArr[idx].dwDrawTick := GetTickCount;
                Inc(g_DrawHeroBagItemsArr[idx].nIndex);
                if g_DrawHeroBagItemsArr[idx].nIndex > btBagCount-1 then g_DrawHeroBagItemsArr[idx].nIndex := 0;
              end;
              wm := GetItemEffectWil(btBagWilIndex);
              if wm <> nil then begin
                d := wm.GetCachedImage(wBagIndex+g_DrawHeroBagItemsArr[idx].nIndex, ax, ay);
                if d <> nil then begin
                  dsurface.DrawBlend(SurfaceX(Rect.Left)+ax+nBagX, SurfaceY(Rect.Top)+ay+nBagY, d);
                end;
              end;
            end;
          end else begin
            if g_HeroItemArr[idx].ClientItem.S.Reserved1 = 1 then begin //发光 20080223
              ItemLightTimeImg();
              d := g_WMain2Images.Images[ItemLightImgIdx + 260];
              if d <> nil then
                dsurface.DrawBlend(SurfaceX(Rect.Left-21), SurfaceY(Rect.Top-23), d);
            end;
          end;
          if g_HeroItemArr[idx].ClientItem.S.StdMode = 17 then begin
            AspTextureFont.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_HeroItemArr[idx].ClientItem.Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_HeroItemArr[idx].ClientItem.Dura));
          end;
        end;
      end;
    end;
  end;
end;

//鼠标移动过程，鼠标经过某个物品上显示
// new copy by liuzhigang
procedure TFrmDlg.DHeroItemGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  int: Byte;
begin
  DScreen.ClearHint;
   if ssRight in Shift then begin
      if g_boHeroItemMoving then
         DHeroItemGridGridSelect (self, ACol, ARow, Shift);
   end else begin
      idx := ACol + ARow * DHeroItemGrid.ColCount;
      if idx in [0..g_HeroBagCount-1] then begin
         if (g_HeroItemArr[idx].ClientItem.S.StdMode = 17) and (ssShift in Shift) and (ssLeft in Shift) then begin//拆分物品 20090615
           if g_HeroItemArr[idx].ClientItem.Dura > 1 then begin
             int := 0;
             DMessageDlg ('要拆分多少?', [mbOk, mbAbort]);
             if DlgEditText = '' then int := 1;
             if length(DlgEditText) > 5 then begin
               int := 3;
             end else begin
               if not IsStringNumber(DlgEditText) then int := 2;
             end;
             if int = 0 then begin
               if StrToInt(DlgEditText) >= g_HeroItemArr[idx].ClientItem.Dura then int := 4;//输入大于等于数量时，不做处理
             end;
             case int of
               0: frmMain.SendItemNumUpdateValue(g_HeroItemArr[idx].ClientItem.MakeIndex, StrToInt(DlgEditText), 1);
               1: DMessageDlg ('内容不能为空！', [mbOk]);
               2: DMessageDlg ('输入错误', [mbOk]);
               3: DMessageDlg ('数量不能超过5位', [mbOk]);
             end;
           end;
         end else begin
           g_HeroMouseItem := g_HeroItemArr[idx];
           with DHeroItemGrid do
             ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                               SurfaceY(GTop)+(ARow+1)*RowHeight, '', 2, False);
         end;
      end;
   end;
end;

//移动英雄装备
procedure TFrmDlg.DSHWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: integer;
  flag: Boolean;
  msg: TDefaultMessage;
  {$IF M2Version <> 2}
  MovItem: TMovingItem;
  msgWho: Byte; //2-主人 4-英雄
  {$IFEND}
begin
   if g_HeroSelf = nil then Exit;
   if (HeroStateTab <> 0) or (HeroStatePage <> 0) then exit;
   {$IF M2Version <> 2}
   //修补火龙之心
   if g_boHeroItemMoving or g_boItemMoving then begin
     if Sender = DSHBujuk then begin
       if (g_HeroItems[U_BUJUK].ClientItem.S.Shape = 9) and (g_HeroItems[U_BUJUK].ClientItem.S.StdMode = 25) and (g_HeroItems[U_BUJUK].ClientItem.S.Name <> '') then begin//20090205
         if g_boHeroItemMoving then begin
           if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
           if (g_MovingHeroItem.Item.ClientItem.S.Name = '') or (g_WaitingHeroUseItem.Item.ClientItem.S.Name <> '') then exit;
           MovItem := g_MovingHeroItem;
           msgWho := 4;
         end else if g_boItemMoving then begin
           if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
           if (g_MovingItem.Item.ClientItem.S.Name = '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
           MovItem := g_MovingItem;
           msgWho := 2;
         end;
         if MovItem.Item.ClientItem.S.Name <> '' then begin
           case MovItem.Item.ClientItem.S.StdMode of
             42: begin
               msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.ClientItem.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);//20071231
               FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.ClientItem.S.Name));//20071231
             end;
             15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.ClientItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
               if (MovItem.Item.ClientItem.S.Source = 127) and (MovItem.Item.ClientItem.S.Stock > 0) then begin
                 msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.ClientItem.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                 FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.ClientItem.S.Name));
               end;
             end;
             4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.ClientItem.Source = 127时认为是可以修复火龙之心，
               if (MovItem.Item.ClientItem.S.Source = 127) and (MovItem.Item.ClientItem.S.Reserved > 0) then begin
                 msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.ClientItem.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                 FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.ClientItem.S.Name));
               end;
             end;
           end;
           Exit;
         end;
       end;
     end
   end;
   {$IFEND}
   if g_boHeroItemMoving (*or g_boHeroRightItem{右键点物品}*)  then begin
      flag := FALSE;
      if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
      if (g_MovingHeroItem.Item.ClientItem.S.Name = '') or (g_WaitingHeroUseItem.Item.ClientItem.S.Name <> '') then exit;
      where := GetTakeOnPosition (g_MovingHeroItem.Item.ClientItem.S.StdMode);
      if g_MovingHeroItem.Index >= 0 then begin
         case where of
            U_DRESS: begin
               if Sender = DSHDress then begin
                  if g_HeroSelf.m_btSex = 0 then //男
                     if g_MovingHeroItem.Item.ClientItem.S.StdMode <> 10 then //男衣服
                        exit;
                  if g_HeroSelf.m_btSex = 1 then //女
                     if g_MovingHeroItem.Item.ClientItem.S.StdMode <> 11 then //女衣服
                        exit;
                  flag := TRUE;
               end;
            end;
            U_WEAPON: begin
               if Sender = DSHWEAPON then begin
                  flag := TRUE;
               end;
            end;
            {X_RepairFir: begin //修补火龙之心
              if Sender = DSHBujuk then begin
                if (g_HeroItems[U_BUJUK].ClientItem.s.Shape = 9) and (g_HeroItems[U_BUJUK].ClientItem.s.StdMode = 25) then begin//20090205
                  case g_MovingHeroItem.Item.ClientItem.S.StdMode of
                    42: begin
                      msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
                      FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));//20071231
                    end;
                    15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.ClientItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
                      if (g_MovingHeroItem.Item.ClientItem.S.Source = 127) and (g_MovingHeroItem.Item.ClientItem.S.Stock > 0) then begin
                        msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                        FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));
                      end;
                    end;
                    4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.ClientItem.Source = 127时认为是可以修复火龙之心，
                      if (g_MovingHeroItem.Item.ClientItem.S.Source = 127) and (g_MovingHeroItem.Item.ClientItem.S.Reserved > 0) then begin
                        msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                        FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));
                      end;
                    end;
                  end;
                end;   
              end;
            end;  }
            U_NECKLACE: begin
               if Sender = DSHNecklace then
                  flag := TRUE;
            end;
            U_RIGHTHAND: begin
               if Sender = DSHLight then
                  flag := TRUE;
            end;
            U_HELMET: begin  //头盔
               if Sender = DSHHelmet then
                  flag := TRUE;
            end;
            U_ZHULI: begin //斗笠
              if Sender = DSHHelmet then
                 flag := True;
            end;
            U_RINGR, U_RINGL: begin
               if Sender = DSHRingL then begin
                  where := U_RINGL;
                  flag := TRUE;
               end;
               if Sender = DSHRingR then begin
                  where := U_RINGR;
                  flag := TRUE;
               end;
            end;
            U_ARMRINGR: begin  //迫骂
               if Sender = DSHArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
               if Sender = DSHArmRingR then begin
                  where := U_ARMRINGR;
                  flag := TRUE;
               end;
            end;
            U_ARMRINGL: begin  //25,  刀啊风,迫骂
               if Sender = DSHArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            U_BUJUK: begin
               if Sender = DSHBujuk then begin
                  where := U_BUJUK;
                  flag := TRUE;
               end;
               if Sender = DSHArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            U_BELT: begin
               if Sender = DSHBelt then begin
                  where := U_BELT;
                  flag := TRUE;
               end;
            end;
            U_BOOTS: begin
               if Sender = DSHBoots then begin
                  where := U_BOOTS;
                  flag := TRUE;
               end;
            end;
            U_CHARM: begin
               if Sender = DSHCharm then begin
                  where := U_CHARM;
                  flag := TRUE;
               end;
            end;
         end;
         {if Sender = DSHBujuk then begin
           if (g_HeroItems[U_BUJUK].ClientItem.s.Shape = 9) and (g_HeroItems[U_BUJUK].ClientItem.s.StdMode = 25) and (g_HeroItems[U_BUJUK].ClientItem.s.Name <> '') then begin//20090205
             case g_MovingHeroItem.Item.ClientItem.S.StdMode of
               42: begin
                 msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
                 FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));//20071231
               end;
               15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.ClientItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
                 if (g_MovingHeroItem.Item.ClientItem.S.Source = 127) and (g_MovingHeroItem.Item.ClientItem.S.Stock > 0) then begin
                   msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                   FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));
                 end;
               end;
               4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.ClientItem.Source = 127时认为是可以修复火龙之心，
                 if (g_MovingHeroItem.Item.ClientItem.S.Source = 127) and (g_MovingHeroItem.Item.ClientItem.S.Reserved > 0) then begin
                   msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                   FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));
                 end;
               end;
             end;
           end;
         end else begin  }
           if Sender = DSHCharm then begin
             if (g_HeroItems[U_CHARM].ClientItem.S.Shape = 5) and (g_HeroItems[U_CHARM].ClientItem.S.StdMode = 7) and (g_HeroItems[U_CHARM].ClientItem.S.Name <> '') then begin//20090205
               case g_MovingHeroItem.Item.ClientItem.S.StdMode of
                 7: begin
                   if g_MovingHeroItem.Item.ClientItem.S.Shape = 3 then begin
                     msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingHeroItem.Item.ClientItem.MakeIndex, 2, 0, 0, frmMain.m_nSendMsgCount);//20071231
                     FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.ClientItem.S.Name));//20071231
                     Exit;
                   end;
                 end;
               end;
             end;
           end;
         //end;
      end else begin
         n := -(g_MovingHeroItem.Index+1);
         if n in [0..14] then begin
            ItemClickSound (g_MovingHeroItem.Item.ClientItem.S);
            g_HeroItems[n].ClientItem := g_MovingHeroItem.Item.ClientItem;
            g_MovingHeroItem.Item.ClientItem.S.Name := '';
            g_boHeroItemMoving := FALSE;
         end;
      end;
      if flag then begin
         ItemClickSound (g_MovingHeroItem.Item.ClientItem.S);
         g_WaitingHeroUseItem := g_MovingHeroItem;
         g_WaitingHeroUseItem.Index := where;
         FrmMain.SendTakeOnHeroItem (where, g_MovingHeroItem.Item.ClientItem.MakeIndex, g_MovingHeroItem.Item.ClientItem.S.Name);
         g_MovingHeroItem.Item.ClientItem.S.Name := '';
         g_boHeroItemMoving := FALSE;
      end;
      if (Sender = DSHBujuk) and (g_MovingHeroItem.Item.ClientItem.S.StdMode=25) and (g_MovingHeroItem.Item.ClientItem.S.Shape=9) and (g_boHeroItemMoving = FALSE) then begin
        DBHeroSpleenImg.Visible:=TRUE;
      end;   //20080319
   end else begin
      if g_boItemMoving then Exit;
      if (g_MovingHeroItem.Item.ClientItem.S.Name <> '') or (g_WaitingHeroUseItem.Item.ClientItem.S.Name <> '') then exit;
      
      sel := -1;
      if Sender = DSHDress then sel := U_DRESS;
      if Sender = DSHWeapon then sel := U_WEAPON;

      //斗笠
      if Sender = DSHHelmet then begin
        if g_HeroItems[U_ZHULI].ClientItem.S.Name <> '' then
         sel := U_ZHULI
        else sel := U_HELMET;
      end;

      if Sender = DSHNecklace then sel := U_NECKLACE;
      if Sender = DSHLight then sel := U_RIGHTHAND;
      if Sender = DSHRingL then sel := U_RINGL;
      if Sender = DSHRingR then sel := U_RINGR;
      if Sender = DSHArmRingL then sel := U_ARMRINGL;
      if Sender = DSHArmRingR then sel := U_ARMRINGR;

      if Sender = DSHBujuk then sel := U_BUJUK;
      if Sender = DSHBelt then sel := U_BELT;  //
      if Sender = DSHBoots then sel := U_BOOTS;
      if Sender = DSHCharm then sel := U_CHARM;

      if sel >= 0 then begin
         if g_HeroItems[sel].ClientItem.S.Name <> '' then begin
            ItemClickSound (g_HeroItems[sel].ClientItem.S);
            g_MovingHeroItem.Index := -(sel+1);
            g_MovingHeroItem.Item := g_HeroItems[sel];
            g_HeroItems[sel].ClientItem.S.Name := '';
            g_boHeroItemMoving := TRUE;
         end;
      end;
      if (Sender = DSHBujuk) and (g_HeroItems[U_BUJUK].ClientItem.S.Shape=9) and (g_boHeroItemMoving = TRUE) then begin
        DBHeroSpleenImg.Visible:=FALSE;
      end;
   end;
end;
//英雄翻页码过程 $013 2007.10.21
procedure TFrmDlg.HeroPageChanged;
begin
   DScreen.ClearHint;
   DLHeroNGUpLevel1.Visible := False;
   DLHeroNGUpLevel2.Visible := False;
   DLHeroNGUpLevel3.Visible := False;
   DLHeroNGUpLevel4.Visible := False;
   DLHeroNGUpLevel5.Visible := False;
   DLHeroNGUpLevel6.Visible := False;
   case HeroStatePage of
      3: begin
         DStMagHero1.Visible := TRUE;  DStMagHero2.Visible := TRUE;
         DStMagHero3.Visible := TRUE;  DStMagHero4.Visible := TRUE;
         DStMagHero5.Visible := TRUE;  DStMagHero6.Visible := TRUE;
         DSHPageUp.Visible := TRUE;
         DSHPageDown.Visible := TRUE;
         HeroMagicPage := 0;
         DCheckHeroDeputyHeroWarr.Visible := FALSE;
         DCheckHeroDeputyHeroWiz.Visible := FALSE;
         DCheckHeroDeputyHeroTaos.Visible := FALSE;
      end;
      4: begin
        DStMagHero1.Visible := FALSE;  DStMagHero2.Visible := FALSE;
        DStMagHero3.Visible := FALSE;  DStMagHero4.Visible := FALSE;
        DStMagHero5.Visible := FALSE;  DStMagHero6.Visible := FALSE;
        DSHPageUp.Visible := FALSE;
        DSHPageDown.Visible := FALSE;
        DCheckHeroDeputyHeroWarr.Visible := True;
        DCheckHeroDeputyHeroWiz.Visible := True;
        DCheckHeroDeputyHeroTaos.Visible := True;
        DCheckHeroDeputyHeroWarr.Checked := False;
        DCheckHeroDeputyHeroWiz.Checked := False;
        DCheckHeroDeputyHeroTaos.Checked := False;
        case m_btDeputyHeroJob of
          0: DCheckHeroDeputyHeroWarr.Checked := True;
          1: DCheckHeroDeputyHeroWiz.Checked := True;
          2: DCheckHeroDeputyHeroTaos.Checked := True;
          else DCheckHeroDeputyHeroWarr.Checked := True;
        end;
      end;
      else begin
         DStMagHero1.Visible := FALSE;  DStMagHero2.Visible := FALSE;
         DStMagHero3.Visible := FALSE;  DStMagHero4.Visible := FALSE;
         DStMagHero5.Visible := FALSE;  DStMagHero6.Visible := FALSE;
         DSHPageUp.Visible := FALSE;
         DSHPageDown.Visible := FALSE;
          DCheckHeroDeputyHeroWarr.Visible := FALSE;
          DCheckHeroDeputyHeroWiz.Visible := FALSE;
          DCheckHeroDeputyHeroTaos.Visible := FALSE;
      end;
   end;
end;
procedure TFrmDlg.DPrevStateHeroClick(Sender: TObject; X, Y: Integer);
begin
  if HeroStateTab = 0 then begin
   Dec (HeroStatePage);
   if HeroStatePage < 0 then
      HeroStatePage := MAXSTATEPAGE-1;
   HeroPageChanged;
  end else begin
    Dec (HeroInternalForcePage);
    if HeroInternalForcePage < 0 then
      HeroInternalForcePage := 1;
    HeroInternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DNextStateHeroClick(Sender: TObject; X, Y: Integer);
begin
  if HeroStateTab = 0 then begin
   Inc (HeroStatePage);
   if HeroStatePage > MAXSTATEPAGE-1 then
      HeroStatePage := 0;
   HeroPageChanged;
  end else begin
    Inc (HeroInternalForcePage);
    if HeroInternalForcePage > 1 then
      HeroInternalForcePage := 0;
    HeroInternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DHeroItemGridCloseClick(Sender: TObject; X, Y: Integer);
begin
   DHeroItemBag.Visible := FALSE;
end;

procedure TFrmDlg.DHeroItemGridGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx, mi: integer;
   temp: TClientEffecItem;
   TempIdx: Integer;
begin
  //20080803修正 主人装备拿下点英雄包里 物品重叠
  if (g_boItemMoving) and (-g_MovingItem.Index in [1..14]) then Exit;
{-------------------------------------------------------}
//从主人包裹到英雄包裹  2007.10.24
   if g_boItemMoving then begin
     if g_MovingItem.Item.ClientItem.S.Name <> '' then begin
       TempIdx := -(g_MovingItem.Index);
       if not (TempIdx in [1..14]) then begin
         g_WaitingUseItem := g_MovingItem;
         FrmMain.SendItemToHeroBag(-(g_MovingItem.Index+1), g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
         g_boItemMoving := FALSE;
         g_MovingItem.Item.ClientItem.S.Name:='';
         Exit; //20080331
       end;
     end;
   end;
{-------------------------------------------------------------}
  idx := ACol + ARow * DHeroItemGrid.ColCount;
  if idx in [0..g_HeroBagCount-1] then begin
    if ssCtrl in Shift then begin
      if (g_HeroItemArr[idx].ClientItem.S.Name <> '') and not g_boHeroItemMoving then begin
        g_WaitingHeroUseItem.Item := g_HeroItemArr[idx];
        FrmMain.SendItemToMasterBag(idx, g_HeroItemArr[idx].ClientItem.MakeIndex, g_HeroItemArr[idx].ClientItem.S.Name);
        g_HeroItemArr[idx].ClientItem.S.Name := '';
      end;
    end else begin
      if not g_boHeroItemMoving then begin
         if g_HeroItemArr[idx].ClientItem.S.Name <> '' then begin
            g_boHeroItemMoving := TRUE;
            g_MovingHeroItem.Index := idx;
            g_MovingHeroItem.Item := g_HeroItemArr[idx];
            g_HeroItemArr[idx].ClientItem.S.Name := '';
            ItemClickSound (g_HeroItemArr[idx].ClientItem.S);
         end;
      end else begin
         mi := g_MovingHeroItem.Index;
         if (mi = -97) or (mi = -98) then exit;
         if (mi < 0) and (mi >= -15 {-9}) then begin
            g_WaitingHeroUseItem := g_MovingHeroItem;
            FrmMain.SendTakeOffHeroItem (-(g_MovingHeroItem.Index+1), g_MovingHeroItem.Item.ClientItem.MakeIndex, g_MovingHeroItem.Item.ClientItem.S.Name);
            g_MovingHeroItem.Item.ClientItem.S.name := '';
            g_boHeroItemMoving := FALSE;
         end else begin
            if (mi <= -20) and (mi > -30) then
               DealItemReturnBag (g_MovingHeroItem.Item);
            if g_HeroItemArr[idx].ClientItem.S.Name <> '' then begin
               temp := g_HeroItemArr[idx];
               g_HeroItemArr[idx] := g_MovingHeroItem.Item;
               g_MovingHeroItem.Index := idx;
               g_MovingHeroItem.Item := temp
            end else begin
               g_HeroItemArr[idx] := g_MovingHeroItem.Item;
               g_MovingHeroItem.Item.ClientItem.S.name := '';
               g_boHeroItemMoving := FALSE;
            end;
         end;
         if (g_MovingHeroItem.Item.ClientItem.S.StdMode = 17) and (g_HeroItemArr[idx].ClientItem.S.StdMode = 17) and (g_MovingHeroItem.Item.ClientItem.MakeIndex <> g_HeroItemArr[idx].ClientItem.MakeIndex) then begin
           if (g_MergerItem.ClientItem.S.Name <> '') and (GetTickCount - g_dwMergerTime > 5000) then g_MergerItem.ClientItem.S.Name := '';
           if g_MergerItem.ClientItem.S.Name = '' then begin
             g_MergerItem := g_MovingHeroItem.Item;
             g_MovingHeroItem.Item.ClientItem.S.Name := '';
             g_dwMergerTime := GetTickCount;
             g_boHeroItemMoving := False;
             frmMain.SendItemMakeOne(g_MergerItem.ClientItem.MakeIndex, g_HeroItemArr[idx].ClientItem.MakeIndex, 1);
           end;
         end;
      end;
    end;
  end;
  ArrangeHeroItemBag;
end;

// new copy by liuzhigang
procedure TFrmDlg.DHeroItemGridDblClick(Sender: TObject);
var
   idx, where: integer;
   keyvalue: TKeyBoardState;
   cu: TClientEffecItem;
begin
   idx := DHeroItemGrid.Col + DHeroItemGrid.Row * DHeroItemGrid.ColCount;
   if idx in [0..g_HeroBagCount-1] then begin
      if g_HeroItemArr[idx].ClientItem.S.Name <> '' then begin
         FillChar(keyvalue, sizeof(TKeyboardState), #0);
         GetKeyboardState (keyvalue);
         if keyvalue[VK_CONTROL] = $80 then begin   //ctrl
            cu := g_HeroItemArr[idx];
            g_HeroItemArr[idx].ClientItem.S.Name := '';
            AddHeroItemBag (cu);
         end else
         if (g_HeroItemArr[idx].ClientItem.S.StdMode <= 4) or (g_HeroItemArr[idx].ClientItem.S.StdMode = 31) then begin
           FrmMain.HeroEatItem (idx);
         end;
      end else begin
         if g_boHeroItemMoving and (g_MovingHeroItem.Item.ClientItem.S.Name <> '') then begin
            FillChar(keyvalue, sizeof(TKeyboardState), #0);
            GetKeyboardState (keyvalue);
            if keyvalue[VK_CONTROL] = $80 then begin
               cu := g_MovingHeroItem.Item;
               g_MovingHeroItem.Item.ClientItem.S.Name := '';
               g_boHeroItemMoving := FALSE;
               AddHeroItemBag (cu);
            end else
            if (g_MovingHeroItem.Index = idx) and
              (g_MovingHeroItem.Item.ClientItem.S.StdMode <= 4) or (g_HeroItemArr[idx].ClientItem.S.StdMode = 17) or
              (g_HeroItemArr[idx].ClientItem.S.StdMode = 31) or ((g_MovingHeroItem.Item.ClientItem.S.StdMode = 60) and (g_MovingHeroItem.Item.ClientItem.S.Shape <> 0)) or
              ((g_HeroItemArr[idx].ClientItem.S.StdMode = 51) and (g_HeroItemArr[idx].ClientItem.S.Shape in [2..3]))
            then begin
              FrmMain.HeroEatItem (-1);
            end else begin
              //双击穿装备
              where := GetTakeOnPosition(g_MovingHeroItem.Item.ClientItem.S.StdMode);
              if (where <> -1) then begin
                if where = U_RINGR then begin
                  if g_HeroItems[U_RINGR].ClientItem.S.Name = '' then begin
                    where := U_RINGR;
                  end else
                  if g_HeroItems[U_RINGL].ClientItem.S.Name = '' then begin
                    where := U_RINGL;
                  end else
                  if not g_boHeroRightItemRingEmpty then begin
                    where := U_RINGR;
                    g_boHeroRightItemRingEmpty := True;
                  end else begin
                    where := U_RINGL;
                    g_boHeroRightItemRingEmpty := False;
                  end;
                end;
                if where = U_ARMRINGR then begin
                  if g_HeroItems[U_ARMRINGR].ClientItem.S.Name = '' then begin
                    where := U_ARMRINGR;
                  end else
                  if g_HeroItems[U_ARMRINGL].ClientItem.S.Name = '' then begin
                    where := U_ARMRINGL;
                  end else
                  if not g_boHeroRightItemArmRingEmpty then begin
                    where := U_ARMRINGR;
                    g_boHeroRightItemArmRingEmpty := True;
                  end else begin
                    where := U_ARMRINGL;
                    g_boHeroRightItemArmRingEmpty := False;
                  end;
                end;
                g_WaitingHeroUseItem.Item := g_MovingHeroItem.Item;
                g_WaitingHeroUseItem.Index := where;
                FrmMain.SendTakeOnHeroItem(where, g_MovingHeroItem.Item.ClientItem.MakeIndex, g_MovingHeroItem.Item.ClientItem.S.Name);
                DelHeroItemBag(g_MovingHeroItem.Item.ClientItem.S.Name, g_MovingHeroItem.Item.ClientItem.MakeIndex);
                g_MovingHeroItem.Item.ClientItem.S.Name := '';
              end;
            end;
         end;
      end;
   end;
end;

//英雄图标性别 职业 图象区分     2007.11.2  代码$005
function TFrmDlg.HeroIcon(sex:integer;job:integer):integer;
begin
  case Sex of
    0:Result := 635+job;
    1:Result := 638+job;
    else Result := 635+job;
  end;
end;

//英雄底层背景绘制
procedure TFrmDlg.DHeroRoleIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  pgidx,bbx,bby:integer;
  d: TAsphyreLockableTexture;
  rc: TRect;
begin
  pgidx:=HeroIcon(g_HeroSelf.m_btSex,g_HeroSelf.m_btJob);
  if g_WUI1Images.Images[1290] <> nil then begin
    bbx := 30;
    bby := 21;
    with Sender as TAspDButton do begin
      d := g_WMain3Images.Images[pgidx];
      if (g_HeroSelf <> nil) and (g_HeroSelf.m_Abil.HP <= 0) and (g_HeroSelf.m_boDeath) then begin
        g_HeroSelf.m_Abil.MP := 0;
        g_HeroSelf.m_Abil.Exp := 0;
        if d <> nil then begin
          dsurface.DrawAlpha(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, True, 124);
        end;
      end else begin
        if d <> nil then
        dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, true);
      end;
    end;
    with DHeroIcon do begin
      AspTextureFont.TextOut (SurfaceX(GLeft)+71 - FrmMain.Canvas.TextWidth(IntToStr(g_HeroSelf.m_Abil.Level)) div 2,SurfaceY(GTop)+91, clWhite, Inttostr(g_Heroself.m_Abil.Level));

      {d := g_WMain2Images.Images[513];
      if d <> nil then
         dsurface.Draw (47, 16, d.ClientRect, d, true); }

      //d := g_WMain2Images.Images[582];
      d := g_WUI1Images.Images[1296];
      if d <> nil then begin
         rc := d.ClientRect;
         if (g_HeroSelf.m_Abil.MaxAlcohol > 0) and (g_HeroSelf.m_Abil.WineDrinkValue > 0) then begin
           rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxAlcohol * (g_HeroSelf.m_Abil.MaxAlcohol - g_HeroSelf.m_Abil.WineDrinkValue));
           dsurface.Draw (SurfaceX(GLeft)+66, SurfaceY(GTop)+13+rc.Top, rc, d, True);
         end;
      end;

      {$IF M2Version = 1}
      if g_HeroSelf.m_Abil.MaxTransferValue > 0 then begin
        {d := g_WMainImages.Images[1205];
        if d <> nil then
          dsurface.Draw (20, 14, d.ClientRect, d, true);  }

        //d := g_WMainImages.Images[1206];
        d := g_WUI1Images.Images[1295];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxTransferValue * (g_HeroSelf.m_Abil.MaxTransferValue - g_HeroSelf.m_Abil.TransferValue));
          dsurface.Draw(SurfaceX(GLeft)+20, SurfaceY(GTop)+12+rc.Top, rc, d, True);
        end;
      end;
      {$IFEND}
    end;
  end else begin
    bbx := 17;
    bby := 18;
    with Sender as TAspDButton do begin
      d := g_WMain3Images.Images[pgidx];
      if (g_HeroSelf <> nil) and (g_HeroSelf.m_Abil.HP <= 0) and (g_HeroSelf.m_boDeath) then begin
        g_HeroSelf.m_Abil.MP := 0;
        g_HeroSelf.m_Abil.Exp := 0;
        if d <> nil then begin
          {DrawBlendEx(dsurface,SurfaceX(bbx),  //  要调整 }

          dsurface.DrawAlpha(SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, True, 124);
          //dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
        end;
      end else begin
        if d <> nil then
        dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, true);
      end;
    end;
    with DHeroIcon do begin
      if g_WMainImages.Images[1214] <> nil then
        AspTextureFont.TextOut (SurfaceX(GLeft)+14 - FrmMain.Canvas.TextWidth(IntToStr(g_HeroSelf.m_Abil.Level)) div 2, SurfaceY(GTop)+73, clWhite, Inttostr(g_Heroself.m_Abil.Level))
      else AspTextureFont.TextOut (SurfaceX(GLeft)+14 - FrmMain.Canvas.TextWidth(IntToStr(g_HeroSelf.m_Abil.Level)) div 2, SurfaceY(GTop)+61, clWhite, Inttostr(g_Heroself.m_Abil.Level));

      d := g_WMain2Images.Images[513];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+12, d.ClientRect, d, true);

      d := g_WMain2Images.Images[582];
      if d <> nil then begin
         rc := d.ClientRect;
         if (g_HeroSelf.m_Abil.MaxAlcohol > 0) and (g_HeroSelf.m_Abil.WineDrinkValue > 0) then begin
           rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxAlcohol * (g_HeroSelf.m_Abil.MaxAlcohol - g_HeroSelf.m_Abil.WineDrinkValue));
           dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+12+rc.Top, rc, d, True);
         end;
      end;
      {$IF M2Version = 1}
      if g_HeroSelf.m_Abil.MaxTransferValue > 0 then begin
        d := g_WMainImages.Images[1205];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+12, SurfaceY(GTop)+12, d.ClientRect, d, true);

        d := g_WMainImages.Images[1206];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxTransferValue * (g_HeroSelf.m_Abil.MaxTransferValue - g_HeroSelf.m_Abil.TransferValue));
          dsurface.Draw(SurfaceX(GLeft)+12, SurfaceY(GTop)+12+rc.Top, rc, d, True);
        end;
      end;
      {$IFEND}
    end;
  end;
end;

//英雄图标绘制
procedure TFrmDlg.DHeroIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc:Trect;
begin
  if g_HeroSelf = nil then Exit;  
  with DHeroIcon do begin
    if g_WUI1Images.Images[1290] <> nil then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      d := g_WUI1Images.Images[1291];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxHP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxHP * g_Heroself.m_Abil.HP);
         dsurface.Draw (SurfaceX(GLeft) + 95, SurfaceY(GTop) + 34, rc, d, true);
      end;
      d := g_WUI1Images.Images[1292];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxMP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxMP * g_Heroself.m_Abil.MP);
         dsurface.Draw (SurfaceX(GLeft) + 98, SurfaceY(GTop) + 46, rc, d, TRUE);
      end;
      d := g_WUI1Images.Images[1293];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Skill69MaxNH > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_HeroSelf.m_Skill69MaxNH * g_Heroself.m_Skill69NH);
         dsurface.Draw (SurfaceX(GLeft) + 96, SurfaceY(GTop) + 58, rc, d, TRUE);
      end;
      d := g_WUI1Images.Images[1294];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxExp > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxExp * g_Heroself.m_Abil.Exp);
         dsurface.Draw (SurfaceX(GLeft) + 87, SurfaceY(GTop) + 70, rc, d, TRUE);
      end;
      AspTextureFont.TextOut (SurfaceX(GLeft) + 15, SurfaceY(GTop) + 13, clWhite, GetHeroJobStr(g_Heroself.m_btJob));
      AspTextureFont.TextOut (SurfaceX(GLeft) + 94, SurfaceY(GTop) + 18, clWhite, g_HeroSelf.m_sUserName);
      AspTextureFont.TextOut (SurfaceX(GLeft) + 184, SurfaceY(GTop) + 17, $0088C4E8, g_sMyHeroType);
      case g_HeroSelf.m_btJob of
        0: begin  //战士
          if (g_HeroSelf.m_nState and $04000000 = 0){非麻痹} then AspTextureFont.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clWhite, '石化')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clRed, '石化');
          if (g_HeroSelf.m_nState and $1000000 = 0){非冰冻} then AspTextureFont.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clWhite, '冰冻')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clRed, '冰冻');
          if (g_HeroSelf.m_nState and $10000000 = 0){非网罩} then AspTextureFont.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clWhite, '网罩')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clRed, '网罩');
        end;
        1: begin  //法师
          if (g_HeroSelf.m_nState and $00100000 <> 0){非破盾} then AspTextureFont.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clWhite, '破盾')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clRed, '破盾');
          if (g_HeroSelf.m_nState and $04000000 = 0){非麻痹} then AspTextureFont.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clWhite, '石化')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clRed, '石化');
          if (g_HeroSelf.m_nState and $1000000 = 0){非冰冻} then AspTextureFont.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clWhite, '冰冻')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clRed, '冰冻');
        end;
        2: begin  //道士
          if g_boHeroInfuriating then
            AspTextureFont.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clRed, '真气')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clWhite, '真气');
          if (g_HeroSelf.m_nState and $04000000 = 0){非麻痹} then AspTextureFont.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clWhite, '石化')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clRed, '石化');
          if (g_HeroSelf.m_nState and $1000000 = 0){非冰冻} then AspTextureFont.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clWhite, '冰冻')
          else AspTextureFont.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clRed, '冰冻');
        end;
      end;
      if g_boShowHeroStateNumber then begin
        AspTextureFont.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 31, clWhite, Format('%d/%d',[g_HeroSelf.m_Abil.HP, g_HeroSelf.m_Abil.MaxHP]));
        AspTextureFont.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 43, clWhite, Format('%d/%d',[g_HeroSelf.m_Abil.MP, g_HeroSelf.m_Abil.MaxMP]));
        AspTextureFont.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 55, clWhite, Format('%d/%d',[g_HeroSelf.m_Skill69NH, g_HeroSelf.m_Skill69MaxNH]));
        if g_HeroSelf.m_Abil.MaxExp > 0 then
        AspTextureFont.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 67, clWhite, FloatToStrFixFmt (100 * (g_HeroSelf.m_Abil.Exp / g_HeroSelf.m_Abil.MaxExp), 3, 2) + '%');
      end;
    end else begin
      if g_WMainImages.Images[1214] <> nil then begin
        if WLib <> nil then begin //20080701
          d := WLib.Images[FaceIndex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        d := g_WUiMainImages.Images[0];
        if d <> nil then begin
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
        end;
      end;

      d := g_WMain3Images.Images[386];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxHP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxHP * g_Heroself.m_Abil.HP);
         dsurface.Draw (SurfaceX(GLeft)+75, SurfaceY(GTop)+24, rc, d, true);
      end;
      d := g_WMain3Images.Images[387];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxMP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxMP * g_Heroself.m_Abil.MP);
         dsurface.Draw (SurfaceX(GLeft)+80, SurfaceY(GTop)+37, rc, d, TRUE);
      end;
      d := g_WMain3Images.Images[388];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxExp > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxExp * g_Heroself.m_Abil.Exp);
         dsurface.Draw (SurfaceX(GLeft)+80, SurfaceY(GTop)+49, rc, d, TRUE);
      end;
      AspTextureFont.TextOut (SurfaceX(GLeft)+80, SurfaceY(GTop)+5, clWhite, g_HeroSelf.m_sUserName);
      if g_WMainImages.Images[1214] <> nil then
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+300 div 2 - FrmMain.Canvas.TextWidth(formatfloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%') div 2,
            SurfaceY(GTop)+62, clWhite, clBlack, FormatFloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%')
      else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+240 div 2 - FrmMain.Canvas.TextWidth(formatfloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%') div 2,
            SurfaceY(GTop)+62, clWhite, clBlack, FormatFloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%');
      if g_WMainImages.Images[1214] <> nil then AspTextureFont.TextOut (SurfaceX(GLeft)+83, SurfaceY(GTop)+63, $0000A4D8, g_sMyHeroType);
    end;
  end;
end;

//英雄怒气变换函数
procedure TFrmDlg.typeTimeimg;
begin
    if GetTickCount - typetime > 200 then begin
     typetime := GetTickCount;
     inc(imginsex);
    if imginsex > 1 then imginsex := 0;
    end;
end;

//英雄怒气
procedure TFrmDlg.DHeroSpleenImgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc:Trect;
  nTop: Byte;
begin
  with DBHeroSpleenImg do
  begin
    if g_WinBatterMagicList.Count > 0 then
    begin
      d := g_WMainImages.Images[1127];
      if d = nil then d := g_WMain3Images.Images[410];
    end else d := g_WMain3Images.Images[410];
    if d <> nil then
      dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;

  nTop := 0;
  with DBHeroSpleenImg do begin
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1128];
      if d = nil then d := g_WMain3Images.Images[411] else nTop := 14;
    end else d := g_WMain3Images.Images[411];
    rc := d.ClientRect;
    if d <> nil then begin
      if nMaxFirDragonPoint > 0 then begin
       rc.Top := Round(rc.Bottom / nMaxFirDragonPoint * (nMaxFirDragonPoint - m_nFirDragonPoint));
       dsurface.Draw (SurfaceX(GLeft)+2, SurfaceY(GTop)+rc.Top+nTop+21, rc, d, FALSE);
      end;
    end;
    if m_nFirDragonPoint >= nMaxFirDragonPoint then begin
      typeTimeimg;//显示时间间隔
      if g_WinBatterMagicList.Count > 0 then begin
        d := g_WMainImages.Images[1128 + imginsex];
        if d = nil then  g_WMain3Images.Images[imginsex + 411] else nTop := 14;
      end else d := g_WMain3Images.Images[imginsex + 411];
      if d <> nil then
       dsurface.Draw (SurfaceX(GLeft)+2, SurfaceY(GTop)+rc.Top+nTop+21, d.ClientRect, d, false);
    end;
  end;
end;

procedure TFrmDlg.DSHPageUpClick(Sender: TObject; X, Y: Integer);
begin
  if HeroStateTab = 0 then begin
    if Sender = DSHPageUp then begin
      if HeroMagicPage > 0 then
         Dec (HeroMagicPage);
    end else begin
      if HeroMagicPage < (g_HeroMagicList.Count+5) div 6 - 1 then
         Inc (HeroMagicPage);
    end;
  end else begin
    if Sender = DSHPageUp then begin
      if HeroInternalForceMagicPage > 0 then begin
      	Dec (HeroInternalForceMagicPage);
        {$IF M2Version <> 2}
        NGUpLevelState(True);
        {$IFEND}
      end;
    end else begin
      if HeroInternalForceMagicPage < (g_HeroInternalForceMagicList.Count+5) div 6 - 1 then begin
      	Inc (HeroInternalForceMagicPage);
        {$IF M2Version <> 2}
        NGUpLevelState(True);
        {$IFEND}
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroIconClick(Sender: TObject; X, Y: Integer);
begin
 if g_HeroSelf = nil then exit;
{-------------------------------------------------------}
//从主人包裹到英雄包裹  2007.10.24
  if g_boItemMoving then begin
    if g_MovingItem.Item.ClientItem.S.Name <> '' then begin
     {g_WaitingHeroUseItem}g_WaitingUseItem := g_MovingItem;
     FrmMain.SendItemToHeroBag(-(g_MovingItem.Index+1), g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
     g_boItemMoving := FALSE;
     g_MovingItem.Item.ClientItem.S.Name:='';
    end;
  end;
end;

procedure TFrmDlg.DStMagHero1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   idx, icon: integer;
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   wm: TAspWMImages;
begin
  with Sender as TAspDButton do begin
    pm := nil;
    if HeroStateTab = 0 then begin
      idx := _Max(Tag + HeroMagicPage * 6, 0);
      if idx < g_HeroMagicList.Count then begin
        pm := PTClientMagic (g_HeroMagicList[idx]);
        if pm <> nil then begin
          wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, Icon);
          if wm <> nil then begin
            if icon >= 0 then begin
              if not Downed then begin
                d := wm.Images[icon];
                if d <> nil then begin
                  if word(pm.Key) = 0 then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                  else begin
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                    dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
                  end;
                 end;
              end else begin
                if (pm.Def.wMagicId in [3,4,60..65,67]) then begin
                  d := g_WMagIconImages.Images[icon];
                  if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end else begin
                  d := wm.Images[icon+1];
                  if d <> nil then
                    if word(pm.Key) = 0 then
                      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                    else begin
                      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                      dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
                    end;
                  end;
               end;
             end;
           end;
         end;
      end;
    end else begin
      idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
      if idx < g_HeroInternalForceMagicList.Count then begin
        pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        if pm <> nil then begin
          if not Downed then begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end else begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2+1];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          if word(pm.Key) <> 0 then begin
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateHeroMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
  g_HeroMouseStateItem.ClientItem.S.Name := '';
end;

// Checked by liuzhgiang
procedure TFrmDlg.DBotMemoClick(Sender: TObject; X, Y: Integer);
begin
  if (not Dshop.Visible) and (GetTickCount - g_dwShopTick > 2000) then begin
    g_dwShopTick := GetTickCount();
    Dshop.Visible:=True;
    DShopDecorateClick(DBotMemo,x,y);
    //ShopIndex := -1;
    //ShopSpeciallyIndex := -1;
  end else Dshop.Visible := False;
end;

// new copy bu liuzhigang
(*******************************************************************************
  作用 : 商铺描述地方的分割符函数
  过程 : ShopStrWord(s:string;dsurface:TdirectDrawSurface;x,y:integer)
  参数 : s为描述的字符串. dsurface为输出场景. x,y为输出的坐标
*******************************************************************************)
procedure TFrmDlg.ShopStrWord(s:string;dsurface: TAsphyreCanvas; x,y:integer);//取|符号 左右边的内容
var
  i,j:integer;
  str:string;
begin
  j:=0;
  str:='';
  s:=s+'|';
  if Length(s)<=0 then begin //20080629
      exit;
  end;
  for i:=1 to length(s) do begin
    if (s[i]='|' ) then begin
      if str<>'' then begin
          j:=j+1;
          AspTextureFont.TextOut (x, y+j*14, clWhite, str);
      end;
      str:='';
      continue;
    end;
    str:=str+s[i]
  end;
end;

// new copy by liuzhigang
procedure TFrmDlg.DShopDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i,bbx,bby,m:integer;
  d:TAsphyreLockableTexture;
  pm:pTShopInfo;
  Color: TColor;
begin
  with DShop do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WEffectImages.Images[380];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft+18), SurfaceY(GTop+35), d.ClientRect, d, true);
    if g_ShopSpeciallyItemList.Count > 0 then begin//20080629
      for I:=0 to g_ShopSpeciallyItemList.Count-1 do begin
        pm := pTShopInfo (g_ShopSpeciallyItemList[i]);
        if ShopSpeciallyIndex=i then begin
          ShopGifInfo(dsurface,SurfaceX(GLeft+18),SurfaceY(GTop+35),strtoint(pm.ImgBegin),strtoint(pm.Imgend));
        end;
      end;
    end;
    if g_ShopItemList.Count > 0 then begin//20080629
      for I:=0 to g_ShopItemList.Count-1 do begin
        pm := pTShopInfo (g_ShopItemList[i]);
        if ShopIndex=i then begin
          ShopGifInfo(dsurface,SurfaceX(GLeft+18),SurfaceY(GTop+35),strtoint(pm.ImgBegin),strtoint(pm.Imgend));
        end;
      end;
    end;
    bbx:=GLeft+170;
    bby:=GTop+10;
  end;

  if g_ShopItemList.Count > 0 then //20080629
  for i:=0 to g_ShopItemList.Count-1 do begin
    pm := pTShopInfo (g_ShopItemList[i]);
    m := i;
    if odd(i) then begin
      if ShopIndex=i then Color := clRed else Color := clWhite;
      AspTextureFont.TextOut (bbx + 230, bby + 25 + m*27, Color, pm.StdItem.Name);
      AspTextureFont.TextOut (bbx + 230, bby + 40 + m*27, Color, pm.Introduce1);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        AspTextureFont.TextOut (bbx + 230, bby + 55 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        AspTextureFont.TextOut (bbx + 230, bby + 55 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      AspTextureFont.TextOut (bbx + 230, bby + 55 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
      if ShopIndex=i then begin
        g_ShopItemName :=pm.StdItem.Name;
        g_nShopItemGold := pm.StdItem.Price;
        Color := clWhite;
        ShopStrWord(pm.sIntroduce,dsurface,bbx -150,bby + 230);
      end;
    end else begin
      if ShopIndex=i then Color := clRed else Color := clWhite;
      AspTextureFont.TextOut (bbx + 60, bby + 52 + m*27, Color, pm.StdItem.Name);
      AspTextureFont.TextOut (bbx + 60, bby + 67 + m*27, Color, pm.Introduce1);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        AspTextureFont.TextOut (bbx + 60, bby + 82 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        AspTextureFont.TextOut (bbx + 60, bby + 82 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      AspTextureFont.TextOut (bbx + 60, bby + 82 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
      if ShopIndex=i then  begin
        g_ShopItemName :=pm.StdItem.Name;
        g_nShopItemGold := pm.StdItem.Price;
        Color := clWhite;
        ShopStrWord(pm.sIntroduce,dsurface,bbx -150,bby + 230);
      end;
    end;
  end;
  if g_ShopSpeciallyItemList.Count > 0 then //20080629
  for i:=0 to g_ShopSpeciallyItemList.Count-1 do begin
    pm := pTShopInfo (g_ShopSpeciallyItemList[i]);
    if ShopSpeciallyIndex=i then begin
      Color := clRed;
      AspTextureFont.TextOut (bbx + 350, bby + 89 + i*65, Color, pm.StdItem.Name);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        AspTextureFont.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        AspTextureFont.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      AspTextureFont.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
      Color := clWhite;
      ShopStrWord(pm.sIntroduce,dsurface,bbx -150,bby + 230);
      g_ShopItemName:=pm.StdItem.Name;
      g_nShopItemGold := pm.StdItem.Price;
    end else begin
      Color := clWhite;
      AspTextureFont.TextOut (bbx + 350, bby + 89 + i*65, Color, pm.StdItem.Name);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        AspTextureFont.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
       AspTextureFont.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      AspTextureFont.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DShopCloseClick(Sender: TObject; X, Y: Integer);
begin
  Dshop.Visible := FALSE;
end;

procedure TFrmDlg.DShopImg1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  icon,idx:integer;
  pm:pTShopInfo;
  d:TAsphyreLockableTexture;
begin
    with Sender as TAspDButton do begin
      idx := _Max(Tag + 0 * 10, 0);
      if idx < g_ShopItemList.Count then begin
         pm := pTShopInfo (g_ShopItemList[idx]);
         icon := pm.StdItem.Looks;
         if icon >= 0 then begin
               d := frmMain.GetBagItemImg(icon);
               if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft+(50-d.Width) div 2), SurfaceY(GTop + (50 - d.Height) div 2), d.ClientRect, d, TRUE);
         end;
      end;
   end;
end;

procedure TFrmDlg.GotoShopPage(CurPage:Integer);
var
 msg: TDefaultMessage;
 I: Integer;
begin
   for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
    if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
     Dispose(PTShopInfo(g_ShopItemList.Items[i]));
   end;
   g_ShopItemList.Clear;
   msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, CurPage{页数}, g_ShopTypePage{ShopType}, 0, frmMain.m_nSendMsgCount);
   FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DShopNextClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
 I: Integer;
begin
  if Sender = DShopPrev then begin
    if g_ShopPage > 0 then begin
       Dec (g_ShopPage);
       for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
        if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
         Dispose(PTShopInfo(g_ShopItemList.Items[i]));
       end;
       g_ShopItemList.Clear;
       msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, g_ShopPage{页数}, g_ShopTypePage{ShopType}, 0, frmMain.m_nSendMsgCount);
       FrmMain.SendSocket (EncodeMessage (msg));
    end;
  end else begin
    if g_ShopPage < g_ShopReturnPage-1 then begin
       Inc (g_ShopPage);
       for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
        if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
         Dispose(PTShopInfo(g_ShopItemList.Items[i]));
       end;
       g_ShopItemList.Clear;
       msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, g_ShopPage{页数}, g_ShopTypePage{ShopType}, 0, frmMain.m_nSendMsgCount);
       FrmMain.SendSocket (EncodeMessage (msg));
    end;
  end;
end;

procedure TFrmDlg.DShopDecorateClick(Sender: TObject; X, Y: Integer);

    procedure ShopClear();
    begin
       DShopDecorate.SetImgIndex(g_Wmain3Images,-1);
       DShopSupplies.SetImgIndex(g_Wmain3Images,-1);
       DshopStrengthen.SetImgIndex(g_Wmain3Images,-1);
       DShopFriend.SetImgIndex(g_Wmain3Images,-1);
       DShopCapacity.SetImgIndex(g_Wmain3Images,-1);
       if Sender<>DBotMemo then ShopIndex:=-1;
       g_ShopItemName:='';
    end;

var
  btn:array[0..4] of TAspDButton;
  CurBtn:TAspDButton;
var
 msg: TDefaultMessage;
 I: Integer; 
begin
  ShopClear();
  for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
    if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
      Dispose(PTShopInfo(g_ShopItemList.Items[i]));
  end;
  g_ShopItemList.Clear;

  CurBtn:=TAspDButton(Sender);
  if (Sender=DBotMemo) then
  begin
    if g_ShopTypePage=1 then
      Sender := DShopSupplies
    else if g_ShopTypePage=2 then
      Sender := DshopStrengthen
    else if g_ShopTypePage=3 then
      Sender := DShopFriend
    else if g_ShopTypePage=4 then
      Sender := DShopCapacity
    else
      Sender := DShopDecorate;
  end;

  if (Sender = DShopDecorate) then begin
    g_ShopTypePage:=0;
    DShopDecorate.SetImgIndex(g_Wmain3Images,299);
    if CurBtn=DBotMemo then
      GotoShopPage(g_ShopPage)
    else begin
      msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 0{ShopType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
      g_ShopPage:=0;
    end;
  end;
  if Sender = DShopSupplies then begin
    g_ShopTypePage:=1;
    DShopSupplies.SetImgIndex(g_Wmain3Images,300);
    if CurBtn=DBotMemo then
      GotoShopPage(g_ShopPage)
    else begin
      msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 1{ShopType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
      g_ShopPage:=0;
    end;
  end;
  if Sender = DshopStrengthen then begin
    g_ShopTypePage:=2;
    DshopStrengthen.SetImgIndex(g_Wmain3Images,301);
    if CurBtn=DBotMemo then
      GotoShopPage(g_ShopPage)
    else begin
      msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 2{ShopType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
      g_ShopPage:=0;
    end;
  end;
  if Sender = DShopFriend then begin
    g_ShopTypePage:=3;
    DShopFriend.SetImgIndex(g_Wmain3Images,302);
    if CurBtn=DBotMemo then
      GotoShopPage(g_ShopPage)
    else begin
      msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 3{ShopType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
      g_ShopPage:=0;
    end;
  end;
  if Sender = DShopCapacity then begin
    g_ShopTypePage:=4;
    DShopCapacity.SetImgIndex(g_Wmain3Images,303);
    if CurBtn=DBotMemo then
      GotoShopPage(g_ShopPage)
    else begin
      msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 4{ShopType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
      g_ShopPage:=0;
    end;
  end;
end;

procedure TFrmDlg.DShopImg1Click(Sender: TObject; X, Y: Integer);
begin
  ShopGifFrame:=0;
  ShopSpeciallyIndex:=-1;
  ShopIndex:=TAspDButton(Sender).Tag
end;
(*******************************************************************************
  作用 : TextOut自动换行代码 (暂时未用)
  过程 : Itemstrorlist(str:string; WIDTH,HEIGH:integer);
  参数 : str为描述的字符串. 想要输出的WIDTH宽度. HEIGH想要输出的高度
*******************************************************************************)
procedure TFrmDlg.Itemstrorlist(str:string; WIDTH,HEIGH:integer);
var
   i, len, aline, n, MAXWIDTH,MAXEIGHS: integer;
    temp: string;
   loop: Boolean;
begin
  MAXWIDTH := WIDTH;
  MAXEIGHS := HEIGH;
  strorliscont := 0;
  n := 0;
  loop := TRUE;
  while loop do begin
    temp := '';
    i := 1;
    len := Length (str);
    while TRUE do begin
      if i > len then begin
       loop := FALSE;
       break;
      end;
      if byte (str[i]) >= MAXWIDTH then begin
        temp := temp + str[i];
        Inc (i);
        if i <= len then
          temp := temp + str[i]
        else begin
          loop := FALSE;
          break;
        end;
      end else temp := temp + str[i];
      aline := AspTextureFont.TextWidth (temp);
      if aline > MAXWIDTH then begin
        strorlist[n] := temp;
        strorlistidx[n] := aline;
        Inc (strorliscont);
        Inc (n);
        if n >= MAXEIGHS then begin
          loop := FALSE;
          break;
        end;
        str := Copy (str, i+1, Len-i);
        temp := '';
        break;
      end;
      Inc (i);
    end;
    if temp <> '' then begin
      if n < MAXWIDTH then begin
        strorlist[n] := temp;
        strorlistidx[n] := AspTextureFont.TextWidth (temp);
        Inc (strorliscont);
      end;
    end;
  end;
end;

// new copy by liuzhigang
procedure TFrmDlg.DShopBuyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
  DlgResult :TModalResult;
begin
  if g_ShopItemName <> '' then begin
    DlgResult := FrmDlg.DMessageDlg(Format('你确认购买 %s ？\（你可以使用%s购买，购买%s需要%d%s）', [g_ShopItemName, g_sGamePointName, g_ShopItemName, g_nShopItemGold, g_sGamePointName]),
                      [mbRetry, mbIgnore, mbCancel]);
    if DlgResult = mrRetry then begin//元宝购买
      msg := MakeDefaultMsg (aa(CM_BUYSHOPITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName));
    end else if DlgResult = mrIgnore then begin
      msg := MakeDefaultMsg (aa(CM_BUYSHOPITEM, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName));
    end;
  end;
end;

procedure TFrmDlg.DShopSpeciallyImg1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  icon,idx:integer;
  pm:pTShopInfo;
  d:TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    idx := _Max(Tag-10, 0);
    if idx < g_ShopSpeciallyItemList.Count then begin
      pm := pTShopInfo (g_ShopSpeciallyItemList[idx]);
      icon := pm.StdItem.Looks;
      if icon >= 0 then begin
        d := frmMain.GetBagItemImg(icon);
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+(120 - d.Width) div 2), SurfaceY(GTop + (31 - d.Height) div 2), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DShopSpeciallyImg1Click(Sender: TObject; X, Y: Integer);
begin
  ShopGifFrame:=0;
  ShopIndex:=-1;
  ShopSpeciallyIndex:=TAspDButton(Sender).Tag-10;
end;

//Shop 物品动画演示
procedure TFrmDlg.ShopGifInfo(dsurface: TAsphyreCanvas;dx,dy,ShopGifBegin,ShopGifEnd:integer);
var
  d:TAsphyreLockableTexture;
  img: integer;
begin
    if ShopGifEnd = 0 then begin
      d := g_WEffectImages.Images[380];
      if d <> nil then
      dsurface.Draw (dx, dy, d.ClientRect, d, true);
      Exit;
    end;
    ShopGifExplosionFrame:=ShopGifEnd-ShopGifBegin;
    if GetTickCount - ShopGifTime >  700 then
    begin
      ShopGifTime:=GetTickCount;
      inc(ShopGifFrame);
    end;

    if ShopGifFrame > ShopGifExplosionFrame then
      ShopGifFrame := 0;

      img:=ShopGifBegin+ShopGifFrame;
           d := g_WEffectImages.Images[img];
      if d <> nil then
      dsurface.Draw(dx,dy,d.ClientRect,d, False);
end;

// new copy by liuzhigang
procedure TFrmDlg.DShopPresentClick(Sender: TObject; X, Y: Integer);
var
  who: string;
  msg: TDefaultMessage;
  DlgResult :TModalResult;
begin
  if g_ShopItemName <> '' then begin
    DlgResult := FrmDlg.DMessageDlg(Format('请输入%s要赠送的人物名：\（你可以使用%s购买，购买%s需要%d%s）', [g_ShopItemName, g_sGamePointName, g_ShopItemName, g_nShopItemGold, g_sGamePointName]),
                      [mbRetry, mbIgnore, mbCancel, mbAbort]);
    who := Trim (DlgEditText);
    if who <> '' then begin
      if DlgResult = mrRetry then begin//元宝购买
        msg := MakeDefaultMsg (aa(CM_BUYSHOPITEMGIVE, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName) + '/' + EncodeString(who) + '/' +EncodeString(g_MySelf.m_sUserName));
      end else if DlgResult = mrIgnore then begin
        msg := MakeDefaultMsg (aa(CM_BUYSHOPITEMGIVE, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName) + '/' + EncodeString(who) + '/' +EncodeString(g_MySelf.m_sUserName));
      end;
    end;
  end;
end;

procedure TFrmDlg.CharacterSrankingClick(Sender: TObject; X, Y: Integer);
begin
  DWLevelOrder.Visible:=not DWLevelOrder.Visible;
  if DWLevelOrder.Visible then begin
    LevelOrderPage := 0;
    {$IF M2Version <> 2}
    nLevelOrderSortTypePage := 0;
    {$IFEND}
    LevelOrderPageChanged;
  end;
end;

procedure TFrmDlg.CharacterSrankingInitialize(Sender: TObject);
begin
  CharacterSranking.SetImgIndex (g_WMain3Images,460);  //人物排行
end;

procedure TFrmDlg.DLevelOrderCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWLevelOrder.Visible := False;
end;

procedure TFrmDlg.LevelOrderPageChanged;
var
  I: Integer;
begin
  DColonyHeroOrder.Visible := FALSE;  DWarriorOrder.Visible := FALSE;
  DWizerdOrder.Visible := FALSE;  DTaoistOrder.Visible := FALSE;
  DHeroAllOrder.Visible := FALSE;
  DWarriorHeroOrder.Visible := FALSE;
  DWizerdHeroOrder.Visible := FALSE;
  DTaoistHeroOrder.Visible := FALSE;
  DLevelOrderIndex.Visible := FALSE;
  DLevelOrderPrev.Visible := FALSE;
  DLevelOrderNext.Visible := FALSE;
  DLevelOrderLastPage.Visible := FALSE;
  DMyLevelOrder.Visible := FALSE;
  {$IF M2Version <> 2}
  DLevelOrderPrev.GLeft := 75;
  DLevelOrderNext.GLeft := 125;
  DBOrderWeapon.Visible := LevelOrderPage = 5;
  DBOrderRing.Visible := LevelOrderPage = 5;
  DBOrderDress.Visible := LevelOrderPage = 5;
  DBOrderBoots.Visible := LevelOrderPage = 5;
  DBOrderHelmet.Visible := LevelOrderPage = 5;
  DBOrderBelt.Visible := LevelOrderPage = 5;
  DBOrderNecklace.Visible := LevelOrderPage = 5;
  DBOrderMedal.Visible := LevelOrderPage = 5;
  DBOrderWristlet.Visible := LevelOrderPage = 5;
  DBOrderHat.Visible := LevelOrderPage = 5;
  DBItemLevelBelt1.Visible := LevelOrderPage = 6;
  DBItemLevelBelt2.Visible := LevelOrderPage = 6;
  DBItemLevelBelt3.Visible := LevelOrderPage = 6;
  DBItemLevelBelt4.Visible := LevelOrderPage = 6;
  DBItemLevelBelt5.Visible := LevelOrderPage = 6;
  DBItemLevelBelt6.Visible := LevelOrderPage = 6;
  DBItemLevelBelt7.Visible := LevelOrderPage = 6;
  DBItemLevelBelt8.Visible := LevelOrderPage = 6;
  DBItemLevelBelt9.Visible := LevelOrderPage = 6;
  DBItemLevelBelt10.Visible := LevelOrderPage = 6;
  if g_UserItemLevelList.Count > 0 then begin
    for I := 0 to g_UserItemLevelList.Count - 1 do begin
      if pTItemLevelSort(g_UserItemLevelList[i]) <> nil then
        Dispose(pTItemLevelSort(g_UserItemLevelList[i]));
    end;
    g_UserItemLevelList.Clear;
  end;
  {$IFEND}
  if m_PlayObjectLevelList.Count > 0 then begin   //人物等级排行
    for I := 0 to m_PlayObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_PlayObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_PlayObjectLevelList.Items[i]));
    end;
    m_PlayObjectLevelList.Clear;
  end;
  if m_WarrorObjectLevelList.Count > 0 then begin   //战士等级排行
    for I := 0 to m_WarrorObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_WarrorObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_WarrorObjectLevelList.Items[i]));
    end;
    m_WarrorObjectLevelList.Clear;
  end;
  if m_WizardObjectLevelList.Count > 0 then begin   //法师等级排行
    for I := 0 to m_WizardObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_WizardObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_WizardObjectLevelList.Items[i]));
    end;
    m_WizardObjectLevelList.Clear;
  end;
  if m_TaoistObjectLevelList.Count > 0 then begin   //道士等级排行
    for I := 0 to m_TaoistObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_TaoistObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_TaoistObjectLevelList.Items[i]));
    end;
    m_TaoistObjectLevelList.Clear;
  end;
  if m_PlayObjectMasterList.Count > 0 then begin   //道士等级排行
    for I := 0 to m_PlayObjectMasterList.Count - 1 do begin
      if pTUserLevelSort(m_PlayObjectMasterList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_PlayObjectMasterList.Items[i]));
    end;
    m_PlayObjectMasterList.Clear;
  end;
  if m_HeroObjectLevelList.Count > 0 then begin   //英雄等级排行
    for I := 0 to m_HeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_HeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_HeroObjectLevelList.Items[i]));
    end;
    m_HeroObjectLevelList.Clear;
  end;
  if m_WarrorHeroObjectLevelList.Count > 0 then begin   //英雄战士等级排行
    for I := 0 to m_WarrorHeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_WarrorHeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_WarrorHeroObjectLevelList.Items[i]));
    end;
    m_WarrorHeroObjectLevelList.Clear;
  end;
  if m_WizardHeroObjectLevelList.Count > 0 then begin   //英雄法师等级排行
    for I := 0 to m_WizardHeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_WizardHeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_WizardHeroObjectLevelList.Items[i]));
    end;
    m_WizardHeroObjectLevelList.Clear;
  end;
  if m_TaoistHeroObjectLevelList.Count > 0 then begin   //英雄道士等级排行
    for I := 0 to m_TaoistHeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_TaoistHeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_TaoistHeroObjectLevelList.Items[i]));
    end;
    m_TaoistHeroObjectLevelList.Clear;
  end;
  case LevelOrderPage of
    0: begin
      DColonyHeroOrder.Visible := TRUE;  DWarriorOrder.Visible := TRUE;
      DWizerdOrder.Visible := TRUE;  DTaoistOrder.Visible := TRUE;
    end;
    1: begin
      DHeroAllOrder.Visible := TRUE;
      DWarriorHeroOrder.Visible := TRUE;
      DWizerdHeroOrder.Visible := TRUE;
      DTaoistHeroOrder.Visible := TRUE;
    end;
    2: begin
      DLevelOrderIndex.Visible := TRUE;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
      DLevelOrderLastPage.Visible := TRUE;
      DMyLevelOrder.Visible := TRUE;
    end;
    3: begin
      DLevelOrderIndex.Visible := TRUE;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
      DLevelOrderLastPage.Visible := TRUE;
      DMyLevelOrder.Visible := TRUE;
    end;
    4: begin
      DLevelOrderIndex.Visible := TRUE;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
      DLevelOrderLastPage.Visible := TRUE;
      DMyLevelOrder.Visible := TRUE;
    end;
    {$IF M2Version <> 2}
    6: begin
      DLevelOrderPrev.GLeft := 110;
      DLevelOrderNext.GLeft := 168;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DIndividualOrderClick(Sender: TObject; X, Y: Integer);
begin
   LevelOrderPage := TAspDButton(Sender).Tag;
   LevelOrderPageChanged;
   nLevelOrderSortTypePage := 0;
end;

procedure TFrmDlg.DIndividualOrderDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
    {$IF M2Version <> 2}
      if Tag = nLevelOrderSortTypePage then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    {$ELSE}
      if TAspDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DHeroOrderClick(Sender: TObject; X, Y: Integer);
begin
   LevelOrderPage := TAspDButton(Sender).Tag;
   LevelOrderPageChanged;
   nLevelOrderSortTypePage := 1;
end;

procedure TFrmDlg.DWLevelOrderDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  function GetSortList: TList;
  begin
    Result := nil;
    case nLevelOrderSortType of
      0: begin
        case nLevelOrderType of
          1: Result := m_PlayObjectLevelList;
          2: Result := m_WarrorObjectLevelList;
          3: Result := m_WizardObjectLevelList;
          4: Result := m_TaoistObjectLevelList;
        end;
      end;
      1: begin
        case nLevelOrderType of
          1: Result := m_HeroObjectLevelList;
          2: Result := m_WarrorHeroObjectLevelList;
          3: Result := m_WizardHeroObjectLevelList;
          4: Result := m_TaoistHeroObjectLevelList;
        end;
      end;
      2: Result := m_PlayObjectMasterList;
      {$IF M2Version <> 2}
      3: Result := g_UserItemLevelList;
      {$IFEND}
    end;
  end;
var
  d: TAsphyreLockableTexture;
  I: Integer;
  UserLevelSort: pTUserLevelSort;
  HeroLevelSort: pTHeroLevelSort;
  UserMasterSort: pTUserLevelSort;
  {$IF M2Version <> 2}
  ItemLevelSort: pTItemLevelSort;
  {$IFEND}
  bbx,bby: Integer;
  List: TList;
  cColor: TColor;
  S:string;
begin
  List := GetSortList;
  with DWLevelOrder do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    case LevelOrderPage of
      2: begin
        d := g_WMain3Images.Images[423];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      3: begin
        d := g_WMain3Images.Images[424];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      4: begin
        d := g_WMain3Images.Images[425];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      {$IF M2Version <> 2}
      6: begin //装备榜
        d := g_WUI1Images.Images[1341];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      {$IFEND}
    end;
    bbx:=GLeft+20;
    bby:=GTop+120;
  end;

  cColor := clWhite;
  if (List <> nil) and (List.Count > 0) then begin
    case nLevelOrderSortType of
      0: begin
        for I:= 0 to List.Count-1 do begin
          if I = nLevelOrderIndex then
            cColor := clYellow
          else cColor := clWhite;
          if pTUserLevelSort(List[i]) <> nil then begin
            UserLevelSort := pTUserLevelSort (List[i]);
            AspTextureFont.TextOut (bbx + 35, bby + i*22, cColor, Inttostr(UserLevelSort.nIndex));
            AspTextureFont.TextOut (bbx + 95, bby + i*22, cColor, UserLevelSort.sChrName);
            AspTextureFont.TextOut (bbx + 240, bby + i*22, cColor, Inttostr(UserLevelSort.wLevel));
            {$IF M2Version <> 2}
            if UserLevelSort.nHeartLevel > 0 then // MainForm.
              AspTextureFont.TextOut (bbx + 240 + frmMain.Canvas.TextWidth(Inttostr(UserLevelSort.wLevel)), bby + i*22, clYellow, Format('+%d', [UserLevelSort.nHeartLevel]));
            {$IFEND}
          end;
        end;
      end;
      1: begin
        for I:= 0 to List.Count-1 do begin
          if I = nLevelOrderIndex then
            cColor := clYellow
          else cColor := clWhite;
          if pTHeroLevelSort(List[i]) <> nil then begin
            HeroLevelSort := pTHeroLevelSort (List[i]);
            AspTextureFont.TextOut (bbx + 18, bby + i*22, cColor, inttostr(HeroLevelSort.nIndex));
            AspTextureFont.TextOut (bbx + 50, bby + i*22, cColor, HeroLevelSort.sHeroName);
            AspTextureFont.TextOut (bbx + 145, bby + i*22, cColor, HeroLevelSort.sChrName);
            AspTextureFont.TextOut (bbx + 255, bby + i*22, cColor, inttostr(HeroLevelSort.wLevel));
          end;
        end;
      end;
      2: begin
        for I:= 0 to List.Count-1 do begin
          if I = nLevelOrderIndex then   
            cColor := clYellow
          else cColor := clWhite;
          if pTUserLevelSort(List[i]) <> nil then begin
            UserMasterSort := pTUserLevelSort(List[i]);
            AspTextureFont.TextOut (bbx + 35, bby + i*22, cColor, inttostr(UserMasterSort.nIndex));
            AspTextureFont.TextOut (bbx + 95, bby + i*22, cColor, UserMasterSort.sChrName);
            AspTextureFont.TextOut (bbx + 240, bby + i*22, cColor, inttostr(UserMasterSort.wLevel));
          end;
        end;
      end;
      {$IF M2Version <> 2}
      3: begin
        for I:=0 to List.Count - 1 do begin
          if pTItemLevelSort(List[i]) <> nil then begin
            ItemLevelSort := pTItemLevelSort(List[i]);
            AspTextureFont.TextOut (bbx + 24 - AspTextureFont.TextWidth(IntToStr(ItemLevelSort.nIndex)) div 2, bby + i*21, $008CC7EF, IntToStr(ItemLevelSort.nIndex));
            AspTextureFont.TextOut (bbx + 200 - AspTextureFont.TextWidth(ItemLevelSort.sChrName) div 2, bby + i*21, $008CC7EF, ItemLevelSort.sChrName);
            AspTextureFont.TextOut (bbx + 270 - AspTextureFont.TextWidth(IntToStr(ItemLevelSort.wLevel)) div 2, bby + i*21, $008CC7EF, IntToStr(ItemLevelSort.wLevel));
          end;
        end;
      end;
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DWLevelOrderMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
{$IFEND}
end;

procedure TFrmDlg.DWLingWUXinFaDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  OldFontSize: Byte;
  dStatFrame: Word;
const
  XinFaColor: array[0..4] of TColor = ($FF009C, clWhite, clYellow, $8C6531, clRed);
  XinFaHint: array[0..4, 0..2] of string = (
    ('紫金为帝王之象，紫金心法戾气最重。性格杀伐果断', '，十荡十决的勇气适合修炼紫金心法，紫金心法讲究', '大开大合，包罗万象。'),
    ('乙木为自然循环往生的法则，天生怀一个怜悯之心的', '人，则适合修炼乙木心法，乙木心法运行讲究生生不', '息，气息悠长，最善持久战。'),
    ('大地心法主旨沉稳，不动如山。肉体强横，老成持重', '的人最适合此类心法，大地心法的运行讲究一力降十', '会，以拙破巧，先立于不败之地。'),
    ('抽刀水更流，四两拨千斤。葵水心法讲究以柔克刚，', '劲力阴柔，伤人经脉。修习葵水心法讲究平心静气，', '后发制人，适合心态平和之人。'),
    ('阳炎天火，焚尽万物。习此心法者，功法凶狠毒辣，', '招招搏命。阳炎心法以怒火仇恨为根本，有时伤敌伤', '己，爆发力最是强劲。')
  );
  //0..4   5个对象
  //0..2   0为上面图象  1为小原点图象 2为小原点X坐标
  XinFaImages: array[0..4, 0..2] of Word = ((2151, 2040, 133), (2152, 1920, 186), (2154, 1980, 238), (2153, 2010, 296), (2150, 1950, 348));
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWLingWUXinFa do begin
    if WLib <> nil then begin
      if g_LingWuXinFa.btPage = 0 then
        if g_LingWuXinFa.boChangeXinFa then
          d := WLib.Images[FaceIndex-1]
        else d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex-3];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      with g_LingWuXinFa do begin
        frmMain.Canvas.Font.Style := [fsBold];
        AspTextureFont.TextOut(SurfaceX(GLeft)+44, SurfaceY(GTop)+155, clSilver, '龙卫信使');
        frmMain.Canvas.Font.Style := [];
        if g_LingWuXinFa.btPage = 0 then begin
          OldFontSize := frmMain.Canvas.Font.Size;
          frmMain.Canvas.Font.Size := 15;
          AspTextureFont.TextOut(SurfaceX(GLeft)+261, SurfaceY(GTop)+141, XinFaColor[btIndex], g_XinFaName[btIndex]+'心法');
          frmMain.Canvas.Font.Size := OldFontSize;
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+170, SurfaceY(GTop)+161, $88C4E8, clBlack, XinFaHint[btIndex, 0]);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+170, SurfaceY(GTop)+176, $88C4E8, clBlack, XinFaHint[btIndex, 1]);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+170, SurfaceY(GTop)+191, $88C4E8, clBlack, XinFaHint[btIndex, 2]);
          d := WLib.Images[XinFaImages[btIndex, 0]];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          end;
          if GetTickCount - dwStartTimeTick > 100 then begin
            dwStartTimeTick := GetTickCount;
            Inc(btCurrentFrame);
            if btCurrentFrame > 19 then btCurrentFrame := 0;
          end;
          d := WLib.Images[XinFaImages[btIndex, 1]+btCurrentFrame];
          if d <> nil then begin
            dsurface.DrawBlend(SurfaceX(GLeft)+XinFaImages[btIndex, 2], SurfaceY(GTop)+80, d.ClientRect,d);
          end;
          if boChangeXinFa then begin
            AspTextureFont.BoldTextOut(SurfaceX(GLeft)+253, SurfaceY(GTop)+207, clLime, clBlack, '当前心法种类：' + g_XinFaName[btGetM2Type]);
          end else begin
            if sKeySelCaption = '' then
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+190, SurfaceY(GTop)+229, $88C4E8, clBlack, '心法命名2-6字')
            else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+190, SurfaceY(GTop)+229, $88C4E8, clBlack, sKeySelCaption);
          end;
        end else begin
          case btHelpPage of
            0: begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+64, clWhite, clBlack, '所谓龙卫心法，不过是神龙子嗣修炼到一定程度后，');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+78, clWhite, clBlack, '通过激发神龙血脉，获得的能力的大幅提升。龙卫心');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+92, clWhite, clBlack, '法因人而异，名字也不同，因为能够修炼该心法之人');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+106, clWhite, clBlack, '，均成为神龙帝国龙卫封号，所以统称为龙卫心法。');
            end;
            1: begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+64, clWhite, clBlack, '人法地，地法天，天法道，道法自然。领悟招式也是');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+78, clWhite, clBlack, '如此，无论是在战场搏杀，还是在密室修炼，又或是');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+92, clWhite, clBlack, '在野外冒险，只要心法等级达到一定程度，均有机会');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+106, clWhite, clBlack, '在使用招式时领悟进入下一重境界。普通招式境界共');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+120, clWhite, clBlack, '分九重，每领悟一重都将强大几分。心法跨入三阶龙');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+134, clWhite, clBlack, '卫境界更能激发神龙血脉，施展更强威力。');
            end;
            2: begin
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+64, clWhite, clBlack, '龙卫心法是驱动一切上乘武工的基础，能够激发神龙');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+78, clWhite, clBlack, '血脉的怒火，瞬间进入龙卫境界。心法等级提升将带');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+92, clWhite, clBlack, '来独特的神圣攻防属性加成，更能帮助你自行领悟强');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+106, clWhite, clBlack, '大的招式。每个人的性格经脉不同，会产生不同的行');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+120, clWhite, clBlack, '气方式，相生相克均是自然规律，心法提升终将带你');
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+134, clWhite, clBlack, '踏入龙卫境界，领悟神龙血脉中隐藏的神技实力。');
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWLingWUXinFaInitialize(Sender: TObject);
begin
  DWLingWUXinFa.SetImgIndex(g_WUI1Images, 2134);
end;

procedure TFrmDlg.DWLingWuXinFaKeyInitialize(Sender: TObject);
begin
  DWLingWuXinFaKey.SetImgIndex(g_WUI1Images, 2321); 
end;

procedure TFrmDlg.DColonyHeroOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  LevelOrderPage := 2;
  LevelOrderPageChanged;
  nLevelOrderTypePage := TAspDButton(Sender).Tag;
  if Sender = DColonyHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 1{nType}, 0, frmMain.m_nSendMsgCount);
  if Sender = DWarriorOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 2{nType}, 0, frmMain.m_nSendMsgCount);
  if Sender = DWizerdOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 3{nType}, 0, frmMain.m_nSendMsgCount);
  if Sender = DTaoistOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 4{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DHeroAllOrderClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
 msg: TDefaultMessage;
{$IFEND}
begin
  {$IF M2Version <> 2}
  LevelOrderPage := 3;
  LevelOrderPageChanged;
  nLevelOrderTypePage := TAspDButton(Sender).Tag;
  if g_boOpenHero then begin
    if Sender = DHeroAllOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 1{nType}, 0, frmMain.m_nSendMsgCount);
    if Sender = DWarriorHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 2{nType}, 0, frmMain.m_nSendMsgCount);
    if Sender = DWizerdHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 3{nType}, 0, frmMain.m_nSendMsgCount);
    if Sender = DTaoistHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 4{nType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
  end;
  {$IFEND}
end;

procedure TFrmDlg.DMasterOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  LevelOrderPage := 4;
  LevelOrderPageChanged;           
  nLevelOrderSortTypePage := 2;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 2{nSortType}, 0{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DBLevelOrderUseItemClick(Sender: TObject; X, Y: Integer);
begin
  with Sender as TAspDButton do begin
    if Sender = DBLevelOrderUseItem then
      LevelOrderPage := 5
    else LevelOrderPage := 7;
    LevelOrderPageChanged;
    nLevelOrderSortTypePage := Tag;
  end;
end;

procedure TFrmDlg.DMyLevelOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  nLevelOrderIndex := 0;
  LevelOrderPageChanged;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), -1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DLevelOrderIndexClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  LevelOrderPageChanged;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DLevelOrderLastPageClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  LevelOrderPageChanged;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), nLevelOrderTypePageCount-1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DLevelOrderNextClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if Sender = DLevelOrderNext then begin
    if nLevelOrderPage < nLevelOrderTypePageCount-1 then begin
      LevelOrderPageChanged;
      msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), nLevelOrderPage+1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
    end;
  end else begin
    if nLevelOrderPage > 0 then begin
      LevelOrderPageChanged;
      msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), nLevelOrderPage-1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
    end;
  end;
end;

procedure TFrmDlg.DBottomMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  {g_nUserSelectName := 0; //20080302
  DScreen.ClearHint; }
end;
{******************************************************************************}
//宝箱系统
procedure TFrmDlg.DBoxsDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  Shape :integer;
  BackImages: Integer; //宝箱背景图
begin
  with DBoxs do begin
    if g_boNewBoxs = 1 then BackImages := 210 else BackImages := 510;
    if DBoxs.FaceIndex = BackImages then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
    if g_boPutBoxsKey then begin
      if GetTickCount - g_dwBoxsTick > 200 then begin
        g_dwBoxsTick := GetTickCount;
        Inc(g_nBoxsImg);
        if g_nBoxsImg > 6 then begin
          g_nBoxsImg := 0;
          g_boPutBoxsKey := False;
          if g_boNewBoxs = 1 then begin
            DBoxs.SetImgIndex(g_WMain2Images, 210);
          end else begin
            DBoxs.SetImgIndex(g_WMain3Images, 510);
          end;
          if g_BoxsIsFill <> 3 then begin //新宝箱全部物品更新 不重新调整窗口位置
            if g_boNewBoxs = 1 then begin
              DBoxs.GLeft := 450;
              DBoxs.GTop  := 100;
            end else begin
              DBoxs.GLeft := 332;
              DBoxs.GTop  := 192;
            end;
          end;
          if g_boNewBoxs = 1 then
            d := g_WMain2Images.Images[210]
          else
            d := g_WMain3Images.Images[510];
          if d <> nil then  
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          ShowBoxsGird(True, g_boNewBoxs); //显示宝箱格
          if g_boNewBoxs = 1 then begin  //新宝箱
            DBNewHelpBtn.Visible := True;
            DCheckAutoOpenBoxs.Visible := True;
            DBoxsTautology.SetImgIndex(g_WMain2Images, 215);
            DBoxsTautology.GTop := 232;
            DBoxsTautology.GLeft := 65;
            DBoxsTautology.Visible := True;
          end else begin //老宝箱
            DBoxsTautology.SetImgIndex(g_WMain3Images, 511);
            DBoxsTautology.GTop := 175;
            DBoxsTautology.GLeft := 77;
            DBoxsTautology.Visible := True;
          end;
        end;
      end;
    end;

    if DBoxsBelt1.Visible then Exit;
    case g_EatingItem.ClientItem.S.Shape of
      1: Shape := 520;
      2: Shape := 540;
      3: Shape := 560;
      4: Shape := 580;
      5: Shape := 130;
      else Shape := 520;
    end;
    if Shape <> 130 then begin
      DBoxs.SetImgIndex(g_WMain3Images, Shape);
      d := g_WMain3Images.Images[Shape+g_nBoxsImg];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
      d := g_WMain3Images.Images[Shape+7+g_nBoxsImg];
      if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft), SurfaceY(GTop), d);
    end else begin
      DBoxs.SetImgIndex(g_WMain2Images, Shape);
      d := g_WMain2Images.Images[Shape+g_nBoxsImg];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
      d := g_WMain2Images.Images[Shape+7+g_nBoxsImg];
      if d <> nil then
        dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d);
    end;
  end;
end;

procedure TFrmDlg.DBoxsClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
  butt: TAspDButton;
begin
  if g_boJNBox then Exit;
  if g_boNewBoxs = 1 then butt := DBNewHelpBtn else butt := DBoxsTautology;
  if not butt.Visible then begin
    if (not g_boItemMoving) and (g_MovingItem.Item.ClientItem.S.Name = '') and (not g_boPutBoxsKey) then  begin
      AddItemBag (g_EatingItem);
      DBoxS.Visible := False;
      ShowBoxsGird(False, g_boNewBoxs); //显示宝箱格
      g_BoxsShowPosition := -1;
      Exit;
    end;
    if g_boItemMoving then begin
      if g_MovingItem.Item.ClientItem.S.Shape = g_EatingItem.ClientItem.S.AniCount then begin
        msg := MakeDefaultMsg(aa(CM_OPENBOXS, frmMain.TempCertification), g_EatingItem.ClientItem.MakeIndex, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket(EncodeMessage(msg) + EncodeString(Inttostr(g_MovingItem.Item.ClientItem.MakeIndex)));
        g_BoxsTempKeyItems := g_MovingItem.Item;  //把钥匙存放到临时物品     失败则返回
        g_boItemMoving := False;
        g_MovingItem.Item.ClientItem.S.Name := '';  //把钥匙变没
        g_MovingItem.Item.ClientItem.S.Shape := 0;  //把钥匙变没
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowBoxsGird(Show:Boolean; IsNewBoxs: Byte);
begin
  if Show and (IsNewBoxs = 1) then begin
    DBoxsBelt1.GLeft := 31;
    DBoxsBelt1.GTop  := 88;
    DBoxsBelt2.GLeft := 83;
    DBoxsBelt2.GTop  := 88;
    DBoxsBelt3.GLeft := 134;
    DBoxsBelt3.GTop  := 88;
    DBoxsBelt4.GLeft := 31;
    DBoxsBelt4.GTop  := 136;
    DBoxsBelt5.GLeft := 83;
    DBoxsBelt5.GTop  := 137;
    DBoxsBelt6.GLeft := 134;
    DBoxsBelt6.GTop  := 136;
    DBoxsBelt7.GLeft := 31;
    DBoxsBelt7.GTop  := 184;
    DBoxsBelt8.GLeft := 83;
    DBoxsBelt8.GTop  := 184;
    DBoxsBelt9.GLeft := 134;
    DBoxsBelt9.GTop  := 184;
  end else begin
    DBoxsBelt1.GLeft := 30;
    DBoxsBelt1.GTop  := 28;
    DBoxsBelt2.GLeft := 80;
    DBoxsBelt2.GTop  := 28;
    DBoxsBelt3.GLeft := 130;
    DBoxsBelt3.GTop  := 28;
    DBoxsBelt4.GLeft := 30;
    DBoxsBelt4.GTop  := 76;
    DBoxsBelt5.GLeft := 80;
    DBoxsBelt5.GTop  := 76;
    DBoxsBelt6.GLeft := 130;
    DBoxsBelt6.GTop  := 76;
    DBoxsBelt7.GLeft := 30;
    DBoxsBelt7.GTop  := 124;
    DBoxsBelt8.GLeft := 80;
    DBoxsBelt8.GTop  := 124;
    DBoxsBelt9.GLeft := 130;
    DBoxsBelt9.GTop  := 124;
  end;
  DBoxsNewBelt1.Visible := False;
  DBoxsNewBelt2.Visible := False;
  DBoxsNewBelt3.Visible := False;
  if g_boNewBoxs = 1 then begin
    DBoxsNewBelt1.Visible := Show;
    DBoxsNewBelt2.Visible := Show;
    DBoxsNewBelt3.Visible := Show;
  end;
  if g_boNewBoxs <> 2 then begin
    DBoxsBelt1.Visible := Show;
    DBoxsBelt2.Visible := Show;
    DBoxsBelt3.Visible := Show;
    DBoxsBelt4.Visible := Show;
    DBoxsBelt5.Visible := Show;
    DBoxsBelt6.Visible := Show;
    DBoxsBelt7.Visible := Show;
    DBoxsBelt8.Visible := Show;
    DBoxsBelt9.Visible := Show;
  end else begin
    DJLBoxBelt1.Visible := Show;
    DJLBoxBelt2.Visible := Show;
    DJLBoxBelt3.Visible := Show;
    DJLBoxBelt4.Visible := Show;
    DJLBoxBelt5.Visible := Show;
    DJLBoxBelt6.Visible := Show;
    DJLBoxBelt7.Visible := Show;
    DJLBoxBelt8.Visible := Show;
  end;
end;

procedure TFrmDlg.DBoxsBelt5DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  Butt:TAspDButton;
  Sel: Integer;
begin
  BoxsRunning(dsurface);//宝箱转动
  Butt:=TAspDButton(Sender);
  Sel := 0;
  idx := 0;
  if Sender = DBoxsBelt1 then Sel := 0;
  if Sender = DBoxsBelt2 then Sel := 1;
  if Sender = DBoxsBelt3 then Sel := 2;
  if Sender = DBoxsBelt4 then Sel := 7;
  if Sender = DBoxsBelt5 then Sel := 8;
  if Sender = DBoxsBelt6 then Sel := 3;
  if Sender = DBoxsBelt7 then Sel := 6;
  if Sender = DBoxsBelt8 then Sel := 5;
  if Sender = DBoxsBelt9 then Sel := 4;
  if Sender = DBoxsNewBelt1 then Sel := 9;
  if Sender = DBoxsNewBelt2 then Sel := 10;
  if Sender = DBoxsNewBelt3 then Sel := 11;
  with Butt do begin
    if g_boNewBoxs = 0 then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if Sender = DBoxsBelt5 then begin
        if not g_boJNBox then //金牛宝箱
          d := g_Wmain3Images.Images[513]
        else d := g_WmainImages.Images[595];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft-5), SurfaceY(GTop-5), d.ClientRect, d, true);
      end;
    end;
    if (g_BoxsIsFill = 0) and (g_BoxsShowPosition = Butt.Tag) then BoxsFlash(Butt, dsurface);
    if g_BoxSItems[Sel].ClientItem.s.Name <> '' then begin
      idx := g_BoxSItems[Sel].ClientItem.s.Looks;
      if idx >= 0 then begin
        if g_BoxsShowPosition = Butt.Tag then begin
          d := frmMain.GetBagItemImg(idx);
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                         SurfaceY(GTop + (GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
        end else begin
          d := frmMain.GetBagItemImg(idx);
          if d <> nil then begin
            if Sel in [9..11] then
              if (g_BoxsIsFill = 1) and (g_nFilledGetItmesID = Butt.Tag) then begin
                dsurface.DrawAlpha(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2), Rect(0,0,d.Width, d.Height), d, 150);
                BoxsFillFlash(Butt, dsurface);  //显示宝箱填充动画
              end else begin
                dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE)
              end
            else begin
              dsurface.DrawAlpha(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2), Rect(0,0,d.Width, d.Height), d, 150);
            end;
          end;
        end;
      end;
      if g_BoxsIsFill = 3 then BoxsFillFlash(Butt, dsurface);
    end;
    if (g_BoxsShowPosition = Butt.Tag) and (g_BoxsIsFill = 2) then BoxsFillFlash(Butt, dsurface); //下面填充
  end;
end;

procedure TFrmDlg.DBoxsBelt5MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  Sel: Integer;
  Butt:TAspDButton;
begin
  Sel := -1;
  Butt:=TAspDButton(Sender);
  if Sender = DBoxsBelt1 then Sel := 0;
  if Sender = DBoxsBelt2 then Sel := 1;
  if Sender = DBoxsBelt3 then Sel := 2;
  if Sender = DBoxsBelt4 then Sel := 7;
  if Sender = DBoxsBelt5 then Sel := 8;
  if Sender = DBoxsBelt6 then Sel := 3;
  if Sender = DBoxsBelt7 then Sel := 6;
  if Sender = DBoxsBelt8 then Sel := 5;
  if Sender = DBoxsBelt9 then Sel := 4;
  if Sender = DBoxsNewBelt1 then Sel := 9;
  if Sender = DBoxsNewBelt2 then Sel := 10;
  if Sender = DBoxsNewBelt3 then Sel := 11;
  if (g_BoxsItems[sel].ClientItem.s.Name = '经验') or (g_BoxsItems[sel].ClientItem.s.Name = '经验(大量)') or (g_BoxsItems[sel].ClientItem.s.Name = '经验(海量)') or
     (g_BoxsItems[sel].ClientItem.s.Name = '声望') or
     (g_BoxsItems[sel].ClientItem.s.Name = '内功') or (g_BoxsItems[sel].ClientItem.s.Name = '内功(大量)') or (g_BoxsItems[sel].ClientItem.s.Name = '内功(海量)') or
     (g_BoxSItems[Sel].ClientItem.s.Name = g_sGameGird) or (g_BoxSItems[Sel].ClientItem.s.Name = Format('%s(大量)',[g_sGameGird{'灵符'}])) or (g_BoxSItems[Sel].ClientItem.s.Name = Format('%s(海量)',[g_sGameGird{'灵符'}])) or
     (g_BoxsItems[sel].ClientItem.s.Name = g_sGameDiaMond) or (not (g_BoxsItems[sel].ClientItem.s.StdMode in [5..6,10..11,15..16,19..24,26,30,52..54,62..64])) then begin
    iname := g_BoxsItems[sel].ClientItem.s.Name + '\' + '数量: '+IntToStr(g_BoxsItems[sel].ClientItem.s.Price);
    if (g_BoxsShowPosition = Butt.Tag) and not g_boBoxsLockGetItems then
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname+ '\' + '(双击获得)', clYellow, FALSE)
    else
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname, clWhite, FALSE);
    g_MouseItem.ClientItem.S.Name := '';
  end else begin
    if g_BoxsItems[sel].ClientItem.s.Name <> '' then begin
      g_MouseItem := g_BoxsItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable ,1);
      if (g_BoxsShowPosition = Butt.Tag) and (not g_boBoxsLockGetItems) then
        DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname + d1 + '\' + d2 + '\' + d3 + '\' + '(双击获得)', clYellow, FALSE)
      else
        DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname + d1 + '\' + d2 + '\' + d3 , clWhite, FALSE);
      g_MouseItem.ClientItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

//宝箱物品闪烁函数
procedure TFrmDlg.BoxsFlash(Button: TAspDButton;dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if GetTickCount - g_dwBoxsFlashTick > 100 then begin
    g_dwBoxsFlashTick := GetTickCount;
    Inc(g_BoxsFlashImg);
    if g_BoxsFlashImg > 2 then g_BoxsFlashImg := 0;
  end;
  if g_BoxsFlashImg = 2 then Exit;
  d := g_WMain3Images.Images[g_BoxsbsImg+g_BoxsFlashImg];
  if d <> nil then
    dsurface.DrawBlend(Button.SurfaceX(Button.GLeft-10),Button.SurfaceY(Button.GTop-11), d);
end;

procedure TFrmDlg.BoxsFillFlash(Button: TAspDButton;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  msg: TDefaultMessage;
begin
  if g_BoxsIsFill <> 0 then begin
    case g_BoxsIsFill of
      1: begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 100 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 10 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsItems[g_nPlayGetItmesID] := g_BoxsItems[g_nFilledGetItmesID];
            g_BoxsItems[g_nFilledGetItmesID].ClientItem.s.Name := '';
            g_BoxsItems[g_nFilledGetItmesID].ClientItem.MakeIndex := 0;
            g_BoxsIsFill := 2;
          end;
        end;
        if g_BoxsFilleFlashImg = 10 then Exit;
        d := g_WMain2Images.Images[240+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(Button.SurfaceX(Button.GLeft-20),Button.SurfaceY(Button.GTop-20), d);
      end;
      2: begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 100 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 10 then begin
            g_BoxsFilleFlashImg := 0;
            if g_nFilledGetItmesID = 0 then begin //最后一个填充动画
               msg := MakeDefaultMsg(aa(CM_UPDADEBOXSITMES, frmMain.TempCertification), 0{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
               FrmMain.SendSocket(EncodeMessage(msg));
            end;
            if not DCheckAutoOpenBoxs.Checked then begin
              DBoxsNewClose.Visible := True;
            end;
            DBoxsTautology.SetImgIndex(g_WMain2Images, 225);
            DBoxsTautology.Visible := True;
            if DCheckAutoOpenBoxs.Checked then begin
              msg := MakeDefaultMsg(aa(CM_ROTATIONBOX, frmMain.TempCertification), 1{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
              FrmMain.SendSocket(EncodeMessage(msg));
            end;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsFilleFlashImg = 10 then Exit;
        d := g_WMain2Images.Images[230+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(Button.SurfaceX(Button.GLeft-20),Button.SurfaceY(Button.GTop-20), d);
      end;
      3: begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 7 then begin
            g_BoxsFilleFlashImg := 0;
            if FrmDlg.DCheckAutoOpenBoxs.Checked then begin
              msg := MakeDefaultMsg(aa(CM_ROTATIONBOX, frmMain.TempCertification), 1{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
              FrmMain.SendSocket(EncodeMessage(msg));
            end;
            g_BoxsIsFill := 0;
          end;
        end;
        if (g_BoxsFilleFlashImg = 8) or (g_BoxsIsFill = 0) then Exit;
        d := g_WMain2Images.Images[250+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(Button.SurfaceX(Button.GLeft-20),Button.SurfaceY(Button.GTop-20), d);
      end;
    end;
  end;
end;

//宝箱物品随机取图
procedure TFrmDlg.BoxsRandomImg;
var
    vList:   TList;
    I,   J:   Integer;
    vData:   Integer;
begin
  Randomize;   //播下随机种子
  vList := TList.Create;
  try
    for I:=600 to 617 do vList.Add(Pointer(I));//得到一副顺序排列的扑克
    for I:=1 to 8 do begin  //取8个数
      J := Random(vList.Count);  //从余下的扑克中随机选一张
      vData := Integer(vList[J]);
      if vData= 601 then Continue;
      if vData= 603 then Continue;
      if vData= 605 then Continue;
      if vData= 607 then Continue;
      if vData= 609 then Continue;
      if vData= 611 then Continue;
      if vData= 613 then Continue;
      if vData= 615 then Continue;
      if vData= 617 then Continue;
      vList.Delete(J); //抽取完后从列表中删除
      g_BoxsbsImg := vData;
      break;
    end;
  finally
    vList.Free;
  end;
end;

procedure TFrmDlg.DBoxsTautologyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  BoxsRandomImg; //变换颜色
  if not g_boBoxsShowPosition then begin
    if g_boNewBoxs = 1 then begin//新宝箱转动模式
      msg := MakeDefaultMsg (aa(CM_ROTATIONBOX, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
    end else //老宝箱转动模式
      msg := MakeDefaultMsg (aa(CM_MOVEBOXS, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket(EncodeMessage(msg));
    if g_BoxsMoveDegree < 1 then begin
      if g_boNewBoxs = 0 then begin
        g_boBoxsShowPosition := True;
        g_BoxsCircleNum := 0; //圈数设为0
        g_boBoxsMiddleItems := False; //显示中间物品
        g_BoxsFirstMove := True;
        Inc(g_BoxsMoveDegree);
      end;
    end;
    //end;
  end;
end;
//宝箱转动
procedure TFrmDlg.BoxsRunning(dsurface: TAsphyreCanvas);
var
  msg: TDefaultMessage;
  dwBoxsShowPositionTime: Word;
begin
  if g_boBoxsShowPosition then begin
    if (g_BoxsCircleNum > 0) and (g_BoxsCircleNum < 9) then dwBoxsShowPositionTime := 50 else dwBoxsShowPositionTime := 400;//g_BoxsShowPositionTime := 50 else g_BoxsShowPositionTime := 400;
    if GetTickCount - g_BoxsShowPositionTick > dwBoxsShowPositionTime then begin//g_BoxsShowPositionTime then begin
     g_BoxsShowPositionTick := GetTickCount;
     Inc(g_BoxsShowPosition);
      MyPlaySound (SelectBoxFlash_ground); //点宝箱声音
      if g_BoxsShowPosition > 7 then begin
        g_BoxsShowPosition := 0;
        Inc(g_BoxsCircleNum); //转动圈数
      end;
      if g_BoxsCircleNum = 9 then begin
        if g_BoxSItems[g_BoxsShowPosition].ClientItem.MakeIndex = g_BoxsMakeIndex then begin
          g_boBoxsShowPosition := False;
          if DCheckAutoOpenBoxs.Checked then begin
            msg := MakeDefaultMsg(aa(CM_GETBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
            FrmMain.SendSocket(EncodeMessage(msg));
            g_BoxSItems[g_BoxsShowPosition].ClientItem.s.Name := ''; //隐藏物品
            g_boBoxsLockGetItems := True;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBoxsTautologyMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if g_boNewBoxs = 0 then
  DScreen.ShowHint(DBoxsTautology.SurfaceX(DBoxsTautology.GLeft)-62, DBoxsTautology.SurfaceY(DBoxsTautology.GTop)-16, '启动乾坤挪移换取一件外圈物品', clWhite, FALSE);
end;

procedure TFrmDlg.DBPrevTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
    SetImgIndex(g_WUI1Images, 681);
{$IFEND}
end;

procedure TFrmDlg.DBProMySelfDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2+1, SurfaceY(GTop) + 4, $004AA6EF, clBlack, Hint);
      end else begin
        if MouseMoveing then begin
          if Tag = m_btProPage then
            d := WLib.Images[FaceIndex + 1]
          else d := WLib.Images[FaceIndex];
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $00ADD7EF, clBlack, TAspDButton(Sender).Hint);
          end;
        end else begin
          if Tag = m_btProPage then
            d := WLib.Images[FaceIndex + 1]
          else d := WLib.Images[FaceIndex];
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $008CC7EF, clBlack, TAspDButton(Sender).Hint);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBQJPracticeCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
    if m_boQJPracticeHero then begin
      if g_HeroSelf <> nil then
        AddHeroItemBag(g_QJPracticeItems);
      g_QJPracticeItems.ClientItem.s.Name := '';
    end else begin
      if g_MySelf <> nil then
        AddItemBag(g_QJPracticeItems);
      g_QJPracticeItems.ClientItem.s.Name := '';
    end;
  end;
  DWQJPractice.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBQJPracticeCloseInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DBQJPracticeClose.SetImgIndex(g_WMain2Images, 148);
  {$IFEND}
end;

procedure TFrmDlg.DBQJPracticePage1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  OldFontStyle: TFontStyles;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      if Caption <> '' then begin
        if Downed then begin
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+3, SurfaceY(GTop)+6, $00ADD7EF, clBlack, Caption, Font.Style);
        end else begin
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+2, SurfaceY(GTop)+5, $00ADD7EF, clBlack, Caption, Font.Style);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBQJPracticePage1Initialize(Sender: TObject);
begin
  DBQJPracticePage1.SetImgIndex(g_WMainImages, 1178);
end;

procedure TFrmDlg.DBQJPracticeStartClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
    if m_boQJPracticeHero then begin
      if g_HeroSelf <> nil then begin
        if not g_boQJHeroDZXY99 and (m_btQjPracticeSkillLevel = 64) then
          frmMain.SendOpenupSkill95(g_QJPracticeItems.ClientItem.MakeIndex, 1)
        else frmMain.SendQJPractice(g_QJPracticeItems.ClientItem.MakeIndex, 0, 1);
      end;
    end else begin
      if g_MySelf <> nil then begin
        if not g_boQJDZXY99 and (m_btQjPracticeSkillLevel = 64) then
          frmMain.SendOpenupSkill95(g_QJPracticeItems.ClientItem.MakeIndex, 0)
        else frmMain.SendQJPractice(g_QJPracticeItems.ClientItem.MakeIndex, 0, 0);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBQJPracticeStartInitialize(Sender: TObject);
begin
  DBQJPracticeStart.SetImgIndex(g_WMainImages, 1173);
end;

procedure TFrmDlg.DBRefineDrumCloseBtnClick(Sender: TObject; X, Y: Integer);
var
  I : Integer;
begin
  DWRefineDrum.Visible:=False;
  for I := 0 to 5 do
  if g_RefineDrumItem[I].ClientItem.s.Name <> '' then begin
    AddItemBag(g_RefineDrumItem[I]);
    g_RefineDrumItem[I].ClientItem.s.Name := '';
  end;
  // 发送消息给服务端，有物品则放到包裹里面
end;

procedure TFrmDlg.DBRefineDrumCloseBtnDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
    if WLib <> nil then begin   //20080701
      if not Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
           dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
   end;
end;

procedure TFrmDlg.DBRefineDrumCloseBtnInitialize(Sender: TObject);
begin
	with Sender as TAspDButton do
    SetImgIndex(g_WMain3Images,233);
end;

procedure TFrmDlg.DBRefineDrumOKBtnClick(Sender: TObject; X, Y: Integer);
var msg: TDefaultMessage;
    I,btCount:Integer;
    Str2:string;
    MakeIndexs : array [0..9] of Integer;
begin
  btCount := 0;
  for I := 0 to g_RefineDrumCount-1 do
  begin
    if (g_RefineDrumItemName[I+1]<>'') and (g_RefineDrumItem[I].ClientItem.s.Name='') then
    begin
      DMessageDlg('第 '+IntToStr(I+1)+' 位置缺少物品:'+g_RefineDrumItemName[I+1]+'!',[mbOK]);
      Exit;
    end;
    if g_RefineDrumItem[I].ClientItem.s.Name<>'' then
    begin
      MakeIndexs[btCount] := g_RefineDrumItem[I].ClientItem.MakeIndex;
      Inc(btCount);
    end;
  end;
  msg := MakeDefaultMsg (aa(CM_REFINEARMYDRUM, frmMain.TempCertification), btCount, 0, 0, 0, frmMain.m_nSendMsgCount);// 发送淬炼军鼓到服务端
  FrmMain.SendSocket(EncodeMessage (msg)+Encodestring(g_RefineDrumItemName[0]+#10+ EncodeBuffer(PChar(@MakeIndexs), btCount * 4)));//20071231
end;

procedure TFrmDlg.DBRefineDrumOKBtnDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
    if WLib <> nil then begin   //20080701
      if not Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         AspTextureFont.TextOut(SurfaceX(GLeft)+18,SurfaceY(GTop)+11,$00B4E2FE,'升级',[fsBold]); // $00C0E9FE
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
           dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         AspTextureFont.TextOut(SurfaceX(GLeft)+19,SurfaceY(GTop)+12,$00B4E2FE,'升级',[fsBold]);
      end;
    end;
   end;
end;

procedure TFrmDlg.DBRefineDrumOKBtnInitialize(Sender: TObject);
begin
	with Sender as TAspDButton do
    SetImgIndex(g_WMainImages,1421);
end;

procedure TFrmDlg.DBRefuseCRYClick(Sender: TObject; X, Y: Integer);
begin
  if g_RefuseCRY then begin
      DBRefuseCRY.SetImgIndex(g_WMain3Images,283);
      g_RefuseCRY:=false;
      FrmMain.SendSay ('@禁止喊话');
  end else begin
      DBRefuseCRY.SetImgIndex(g_WMain3Images,282);
      g_RefuseCRY:=true;
      FrmMain.SendSay ('@禁止喊话');
  end;
end;

procedure TFrmDlg.DBRefuseCRYInitialize(Sender: TObject);
begin
  DBRefuseCRY.SetImgIndex(g_WMain3Images,282);    //拒绝所有喊话信息
end;

procedure TFrmDlg.DBRefuseguildClick(Sender: TObject; X, Y: Integer);
begin
  if g_Refuseguild then begin
      DBRefuseguild.SetImgIndex(g_WMain3Images,287);
      DBRefuseguild.GLeft:=175;
      DBRefuseguild.GTop:=182;
      g_Refuseguild:=false;
      FrmMain.SendSay ('@拒绝行会聊天');
  end else begin
      DBRefuseguild.SetImgIndex(g_WMain3Images,286);
      DBRefuseguild.GLeft:=175;
      DBRefuseguild.GTop:=182;
      g_Refuseguild:=true;
      FrmMain.SendSay ('@拒绝行会聊天');
  end;
end;

procedure TFrmDlg.DBRefuseguildInitialize(Sender: TObject);
begin
  DBRefuseguild.SetImgIndex(g_WMain3Images,286);  //拒绝行会聊天信息
end;

procedure TFrmDlg.DBRefusePublicChatClick(Sender: TObject; X, Y: Integer);
begin
  g_boOwnerMsg := not g_boOwnerMsg;
  if g_boOwnerMsg then begin
    DBRefusePublicChat.SetImgIndex(g_WMain3Images,281);
    DScreen.AddChatBoardString('[禁止接收公聊]', GetRGB(219), clWhite);
  end else begin
    DBRefusePublicChat.SetImgIndex(g_WMain3Images,280);
    DScreen.AddChatBoardString('[允许接收公聊]', GetRGB(219), clWhite);
  end;
end;

procedure TFrmDlg.DBRefusePublicChatInitialize(Sender: TObject);
begin
  DBRefusePublicChat.SetImgIndex(g_WMain3Images,280); //拒绝所有公聊信息
end;

procedure TFrmDlg.InitOtherParm;
var Str:string;
begin
  {if (RefuseWhisperLevel>=0) and (RefuseWhisperLevel<=9998) then
  begin
    DBRefuseWHISPER.SetImgIndex(g_WMain3Images,285); //灰色
    DBRefuseWHISPER.GLeft:=175;
    DBRefuseWHISPER.GTop:=162;
    g_RefuseWHISPER:=true;
    if RefuseWhisperLevel=0 then
      Str:='[拒绝与所有玩家私聊]' else Str:='[拒绝与'+IntToStr(RefuseWhisperLevel)+'级以下玩家私聊]';
    DScreen.AddChatBoardString(Str, GetRGB(161), GetRGB(133));
    //FrmMain.SendSay ('@拒绝私聊');
  end else
  begin
    DBRefuseWHISPER.SetImgIndex(g_WMain3Images,284);
    DBRefuseWHISPER.GLeft:=175;
    DBRefuseWHISPER.GTop:=162;
    g_RefuseWHISPER:=false;
    RefuseWhisperLevel:=9999;
    DScreen.AddChatBoardString('[允许私聊]', GetRGB(161), GetRGB(133));
    //FrmMain.SendSay ('@拒绝私聊');
  end;}
end;

procedure TFrmDlg.DBRefuseWHISPERClick(Sender: TObject; X, Y: Integer);
var Value:Integer;
    Str:string;
begin
  if not g_RefuseWHISPER then
  begin
    EdDlgEdit.Text:='0';
    if DMessageDlg ('请输入拒绝私聊的玩家等级上限，默认0级为拒绝所有私聊信息!', [mbOK, mbAbort, mbCancel],False)<>mrOK then Exit;
    begin
      try
        Value:=StrToInt(DlgEditText);
        if (Value>=9999) or (Value<0) then Abort;
        RefuseWhisperLevel:=Value;
      except
        DMessageDlg ('请输入正确的等级上限!', [mbOK]);
        Exit;
      end;
    end;

    if (RefuseWhisperLevel>=0) and (RefuseWhisperLevel<=9998) then
    begin
      DBRefuseWHISPER.SetImgIndex(g_WMain3Images,285); //灰色
      DBRefuseWHISPER.GLeft:=175;
      DBRefuseWHISPER.GTop:=162;
      g_RefuseWHISPER:=true;
      if RefuseWhisperLevel=0 then
      Str:='[拒绝与所有玩家私聊]' else Str:='[拒绝与'+IntToStr(RefuseWhisperLevel)+'级以下玩家私聊]';
      DScreen.AddChatBoardString(Str, GetRGB(161), GetRGB(133));
      //FrmMain.SendSay ('@拒绝私聊');
    end else
    begin
      DBRefuseWHISPER.SetImgIndex(g_WMain3Images,284);
      DBRefuseWHISPER.GLeft:=175;
      DBRefuseWHISPER.GTop:=162;
      g_RefuseWHISPER:=false;
      RefuseWhisperLevel:=9999;
      DScreen.AddChatBoardString('[允许私聊]', GetRGB(221),  GetRGB(255));
      //FrmMain.SendSay ('@拒绝私聊');
    end;
  end else
  begin
    DBRefuseWHISPER.SetImgIndex(g_WMain3Images,284);
    DBRefuseWHISPER.GLeft:=175;
    DBRefuseWHISPER.GTop:=162;
    g_RefuseWHISPER:=false;
    RefuseWhisperLevel:=9999;
    DScreen.AddChatBoardString('[允许私聊]', GetRGB(221), GetRGB(255));
  end;
end;

procedure TFrmDlg.DBRefuseWHISPERInitialize(Sender: TObject);
begin
  DBRefuseWHISPER.SetImgIndex(g_WMain3Images,284);   //拒绝所有私聊信息
end;

procedure TFrmDlg.DBoxsBelt1DblClick(Sender: TObject);
var
  msg: TDefaultMessage;
  Sel: Byte;
begin
  if not g_boBoxsShowPosition then begin //转盘停止中。。
    Sel := 0;
    if Sender = DBoxsBelt1 then Sel := 0;
    if Sender = DBoxsBelt2 then Sel := 1;
    if Sender = DBoxsBelt3 then Sel := 2;
    if Sender = DBoxsBelt4 then Sel := 7;
    if Sender = DBoxsBelt5 then Sel := 8;
    if Sender = DBoxsBelt6 then Sel := 3;
    if Sender = DBoxsBelt7 then Sel := 6;
    if Sender = DBoxsBelt8 then Sel := 5;
    if Sender = DBoxsBelt9 then Sel := 4;
    if Sel <> 8 then begin //不为中间物品
      if g_BoxsShowPosition = Sel then begin
        if g_BoxSItems[Sel].ClientItem.s.Name <> '' then begin
          if not g_boBoxsLockGetItems then begin
            msg := MakeDefaultMsg(aa(CM_GETBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
            FrmMain.SendSocket(EncodeMessage(msg));
            if g_boNewBoxs = 0 then begin
              DBoxS.Visible := False; //宝箱 界面隐藏
              g_boJNBox := False;
            end else begin
              g_BoxSItems[Sel].ClientItem.s.Name := ''; //隐藏物品
              g_boBoxsLockGetItems := True;
            end;
          end;
        end;
      end;
    end else begin //中间物品
      if g_BoxsMoveDegree = 0 then begin
        if g_BoxSItems[Sel].ClientItem.s.Name <> '' then begin
          msg := MakeDefaultMsg(aa(CM_GETBOXS, frmMain.TempCertification), 5, 0, 0, 0, frmMain.m_nSendMsgCount);
          FrmMain.SendSocket(EncodeMessage(msg));
          DBoxS.Visible := False;   //宝箱 界面隐藏
          if g_boNewBoxs =0 then g_boJNBox := False;
        end;
      end;
    end;
  end;
end;

{******************************************************************************}
procedure TFrmDlg.DLieDragonDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  d:=g_WUiMainImages.Images[1];
  if d<>nil then begin
     dsurface.Draw(DLieDragon.SurfaceX(DLieDragon.GLeft), DLieDragon.SurfaceY(DLieDragon.GTop), d.ClientRect, d, TRUE);
  end;
  case g_LieDragonPage of
    0: begin
      d:=g_WUiMainImages.Images[8];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    1: begin
      d:=g_WUiMainImages.Images[9];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    2: begin
      d:=g_WUiMainImages.Images[10];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    3: begin
      d:=g_WUiMainImages.Images[11];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    4: begin
      d:=g_WUiMainImages.Images[12];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DLieDragonInitialize(Sender: TObject);
begin
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DLieDragonCloseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if TAspDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[2];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[3];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLieDragonCloseClick(Sender: TObject; X, Y: Integer);
begin
  DLieDragon.Visible := False;
end;

procedure TFrmDlg.DLieDragonNextPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if TAspDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[4];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[5];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLieDragonPrevPageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if TAspDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[6];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[7];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLieDragonNextPageClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DLieDragonNextPage then begin
     Inc (g_LieDragonPage);
     if g_LieDragonPage > 0 then DLieDragonPrevPage.Visible := True;
     if g_LieDragonPage >= 4 then begin
       DLieDragonNextPage.Visible := False;
       DGoToLieDragon.Visible := True;
     end;
  end else begin
     Dec (g_LieDragonPage);
     if g_LieDragonPage < 4 then begin
       DLieDragonNextPage.Visible := True;
       DGoToLieDragon.Visible := False;
       if g_LieDragonPage <= 0 then DLieDragonPrevPage.Visible := False;
     end;
  end;
end;

procedure TFrmDlg.DGoToLieDragonDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if TAspDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[13];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[14];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;     
end;

procedure TFrmDlg.DLieDragonNpcDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  case g_LieDragonNpcIndex of
    1: begin
      d:=g_WUiMainImages.Images[15];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    2: begin
      d:=g_WUiMainImages.Images[16];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    3: begin
      d:=g_WUiMainImages.Images[17];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    4: begin
      d:=g_WUiMainImages.Images[18];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    5: begin
      d:=g_WUiMainImages.Images[19];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DLieDragonNpcCloseClick(Sender: TObject; X, Y: Integer);
begin
  DLieDragonNpc.Visible := False;
end;

procedure TFrmDlg.DGoToLieDragonClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendMerchantDlgSelect (g_nCurMerchant, '@goHero1');
  DLieDragon.Visible := False;
end;

procedure TFrmDlg.DItemsUpButMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ShowHint(DItemsUpBut.SurfaceX(DItemsUpBut.GLeft), DItemsUpBut.SurfaceY(DItemsUpBut.GTop + DItemsUpBut.GHeight), '升级装备', clWhite, FALSE);
end;

procedure TFrmDlg.DItemsUpButClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DItemsUpBut then
    DItemsUp.Visible := True
  else DItemsUp.Visible := False;
end;

procedure TFrmDlg.DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DCIDSpleenDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
{  d:=FrmMain.UiDXImageList.Items.Find('vigourbar1').PatternSurfaces[0];
  if d<>nil then begin
     dsurface.Draw (DCIDSpleen.SurfaceX(DCIDSpleen.Left), DCIDSpleen.SurfaceY(DCIDSpleen.Top), d.ClientRect, d, TRUE);
  end;   }
end;

procedure TFrmDlg.DBQJPracticeItemClick(Sender: TObject; X, Y: Integer);
{$IF M2Version =1}
var
  temp: TClientEffecItem;
  function GetMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_MySelf <> nil then begin
      for I:=0 to g_MagicList.Count - 1 do begin
        pm := PTClientMagic(g_MagicList[I]);
        if pm <>nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
  function GetHeroMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_HeroSelf <> nil then begin
      for I:=0 to g_HeroMagicList.Count - 1 do begin
        pm := PTClientMagic(g_HeroMagicList[I]);
        if pm <>nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
begin
{$IF M2Version =1}
  with Sender as TAspDButton do begin
    if m_boQJPracticeHero then begin
      if not g_boHeroItemMoving then begin
        if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
           ItemClickSound (g_QJPracticeItems.ClientItem.s);
           if g_MovingHeroItem.Item.ClientItem.S.Name <> '' then Exit;
           g_boHeroItemMoving := TRUE;
           g_MovingHeroItem.Item := g_QJPracticeItems;
           g_QJPracticeItems.ClientItem.s.Name := '';
        end;
      end else begin
        if (g_MovingHeroItem.Item.ClientItem.S.Name <> '') and (g_MovingHeroItem.Index >= 0) and
          ((((GetHeroMagicLevel < 64) or ((GetHeroMagicLevel < 99) and g_boQJHeroDZXY99)) and (g_MovingHeroItem.Item.ClientItem.S.StdMode = 17) and (g_MovingHeroItem.Item.ClientItem.S.Shape = 238)) or (((GetHeroMagicLevel = 64) and not g_boQJHeroDZXY99) and (g_MovingHeroItem.Item.ClientItem.S.StdMode = 44) and (g_MovingHeroItem.Item.ClientItem.S.Shape = 248))) then begin
          ItemClickSound (g_MovingHeroItem.Item.ClientItem.S);
          if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
            temp := g_QJPracticeItems;
            g_QJPracticeItems := g_MovingHeroItem.Item;
            g_MovingHeroItem.Item := temp
          end else begin
            g_QJPracticeItems := g_MovingHeroItem.Item;
            g_MovingHeroItem.Item.ClientItem.S.name := '';
            g_boHeroItemMoving := FALSE;
          end;
        end;
      end;
    end else begin
      if not g_boItemMoving then begin
        if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
           ItemClickSound (g_QJPracticeItems.ClientItem.s);
           if g_MovingItem.Item.ClientItem.S.Name <> '' then Exit;
           g_boItemMoving := TRUE;
           g_MovingItem.Item := g_QJPracticeItems;
           g_QJPracticeItems.ClientItem.s.Name := '';
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) and
          ((((GetMagicLevel < 64) or ((GetMagicLevel < 99) and g_boQJDZXY99)) and (g_MovingItem.Item.ClientItem.S.StdMode = 17) and (g_MovingItem.Item.ClientItem.S.Shape = 238)) or (((GetMagicLevel = 64) and not g_boQJDZXY99) and (g_MovingItem.Item.ClientItem.S.StdMode = 44) and (g_MovingItem.Item.ClientItem.S.Shape = 248))) then begin
          ItemClickSound (g_MovingItem.Item.ClientItem.S);
          if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
            temp := g_QJPracticeItems;
            g_QJPracticeItems := g_MovingItem.Item;
            g_MovingItem.Item := temp;
          end else begin
            g_QJPracticeItems := g_MovingItem.Item;
            g_MovingItem.Item.ClientItem.S.name := '';
            g_boItemMoving := FALSE;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBQJPracticeItemDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  Idx: Integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
  {$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if g_QJPracticeItems.ClientItem.s.Name <> '' then begin
      idx := g_QJPracticeItems.ClientItem.s.Looks;
      if idx >= 0 then begin
          d := frmMain.GetBagItemImg(idx);
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                         SurfaceY(GTop + (GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
          if g_QJPracticeItems.ClientItem.s.StdMode = 17 then
          AspTextureFont.TextOut (SurfaceX(GLeft+35-AspTextureFont.TextWidth(IntToStr(g_QJPracticeItems.ClientItem.Dura))), SurfaceY(GTop+20), clWhite, InttoStr(g_QJPracticeItems.ClientItem.Dura));
      end;
    end else if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
      dsurface.FillRectAlpha(ClientRect, $0046B5FF, 90);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBQJFurnaceCloseClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if not g_boQJFurnaceGet then DWQJFurnace.Visible := False;
  {$IFEND}
end;

procedure TFrmDlg.DBQJFurnaceCloseInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DBQJFurnaceClose.SetImgIndex(g_WMain2Images, 148);
  {$IFEND}
end;

procedure TFrmDlg.DBQJFurnaceStartClick(Sender: TObject; X, Y: Integer);
  {$IF M2Version = 1}
var
  msg: TDefaultMessage;
  {$IFEND}
begin
  {$IF M2Version = 1}
  if g_boQJFurnaceGet then begin
    msg := MakeDefaultMsg (aa(CM_CLENTGETLIANQIPRACTICE, FrmMain.TempCertification), g_btQJFurnaceType, 0, 0, 0, FrmMain.m_nSendMsgCount);
  end else begin
    msg := MakeDefaultMsg (aa(CM_LIANQIPRACTICE, FrmMain.TempCertification), g_btQJFurnaceType, 0, 0, 0, FrmMain.m_nSendMsgCount);
  end;
  FrmMain.SendSocket (EncodeMessage (msg));//20071231
  if g_btQJFurnaceType = 1 then begin //强化练气
    with FrmDlg do begin
      DBQJFurnaceStart.SetImgIndex(g_WMainImages, 1312);
      DBQJFurnaceStart.GLeft := 210;
      DBQJFurnaceStart.GTop := 100;
    end;
  end else begin
    with FrmDlg do begin
      DBQJFurnaceStart.SetImgIndex(g_WMainImages, 1292);
      DBQJFurnaceStart.GLeft := 220;
      DBQJFurnaceStart.GTop := 100;
    end;
  end;
  g_btQJFurnacePosition := 0;
  g_boQJFurnaceGet := False;
  {$IFEND}
end;

procedure TFrmDlg.DButton4DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
//var
 // d: TAsphyreLockableTexture;
 // rc:Trect;
begin
  {d := FrmMain.UiDXImageList.Items.Find('vigourbar2').PatternSurfaces[0];
  rc := d.ClientRect;
  if d <> nil then begin
     rc.Top := Round(rc.Bottom / nMaxDragonPoint * (nMaxDragonPoint - m_nDragonPoint));
     dsurface.Draw (DCIDSpleen.Left + rc.Left, DCIDSpleen.Top+DBottom.top+rc.Top, rc, d, FALSE);
  end;
  if g_boHintDragonPoint then begin  //20080401
    with dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);
      BoldTextOut(dsurface,86- TextWidth(IntToStr(m_nDragonPoint)+'/'+IntToStr(nMaxDragonPoint)) div 2, g_D3DConfig.wScreenHeight - 120, clWhite, clBlack,IntToStr(m_nDragonPoint)+'/'+IntToStr(nMaxDragonPoint));
      Release;
    end;
  end;  }//20080619
end;

//物品发光变换函数 20080223
procedure TFrmDlg.ItemLightTimeImg();
begin
  if GetTickCount - ItemLightTimeTick > 200 then begin
    ItemLightTimeTick := GetTickCount;
    Inc(ItemLightImgIdx);
    if ItemLightImgIdx > 5 then ItemLightImgIdx := 0;
  end;
end;

//金牛物品发光         0为金牛首饰发光， 1为金牛头盔发光  2为虎威套装  3主宰首饰发光
function TFrmDlg.StateItemEffect(btType: Byte): Integer;
begin
  Result := -1;
  case btType of
    0: begin
      if GetTickCount - JNItemLightTimeTick > 100 then begin
        JNItemLightTimeTick := GetTickCount;
        Inc(JNItemLightImgIdx);
        if JNItemLightImgIdx > 8 then JNItemLightImgIdx := 0;
      end;
      Result := JNItemLightImgIdx;
    end;
    1: begin
      if GetTickCount - JNHelmetLightTimeTick > 200 then begin
        JNHelmetLightTimeTick := GetTickCount;
        Inc(JNHelmetLightImgIdx);
        if JNHelmetLightImgIdx > 10 then JNHelmetLightImgIdx := 0;
      end;
      Result := JNHelmetLightImgIdx;
    end;
    2: begin
      if GetTickCount - HWItemLightTimeTick > 100 then begin
        HWItemLightTimeTick := GetTickCount;
        Inc(HWItemLightImgIdx);
        if HWItemLightImgIdx > 30 then HWItemLightImgIdx := 0;
      end;
      Result := HWItemLightImgIdx;
    end;
    3: begin
      if GetTickCount - ZZItemLightTimeTick > 100 then begin
        ZZItemLightTimeTick := GetTickCount;
        Inc(ZZItemLightImgIdx);
        if ZZItemLightImgIdx > 10 then ZZItemLightImgIdx := 0;
      end;
      Result := ZZItemLightImgIdx;
    end;
  end;
end;

procedure TFrmDlg.DHelpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if TAspDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TAspDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DGameGirdExchangeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if TAspDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[23];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[24];
    if d<>nil then
      with TAspDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

// new copy by liuzhigang
procedure TFrmDlg.DGameGirdExchangeClick(Sender: TObject; X, Y: Integer);
var
  int, i: Integer;
  msg: TDefaultMessage;
  DlgResult :TModalResult;
  Num: Integer;
begin
  DlgResult := DMessageDlg (Format('请输入需要兑换的%s数量(1-1000)：\（100%s可以兑换一个%s）', [g_sGameGird, g_sGamePointName, g_sGameGird]), [mbRetry, mbIgnore, mbCancel, mbAbort]);
  Num := StrToIntDef(DlgEditText, -1);
  if (Num > 0) and (Num < 1001) then begin
    if DlgResult = mrRetry then begin//元宝购买
      if g_MySelf.m_nGameGold > 0 then begin
        FrmMain.SendBuyGameGird(Num, 0);
      end else DMessageDlg ('你没有足够的'+g_sGameGoldName+'。', [mbOk]);
    end else if DlgResult = mrIgnore then begin
      if g_MySelf.m_nGamePoint > 0 then begin
        FrmMain.SendBuyGameGird(Num, 1);
      end else DMessageDlg ('你没有足够的'+g_sGamePointName+'。', [mbOk]);
    end;
  end else begin
    DMessageDlg ('输入的'+g_sGameGird+'数量不正确。', [mbOk]);
  end;
end;

//得到排行榜点击的索引  20080304
procedure TFrmDlg.DWLevelOrderClick(Sender: TObject; X, Y: Integer);
function GetSortList: TList;
  begin
    Result := nil;
    case nLevelOrderSortType of
      0: begin
          case nLevelOrderType of
            1: Result := m_PlayObjectLevelList;
            2: Result := m_WarrorObjectLevelList;
            3: Result := m_WizardObjectLevelList;
            4: Result := m_TaoistObjectLevelList;
          end;
        end;
      1: begin
          case nLevelOrderType of
            1: Result := m_HeroObjectLevelList;
            2: Result := m_WarrorHeroObjectLevelList;
            3: Result := m_WizardHeroObjectLevelList;
            4: Result := m_TaoistHeroObjectLevelList;
          end;
        end;
      2: begin
          Result := m_PlayObjectMasterList;
        end;
    end;
  end;
var
  lx,ly: Integer;
  List: TList;
  idx: Integer;
  UserLevelSort: pTUserLevelSort;
  HeroLevelSort: pTHeroLevelSort;
  UserMasterSort: pTUserLevelSort;
begin
   lx := DWLevelOrder.LocalX (X) - DWLevelOrder.GLeft;
   ly := DWLevelOrder.LocalY (Y) - DWLevelOrder.GTop;
   List := GetSortList;
   case nLevelOrderSortType of
     0: begin
        if (lx >= 24) and (lx <= 304) and (ly >= 118) and (ly <= 330){ 2008.02.13} then begin
          idx := (ly-118) div 22;
          if List <> nil then begin
            if idx < List.Count then begin
               PlaySound (s_glass_button_click);
               nLevelOrderIndex := idx;
               UserLevelSort := pTUserLevelSort (List[idx]);
               PlayScene.EdChat.Visible := TRUE;
               PlayScene.EdChat.Text := '/'+ UserLevelSort.sChrName+' ';
               PlayScene.EdChat.SetFocus;
               SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
               PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
            end;
          end;
        end;
     end;
     1: begin
        if (lx >= 24) and (lx <= 304) and (ly >= 118) and (ly <= 330){ 2008.02.13} then begin
          idx := (ly-118) div 22 + 0;
          if idx < List.Count then begin
             PlaySound (s_glass_button_click);
             nLevelOrderIndex := idx;
             HeroLevelSort := pTHeroLevelSort (List[idx]);
             PlayScene.EdChat.Visible := TRUE;
             PlayScene.EdChat.Text := '/'+ HeroLevelSort.sChrName+' ';
             PlayScene.EdChat.SetFocus;
             SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
             PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
     end;
     2: begin
        if (lx >= 24) and (lx <= 304) and (ly >= 118) and (ly <= 330){ 2008.02.13} then begin
          idx := (ly-118) div 22 + 0;
          if idx < List.Count then begin
             PlaySound (s_glass_button_click);
             nLevelOrderIndex := idx;
             UserMasterSort := pTUserLevelSort(List[idx]);
             PlayScene.EdChat.Visible := TRUE;
             PlayScene.EdChat.Text := '/'+ UserMasterSort.sChrName+' ';
             PlayScene.EdChat.SetFocus;
             SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
             PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
     end;
   end; //case
end;
{******************************************************************************}
//元宝寄售显示窗口 20080316
procedure TFrmDlg.ShowShopSellOffDlg;
begin
   DWSEllOff.Visible := TRUE;
   DMenuDlg.Visible := FALSE;
   DItemBag.Visible := TRUE;
   LastestClickTime := GetTickCount;
   g_sSellPriceStr := '';
   g_SellOffName := '';
   g_SellOffGameGold := 0;
   g_SellOffGameDiaMond := 0;
end;
procedure TFrmDlg.DSellOffCloseClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.SendCancelSellOffItem;
   g_SellOffName := '';//寄售对方名字
   g_SellOffGameGold := 0; //寄售的元宝数量
   g_SellOffGameDiaMond := 0;
   DWSEllOff.Visible := False;
   ArrangeItembag;
end;

procedure TFrmDlg.DSellOffItemGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..8] then begin
    g_MouseItem := g_SellOffItems[idx];
    with DSellOffItemGrid do
      ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth, SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DSellOffItemGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DSellOffItemGrid.ColCount;
  if idx in [0..8] then begin
    if g_SellOffItems[idx].ClientItem.s.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_SellOffItems[idx].ClientItem.s.Looks);
      if d <> nil then begin
        with DSellOffItemGrid do begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                        SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                        d.ClientRect,
                        d, TRUE);
          if g_SellOffItems[idx].ClientItem.s.StdMode = 17 then begin
             AspTextureFont.TextOut (SurfaceX(Rect.Left+35-AspTextureFont.TextWidth(IntToStr(g_SellOffItems[idx].ClientItem.Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_SellOffItems[idx].ClientItem.Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DSellOffItemGridGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
   mi, idx, i: integer;
   int: Byte;
begin
  idx := ACol + ARow * DSellOffItemGrid.ColCount;  //索引
  if not g_boItemMoving then begin   //如果不是移动物品  那么选择这里的物品
     if idx in [0..8] then begin
        if g_SellOffItems[idx].ClientItem.s.Name <> '' then begin
           g_boItemMoving := TRUE;
           g_MovingItem.Index := -idx - 30;
           g_MovingItem.Item := g_SellOffItems[idx];
           g_SellOffItems[idx].ClientItem.s.Name := '';
           ItemClickSound (g_MovingItem.Item.ClientItem.S);
        end;
     end else begin
        if idx = 9 then begin
            int := 0;
            DMessageDlg ('请输入'+g_sGameDiaMond+'数量，在0-9999之间', [mbOk, mbAbort]);
            if DlgEditText = '' then int := 1;
            for i:=1 to length(DlgEditText) do
              if (DlgEditText[i] <'0') or ( DlgEditText[i] > '9') then int := 2;
            if length(DlgEditText) > 4 then int := 3;
            case int of
              0:g_SellOffGameDiaMond := StrToInt(DlgEditText);
              1:DMessageDlg ('内容不能为空！', [mbOk]);
              2:DMessageDlg ('输入的'+g_sGameDiaMond+'错误', [mbOk]);
              3:DMessageDlg (g_sGameDiaMond + '数量不能超过4位', [mbOk]);
            end;
        end;
     end;
  end else begin
     mi := g_MovingItem.Index;
     if idx in [0..8] then begin
       if (mi >= 0) or (mi <= -30) and (mi > -40) then begin
          ItemClickSound (g_MovingItem.Item.ClientItem.S);
          g_boItemMoving := FALSE;
          if mi >= 0 then begin
             g_SellOffDlgItem := g_MovingItem.Item;
             FrmMain.SendAddSellOffItem (g_SellOffDlgItem);  //发消息
             //g_dwDealActionTick := GetTickCount + 4000;      //这个限制 到时候加上
          end else
             AddSellOffItem (g_MovingItem.Item);
          g_MovingItem.Item.ClientItem.S.name := '';
       end;
     end;
  end;
  ArrangeItemBag;
end;

procedure TFrmDlg.DWSellOffDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with DWSellOff do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
      AspTextureFont.TextOut (GLeft + 174 - AspTextureFont.TextWidth('0') div 2, GTop + 64, clWhite, IntToStr(g_SellOffGameDiaMond));
      AspTextureFont.TextOut (GLeft + 158, GTop + 78, clWhite, g_sGameDiaMond);
  end;
end;

procedure TFrmDlg.DSellOffOkClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
  FrmMain.SendSellOffEnd;
  if g_boItemMoving then begin
     mi := g_MovingItem.Index;
     if (mi <= -30) and (mi > -40) then begin
        AddSellOffItem (g_MovingItem.Item);
        g_boItemMoving := FALSE;
        g_MovingItem.Item.ClientItem.S.name := '';
     end;
  end;
end;

procedure TFrmDlg.DSellOffCancelClick(Sender: TObject; X, Y: Integer);
begin
   //if GetTickCount > g_dwDealActionTick then begin
      //CloseDealDlg;
      FrmMain.SendCancelSellOffItem;
      g_SellOffName := '';//寄售对方名字
      g_SellOffGameGold := 0; //寄售的元宝数量
      g_SellOffGameDiaMond := 0;
      ArrangeItembag;
   //end;
end;

//显示寄售列表界面 20080317
procedure TFrmDlg.ShowSellOffListDlg;
begin
   MenuIndex := -1;
   DMerchantDlg.GLeft := 0;
   DMerchantDlg.GTop := 0;
   DMerchantDlg.Visible := TRUE;

   DWSellOffList.GLeft := 0;
   DWSellOffList.GTop  := 176;
   DWSellOffList.Visible := TRUE;

   DSellOffListCancel.Visible := False;
   DSellOffBuyCancel.Visible := False;
   DSellOffBuy.Visible := False;

   DItemBag.GLeft := 440;
   DItemBag.GTop := -25;
   DItemBag.Visible := TRUE;

   LastestClickTime := GetTickCount;
end;
{******************************************************************************}
procedure TFrmDlg.DEditSellOffNameClick(Sender: TObject; X, Y: Integer);
var
  int: Byte;
begin
    int := 0;
    DMessageDlg ('请输入对方的名字', [mbOk, mbAbort]);
    if DlgEditText = '' then int := 1;
    if length(DlgEditText) > 14 then int := 2;
    case int of
      0:g_SellOffName := DlgEditText;
      1:DMessageDlg ('内容不能为空！', [mbOk]);
      2:DMessageDlg ('输入的对方名字错误', [mbOk]);
    end;
end;

procedure TFrmDlg.DEditSellOffNumClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
  int: Byte;
begin
    int := 0;
    DMessageDlg ('请输入'+g_sGameGoldName+'数量,最多8位数。', [mbOk, mbAbort]);
    if DlgEditText = '' then int := 1;
    for i:=1 to length(DlgEditText) do
      if (DlgEditText[i] <'0') or ( DlgEditText[i] > '9') then int := 2;
    if length(DlgEditText) > 8 then int := 3;
    case int of
      0:g_SellOffGameGold := StrToInt(DlgEditText);
      1:DMessageDlg ('内容不能为空！', [mbOk]);
      2:DMessageDlg ('输入的' + g_sGameGoldName + '错误', [mbOk]);
      3:DMessageDlg (g_sGameGoldName + '数量不能超过8位', [mbOk]);
    end;
end;

procedure TFrmDlg.DEditSellOffNameDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
  with DEditSellOffName do begin
        AspTextureFont.TextOut (SurfaceX(GLeft+1), SurfaceY(GTop+3), clWhite, g_SellOffName);
  end;
end;

procedure TFrmDlg.DEditSellOffNumDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
  with DEditSellOffNum do begin
        AspTextureFont.TextOut (SurfaceX(GLeft+1), SurfaceY(GTop+3), clWhite, IntToStr(g_SellOffGameGold));
  end;
end;

procedure TFrmDlg.DSellOffListColseClick(Sender: TObject; X, Y: Integer);
begin
  DWSellOffList.Visible := False;
end;

procedure TFrmDlg.DWSellOffListDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   str: string;
   Color: TColor;
begin
  with DWSellOffList do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFont.TextOut (GLeft + 18, GTop + 12, clWhite, '交易明细');
    AspTextureFont.TextOut (GLeft + 180, GTop + 12, clWhite, '物品列表');
    AspTextureFont.TextOut (GLeft + 18, GTop + 32, clWhite, '卖方角色：');
    AspTextureFont.TextOut (GLeft + 18, GTop + 32 + 20 * 1, clWhite, '买方角色：');
    AspTextureFont.TextOut (GLeft + 18, GTop + 32 + 20 * 2, clWhite, '元宝数量：');
    case g_SellOffInfo.nSellGold of
          0..9: Color := clWhite;
        10..99: Color := clYellow;
      100..999: Color := clAqua;
    else Color := clFuchsia;
    end;
    AspTextureFont.TextOut (GLeft + 78, GTop + 32 + 20 * 2, Color, IntToStr(g_SellOffInfo.nSellGold), [fsBold]);
    AspTextureFont.TextOut (GLeft + 18, GTop + 32 + 20 * 3, Color, '提交日期：');
    AspTextureFont.TextOut (GLeft + 78, GTop + 32 + 20 * 3, Color, DateToStr(g_SellOffInfo.dSellDateTime));
    AspTextureFont.TextOut (GLeft + 18, GTop + 32 + 20 * 4, Color, '交易状态：');
    case g_SellOffInfo.N of
      0: str := '正常';
      2: str := '完成';
      3: str := '对方取消收购';
    end;
    AspTextureFont.TextOut (GLeft + 78, GTop + 32 + 20 * 4, Color, str);
    AspTextureFont.TextOut (GLeft + 78, GTop + 32, clLime, g_SellOffInfo.sDealCharName);
    AspTextureFont.TextOut (GLeft + 78, GTop + 32 + 20, clLime, g_SellOffInfo.sBuyCharName);
  end;
end;

procedure TFrmDlg.DSellOffItem0DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  Color:TColor;
begin
  if Sender = DSellOffItem0 then begin
    if g_SellOffInfo.UseItems[0].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[0].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem0 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 0 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[0].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem1 then begin
    if g_SellOffInfo.UseItems[1].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[1].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem1 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 1 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[1].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem2 then begin
    if g_SellOffInfo.UseItems[2].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[2].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem2 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 2 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[2].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem3 then begin
    if g_SellOffInfo.UseItems[3].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[3].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem3 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 3 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[3].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem4 then begin
    if g_SellOffInfo.UseItems[4].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[4].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem4 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 4 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[4].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem5 then begin
    if g_SellOffInfo.UseItems[5].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[5].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem5 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 5 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[5].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem6 then begin
    if g_SellOffInfo.UseItems[6].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[6].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem6 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 6 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[6].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem7 then begin
    if g_SellOffInfo.UseItems[7].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[7].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem7 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 7 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[7].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem8 then begin
    if g_SellOffInfo.UseItems[8].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[8].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem8 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 8 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[8].ClientItem.s.Name);
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem9 then begin
    if g_SellOffInfo.UseItems[9].ClientItem.s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[9].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem9 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          if g_SellOffItemIndex = 9 then Color := clRed else
            Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Color, g_SellOffInfo.UseItems[9].ClientItem.s.Name);
        end;
      end;
    end;
  end; 
end;

procedure TFrmDlg.DSellOffItem0Click(Sender: TObject; X, Y: Integer);
var
  iname: string;
  sel: integer;
  Butt:TAspDButton;
begin
   g_SellOffItemIndex := TAspDButton(Sender).Tag;
    sel := -1;
   Butt:=TAspDButton(Sender);
   if Sender = DSellOffItem0 then sel := 0;
   if Sender = DSellOffItem1 then sel := 1;
   if Sender = DSellOffItem2 then sel := 2;
   if Sender = DSellOffItem3 then sel := 3;
   if Sender = DSellOffItem4 then sel := 4;
   if Sender = DSellOffItem5 then sel := 5;
   if Sender = DSellOffItem6 then sel := 6;
   if Sender = DSellOffItem7 then sel := 7;
   if Sender = DSellOffItem8 then sel := 8;
   if Sender = DSellOffItem9 then sel := 9;

   if (g_SellOffInfo.UseItems[sel].ClientItem.Dura = High(Word)) and (g_SellOffInfo.UseItems[sel].ClientItem.s.DuraMax = High(Word))
      and (Pos(g_sGameDiaMond,g_SellOffInfo.UseItems[sel].ClientItem.s.Name ) > 0)
      and (g_SellOffInfo.UseItems[sel].ClientItem.s.Price > 0)
      and (g_SellOffInfo.UseItems[sel].ClientItem.s.Looks = High(Word))then begin
      iname := g_sGameDiaMond + ' 数量 '+IntToStr(g_SellOffInfo.UseItems[sel].ClientItem.s.Price) + ' 颗';
      with Butt as TAspDButton do
        DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft) + 115, Butt.SurfaceY(Butt.GTop), iname, clWhite, FALSE);
        g_MouseItem.ClientItem.S.Name := '';
   end else begin
      //原为注释掉 显示人物身上带的物品信息
      g_MouseItem := g_SellOffInfo.UseItems[sel];
      with Butt as TAspDButton do
        ShowMouseItemInfo(SurfaceX(Butt.GLeft) + 115, SurfaceY(Butt.GTop), '', 1, False);
   end;
end;

procedure TFrmDlg.DSellOffListCancelClick(Sender: TObject; X, Y: Integer);
begin
      FrmMain.SendCancelMySellOffIteming;
      ArrangeItembag;
      DWSellOffList.Visible := False;
      FillChar (g_SellOffInfo, sizeof(TClientDealOffInfo), #0); //清空寄售列表物品 20080318
end;

procedure TFrmDlg.DSellOffBuyCancelClick(Sender: TObject; X, Y: Integer);
begin
      FrmMain.SendSellOffBuyCancel;
      DWSellOffList.Visible := False;
      FillChar (g_SellOffInfo, sizeof(TClientDealOffInfo), #0); //清空寄售列表物品 20080318
end;

procedure TFrmDlg.DSellOffBuyClick(Sender: TObject; X, Y: Integer);
begin         
      FrmMain.SendSellOffBuy;
end;

procedure TFrmDlg.DWGameGoldMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  g_MouseItem.ClientItem.S.Name := '元宝信息';
  g_MouseItem.ClientItem.MakeIndex := 3000;
  g_MouseItem.ClientItem.Dura := 3000;
  g_MouseItem.ClientItem.DuraMax := 3000;
end;

//获得新小地图号  20080324
function TFrmDlg.GetMiniMapNum(num:Integer): TAsphyreLockableTexture;
begin
  case num of
    10301: Result := g_WUiMainImages.Images[20];
    10302: Result := g_WUiMainImages.Images[25];
    10303: Result := g_WUiMainImages.Images[26];
    10304: Result := g_WUiMainImages.Images[27];
    10306: Result := g_WUiMainImages.Images[28];
    10307: Result := g_WUiMainImages.Images[32];
    10308: Result := g_WUiMainImages.Images[33];
    10309: Result := g_WUiMainImages.Images[34];
    10310: Result := g_WUiMainImages.Images[35];
    10311: Result := g_WUiMainImages.Images[36];
    10312: Result := g_WUiMainImages.Images[37];
    10313: Result := g_WUiMainImages.Images[38];
    10314: Result := g_WUiMainImages.Images[39];
    10315: Result := g_WUiMainImages.Images[40];
    10316: Result := g_WUiMainImages.Images[41];
    10317: Result := g_WUiMainImages.Images[42];
    10318: Result := g_WUiMainImages.Images[43];
    10319: Result := g_WUiMainImages.Images[44];
    10320: Result := g_WUiMainImages.Images[45];
    10321: Result := g_WUiMainImages.Images[46];
    10322: Result := g_WUiMainImages.Images[47];
    10323: Result := g_WUiMainImages.Images[48];
    10324: Result := g_WUiMainImages.Images[49];
    10325: Result := g_WUiMainImages.Images[50];
    10326: Result := g_WUiMainImages.Images[51];
    10327: Result := g_WUiMainImages.Images[52];
    10328: Result := g_WUiMainImages.Images[53];
    10329: Result := g_WUiMainImages.Images[54];
    10330: Result := g_WUiMainImages.Images[55];
    10402: Result := g_WUiMainImages.Images[56];
    13021: Result := g_WUiMainImages.Images[57];
    13022: Result := g_WUiMainImages.Images[58];
    13023: Result := g_WUiMainImages.Images[59];
    10331: Result := g_WUiMainImages.Images[60];
  else Result := nil;
  end;
end;



procedure TFrmDlg.DSelectChrMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DCIDSpleenMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
 // g_boHintDragonPoint := True;
end;

procedure TFrmDlg.DUserState1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  g_boSelectText := False;
end;

procedure TFrmDlg.DHeroIconMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
  {$IF M2Version=1}
  function GetTransferOK(): string;
  begin
    if g_HeroSelf.m_Abil.MaxTransferValue > 0 then begin
      Result := '\斗转星移：' + IntToStr(g_HeroSelf.m_Abil.TransferValue) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxTransferValue);
    end else Result := '';
  end;
  {$IFEND}
begin
  if g_Heroself = nil then Exit;
  if g_HeroSelf.m_Abil.MaxExp > 0 then
    DScreen.ShowHint(DHeroIcon.SurfaceX(DHeroIcon.GLeft) + DheroIcon.GWidth - 2, DHeroIcon.SurfaceY(DHeroIcon.GTop)+18,
       '体力值: ' + IntToStr(g_Heroself.m_Abil.HP)+ '/' + IntToStr(g_Heroself.m_Abil.MaxHP) + '\' +
       '魔法值: ' + IntToStr(g_Heroself.m_Abil.MP)+ '/' + IntToStr(g_Heroself.m_Abil.MaxMP) + '\' +
       '内力值: ' + IntToStr(g_Heroself.m_Skill69NH)+ '/' + IntToStr(g_Heroself.m_Skill69MaxNH) + '\' +
       '经验值: ' + FloatToStrFixFmt (100 * (g_HeroSelf.m_Abil.Exp / g_HeroSelf.m_Abil.MaxExp), 3, 2) + '%' + '\' +
       '忠诚度: ' + FormatFloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%' + '\' +
       '醉酒度: ' + IntToStr(_MAX(0, 100 * g_HeroSelf.m_Abil.WineDrinkValue div g_HeroSelf.m_Abil.MaxAlcohol)) + '%'
       {$IF M2Version = 1} + GetTransferOk(){$IFEND}
       , clWhite, FALSE);
end;

procedure TFrmDlg.DBoxsTautologyDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DBoxsTautology do begin
    if g_boNewBoxs = 0 then begin //老宝箱
      if DBoxsTautology.Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
      if GetTickCount - g_dwBoxsTautologyTick > 400 then begin
        g_dwBoxsTautologyTick := GetTickCount;
        Inc(g_BoxsTautologyImg);
        if g_BoxsTautologyImg > 3 then g_BoxsTautologyImg := 0;
      end;
      d := g_WMain3Images.Images[515+g_BoxsTautologyImg];
      if d <> nil then dsurface.DrawBlend(SurfaceX(GLeft- 10),SurfaceY(GTop - 20), d);
    end else begin  //新宝箱
      if DBoxsTautology.Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex+1];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemsUpBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
begin
  if Sender = DItemsUpBelt1 then begin
    if g_ItemsUpItem[0].ClientItem.s.Name <> '' then begin
      idx := g_ItemsUpItem[0].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        if d <> nil then
          dsurface.Draw (DItemsUpBelt1.SurfaceX(DItemsUpBelt1.GLeft + (DItemsUpBelt1.GWidth - d.Width) div 2),
                         DItemsUpBelt1.SurfaceY(DItemsUpBelt1.GTop + (DItemsUpBelt1.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DItemsUpBelt2 then begin
    if g_ItemsUpItem[1].ClientItem.s.Name <> '' then begin
      idx := g_ItemsUpItem[1].ClientItem.s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        if d <> nil then
          dsurface.Draw (DItemsUpBelt2.SurfaceX(DItemsUpBelt2.GLeft + (DItemsUpBelt2.GWidth - d.Width) div 2),
                         DItemsUpBelt2.SurfaceY(DItemsUpBelt2.GTop + (DItemsUpBelt2.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DItemsUpBelt3 then begin
    if g_ItemsUpItem[2].ClientItem.s.Name <> '' then begin
      idx := g_ItemsUpItem[2].ClientItem.s.Looks;
      if idx >= 0 then begin
        d :=frmMain.GetBagItemImg(idx);
        if d <> nil then
          dsurface.Draw (DItemsUpBelt3.SurfaceX(DItemsUpBelt3.GLeft + (DItemsUpBelt3.GWidth - d.Width) div 2),
                         DItemsUpBelt3.SurfaceY(DItemsUpBelt3.GTop + (DItemsUpBelt3.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemsUpBelt1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
   butt: TAspDButton;
   sel: Integer;
begin
   butt := TAspDButton(Sender);
   sel := 0;
   if not g_boItemMoving then begin
      if g_ItemsUpItem[butt.Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_ItemsUpItem[butt.Tag].ClientItem.s);
         if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingItemUp.Item.ClientItem.S.Name <> '') then exit;
         sel := -1;
         if Sender = DItemsUpBelt1 then sel := 0;
         if Sender = DItemsUpBelt2 then sel := 1;
         if Sender = DItemsUpBelt3 then sel := 2;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(sel + 41);
         g_MovingItem.Item := g_ItemsUpItem[butt.Tag];
         g_ItemsUpItem[butt.Tag].ClientItem.s.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -41) or (g_MovingItem.Index = -42) or
         (g_MovingItem.Index = -43) then begin
         ItemClickSound (g_MovingItem.Item.ClientItem.S);
         if g_ItemsUpItem[butt.Tag].ClientItem.s.Name <> '' then begin //磊府俊 乐栏搁
            temp := g_ItemsUpItem[butt.Tag];
            g_ItemsUpItem[butt.Tag] := g_MovingItem.Item;
            g_MovingItem.Index := -(sel + 41);
            g_MovingItem.Item := temp
         end else begin
            g_ItemsUpItem[butt.Tag] := g_MovingItem.Item;
            g_MovingItem.Item.ClientItem.S.name := '';
            g_boItemMoving := FALSE;
         end;
      end;
   end;
end;



procedure TFrmDlg.DItemsUpOkClick(Sender: TObject; X, Y: Integer);
begin
  if (g_ItemsUpItem[0].ClientItem.s.Name = '') or (g_ItemsUpItem[1].ClientItem.s.Name = '') or (g_ItemsUpItem[2].ClientItem.s.Name = '') then Exit;
  FrmMain.SendItemUpOK();
end;

procedure TFrmDlg.DItemsUpBelt1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   idx: integer;
begin
   idx := TAspDButton(Sender).Tag;
   if idx in [0..2] then begin
      if g_ItemsUpItem[idx].ClientItem.s.Name <> '' then begin
         g_MouseItem := g_ItemsUpItem[idx];
      end;
   end;
end;

procedure TFrmDlg.DItemsUpCloseClick(Sender: TObject; X, Y: Integer);
begin
  DItemsUp.Visible := False;
  if g_ItemsUpItem[0].ClientItem.s.Name <> '' then begin
    AddItemBag(g_ItemsUpItem[0]);
    g_ItemsUpItem[0].ClientItem.s.Name := '';
  end;
  if g_ItemsUpItem[1].ClientItem.s.Name <> '' then begin
    AddItemBag(g_ItemsUpItem[1]);
    g_ItemsUpItem[1].ClientItem.s.Name := '';
  end;
  if g_ItemsUpItem[2].ClientItem.s.Name <> '' then begin
    AddItemBag(g_ItemsUpItem[2]);
    g_ItemsUpItem[2].ClientItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DGetHeroCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWiGetHero.Visible := False;
end;

procedure TFrmDlg.DSelHero1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if not TAspDButton(Sender).Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           d := WLib.Images[FaceIndex + 2];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TfrmDlg.DPlayGameNum();
var
  J, vData: Integer;
begin
    if GetTickCount - g_DwPlayDrinkTick > 50 then begin
      g_DwPlayDrinkTick := GetTickCount;
      if g_nImgLeft < 130 then Inc(g_nImgLeft,30)
       else Inc(g_nPlayDrinkDelay);
      if g_nImgLeft > 100 then DPlayDrinkWhoWin.Visible := True;  //显示谁赢
      if g_nPlayDrinkDelay > 30 then begin
        g_boPlayDrink := False;
        ShowPlayDrinkImg(False);
        if g_btWhoWin = 1 then begin //NPC赢
          if g_NpcRandomDrinkList.Count= 0 then Exit;
          Randomize(); //随机种子
          J := Random(g_NpcRandomDrinkList.Count);//从余下的酒中随机选一瓶
          vData := Integer(g_NpcRandomDrinkList[J]);
          g_NpcRandomDrinkList.Delete(J); //抽取完后从列表中删除
          g_btNpcDrinkTarget := vData; //随机目标
          g_boNpcAutoSelDrink := True;  //自动选酒
          g_nNpcSelDrinkPosition := -1; //位置初始化
          g_btNpcAutoSelDrinkCircleNum := 0; //初始化圈数
        end;
      end;
    end;
end;

procedure TFrmDlg.DPlayDrinkDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   MyIcon: Integer;
   Butt: TAspDButton;
   rc: Trect;
   IconFlash: Integer; //定位NPC或玩家头像处喝酒图
begin
  with DPlayDrink do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_btDrinkValue[0] <= 92 then begin
       d := g_WMain2Images.Images[342+g_btNpcIcon]; //NPC头像
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
//------------------------NPC喝酒动画显示
    if g_btShowPlayDrinkFlash = 1 then begin
      if GetTickCount - g_DwShowPlayDrinkFlashTick > 150 then begin
         g_DwShowPlayDrinkFlashTick := GetTickCount;
         inc(g_nShowPlayDrinkFlashImg);
         if g_btTempDrinkValue[0] > 92 then begin//NPC喝醉了
            if g_nShowPlayDrinkFlashImg > 14 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[0] := g_btTempDrinkValue[0];
            end;
         end else begin
            if g_nShowPlayDrinkFlashImg > 10 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[0] := g_btTempDrinkValue[0];
            end;
         end;
      end;
      case g_btNpcIcon of
        0: IconFlash := 370;
        1: IconFlash := 390;
        2: IconFlash := 410;
        else IconFlash := 370;
      end;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
    if g_btDrinkValue[0] > 92 then begin //喝醉了最后的图
      case g_btNpcIcon of
        0: IconFlash := 370;
        1: IconFlash := 390;
        2: IconFlash := 410;
        else IconFlash := 370;
      end;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg - 1];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
//-----------------
    if g_btDrinkValue[1] <= 92 then begin
     if g_Myself.m_btSex = 0 then MyIcon := 337 else MyIcon := 338;
     if MyIcon > 0 then begin //玩家头像
      if g_WMain2Images <> nil then begin
       d := g_WMain2Images.Images[MyIcon];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 248), d.ClientRect, d, TRUE);
      end;
     end;
    end;
//-------------玩家喝酒动画显示
    if g_btShowPlayDrinkFlash = 2 then begin
      if GetTickCount - g_DwShowPlayDrinkFlashTick > 150 then begin
         g_DwShowPlayDrinkFlashTick := GetTickCount;
         inc(g_nShowPlayDrinkFlashImg);
         if g_btTempDrinkValue[1] > 92 then begin//NPC喝醉了
            if g_nShowPlayDrinkFlashImg > 14 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[1] := g_btTempDrinkValue[1];
            end;
         end else begin
            if g_nShowPlayDrinkFlashImg > 10 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[1] := g_btTempDrinkValue[1];
            end;
         end;
      end;
      if g_Myself.m_btSex = 0 then IconFlash := 430 else IconFlash := 450;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 248), d.ClientRect, d, TRUE);
    end;
    if g_btDrinkValue[1] > 92 then begin //喝醉了最后的图
      if g_Myself.m_btSex = 0 then IconFlash := 430 else IconFlash := 450;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg - 1];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 248), d.ClientRect, d, TRUE);
    end;
//-----------------
    d := g_WMain2Images.Images[369];  //NPC酒气
    if d <> nil then begin
       rc := d.ClientRect;
       rc.Right := Round((rc.Right-rc.Left) /100 * g_btDrinkValue[0]);
       dsurface.Draw (SurfaceX(GLeft + 111), SurfaceY(GTop + 97), rc, d, true);
    end;
    d := g_WMain2Images.Images[369];  //玩家酒气
    if d <> nil then begin
       rc := d.ClientRect;
       rc.Right := Round((rc.Right-rc.Left) /100 * g_btDrinkValue[1]);
       dsurface.Draw (SurfaceX(GLeft + 111), SurfaceY(GTop + 326), rc, d, true);
    end;
    dsurface.FillRect(Bounds(SurfaceX(GLeft)+313, SurfaceY(GTop) + 97, 2, 9), clRed);
    dsurface.FillRect(Bounds(SurfaceX(GLeft)+313, SurfaceY(GTop) + 326, 2, 9), clRed);
    AspTextureFont.TextOut(SurfaceX(GLeft) + 60 - AspTextureFont.TextWidth(g_sNpcName) div 2 , SurfaceY(GTop) + 97, clWhite, g_sNpcName);
    AspTextureFont.TextOut(SurfaceX(GLeft) + 60 - AspTextureFont.TextWidth(g_MySelf.m_sUserName) div 2 , SurfaceY(GTop) + 326, clWhite, g_MySelf.m_sUserName);

    d := g_WMain2Images.Images[348];
    if d <> nil then begin
      if g_boStopPlayDrinkGame then begin
        dsurface.DrawBlend(SurfaceX(GLeft) + 395,
                  SurfaceY(GTop)+240, d.ClientRect, d);
      end else dsurface.Draw (SurfaceX(GLeft) + 395, SurfaceY(GTop) + 240, d.ClientRect, d, TRUE);
    end;
    d := g_WMain2Images.Images[350];
    if d <> nil then begin
      if g_boStopPlayDrinkGame then begin
        dsurface.DrawBlend(SurfaceX(GLeft) + 351,
                  SurfaceY(GTop) + 250, d.ClientRect, d);
      end else dsurface.Draw (SurfaceX(GLeft) + 351, SurfaceY(GTop) + 250, d.ClientRect, d, TRUE);
    end;
    d := g_WMain2Images.Images[352];
    if d <> nil then begin
      if g_boStopPlayDrinkGame then begin
        dsurface.DrawBlend(SurfaceX(GLeft) + 342,
                  SurfaceY(GTop) + 294, d.ClientRect, d);
      end else dsurface.Draw (SurfaceX(GLeft) + 342, SurfaceY(GTop) + 294, d.ClientRect, d, TRUE);
    end;
     if not g_boStopPlayDrinkGame then begin
      if g_btPlayDrinkGameNum <= 2 then begin
        if DPlayDrinkFist.Tag = g_btPlayDrinkGameNum then butt := DPlayDrinkFist;
        if DPlayDrinkScissors.Tag = g_btPlayDrinkGameNum then butt := DPlayDrinkScissors;
        if DPlayDrinkCloth.Tag = g_btPlayDrinkGameNum then butt := DPlayDrinkCloth;
        if butt.Tag = g_btPlayDrinkGameNum then begin
            if GetTickCount - g_dwPlayDrinkSelImgTick > 100 then begin
               g_dwPlayDrinkSelImgTick := GetTickCount;
               inc(g_nPlayDrinkSelImg);
              if g_nPlayDrinkSelImg > 1 then g_nPlayDrinkSelImg := 0;
            end;
          with butt do begin
            d := g_WMain2Images.Images[361 + g_nPlayDrinkSelImg];
            if d <> nil then
                dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d);
          end;
        end;
      end;
     end;
    if not g_boPlayDrink then begin
      DMerchantDlgShowText(Sender, g_sPlayDrinkStr1,
      SelectMenuStr, 120, 46, g_PlayDrinkPoints,
      g_boRequireAddPoints1);
      DMerchantDlgShowText(Sender, g_sPlayDrinkStr2,
      SelectMenuStr, 120, 274, g_PlayDrinkPoints,
      g_boRequireAddPoints2);
    end;

    if g_boPlayDrink then begin
      d := g_WMain2Images.Images[339];
      if d <> nil then begin
            dsurface.DrawBlend(SurfaceX(GLeft),
                    SurfaceY(GTop), d.ClientRect, d);
      end;
      DPlayGameNum();
      DPlayDrinkNpcNum.GLeft := 0 + g_nImgLeft;
      d := g_WMain2Images.Images[345];
        if d <> nil then
      DPlayDrinkPlayNum.GLeft := DPlayDrink.GWidth - d.Width - g_nImgLeft;

    end;
  end;
end;

procedure TFrmDlg.ChallengeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendChallenge;
   end;
end;
//酒馆NPC自动选酒中。。
procedure TFrmDlg.NpcAutoSelDrinkRuning(dsurface: TAsphyreCanvas);
begin
  if g_boNpcAutoSelDrink then begin     //NPC自动选酒中
    if GetTickCount - g_DwShowNpcSelDrinkTick > 150 then begin
     g_DwShowNpcSelDrinkTick := GetTickCount;
     Inc(g_nNpcSelDrinkPosition);  //下一个位置
      if g_nNpcSelDrinkPosition > 5 then begin
        g_nNpcSelDrinkPosition := 0;
        Inc(g_btNpcAutoSelDrinkCircleNum); //转动圈数
      end;

    if g_btNpcAutoSelDrinkCircleNum = 2 then begin
      if g_nNpcSelDrinkPosition = 0 then
        if DDrink1.Tag = g_btNpcDrinkTarget then begin
          DDrink1.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 1 then
        if DDrink2.Tag = g_btNpcDrinkTarget then begin
          DDrink2.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 2 then
        if DDrink4.Tag = g_btNpcDrinkTarget then begin
          DDrink4.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 3 then
        if DDrink6.Tag = g_btNpcDrinkTarget then begin
          DDrink6.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 4 then
        if DDrink5.Tag = g_btNpcDrinkTarget then begin
          DDrink5.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 5 then
        if DDrink3.Tag = g_btNpcDrinkTarget then begin
          DDrink3.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
    end;
    end;
  end;
end;

procedure TFrmDlg.DDrink1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  NpcAutoSelDrinkRuning(dsurface);
   with TAspDButton(Sender) do begin
     if g_boPermitSelDrink then begin  //酒不让透明，允许玩家选酒
        if TAspDButton(Sender).ShowHint then begin//鼠标移动到了这瓶酒  高亮
          d := g_WMain2Images.Images[329];
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin   //普通显示
          d := g_WMain2Images.Images[363];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if g_boNpcAutoSelDrink then begin   //NPC自动选
          if TAspDButton(Sender).Tag = g_nNpcSelDrinkPosition then begin
            d := g_WMain2Images.Images[329];
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
        end else begin   //玩家选酒
          if TAspDButton(Sender).Tag = g_btPlaySelDrink then begin
            d := g_WMain2Images.Images[329];
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
        end;
     end else begin
       d := g_WMain2Images.Images[363];
       if d <> nil then begin
         dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d);
       end;
     end;
   end;
end;

procedure TFrmDlg.DWiGetHeroDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  function GetHeroIcon(Job,Sex: Byte): Integer;
  var
    Icon: Integer;
  begin
    case Job of
      0:Icon := 502;
      1:Icon := 506;
      2:Icon := 504;
      else Icon := 502;
    end;
    if Sex = 1 then Result := Icon +1
    else Result := Icon;
  end;
  function GetHeroJob(Job: Byte): string;
  begin
    case Job of
      0:Result := '战士';
      1:Result := '法师';
      2:Result := '道士';
    end;
  end;
var
   d: TAsphyreLockableTexture;
   Job: string;
   Icon: Integer;
   Color: TColor;
begin
  with DWiGetHero do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    if g_GetHeroData[0].sChrName <> '' then begin
      Icon := GetHeroIcon(g_GetHeroData[0].btJob, g_GetHeroData[0].btSex);
      d := g_WMain2Images.Images[Icon];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft) + 32, SurfaceY(GTop) + 76, d.ClientRect, d, TRUE);
    end;

    if g_GetHeroData[1].sChrName <> '' then begin
      Icon := GetHeroIcon(g_GetHeroData[1].btJob, g_GetHeroData[1].btSex);
      d := g_WMain2Images.Images[Icon];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft) + 150, SurfaceY(GTop) + 77, d.ClientRect, d, TRUE);
    end;
    if g_GetHeroData[0].sChrName <> '' then begin
      AspTextureFont.TextOut(SurfaceX(GLeft) + 74 - AspTextureFont.TextWidth(g_GetHeroData[0].sChrName) div 2 , SurfaceY(GTop) + 58, clSkyBlue, g_GetHeroData[0].sChrName);
      Color := $0040BBF1;
      AspTextureFont.TextOut(SurfaceX(GLeft) + 67 , SurfaceY(GTop) + 192, Color, IntToStr(g_GetHeroData[0].Level));
      Job := GetHeroJob(g_GetHeroData[0].btJob);
      AspTextureFont.TextOut(SurfaceX(GLeft) + 67 , SurfaceY(GTop) + 206, Color, Job);
    end;
    if g_GetHeroData[1].sChrName <> '' then begin
      AspTextureFont.TextOut(SurfaceX(GLeft) + 192 - AspTextureFont.TextWidth(g_GetHeroData[1].sChrName) div 2 , SurfaceY(GTop) + 58, clSkyBlue, g_GetHeroData[1].sChrName);
      Color := $0040BBF1;
      AspTextureFont.TextOut(SurfaceX(GLeft) + 184 , SurfaceY(GTop) + 192, Color, IntToStr(g_GetHeroData[1].Level));
      Job := GetHeroJob(g_GetHeroData[1].btJob);
      AspTextureFont.TextOut(SurfaceX(GLeft) + 184 , SurfaceY(GTop) + 206, Color, Job);
    end;
  end;
end;

procedure TFrmDlg.DSelHero1Click(Sender: TObject; X, Y: Integer);
begin
  if g_GetHeroData[TAspDButton(Sender).Tag].sChrName <> '' then begin
    FrmMain.SendSelHeroName(g_GetHeroData[TAspDButton(Sender).Tag].btType, g_GetHeroData[TAspDButton(Sender).Tag].sChrName);
    DWiGetHero.Visible := False;
  end;
end;

procedure TFrmDlg.DPlayFistClick(Sender: TObject; X, Y: Integer);
begin
  if g_boStopPlayDrinkGame then Exit;
  FrmMain.SendPlayDrinkGame(g_nCurMerchant,g_btPlayDrinkGameNum); //发送猜拳码数
  g_boPermitSelDrink := True;
  DPlayFist.Visible := False;
end;

procedure TFrmDlg.DPlayDrinkCloseDirctPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not TAspDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            if g_boPlayDrink then begin
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
            end else
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            if g_boPlayDrink then begin
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
   end;
end;

procedure TFrmDlg.ShowPlayDrink (Who1: integer; msgstr: string);
var
   i: integer;
begin
   if Who1 = 1 then   //上面的人
   g_sPlayDrinkStr1 := msgstr
   else if Who1 = 2 then   g_sPlayDrinkStr2 := msgstr;  //下面的人
   if g_PlayDrinkPoints.Count > 0 then //20080629
   for i:=0 to g_PlayDrinkPoints.Count-1 do
      Dispose (pTClickPoint (g_PlayDrinkPoints[i]));
   g_PlayDrinkPoints.Clear;
   if Who1 = 1 then
   g_boRequireAddPoints1 := TRUE;
   if who1 = 2 then
   g_boRequireAddPoints2 := TRUE;
end;
procedure TFrmDlg.DPlayDrinkMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   SelectMenuStr := '';
   L := DPlayDrink.GLeft;
   T := DPlayDrink.GTop;
   with DPlayDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
end;

procedure TFrmDlg.DPlayDrinkMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DPlayDrinkClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  sData: string;
begin
   L := DPlayDrink.GLeft;
   T := DPlayDrink.GTop;
   with DPlayDrink do
    if g_PlayDrinkPoints.Count > 0 then //20080629
    for i:=0 to g_PlayDrinkPoints.Count-1 do begin
       p := PTClickPoint (g_PlayDrinkPoints[i]);
       if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
          (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
          FrmMain.SendPlayDrinkDlgSelect(g_nCurMerchant, p.RStr);
          break;
       end;
    end;
end;

procedure TFrmDlg.DWPleaseDrinkDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  IconFlash: Integer;
begin
  with DWPleaseDrink do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

       d := g_WMain2Images.Images[342+g_btNpcIcon]; //NPC头像
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
          
//------------------------NPC喝酒动画显示
    if g_btShowPlayDrinkFlash = 1 then begin
      if GetTickCount - g_DwShowPlayDrinkFlashTick > 150 then begin
         g_DwShowPlayDrinkFlashTick := GetTickCount;
         inc(g_nShowPlayDrinkFlashImg);
         if g_nShowPlayDrinkFlashImg > 10 then begin
           g_btShowPlayDrinkFlash := 0;
           g_btDrinkValue[0] := g_btTempDrinkValue[0];
         end;
      end;
      case g_btNpcIcon of
        0: IconFlash := 370;
        1: IconFlash := 390;
        2: IconFlash := 410;
        else IconFlash := 370;
      end;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
      AspTextureFont.TextOut(SurfaceX(GLeft) + 60 - AspTextureFont.TextWidth(g_sNpcName) div 2 , SurfaceY(GTop) + 97, clWhite, g_sNpcName);
    DMerchantDlgShowText(Sender, g_sPlayDrinkStr1,
      SelectMenuStr, 115, 55, g_PlayDrinkPoints,
      g_boRequireAddPoints1);
    DMerchantDlgShowText(Sender, g_sPlayDrinkStr2,
      SelectMenuStr, 30, 263, g_PlayDrinkPoints,
      g_boRequireAddPoints2);

    d := g_WMain2Images.Images[364];
    if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 96), SurfaceY(GTop + 186), d.ClientRect, d, TRUE);
    if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 290), SurfaceY(GTop + 196), d.ClientRect, d, TRUE);


  end;
end;

procedure TFrmDlg.DPDrink1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    d := g_WMain2Images.Images[365];
    if d <> nil then begin
      if ShowHint then begin
         dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d);
      end else
         dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                     SurfaceY(GTop + (GHeight - d.Height) div 2),
                     d.ClientRect, d, TRUE);
    end;
    if g_PDrinkItem[Tag].ClientItem.s.Name <> '' then begin
      d := g_WMain2Images.Images[363];
      if d <> nil then begin
        if ShowHint then begin
           dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d);
        end else
           dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                       SurfaceY(GTop + (GHeight - d.Height) div 2),
                       d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DPlayDrinkCloseClick(Sender: TObject; X, Y: Integer);
begin
  DPlayDrink.Visible := False;
end;

procedure TFrmDlg.DPlayDrinkFistClick(Sender: TObject; X, Y: Integer);
begin
  if g_boPlayDrink then Exit;
  if g_boNpcAutoSelDrink then Exit;
  if g_btWhoWin = 0 then if not g_boHumWinDrink then Exit; //20080614 玩家赢，是否喝了酒
  g_btPlayDrinkGameNum := TAspDButton(Sender).Tag;
  DPlayFist.Visible := True;
end;

procedure TFrmDlg.DPlayDrinkNpcNumDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DPlayDrinkNpcNum do begin
    d := g_WMain2Images.Images[366 + g_btNpcNum];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DPlayDrinkPlayNumDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DPlayDrinkPlayNum do begin
    d := g_WMain2Images.Images[345 + g_btPlayNum];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DPlayDrinkWhoWinDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DPlayDrinkWhoWin do begin
    d := g_WMain2Images.Images[334 + g_btWhoWin];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

//是否显示斗酒一些图
procedure TFrmDlg.ShowPlayDrinkImg(Show: Boolean);
begin
    DPlayDrinkWhoWin.Visible := Show;
    DPlayDrinkNpcNum.Visible := Show;
    DPlayDrinkPlayNum.Visible := Show;
end;

procedure TFrmDlg.DPlayDrinkFistDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
 //这个过程不能删除  让斗酒的按钮为空显示
end;

procedure TFrmDlg.DDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  if g_boPlayDrink then Exit;
  if g_boNpcAutoSelDrink then Exit;
  TAspDButton(Sender).ShowHint := True;
end;

procedure TFrmDlg.DPlayDrinkMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DDrink1.ShowHint := False;
  DDrink2.ShowHint := False;
  DDrink3.ShowHint := False;
  DDrink4.ShowHint := False;
  DDrink5.ShowHint := False;
  DDrink6.ShowHint := False;
end;

procedure TFrmDlg.DDrink1Click(Sender: TObject; X, Y: Integer);
begin
  if g_boPlayDrink then Exit;
  if g_boNpcAutoSelDrink then Exit;
  if not g_boPermitSelDrink then Exit;
  g_btPlaySelDrink := TAspDButton(Sender).Tag;  //玩家选的酒
  FrmMain.ClientGetPlayDrinkSay(g_nCurMerchant,2,'这坛酒给谁喝好呢？  <对方/@@@对方> <自己/@@@自己>');
end;

procedure TFrmDlg.DPDrink1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
   butt: TAspDButton;
   sel: Integer;
begin
   butt := TAspDButton(Sender);
   if not g_boItemMoving then begin
      if g_PDrinkItem[butt.Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_PDrinkItem[butt.Tag].ClientItem.s);
         if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingItemUp.Item.ClientItem.S.Name <> '') then exit;
         sel := -1;
         if Sender = DPDrink1 then sel := 0;
         if Sender = DPDrink2 then sel := 1;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(sel + 45);
         g_MovingItem.Item := g_PDrinkItem[butt.Tag];
         g_PDrinkItem[butt.Tag].ClientItem.s.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -45) or (g_MovingItem.Index = -46) then begin
         if (g_MovingItem.Item.ClientItem.S.StdMode = 60) and (g_MovingItem.Item.ClientItem.S.Shape = 0) then begin  //是烧酒
           ItemClickSound (g_MovingItem.Item.ClientItem.S);
           if g_PDrinkItem[butt.Tag].ClientItem.s.Name <> '' then begin
              temp := g_PDrinkItem[butt.Tag];
              g_PDrinkItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(sel + 45);
              g_MovingItem.Item := temp
           end else begin
              g_PDrinkItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
           end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DPDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  TAspDButton(Sender).ShowHint := True;
end;

procedure TFrmDlg.DWPleaseDrinkMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DPDrink1.ShowHint := False;
  DPDrink2.ShowHint := False;
end;

procedure TFrmDlg.DPleaseDrinkExitClick(Sender: TObject; X, Y: Integer);
begin
  DWPleaseDrink.Visible := False;
  if g_PDrinkItem[0].ClientItem.s.Name <> '' then begin
    AddItemBag(g_PDrinkItem[0]);
    g_PDrinkItem[0].ClientItem.s.Name := '';
  end;
  if g_PDrinkItem[1].ClientItem.s.Name <> '' then begin
    AddItemBag(g_PDrinkItem[1]);
    g_PDrinkItem[1].ClientItem.s.Name := '';
  end;
end;

procedure TFrmDlg.DPleaseDrinkDrinkClick(Sender: TObject; X, Y: Integer);
begin
  if g_PDrinkItem[0].ClientItem.s.Name = '' then begin
     FrmMain.ClientGetPlayDrinkSay(g_nCurMerchant,1,'年轻人，你不是请我喝酒吗？我的酒呢？');
     Exit;
  end;
  if g_PDrinkItem[1].ClientItem.s.Name = '' then begin
     FrmMain.ClientGetPlayDrinkSay(g_nCurMerchant,1,'年轻人，你请我喝酒，怎么自己不喝呢？');
     Exit;
  end;
  FrmMain.SendDrinkDrinkOK();
end;

procedure TFrmDlg.DWPFLingPaiInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWPFLingPai.SetImgIndex(g_WUI1Images, 61);
{$IFEND}
end;

procedure TFrmDlg.DWPleaseDrinkClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  sData: string;
begin
   L := DWPleaseDrink.GLeft;
   T := DWPleaseDrink.GTop;
   with DWPleaseDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            FrmMain.SendPlayDrinkDlgSelect(g_nCurMerchant, p.RStr);
            break;
         end;
      end;
end;

procedure TFrmDlg.DWPleaseDrinkMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   SelectMenuStr := '';
   L := DWPleaseDrink.GLeft;
   T := DWPleaseDrink.GTop;
   with DWPleaseDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
end;

procedure TFrmDlg.DWPleaseDrinkMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DWQJFurnaceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  str: string;
  rc: TRect;
  r: Real;
  bbx, bby: Integer;
begin
  {$IF M2Version = 1}
  with DWQJFurnace do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d<>nil then 
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

      d := WLib.Images[1310];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+214, SurfaceY(GTop)+60, d.ClientRect, d, TRUE);

      d := WLib.Images[1311];
      if d <> nil then begin
        rc := d.ClientRect;
        if g_dwQJFurnaceExp > 0 then r := g_dwQJFurnaceMaxExp / g_dwQJFurnaceExp
        else r := 0;
        if r > 0 then rc.Right := Round (rc.Right / r)
        else rc.Right := 0;
        dsurface.Draw (SurfaceX(GLeft)+214, SurfaceY(GTop)+60, rc, d, TRUE);
      end;

      if g_boQJFurnaceMove then begin //转动
        if GetTickCount - g_dwQJFurnaceTick > 100 then begin
          g_dwQJFurnaceTick := GetTickCount();
          Inc(g_btQJFurnacePosition);
          if g_btQJFurnacePosition > 7 then begin
            g_btQJFurnacePosition := 0;
            if g_btQJFurnaceTarget >= 7 then Dec(g_btQJFurnaceTarget, 7);
          end;
          if g_btQJFurnacePosition = g_btQJFurnaceTarget then begin
            g_boQJFurnaceMove := False;
            DBQJFurnaceStart.Visible := True;
          end;
        end;
      end;

      d := WLib.Images[1299];
      if d <> nil then begin
        case g_btQJFurnacePosition of
          0: begin
            bbx := 26;
            bby := 57;
          end;
          1: begin
            bbx := 26;
            bby := 96;
          end;
          2: begin
            bbx := 57;
            bby := 122;
          end;
          3: begin
            bbx := 95;
            bby := 122;
          end;
          4: begin
            bbx := 126;
            bby := 96;
          end;
          5: begin
            bbx := 126;
            bby := 57;
          end;
          6: begin
            bbx := 95;
            bby := 30;
          end;
          7: begin
            bbx := 57;
            bby := 30;
          end;
        end;
        dsurface.Draw (SurfaceX(GLeft)+bbx, SurfaceY(GTop)+bby, d.ClientRect, d, TRUE);
      end;

      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+280, SurfaceY(GTop)+76, $008CC7EF, clBlack, Format('%d/%d', [g_dwQJFurnaceExp, g_dwQJFurnaceMaxExp]));
      if g_btQJFurnaceType = 1 then begin
        str := ForMat('每次至少需要消耗%d%s和%d%s', [g_dwQJFurnaceLingfu, g_sGameGird, g_dwQJFurnaceGold, g_sGoldName]);
      end else begin
        str := ForMat('每次炼气需要消耗%d%s', [g_dwQJFurnaceGold, g_sGoldName]);
      end;
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+254 - AspTextureFont.TextWidth(str) div 2, SurfaceY(GTop)+140, clYellow, clBlack, str);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWQJFurnaceInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DWQJFurnace.SetImgIndex(g_WMainImages, 1290);
  {$IFEND}
end;

procedure TFrmDlg.DWQJPracticeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  OldFontStyle: TFontStyles;
  I: Integer;
  pm: PTClientMagic;
  boOpen95: Boolean;
begin
{$IF M2Version = 1}
  with DWQJPractice do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      d := g_WMainImages.Images[112];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+118, SurfaceY(GTop) + 183, d.ClientRect, d, TRUE);

      if m_boQJPracticeHero then begin
        if g_HeroSelf <> nil then begin
          boOpen95 := g_boQJHeroDZXY99;
          for I:=0 to g_HeroMagicList.Count-1 do begin
            pm := PTClientMagic (g_HeroMagicList[I]);
            if pm <> nil then begin
              if pm.Def.wMagicId = 95 then begin //斗转星移
                m_btQjPracticeSkillLevel := pm.Level;
                m_dwQjPracticeCurTrain := pm.CurTrain;
                m_dwQJpracticeMaxTrain := pm.Def.MaxTrain[0];
                Break;
              end;
            end;
          end;
          if not g_boQJHeroDZXY99 and (m_btQjPracticeSkillLevel = 64) then begin
            AspTextureFont.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+164, clWhite, '斗转', [fsBold]);
            AspTextureFont.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+178, clWhite, '灵丹', [fsBold]);
          end;

        end;
      end else begin
        if g_MySelf <> nil then begin
          boOpen95 := g_boQJDZXY99;
          for I:=0 to g_MagicList.Count-1 do begin
            pm := PTClientMagic (g_MagicList[I]);
            if pm <> nil then begin
              if pm.Def.wMagicId = 95 then begin //斗转星移
                m_btQjPracticeSkillLevel := pm.Level;
                m_dwQjPracticeCurTrain := pm.CurTrain;
                m_dwQJpracticeMaxTrain := pm.Def.MaxTrain[0];
                Break;
              end;
            end;
          end;
          if not g_boQJDZXY99 and (m_btQjPracticeSkillLevel = 64) then begin
            AspTextureFont.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+164, clWhite, '斗转', [fsBold]);
            AspTextureFont.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+178, clWhite, '灵丹', [fsBold]);
          end;
        end;
      end;
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+128 - AspTextureFont.TextWidth(m_sQJPracticeObjectName) div 2, SurfaceY(GTop)+47, $00ADD7EF, clBlack, m_sQJPracticeObjectName, [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+84, $00ADD7EF, clBlack, '神冲穴', [fsBold]);
      
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+100, $00ADD7EF, clBlack, IntToStr(m_btQjPracticeSkillLevel), [fsBold]);


      if (m_btQjPracticeSkillLevel < 64) or ((m_btQjPracticeSkillLevel < 99) and boOpen95 ) then
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+105, SurfaceY(GTop)+131, $00ADD7EF, clBlack, ForMat('%d/%d', [m_dwQjPracticeCurTrain, m_dwQJpracticeMaxTrain]), [fsBold])
      else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+105, SurfaceY(GTop)+131, $00ADD7EF, clBlack, '-/-', [fsBold]);

      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+114, SurfaceY(GTop)+166, $00ADD7EF, clBlack, '斗转星移', [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+182, $00ADD7EF, clBlack, IntToStr(m_btQjPracticeSkillLevel), [fsBold]);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWQJPracticeInitialize(Sender: TObject);
begin
  DWQJPractice.SetImgIndex(g_WMainImages, 1177);
end;

procedure TFrmDlg.DLOGODirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if GetTickCount - g_dwLogoTick > 1000 then begin
    g_dwLogoTick := GetTickCount;
    Inc(g_nLogoTimer);
    if g_nLogoTimer > 5 then begin
      DLOGOClick( DLOGO, 0, 0);
      g_nLogoTimer := 0;
      Exit;
    end;
  end;

  d := g_WUiMainImages.Images[g_WUiMainImages.ImageCount-1];
  if d<>nil then begin
    dsurface.FillRect(dsurface.ClipRect, GetRGB(255));//下边
    
    dsurface.Draw ((g_D3DConfig.wScreenWidth - d.Width) div 2, (g_D3DConfig.wScreenHeight - d.Height) div 2, d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLQJPracticeLink1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  with Sender as TAspDLabel do begin
    if m_boQJPracticeHero then
      FrmMain.SendQJAutoPractice(Tag, 1)
    else FrmMain.SendQJAutoPractice(Tag, 0);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLQJPracticeLink3Click(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version = 1}
  msg := MakeDefaultMsg (aa(CM_CLOSEGAMEGIRDUPSKILL95, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg));
{$IFEND}
end;

procedure TFrmDlg.DLQJPracticeLink4Click(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version = 1}
  if m_boQJPracticeHero then begin
    msg := MakeDefaultMsg (aa(CM_QUERYGAMEGIRDUPSKILL95, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
  end else begin
    msg := MakeDefaultMsg (aa(CM_QUERYGAMEGIRDUPSKILL95, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  end;
  frmMain.SendSocket (EncodeMessage (msg));
{$IFEND}
end;

procedure TFrmDlg.DLXinFaChangeSelNameClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWUXinFa.Visible := False;
  DWLingWuXinFaKey.Visible := False;
  if mrOk = DMessageDlg (Format('你确定要转换为%s属性的心法吗？',
        [g_XinFaName[g_LingWuXinFa.btIndex]]), [mbOk, mbCancel]) then begin
    frmMain.SendChangeLingWuXinFa(g_LingWuXinFa.btIndex);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLXinFaChangeSelNameInitialize(Sender: TObject);
begin
  DLXinFaChangeSelName.SetImgIndex(g_WUI1Images, 2140);  
end;

procedure TFrmDlg.DLXinFaMakeNameClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_LingWuXinFa.sKeySelCaption <> '' then begin
    DWLingWUXinFa.Visible := False;
    DWLingWuXinFaKey.Visible := False;
    if mrOk = DMessageDlg (Format('你确定要修行%s(%s属性)的心法吗？',
          [g_LingWuXinFa.sKeySelCaption, g_XinFaName[g_LingWuXinFa.btIndex]]), [mbOk, mbCancel]) then begin
      frmMain.SendLingWuXinFa(g_LingWuXinFa.btIndex, g_LingWuXinFa.sKeySelCaption);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLXinFaMakeNameInitialize(Sender: TObject);
begin
  DLXinFaMakeName.SetImgIndex(g_WUI1Images, 2142);  
end;

procedure TFrmDlg.DLOGOClick(Sender: TObject; X, Y: Integer);
begin
  if not g_boSendOnePack then
    Exit;//修复过快点击Logo导致无法连接LoginGate的BUG By TasNat at: 2012-03-10 15:31:20

  DLOGO.Visible := False;
//  FrmMain.UiDXImageList.Items[34].Picture.Assign(nil);
 // {$IF GVersion <> 2}
  frmMain.SendConn;//通知账号程序发来服务区信息 20090310
  //{$IFEND}
  PlayBGM (bmg_intro);
end;

procedure TFrmDlg.DFriendDlgFrdDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   b: TAspDButton;
   d: TAsphyreLockableTexture;
begin
   b := nil;
   case g_btFriendTypePage of
      1: b := DFriendDlgFrd;
      2: b := DFriendDlgTanget;
      3: b := DHeiMingDan;
   end;
   if b = Sender then begin
      with b do begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DFriendDlgFrdClick(Sender: TObject; X, Y: Integer);
begin
  g_btFriendTypePage := TAspDButton(Sender).Tag;
  DFriendList.Visible := True;
  DAddFriend.Visible := True;
  DDelFriend.Visible := True;
  DPrevFriendDlg.Visible := True;
  DNextFriendDlg.Visible := True;
  g_btFriendPage := 0;
end;

procedure TFrmDlg.DFriendDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d:TAsphyreLockableTexture;
begin
  with DFriendDlg do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DFriendListDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  msgtop, msgline, I,M: Integer;
  Color: TColor;
begin
  with DFriendList do begin
    Color := clWhite;
    case g_btFriendTypePage of
      1: begin
        msgtop := g_btFriendPage * 10;
        msgline := _MIN(g_btFriendPage * 10 + 10, g_FriendList.Count);
        for I:= msgtop to msgline-1 do begin
          m := I - msgtop;
          if I = g_btFriendIndex then Color := clRed
          else Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop) + M*17, Color, g_FriendList.Strings[I]);
        end;
      end;
      2: begin
        msgtop := g_btFriendPage * 10;
        msgline := _MIN(g_btFriendPage * 10 + 10, g_TargetList.Count);
        for I:= msgtop to msgline-1 do begin
          m := I - msgtop;
          if I = g_btFriendIndex then Color := clRed
          else Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop) + M*17, Color, g_TargetList.Strings[I]);
        end;
      end;
      3: begin
        msgtop := g_btFriendPage * 10;
        msgline := _MIN(g_btFriendPage * 10 + 10, g_HeiMingDanList.Count);
        for I:= msgtop to msgline-1 do begin
          m := I - msgtop;
          if I = g_btFriendIndex then Color := clRed
          else Color := clWhite;
          AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop) + M*17, Color, g_HeiMingDanList.Strings[I]);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DFriendListDblClick(Sender: TObject);
var
  lx,ly, idx, msgtop: Integer;
begin
  lx := g_btFriendMoveX - DFriendList.GLeft;
  ly := g_btFriendMoveY - DFriendList.GTop;
  case g_btFriendTypePage of
    1: begin
      if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
        idx := ly div 17;
        if idx < g_FriendList.Count then begin
          msgtop := g_btFriendPage * 10;
          g_btFriendIndex := idx + msgtop;
          if g_FriendList.Strings[g_btFriendIndex] <> '' then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.Text := '/'+ g_FriendList.Strings[g_btFriendIndex]+' ';
            PlayScene.EdChat.SetFocus;
            SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
      end;
    end;
    2: begin
      if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
        idx := ly div 17;
        if idx < g_TargetList.Count then begin
          msgtop := g_btFriendPage * 10;
          g_btFriendIndex := idx + msgtop;
          if g_TargetList.Strings[g_btFriendIndex] <> '' then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.Text := '/'+ g_TargetList.Strings[g_btFriendIndex]+' ';
            PlayScene.EdChat.SetFocus;
            SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
      end;
    end;
    3: begin
      if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
        idx := ly div 17;
        if idx < g_HeiMingDanList.Count then begin
          msgtop := g_btFriendPage * 10;
          g_btFriendIndex := idx + msgtop;
          if g_HeiMingDanList.Strings[g_btFriendIndex] <> '' then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.Text := '/'+ g_HeiMingDanList.Strings[g_btFriendIndex]+' ';
            PlayScene.EdChat.SetFocus;
            SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DFriendListMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  lx,ly, idx, msgtop: Integer;
begin
  g_btFriendMoveX := x;
  g_btFriendMoveY := Y;
   lx := X - DFriendList.GLeft;
   ly := Y - DFriendList.GTop;
   case g_btFriendTypePage of
     1: begin
        if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
          idx := ly div 17;
          if idx < g_FriendList.Count then begin
            msgtop := g_btFriendPage * 10;
            g_btFriendIndex := idx + msgtop;
          end;
        end;
     end;
     2: begin
        if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
          idx := ly div 17;
          if idx < g_TargetList.Count then begin
            msgtop := g_btFriendPage * 10;
            g_btFriendIndex := idx + msgtop;
          end;
        end;
     end;
     3: begin
        if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
          idx := ly div 17;
          if idx < g_HeiMingDanList.Count then begin
            msgtop := g_btFriendPage * 10;
            g_btFriendIndex := idx + msgtop;
          end;
        end;
     end;
   end;
end;

procedure TFrmDlg.DPrevFriendDlgClick(Sender: TObject; X, Y: Integer);
begin      
  if Sender = DPrevFriendDlg then begin
      if g_btFriendPage > 0 then
         Dec (g_btFriendPage);
  end else begin
     {if g_btFriendTypePage = 1 then begin
       if g_btFriendPage < (g_FriendList.Count+9) div 10 - 1 then
          Inc (g_btFriendPage);
     end;
     if g_btFriendTypePage = 3 then begin
       if g_btFriendPage < (g_HeiMingDanList.Count+9) div 10 - 1 then
          Inc (g_btFriendPage);
     end; }
    case g_btFriendTypePage of
      1: if g_btFriendPage < (g_FriendList.Count+9) div 10 - 1 then Inc (g_btFriendPage);
      2: if g_btFriendPage < (g_TargetList.Count+9) div 10 - 1 then Inc (g_btFriendPage);
      3: if g_btFriendPage < (g_HeiMingDanList.Count+9) div 10 - 1 then Inc (g_btFriendPage);
    end;
  end;
end;

procedure TFrmDlg.DAddFriendClick(Sender: TObject; X, Y: Integer);
  function GetPageCount(List: TStringList): Integer;
  begin
    Result := List.Count div 10;
    if List.Count mod 10 > 0 then Inc(Result);
  end;
var
  int: Integer;
begin
  {if g_btFriendTypePage = 1 then begin
    int := 0;
    DMessageDlg ('添加新的好友', [mbOk, mbAbort]);
    if DlgEditText = '' then Exit;
    if length(DlgEditText) > 14 then int := 3;
    if int = 0 then begin
        g_FriendList.Add(DlgEditText);
        g_btFriendPage := GetPageCount(g_FriendList) - 1;
    end else DMessageDlg ('人物名必须小于15位', [mbOk]);
  end else begin
    int := 0;
    DMessageDlg ('添加新的黑名单', [mbOk, mbAbort]);
    if DlgEditText = '' then Exit;
    if length(DlgEditText) > 14 then int := 3;
    if int = 0 then begin
        g_HeiMingDanList.Add(DlgEditText);
        g_btFriendPage := GetPageCount(g_HeiMingDanList) - 1;
    end else DMessageDlg ('人物名必须小于15位', [mbOk]);
  end;   }
  int := 0;
  case g_btFriendTypePage of
    1: begin
      DMessageDlg ('添加新的好友', [mbOk, mbAbort]);
      if DlgEditText = '' then Exit;
      if length(DlgEditText) > 14 then int := 3;
      if int = 0 then begin
          g_FriendList.Add(DlgEditText);
          g_btFriendPage := GetPageCount(g_FriendList) - 1;
      end else DMessageDlg ('人物名必须小于15位', [mbOk]);
    end;
    2: begin
      DMessageDlg ('添加新的目标名单（使用Ctrl + R快速标示目标）', [mbOk, mbAbort]);
      if DlgEditText = '' then Exit;
      if length(DlgEditText) > 14 then int := 3;
      if int = 0 then begin
          g_TargetList.Add(DlgEditText);
          g_btFriendPage := GetPageCount(g_TargetList) - 1;
      end else DMessageDlg ('人物名必须小于15位', [mbOk]);
    end;
    3: begin
      DMessageDlg ('添加新的黑名单', [mbOk, mbAbort]);
      if DlgEditText = '' then Exit;
      if length(DlgEditText) > 14 then int := 3;
      if int = 0 then begin
          g_HeiMingDanList.Add(DlgEditText);
          g_btFriendPage := GetPageCount(g_HeiMingDanList) - 1;
      end else DMessageDlg ('人物名必须小于15位', [mbOk]);
    end;
  end;
end;

procedure TFrmDlg.DDelFriendClick(Sender: TObject; X, Y: Integer);
var
  sUserName: string;
begin
  case g_btFriendTypePage of
    1: begin
      if g_FriendList.Count > 0 then begin
        if g_btFriendIndex < g_FriendList.Count then begin
          sUserName := g_FriendList.Strings[g_btFriendIndex];
          if mrOk = FrmDlg.DMessageDlg ('你确认删除 [ ' + sUserName+' ] 吗？', [mbOk, mbCancel]) then begin
            g_FriendList.Delete(g_btFriendIndex)
          end;
        end;
      end;
    end;
    2: begin
      if g_TargetList.Count > 0 then begin
        if g_btFriendIndex < g_TargetList.Count then begin
          sUserName := g_TargetList.Strings[g_btFriendIndex];
          if mrOk = FrmDlg.DMessageDlg ('你确认删除 [ ' + sUserName+' ] 吗？', [mbOk, mbCancel]) then begin
            g_TargetList.Delete(g_btFriendIndex)
          end;
        end;
      end;
    end;
    3: begin
      if g_HeiMingDanList.Count > 0 then begin
        if g_btFriendIndex < g_HeiMingDanList.Count then begin
          sUserName := g_HeiMingDanList.Strings[g_btFriendIndex];
          if mrOk = FrmDlg.DMessageDlg ('你确认删除 [ ' + sUserName+' ] 吗？', [mbOk, mbCancel]) then begin
            g_HeiMingDanList.Delete(g_btFriendIndex)
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DInternetClick(Sender: TObject; X, Y: Integer);
begin
  if g_sGameESystem <> '' then frmBrowser.Open(frmMain, g_sGameESystem);
  //frmBrowser.Open('http://www.igem2.com:8081');
end;

procedure TFrmDlg.DStMagHero1Click(Sender: TObject; X, Y: Integer);
var
   idx: integer;
   keych: char;
   pm: PTClientMagic;
begin
  if (HeroStatePage = 3) or (HeroInternalForcePage = 1) then begin
    if HeroStateTab = 0 then begin
      idx := TAspDButton(Sender).Tag + HeroMagTop;
      if (idx >= 0) and (idx < g_HeroMagicList.Count) then begin
      	pm := PTClientMagic (g_HeroMagicList[idx]);
        if pm.Def.wMagicId <> 99 then begin
          if not (pm.Def.wMagicId in [3,4,60..65,67,88,95]) then begin
            if word(pm.Key) = 0 then
              keych := char(word(1))
            else keych := char(word(0));
            pm.Key := keych;
            FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych,'');
          end;
        {$IF M2Version <> 2}
        end else begin
          SetHeroSkillMemoDlg(pm.Def.wMagicId, pm.Def.btEffect, pm.Def.sMagicName, '强身术修炼');
        {$IFEND}
        end;
      end;
    end else begin
      idx := TAspDButton(Sender).Tag + HeroMagTop;
      if (idx >= 0) and (idx < g_HeroInternalForceMagicList.Count) then begin
        pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        if word(pm.Key) = 0 then
          keych := char(word(1))
        else keych := char(word(0));
        pm.Key := keych;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych, '');
      end;
    end;
  end;
end;

procedure TFrmDlg.DWCheckNumDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with DWCheckNum do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFont.BoldTextOut (GLeft + 14, GTop + 14, $0040BBF1, clBlack, '图片验证码:', [fsBold]);

    d := g_dCheckNumImages;
    if d <> nil then begin
      dsurface.Draw (SurfaceX(GLeft)+60, SurfaceY(GTop)+50, d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DCheckNumOKDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if not TAspDButton(Sender).Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 27 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 5, $008CC6EF, clBlack, Hint, [fsBold]);
      end else begin
        if WLib <> nil then begin //20080701
          d := WLib.Images[FaceIndex + 1];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 29 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 6, $0040BBF1, clBlack, Hint, [fsBold]);
      end;
   end;
end;

procedure TFrmDlg.DCheckNumOKClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendCheckNum(DEditCheckNum.Text);
//g_boIsChangeCheckNum:= True;

end;

procedure TFrmDlg.DEditCheckNumKeyPress(Sender: TObject; var Key: Char);
begin
  if not (Key in ['0'..'9','a'..'z','A'..'Z', #8, #13]) then
    Key := #0;
end;

procedure TFrmDlg.DEditFactionAddQueryDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
	Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
	with DEditFactionAddQuery do begin
  	dsurface.FillRect(ClientRect, clBlack);
  	if Moveed then
    	Color := $00387B9C
    else Color := $00638494;
  	if Text = '' then  AspTextureFont.TextOut(SurfaceX(GLeft)+2, SurfaceY(GTop)+4, $00808080, '输入想要查询的宗师名');
		dsurface.FrameRect(ClientRect, Color);
  end;
{$IFEND}
end;

procedure TFrmDlg.DEditCheckNumKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = 13 then DCheckNumOKClick(DCheckNumOK ,0 , 0);
end;

procedure TFrmDlg.DCheckNewDeputyHeroWarrClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version <> 2}
  if Sender = DCheckNewDeputyHeroWarr then begin
    DCheckNewDeputyHeroWarr.Checked := True;
    DCheckNewDeputyHeroWiz.Checked := False;
    DCheckNewDeputyHeroTaos.Checked := False;
  end else if Sender = DCheckNewDeputyHeroWiz then begin
    DCheckNewDeputyHeroWarr.Checked := False;
    DCheckNewDeputyHeroWiz.Checked := True;
    DCheckNewDeputyHeroTaos.Checked := False;
  end else begin
    DCheckNewDeputyHeroWarr.Checked := False;
    DCheckNewDeputyHeroWiz.Checked := False;
    DCheckNewDeputyHeroTaos.Checked := True;
  end;
  m_btDeputyHeroJob := TAspDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_CHOOSEHEROJOB, frmMain.TempCertification), m_btDeputyHeroJob, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket(EncodeMessage (msg));
{$IFEND}
end;

procedure TFrmDlg.DCheckNumChangeClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendChangeCheckNum();
end;

procedure TFrmDlg.DWMakeWineDeskDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DWMakeWineDesk do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;


      d := g_WMain2Images.Images[586];   //上面图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop + 9), d.ClientRect, d, TRUE);
      if g_MakeTypeWine = 0 then begin  //普通酒
        if g_WineItem[0].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[598];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 235), SurfaceY(GTop + 124), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[1].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[596];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 121), SurfaceY(GTop + 109), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[2].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[597];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 155), SurfaceY(GTop + 167), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[4].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[599];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 288), SurfaceY(GTop + 119), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[5].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[600];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 330), SurfaceY(GTop + 137), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[6].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[601];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 294), SurfaceY(GTop + 147), d.ClientRect, d, TRUE);
        end;
    end else begin  //药酒
        if g_DrugWineItem[0].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[603];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 244), SurfaceY(GTop + 107), d.ClientRect, d, TRUE);
        end;
        if g_DrugWineItem[1].ClientItem.s.Name <> '' then begin
          d := g_WMain2Images.Images[602];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 158), SurfaceY(GTop + 132), d.ClientRect, d, TRUE);
        end;
    end;

    if g_sNpcName <> '' then begin  //画NPC名字
         AspTextureFont.TextOut (GLeft + 50 - AspTextureFont.TextWidth(g_sNpcName) div 2, GTop + 110, clWhite, g_sNpcName);
    end;

    if DMaterialMemo.ShowHint then begin
         d := g_WMain2Images.Images[589];   //材料说明
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 102), SurfaceY(GTop + 13), d.ClientRect, d, True);
     if g_MakeTypeWine = 0 then begin    //普通酒
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 20), clWhite, clBlack, '材料的品质是酒品质的基础，品质越好，才越');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 34), clWhite, clBlack, '有可能酿出好酒。还有，如果你有比我这里清');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 48), clWhite, clBlack, '水更甘甜的水，那用它来酿酒就更好了。');
      end else begin   //药酒
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 20), clWhite, clBlack, '药酒的功效主要源自药材，不同的药材会有不');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 34), clWhite, clBlack, '同的效果。据说还有一些独特的药酒，可能会');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 48), clWhite, clBlack, '对配置药酒的瓶子另有要求。');
      end;
    end;

    if g_MakeTypeWine = 0 then begin    //普通酒
      d := g_WMain2Images.Images[585];   //下面图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 98), SurfaceY(GTop + 200), d.ClientRect, d, TRUE);
    end else begin //药酒
      d := g_WMain2Images.Images[587];   //下面图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 98), SurfaceY(GTop + 200), d.ClientRect, d, TRUE);
    end;


    if DMakeWineHelp.ShowHint then begin  //如何酿酒
      if g_MakeTypeWine = 0 then begin    //普通酒
        d := g_WMain2Images.Images[592];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop - 2), d.ClientRect, d, TRUE);
      end else begin  //药酒
        d := g_WMain2Images.Images[593];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop - 2), d.ClientRect, d, TRUE);
      end;
    end;
    if DStartMakeWine.ShowHint then begin
      d := g_WMain2Images.Images[588];   //正在酿酒的背景图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop + 9), d.ClientRect, d, TRUE);
      if GetTickCount - g_dwShowStartMakeWineTick > 150 then begin
        g_dwShowStartMakeWineTick := GetTickCount;
        inc(g_nShowStartMakeWineImg);
        if g_nShowStartMakeWineImg > 18 then begin
          DStartMakeWine.ShowHint := False;
          FrmMain.SendMakeWineItems;
        end;
      end;
      d := g_WMain2Images.Images[610+g_nShowStartMakeWineImg];   //正在酿酒的背景图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 165), SurfaceY(GTop + 9), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DMakeWineHelpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if DStartMakeWine.ShowHint then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft + 35 - AspTextureFont.TextWidth(Hint) div 2), SurfaceY(GTop) + 4, $0099A8AC, clBlack, Hint, [fsBold]);
        Exit;
      end;

      if not TAspDButton(Sender).Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft + 35 - AspTextureFont.TextWidth(Hint) div 2), SurfaceY(GTop) + 4, $008CC6EF, clBlack, Hint, [fsBold]);
      end else begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft + 37 - AspTextureFont.TextWidth(Hint) div 2), SurfaceY(GTop) + 5, $0040BBF1, clBlack, Hint, [fsBold]);
      end;
   end;
end;

procedure TFrmDlg.DMakeWineDeskCloseClick(Sender: TObject; X, Y: Integer);
var
 I: Integer;
begin
  if DStartMakeWine.ShowHint then Exit;
  DWMakeWineDesk.Visible := False;
  DItemBag.Visible := False;
  if g_MakeTypeWine = 0 then begin //普通酒
    for I:=Low(g_WineItem) to High(g_WineItem) do begin
      if g_WineItem[I].ClientItem.s.Name <> '' then begin
        AddItemBag(g_WineItem[I]);
        g_WineItem[I].ClientItem.s.Name := '';
      end;
    end;
  end else begin
    for I:=Low(g_DrugWineItem) to High(g_DrugWineItem) do begin
      if g_DrugWineItem[I].ClientItem.s.Name <> '' then begin  //药酒
        AddItemBag(g_DrugWineItem[I]);
        g_DrugWineItem[I].ClientItem.s.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.DMakeWineHelpClick(Sender: TObject; X, Y: Integer);
begin
  if DStartMakeWine.ShowHint then Exit;
  ShowMakeWine(False); //隐藏下面BUTTON
  DMakeWineHelp.ShowHint := True;   //按下此按钮
end;

procedure TFrmDlg.DMaterialMemoClick(Sender: TObject; X, Y: Integer);
begin
  if DStartMakeWine.ShowHint then Exit;
  ShowMakeWine(True); //显示下面BUTTON
  DMakeWineHelp.ShowHint := False;   //去掉如何酿久按下为FALSE
  DMaterialMemo.ShowHint := True;    //按下此按钮
end;

procedure TFrmDlg.DBMateriaMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  Butt:TAspDButton;
begin
   Butt:=TAspDButton(Sender);
   DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop - 18), Butt.Hint, clWhite, FALSE);
   g_MouseItem := g_WineItem[Butt.Tag];
end;

procedure TFrmDlg.DWMakeWineDeskMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  g_MouseItem.ClientItem.S.Name := '';
end;

procedure TFrmDlg.ShowMakeWine(bool:Boolean);
begin
    DBMateria.Visible := False;
    DBWineSong.Visible := False;
    DBWater.Visible := False;
    DBWineCrock.Visible := False;
    DBAssistMaterial1.Visible := False;
    DBAssistMaterial2.Visible := False;
    DBAssistMaterial3.Visible := False;
    DBDrug.Visible := False;
    DBWine.Visible := False;
    DBWineBottle.Visible := False;
  if g_MakeTypeWine = 0 then begin //普通酒
    DBMateria.Visible := bool;
    DBWineSong.Visible := bool;
    DBWater.Visible := bool;
    DBWineCrock.Visible := bool;
    DBAssistMaterial1.Visible := bool;
    DBAssistMaterial2.Visible := bool;
    DBAssistMaterial3.Visible := bool;
  end else begin  //药酒
    DBDrug.Visible := bool;
    DBWine.Visible := bool;
    DBWineBottle.Visible := bool;
  end;
end;

procedure TFrmDlg.DBMateriaClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
   butt: TAspDButton;
begin
   if DStartMakeWine.ShowHint then Exit;
   butt := TAspDButton(Sender);
   if not g_boItemMoving then begin
      if g_WineItem[butt.Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_WineItem[butt.Tag].ClientItem.s);
         if (g_MovingItem.Item.ClientItem.S.Name <> '')then exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(butt.Tag + 47);
         g_MovingItem.Item := g_WineItem[butt.Tag];
         g_WineItem[butt.Tag].ClientItem.s.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -47) or (g_MovingItem.Index = -48) or (g_MovingItem.Index = -49)
         or (g_MovingItem.Index = -50) or (g_MovingItem.Index = -51) or (g_MovingItem.Index = -52) or (g_MovingItem.Index = -53) then begin
           case butt.Tag of
             0,4..6: if g_MovingItem.Item.ClientItem.S.StdMode <> 8 then Exit;
             1: if g_MovingItem.Item.ClientItem.S.StdMode <> 13 then Exit;
             2: if g_MovingItem.Item.ClientItem.S.StdMode <> 9 then Exit;
             3: if g_MovingItem.Item.ClientItem.S.StdMode <> 12 then Exit;
           end;
           ItemClickSound (g_MovingItem.Item.ClientItem.S);
           if g_WineItem[butt.Tag].ClientItem.s.Name <> '' then begin
              temp := g_WineItem[butt.Tag];
              g_WineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(butt.Tag + 47);
              g_MovingItem.Item := temp
           end else begin
              g_WineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
           end;
      end;
   end;
end;

procedure TFrmDlg.DBMateriaDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  Butt:TAspDButton;
begin
  Butt:=TAspDButton(Sender);
  if Sender = DBMateria then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 8) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBWineSong then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 13) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBWater then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 9) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBWineCrock then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 12) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBAssistMaterial1 then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 8) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBAssistMaterial2 then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 8) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBAssistMaterial3 then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 8) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBDrugDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  Butt:TAspDButton;
begin
  if Sender = DBDrug then begin
    Butt:=TAspDButton(Sender);
    with Butt do begin
      if g_DrugWineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_DrugWineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 14) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBWine then begin
    Butt:=TAspDButton(Sender);
    with Butt do begin
      if g_DrugWineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_DrugWineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 60) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
  if Sender = DBWineBottle then begin
    Butt:=TAspDButton(Sender);
    with Butt do begin
      if g_DrugWineItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_DrugWineItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.ClientItem.S.StdMode = 12) and g_boItemMoving then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBDrugClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
   butt: TAspDButton;
begin
   if DStartMakeWine.ShowHint then Exit;
   butt := TAspDButton(Sender);
   if not g_boItemMoving then begin
      if g_DrugWineItem[butt.Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_DrugWineItem[butt.Tag].ClientItem.s);
         if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingDrugWineItem.Item.ClientItem.S.Name <> '') then exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(butt.Tag + 54);
         g_MovingItem.Item := g_DrugWineItem[butt.Tag];
         g_DrugWineItem[butt.Tag].ClientItem.s.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;  //-97 -98 是金币
      if (g_MovingItem.Index = -45) or (g_MovingItem.Index = -46) then Exit;  //-45 .. -46 是请酒里的烧酒物品
      if (g_MovingItem.Index = -47) or (g_MovingItem.Index = -48) or (g_MovingItem.Index = -49)
         or (g_MovingItem.Index = -50) or (g_MovingItem.Index = -51) or (g_MovingItem.Index = -52) or (g_MovingItem.Index = -53) then Exit; //普通酒物品
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -54) or (g_MovingItem.Index = -55) or (g_MovingItem.Index = -56) then begin
           case butt.Tag of
             0: if g_MovingItem.Item.ClientItem.S.StdMode <> 14 then Exit;
             1: if g_MovingItem.Item.ClientItem.S.StdMode <> 60 then Exit;
             2: if g_MovingItem.Item.ClientItem.S.StdMode <> 12 then Exit;
           end;
           ItemClickSound (g_MovingItem.Item.ClientItem.S);
           if g_DrugWineItem[butt.Tag].ClientItem.s.Name <> '' then begin
              temp := g_DrugWineItem[butt.Tag];
              g_DrugWineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(butt.Tag + 54);
              g_MovingItem.Item := temp
           end else begin
              g_DrugWineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
           end;
      end;
   end;
end;

procedure TFrmDlg.DStartMakeWineClick(Sender: TObject; X, Y: Integer);
begin
  if g_boItemMoving then Exit;
  if DStartMakeWine.ShowHint then Exit;
  if g_MakeTypeWine = 0 then begin //普通酒
     if (g_WineItem[0].ClientItem.s.Name = '') or (g_WineItem[2].ClientItem.s.Name = '') or (g_WineItem[3].ClientItem.s.Name = '')
      or (g_WineItem[4].ClientItem.s.Name = '') or (g_WineItem[5].ClientItem.s.Name = '') or (g_WineItem[6].ClientItem.s.Name = '') then Exit;
  end else begin  //药酒
    if (g_DrugWineItem[0].ClientItem.s.Name = '') or (g_DrugWineItem[1].ClientItem.s.Name = '') or (g_DrugWineItem[2].ClientItem.s.Name = '') then Exit;
  end;
  if DMakeWineHelp.ShowHint then begin
   DMakeWineHelp.ShowHint := False;
   ShowMakeWine(False); //显示下面BUTTON
  end;
  DStartMakeWine.ShowHint := True;
  g_nShowStartMakeWineImg := 0;
end;

procedure TFrmDlg.DDrunkScaleDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc: Trect;
begin
  with DDrunkScale do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[583];
    if d <> nil then begin
       rc := d.ClientRect;
       if (g_MySelf.m_Abil.WineDrinkValue > 0) then begin
       rc.Top := _Max(0,Round(rc.Bottom / g_MySelf.m_Abil.MaxAlcohol * (g_MySelf.m_Abil.MaxAlcohol - g_MySelf.m_Abil.WineDrinkValue)));
       dsurface.Draw (SurfaceX(GLeft) + rc.Left, SurfaceY(GTop)+rc.Top, rc, d, FALSE);
       end;
    end;
  end;
end;

procedure TFrmDlg.DLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc: Trect;
begin
  with DLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;

      if g_MySelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_MySelf.m_Abil.MaxAlcohol * g_MySelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBDrugMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  Butt:TAspDButton;
begin
   Butt:=TAspDButton(Sender);
   DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop - 18), Butt.Hint, clWhite, FALSE);
   g_MouseItem := g_DrugWineItem[Butt.Tag];
end;

procedure TFrmDlg.DHeroLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc: Trect;
begin
  with DHeroLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;
      if g_HeroSelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_HeroSelf.m_Abil.MaxAlcohol * g_HeroSelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DCheckSdoNameShowDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TAspDCheckBox do begin
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex + 1];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      	if not Enabled then
        	dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
      end;
    end;
  end;
end;

procedure TFrmDlg.DCheckSdoNameShowInitialize(Sender: TObject);
begin
  with Sender as TAspDCheckBox do begin
    SetImgIndex(g_qingqingImages, 7);
  end;
end;

procedure TFrmDlg.DNewSdoBasicDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if Tag <> g_btSdoAssistantPage then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 24 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, clWhite, clBlack, Hint);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop) - 2, d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 24 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 1, clWhite, clBlack, Hint);
    end;
  end;
end;

procedure TFrmDlg.DWNewSdoAssistantDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DWNewSdoAssistant do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    case g_btSdoAssistantPage of
      0: begin //基本
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 49, clSilver, clBlack, '基本功能设置', [fsBold]);
          {$IF M2Version <> 2}
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 224, SurfaceY(GTop) + 49, clSilver, clBlack, '自动探索', [fsBold]);
          {$IFEND}
      end;
      1: begin //物品
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 26, SurfaceY(GTop) + 46, clSilver, clBlack, '物品名称', [fsBold]);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 46, clSilver, clBlack, '极品提示', [fsBold]);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 214, SurfaceY(GTop) + 46, clSilver, clBlack, '自动拾取', [fsBold]);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 300, SurfaceY(GTop) + 46, clSilver, clBlack, '显示名字', [fsBold]);
          dsurface.FillRect(Bounds(SurfaceX(GLeft)+26, SurfaceY(GTop)+63, 374, 1), $00808080);
      end;
      2: begin //保护
        {$IF M2Version <> 2}
        d := g_qingqingImages.Images[7];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+70, SurfaceY(GTop) + 217, d.ClientRect, d, TRUE);
        {$IFEND}
        {$IF M2Version <> 2}
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 171, clSilver, clBlack, '英雄保护设置', [fsBold]);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 49, clSilver, clBlack, '自动饮酒', [fsBold]);
        {$IFEND}
        {$IF M2Version <> 2}
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 75, clSilver, clBlack, '普通酒');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 99, clSilver, clBlack, '普通酒(英雄)');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 122, clSilver, clBlack, '药酒');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 148, clSilver, clBlack, '药酒(英雄)');

        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 75, clSilver, clBlack, '% 醉酒度');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 99, clSilver, clBlack, '% 醉酒度');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 122, clSilver, clBlack, '分钟');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 148, clSilver, clBlack, '分钟');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 69, SurfaceY(GTop) + 195, clSilver, clBlack, '躲闪血量:');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 167, SurfaceY(GTop) + 195, clSilver, clBlack, 'HP');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 91, SurfaceY(GTop) + 219, clSilver, clBlack, '怪物狂化保护');

        dsurface.FillRect(Bounds(SurfaceX(GLeft) + 125,SurfaceY(GTop) + 193, 40, 19), clBlack);
        dsurface.FrameRect(Bounds(SurfaceX(GLeft) + 125,SurfaceY(GTop) + 193, 40, 19), $00638494);
        {$IFEND}
      end;
      3: begin //药品

      end;
      4: begin //技能
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 49, clSilver, clBlack, '战士技能', [fsBold]);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 147, SurfaceY(GTop) + 49, clSilver, clBlack, '道士技能', [fsBold]);         //
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 265, SurfaceY(GTop) + 49, clSilver, clBlack, '法师技能', [fsBold]);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 147, SurfaceY(GTop) + 158, clSilver, clBlack, '自动练功', [fsBold]);
        //=================================================
        //dsurface.FrameRect(Rect(SurfaceX(GLeft)+260, SurfaceY(GTop)+69, SurfaceX(GLeft)+390, SurfaceY(GTop)+154), $00638494);
        //==================================================
      end;
      5: begin//按键
        end;
    end;        
  end;
end;

procedure TFrmDlg.NewSdoAssistantPageChanged;
begin
  //基本
  DCheckSdoNameShow.Visible := False;
  DCheckSdoDuraWarning.Visible := False;
  DCheckSdoAvoidShift.Visible := False;
  DCheckSdoExpFiltrate.Visible := False;
  DEdtSdoExpFiltrate.Visible := False;
  DCheckSdoMapDesc.Visible := False;
  DCheckMyHp.Visible := False;
  DCheckBoxHideShiti.Visible := False;
  {$IF M2Version <> 2}
  DCheckAutoButch.Visible := False;
  DCheckAutoUseHuolongzhu.Visible := False;
  DCheckAutoUseJingyuandan.Visible := False;
  DCheckScreenShake.Visible := False;
  DCheckShowHeroStateNumber.Visible := False;
  DCheckHeroLevelHint.Visible := False;
  DCheckHideHumanWing.Visible := False;
  DCheckHideWeaponEffect.Visible := False;
  DCheckBoxHideTitle.Visible := False;
  {$IFEND}
  //物品
  DListViewFilterItem.Visible := False;
  DScrollBarFilterItem.Visible := False;
  DCBFilterItemStdMode.Visible := False;
  DEdtFilterItemStdMode.Visible := False;
  DBtnDefaultFilterItem.Visible := False;
  DCheckBFilterItemPickUpAll.Visible := False;
  //保护
  {$IF M2Version <> 2}
  DCheckSdoAutoDrinkWine.Visible := False;
  DEdtSdoDrunkWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkWine.Visible := False;
  DEdtSdoHeroDrunkWineDegree.Visible := False;
  DCheckSdoAutoDrinkDrugWine.Visible := False;
  DEdtSdoDrunkDrugWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkDrugWine.Visible := False;
  DEdtSdoHeroDrunkDrugWineDegree.Visible := False;
  {$IFEND}
  //药品
  DScrollBoxPro.Visible := False;
  DScrollBarPro.Visible := False;
  //技能
  DCheckSdoLongHit.Visible := False;
  DCheckSdoPosLongHit.Visible := False;
  DCheckSdoAutoWideHit.Visible := False;
  DCheckSdoAutoFireHit.Visible := False;
  DCheckSdoAutoShield.Visible := False;
  {$if M2Version <> 2}
  DCheckSdoZhuri.Visible := False;
  DCheckSdoHeroShield.Visible := False;
  {$IFEND}
  DCheckSdoAutoHide.Visible := False;
  DCheckSdoAutoMagic.Visible := False;
  DEdtSdoAutoMagicTimer.Visible := False;
  {$IF M2Version <> 2}
  DCheckHeroBatterNotMob.Visible := False;
  DCheckShowSpecialDamage.Visible := False;
  DCheckAutoDragInBody.Visible := False;
  {$IFEND}
  //按键页里
  DScrollBoxKey.Visible := False;
  DScrollBarKey.Visible := False;
  (*DCheckSdoStartKey.Visible := False;
  {$IF M2Version <> 2}
  DBtnSdoCallHeroKey.Visible := False;
  DBtnSdoHeroAttackTargetKey.Visible := False;
  DBtnSdoHeroGotethKey.Visible := False;
  DBtnSdoHeroStateKey.Visible := False;
  DBtnSdoHeroGuardKey.Visible := False;
  DBtnSdoSeriesKillKey.Visible := False;
  {$IFEND}
  DBtnSdoAttackModeKey.Visible := False;
  DBtnSdoMinMapKey.Visible := False; *)
  //帮助
  DSdoMemo.Visible := False;
  case g_btSdoAssistantPage of
    0: begin //基本
      DCheckSdoNameShow.Visible := True;
      DCheckSdoDuraWarning.Visible := True;
      DCheckSdoAvoidShift.Visible := True;
      DCheckSdoExpFiltrate.Visible := True;
      DEdtSdoExpFiltrate.Visible := True;
      DCheckSdoMapDesc.Visible := True;
      DCheckMyHp.Visible := True;
      DCheckBoxHideShiti.Visible := True;
      {$IF M2Version <> 2}
      DCheckAutoButch.Visible := True;
      DCheckAutoUseHuolongzhu.Visible := True;
      DCheckAutoUseJingyuandan.Visible := True;
      DCheckScreenShake.Visible := True;
      DCheckShowHeroStateNumber.Visible := True;
      DCheckHeroLevelHint.Visible := True;
      DCheckHideHumanWing.Visible := True;
      DCheckHideWeaponEffect.Visible := True;
      DCheckBoxHideTitle.Visible := True;
      {$IFEND}
    end;
    1: begin //物品
      DListViewFilterItem.Visible := True;
      DScrollBarFilterItem.Visible := True;
      DCBFilterItemStdMode.Visible := True;
      DEdtFilterItemStdMode.Visible := True;
      DBtnDefaultFilterItem.Visible := True;
      DCheckBFilterItemPickUpAll.Visible := True;
    end;
    2: begin //保护
      {$IF M2Version <> 2}
      DCheckSdoAutoDrinkWine.Visible := True;
      DEdtSdoDrunkWineDegree.Visible := True;
      DCheckSdoHeroAutoDrinkWine.Visible := True;
      DEdtSdoHeroDrunkWineDegree.Visible := True;
      DCheckSdoAutoDrinkDrugWine.Visible := True;
      DEdtSdoDrunkDrugWineDegree.Visible := True;
      DCheckSdoHeroAutoDrinkDrugWine.Visible := True;
      DEdtSdoHeroDrunkDrugWineDegree.Visible := True;
      {$IFEND}
    end;
    3: begin //药品
      DScrollBoxPro.Visible := True;
      DScrollBarPro.Visible := True;
    end;
    4: begin //技能
      DCheckSdoLongHit.Visible := True;
      DCheckSdoAutoWideHit.Visible := True;
      DCheckSdoAutoFireHit.Visible := True;
      DCheckSdoPosLongHit.Visible := not ClientConf.boNoCanUseComparThrust;
      {$if M2Version <> 2}
      if ClientConf.boNoCanUseComparThrust then
      	DCheckSdoZhuri.GTop := DCheckSdoPosLongHit.GTop
    	else DCheckSdoZhuri.GTop := 169;
      DCheckSdoZhuri.Visible := True;
      DCheckSdoHeroShield.Visible := True;
      {$IFEND}
      DCheckSdoAutoShield.Visible := True;
      DCheckSdoAutoHide.Visible := True;
      DCheckSdoAutoMagic.Visible := True;
      DEdtSdoAutoMagicTimer.Visible := True;
      {$IF M2Version <> 2}
      DCheckHeroBatterNotMob.Visible := True;
      {$IFEND}
      {$IF M2Version <> 2}
      DCheckShowSpecialDamage.Visible := True;
      DCheckAutoDragInBody.Visible := True;
      {$IFEND}
    end;
    5: begin//按键
      DScrollBoxKey.Visible := True;
      DScrollBarKey.Visible := True;
    end;
    6: begin//帮助
      DSdoMemo.Visible := True;
    end;
  end;
end;

procedure TFrmDlg.DNewSdoBasicClick(Sender: TObject; X, Y: Integer);
begin
  g_btSdoAssistantPage := TAspDButton(Sender).Tag;
  NewSdoAssistantPageChanged();
end;

procedure TFrmDlg.DEdtSdoAutoMagicTimerDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  Color: TColor;
  Rc: TRECT;
begin
  with Sender as TAspDEdit do begin
    if Enabled then begin
      if Moveed then
        Color := $00387B9C
      else Color := $00638494;    
      if Focused then Color := $005993BD;
    end else Color := clGray;
    dsurface.FillRect(ClientRect, clBlack);
    dsurface.FrameRect(ClientRect, Color);
  end;
end;

procedure TFrmDlg.DNewSdoAssistantCloseClick(Sender: TObject; X,
  Y: Integer);
begin
  FrmMain.OpenSdoAssistant;
end;

procedure TFrmDlg.DBtnSdoCallHeroKeyDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   TextColor: TColor;
   Color: TColor;
begin
  with Sender as TAspDButton do begin
    if MouseMoveing then begin
      Color := $005993BD;
      TextColor := clYellow;
    end else begin
      Color := $00638494;
      TextColor := clWhite;
    end;
    dsurface.FillRect(ClientRect, clBlack);
    if Focused then begin
      Color := $005993BD;
      TextColor := clAqua;
      dsurface.FrameRect(Rect(ClientRect.Left+1, ClientRect.Top+1, ClientRect.Right-1, ClientRect.Bottom-1), Color);
    end;
    dsurface.FrameRect(ClientRect, Color);
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 56-AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, TextColor, clBlack, Hint);
  end;
end;

procedure TFrmDlg.DCheckSdoNameShowClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCheckSdoNameShow then begin
    g_boShowName := DCheckSdoNameShow.Checked
  end;

  if Sender = DCheckSdoDuraWarning then begin
    g_boDuraWarning := DCheckSdoDuraWarning.Checked;
  end;
  if Sender = DCheckSdoAvoidShift then begin
    g_boNoShift := DCheckSdoAvoidShift.Checked;
  end;

  if Sender = DCheckBFilterItemPickUpAll then begin
      g_boAutoPuckUpItem := DCheckBFilterItemPickUpAll.Checked;
  end;

  //自动练功DCheckSdoAutoMagic
  if Sender = DCheckSdoAutoMagic then begin
    g_boAutoMagic := DCheckSdoAutoMagic.Checked;
  end;
  //经验显示过滤
  if Sender = DCheckSdoExpFiltrate then begin
    g_boExpFiltrate := DCheckSdoExpFiltrate.Checked;
  end;
  //显示小地图标实
  if Sender = DCheckSdoMapDesc then begin
    g_boShowMimiMapDesc := DCheckSdoMapDesc.Checked;
  end;
  //显示英雄状态数字
  if Sender = DCheckShowHeroStateNumber then begin
    g_boShowHeroStateNumber := DCheckShowHeroStateNumber.Checked;
  end;
  {$IF M2Version <> 2}
  if Sender = DCheckHideHumanWing then begin
    g_boHideHumanWing := DCheckHideHumanWing.Checked;
  end;
  if Sender = DCheckHideWeaponEffect then begin
    g_boHideWeaponEffect := DCheckHideWeaponEffect.Checked;
  end;
  if Sender = DCheckBoxHideShiti then begin
    g_boHideHummanShiTi := DCheckBoxHideShiti.Checked;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DCheckSdoCommonHpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCheckSdoStartKey then begin
    if not DCheckSdoStartKey.Checked then begin
      with FrmMain do begin
        ActSeriesKillKey.Enabled := False;
        ActCallHeroKey.Enabled := False;
        ActCallHero1Key.Enabled := False;
        ActHeroAttackTargetKey.Enabled := False;
        ActHeroGotethKey.Enabled := False;
        ActHeroStateKey.Enabled := False;
        ActHeroGuardKey.Enabled := False;
        ActAttackModeKey.Enabled := False;
        ActMinMapKey.Enabled := False;
      end;
    end else begin
      with FrmMain do begin
        ActSeriesKillKey.Enabled := True;
        ActCallHeroKey.Enabled := True;
        ActCallHero1Key.Enabled := True;
        ActHeroAttackTargetKey.Enabled := True;
        ActHeroGotethKey.Enabled := True;
        ActHeroStateKey.Enabled := True;
        ActHeroGuardKey.Enabled := True;
        ActAttackModeKey.Enabled := True;
        ActMinMapKey.Enabled := True;
      end;
    end;
  end;
  //未开通的功能
  if Sender = DCheckSdoAutoDrinkWine then begin
    g_boAutoEatWine := DCheckSdoAutoDrinkWine.Checked;
  end;
  if Sender = DCheckSdoHeroAutoDrinkWine then begin
    g_boAutoEatHeroWine := DCheckSdoHeroAutoDrinkWine.Checked;
  end;
  if Sender = DCheckSdoAutoDrinkDrugWine then begin
    g_boAutoEatDrugWine := DCheckSdoAutoDrinkDrugWine.Checked;
  end;
  if Sender = DCheckSdoHeroAutoDrinkDrugWine then begin
    g_boAutoEatHeroDrugWine := DCheckSdoHeroAutoDrinkDrugWine.Checked;
  end;
end;

procedure TFrmDlg.DEdtSdoCommonHpChange(Sender: TObject);
begin
  if Sender = DEdtSdoAutoMagicTimer then begin
    if DEdtSdoAutoMagicTimer.Text = '' then Exit;
    g_nAutoMagicTime := StrToInt(DEdtSdoAutoMagicTimer.Text);
  end;

  if Sender = DEdtSdoDrunkWineDegree then begin
    if DEdtSdoDrunkWineDegree.Text = '' then Exit;
    g_btEditWine := StrToInt(DEdtSdoDrunkWineDegree.Text);
  end;

  if Sender = DEdtSdoHeroDrunkWineDegree then begin
    if DEdtSdoHeroDrunkWineDegree.Text = '' then Exit;
    g_btEditHeroWine := StrToInt(DEdtSdoHeroDrunkWineDegree.Text);
  end;

  if Sender = DEdtSdoDrunkDrugWineDegree then begin
    if DEdtSdoDrunkDrugWineDegree.Text = '' then Exit;
    g_btEditDrugWine := StrToInt(DEdtSdoDrunkDrugWineDegree.Text);
  end;

  if Sender = DEdtSdoHeroDrunkDrugWineDegree then begin
    if DEdtSdoHeroDrunkDrugWineDegree.Text = '' then Exit;
    g_btEditHeroDrugWine := StrToInt(DEdtSdoHeroDrunkDrugWineDegree.Text);
  end;

  if Sender = DEdtSdoExpFiltrate then begin
    if DEdtSdoExpFiltrate.Text = '' then Exit;
    g_dwEditExpFiltrate := Str_ToInt(DEdtSdoExpFiltrate.Text,2000);
  end;

end;

procedure TFrmDlg.DCheckSdoLongHitClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCheckSdoLongHit then begin
    if FrmMain.GetMagicByID(12) or g_boCan4LongHit then //刺杀
      g_boLongHit := DCheckSdoLongHit.Checked
    else begin
      DCheckSdoLongHit.Checked := False;
      g_boLongHit := False;
      Exit;
    end;
  end else
  if Sender = DCheckSdoPosLongHit then begin
    if FrmMain.GetMagicByID(12) or g_boCan4LongHit then //隔位刺杀
      g_boPosLongHit := DCheckSdoPosLongHit.Checked
    else begin
      DCheckSdoPosLongHit.Checked := False;
      g_boLongHit := False;
      Exit;
    end;
  end else
  if Sender = DCheckSdoAutoWideHit then begin
    if FrmMain.GetMagicByID(25) or FrmMain.GetMagicByID(90) then begin //半月，圆月弯刀
       g_boAutoWideHit := DCheckSdoAutoWideHit.Checked;
    end else begin
       DCheckSdoAutoWideHit.Checked := False;
       g_boAutoWideHit := False;
       Exit;
    end;
  end else
  if Sender = DCheckSdoAutoFireHit then begin
    if not FrmMain.GetMagicByID(26) then begin //烈火
       DCheckSdoAutoFireHit.Checked := False;
       g_boAutoFireHit := False;
       Exit;
    end;
    g_boAutoFireHit := DCheckSdoAutoFireHit.Checked;
  end else
  if Sender = DCheckSdoZhuri then begin
    if not FrmMain.GetMagicByID(74) then begin //逐日
       DCheckSdoZhuri.Checked := False;
       g_boAutoZhuRiHit := False;
       Exit;
    end;
    g_boAutoZhuRiHit := DCheckSdoZhuri.Checked;
  end else
  if Sender = DCheckSdoAutoShield then begin
    if FrmMain.GetMagicByID(31) or FrmMain.GetMagicByID(66){4级魔法盾} then begin //自动开盾
       g_boAutoShield := DCheckSdoAutoShield.Checked;
    end else begin
       DCheckSdoAutoShield.Checked := False;
       g_boAutoShield := False;
       Exit;
    end;
  end else
  if Sender = DCheckSdoAutoHide then begin
    if not FrmMain.GetMagicByID(18) then begin //自动隐身
       DCheckSdoAutoHide.Checked := False;
       g_boAutoHide := False;
       Exit;
    end;
    g_boAutoHide := DCheckSdoAutoHide.Checked;
  end else
  if Sender = DCheckSdoHeroShield then begin
     if g_HeroSelf <> nil then begin
       if g_HeroSelf.m_btJob = 1 then begin
         if DCheckSdoHeroShield.Checked then FrmMain.SendHeroAutoOpenDefence(1)
         else FrmMain.SendHeroAutoOpenDefence(2);
       end else DCheckSdoHeroShield.Checked := False;
     end else DCheckSdoHeroShield.Checked := False;
     g_boHeroAutoDEfence := DCheckSdoHeroShield.Checked;
  end else
  if Sender = DCheckHeroBatterNotMob then begin
    if g_HeroSelf <> nil then begin
      if DCheckHeroBatterNotMob.Checked then FrmMain.SendHeroUseBatterToMon(1)
      else FrmMain.SendHeroUseBatterToMon(2);
    end else DCheckHeroBatterNotMob.Checked := False;
  end else
  if Sender = DCheckShowSpecialDamage then begin
    g_boShowSpecialDamage := DCheckShowSpecialDamage.Checked;
  end else
  {$IF M2Version <> 2}
  if Sender = DCheckAutoDragInBody then begin
    g_boAutoDragInBody := DCheckAutoDragInBody.Checked;
  end else
  if Sender = DCheckBoxHideTitle then begin
    g_boHideTitle := DCheckBoxHideTitle.Checked;
    if DCheckBoxHideTitle.Checked then
      frmMain.SendHideTitle(0)
    else frmMain.SendHideTitle(1);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBtnSdoCallHeroKeyKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  CombinationKey: Integer;
begin
  if Key in [DBtnSdoSeriesKillKey.Tag,DBtnSdoCallHeroKey.Tag,DBtnSdoCallHero1Key.Tag,DBtnSdoHeroAttackTargetKey.Tag,DBtnSdoHeroGotethKey.Tag,DBtnSdoHeroStateKey.Tag,DBtnSdoHeroGuardKey.Tag,DBtnSdoAttackModeKey.Tag,DBtnSdoMinMapKey.Tag] then begin
    Exit;
  end;
  if key in [0..7,9..11,12,14..15,21..32,41..45,47..92,94..123,144..145,186..192,219..222,226] then begin
    TAspDButton(Sender).Hint:='';
    CombinationKey:=0;
    if ssCtrl in Shift then
      TAspDButton(Sender).Hint := 'Ctrl+';
    if ssShift in Shift then
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Shift+';
    if ssAlt in Shift then
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Alt+';
    case Key of
     0..7,9..11,14..15,21..26,28..32,41..44,47..92,94..95:
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key);
     12: TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Num 5';
     27: TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Esc';
     45: TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Insert';
     96..105: //小键盘
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Num '+Char(key-48);
     106..111:
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Num '+Char(key-64);
     112..122: //功能键
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'F'+IntToStr(Key-112+1);
     123: begin
       frmMain.OpenSdoAssistant();
       Exit;
     end;
     144: //Pause 小键开启灯那个
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Pause';
     145: //Scroll Lock
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+'Scroll Lock';
     192:
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key-96);
     186:
       TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key-127);
     187..191:
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key-144);
     219..221:
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key-128);
     222:
       TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key-183);
     226:
      TAspDButton(Sender).Hint := TAspDButton(Sender).Hint+Char(key-134);
    else
      //TAspDButton(Sender).Hint := inttostr(key);
    end;
  //if  not DCheckSdoStartKey.Checked then begin TAspDButton(Sender).Tag := Key //else begin
      if Pos ('Ctrl',TAspDButton(Sender).Hint) > 0 then  CombinationKey := 16384;
      if Pos ('Shift',TAspDButton(Sender).Hint) > 0 then  CombinationKey := CombinationKey + 8192;
      if Pos ('Alt',TAspDButton(Sender).Hint) > 0 then  CombinationKey := CombinationKey + 32768;
      TAspDButton(Sender).Tag := Key;
    if Sender = DBtnSdoSeriesKillKey then begin
      frmMain.ActSeriesKillKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoCallHeroKey then begin
      FrmMain.ActCallHeroKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoCallHero1Key then begin
      frmMain.ActCallHero1Key.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroAttackTargetKey then begin
      FrmMain.ActHeroAttackTargetKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroGotethKey then begin
      FrmMain.ActHeroGotethKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroStateKey then begin
      FrmMain.ActHeroStateKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroGuardKey then begin
      FrmMain.ActHeroGuardKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoAttackModeKey then begin
      FrmMain.ActAttackModeKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoMinMapKey then begin
      FrmMain.ActMinMapKey.ShortCut := CombinationKey + Key;
    end;
  //end;
  end;
end;

procedure TFrmDlg.DBtnSdoCallHeroKeyMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbRight then begin
    if Sender = DBtnSdoSeriesKillKey then begin
      DBtnSdoSeriesKillKey.Hint := '';
      DBtnSdoSeriesKillKey.Tag := 0;
      frmMain.ActSeriesKillKey.ShortCut := 0;
    end else if Sender = DBtnSdoCallHeroKey then begin
      DBtnSdoCallHeroKey.Hint := '';
      DBtnSdoCallHeroKey.Tag := 0;
      FrmMain.ActCallHeroKey.ShortCut := 0;
    end else if Sender = DBtnSdoCallHero1Key then begin
      DBtnSdoCallHero1Key.Hint := '';
      DBtnSdoCallHero1Key.Tag := 0;
      FrmMain.ActCallHero1Key.ShortCut := 0;
    end else if Sender = DBtnSdoHeroAttackTargetKey then begin
      DBtnSdoHeroAttackTargetKey.Hint := '';
      DBtnSdoHeroAttackTargetKey.Tag := 0;
      FrmMain.ActHeroAttackTargetKey.ShortCut := 0;
    end else if Sender = DBtnSdoHeroGotethKey then begin
      DBtnSdoHeroGotethKey.Hint := '';
      DBtnSdoHeroGotethKey.Tag := 0;
      FrmMain.ActHeroGotethKey.ShortCut := 0;
    end else if Sender = DBtnSdoHeroStateKey then begin
      DBtnSdoHeroStateKey.Hint := '';
      DBtnSdoHeroStateKey.Tag := 0;
      FrmMain.ActHeroStateKey.ShortCut := 0;
    end else if Sender = DBtnSdoHeroGuardKey then begin
      DBtnSdoHeroGuardKey.Hint := '';
      DBtnSdoHeroGuardKey.Tag := 0;
      FrmMain.ActHeroGuardKey.ShortCut := 0;
    end else if Sender = DBtnSdoAttackModeKey then begin
      DBtnSdoAttackModeKey.Hint := '';
      DBtnSdoAttackModeKey.Tag := 0;
      FrmMain.ActAttackModeKey.ShortCut := 0;
    end else if Sender = DBtnSdoMinMapKey then begin
      DBtnSdoMinMapKey.Hint := '';
      DBtnSdoMinMapKey.Tag := 0;
      FrmMain.ActMinMapKey.ShortCut := 0;
    end;
  end;
end;

procedure TFrmDlg.DEdtSdoCommonHpKeyPress(Sender: TObject; var Key: Char);
begin
  if not (Key in ['0'..'9', #8, #13]) then Key := #0;
end;

procedure TFrmDlg.DWChallengeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DWChallenge do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFont.TextOut (GLeft + 30, GTop + 137, clYellow, FrmMain.CharName);
    AspTextureFont.TextOut (GLeft + 30, GTop + 36, clYellow, g_sChallengeWho);
    AspTextureFont.TextOut (GLeft + 80, GTop + 202, clLime, IntToStr(g_nChallengeGold));
    AspTextureFont.TextOut (GLeft + 80, GTop + 101, clLime, IntToStr(g_nChallengeRemoteGold));
    AspTextureFont.TextOut (GLeft + 196 - AspTextureFont.TextWidth(IntToStr(g_nChallengeDiamond)) div 2, GTop + 176, clLime, IntToStr(g_nChallengeDiamond));
    AspTextureFont.TextOut (GLeft + 196 - AspTextureFont.TextWidth(IntToStr(g_nChallengeRemoteDiamond)) div 2, GTop + 75, clLime, IntToStr(g_nChallengeRemoteDiamond));
    AspTextureFont.TextOut (GLeft + 179, GTop + 163, clWhite, g_sGameDiaMond);
    AspTextureFont.TextOut (GLeft + 179, GTop + 62, clWhite, g_sGameDiaMond);
    AspTextureFont.TextOut (GLeft + 52, GTop + 270, clWhite, '挑战中将已武馆教头的挑战规');
    AspTextureFont.TextOut (GLeft + 28, GTop + 284, clWhite, '则做为评判胜负的标准，如果你同');
    AspTextureFont.TextOut (GLeft + 28, GTop + 298, clWhite, '意就请开始挑战吧。');
  end;
end;

procedure TFrmDlg.DChallengeGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DChallengeGrid.ColCount;
  if idx in [0..3] then begin
    g_MouseItem := g_ChallengeItems[idx];
    with DChallengeGrid do
      ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                        SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DChallengeGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DChallengeGrid.ColCount;
  if idx in [0..3] then begin
    if g_ChallengeItems[idx].ClientItem.s.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_ChallengeItems[idx].ClientItem.s.Looks);
      if d <> nil then begin
        with DChallengeGrid do begin
           dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_ChallengeItems[idx].ClientItem.s.StdMode = 17 then begin
            AspTextureFont.TextOut (SurfaceX(Rect.Left+35-AspTextureFont.TextWidth(IntToStr(g_ChallengeItems[idx].ClientItem.Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_ChallengeItems[idx].ClientItem.Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DChallengeGridGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
   I, mi, idx: integer;
   int: Byte;
begin
   if not g_boChallengeEnd and (GetTickCount > g_dwChallengeActionTick) then begin
      if not g_boItemMoving then begin
         idx := ACol + ARow * DChallengeGrid.ColCount;
         if idx in [0..3] then begin
            if g_ChallengeItems[idx].ClientItem.s.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 57;
               g_MovingItem.Item := g_ChallengeItems[idx];
               g_ChallengeItems[idx].ClientItem.s.Name := '';
               ItemClickSound (g_MovingItem.Item.ClientItem.S);
            end;
         end else begin
            if idx = 4 then begin
                int := 0;
                DMessageDlg ('请输入'+g_sGameDiaMond+'数量，在0-9999之间', [mbOk, mbAbort]);
                if DlgEditText = '' then int := 1;
                for I:=1 to length(DlgEditText) do
                  if (DlgEditText[i] <'0') or ( DlgEditText[i] > '9') then int := 2;
                if length(DlgEditText) > 4 then int := 3;
                case int of
                  0: begin
                    if (StrToInt(DlgEditText) > 0) and (StrToInt(DlgEditText) < 10000) then begin
                      FrmMain.SendChangeChallengeDiamond(StrToInt(DlgEditText));
                    end;
                  end;
                  1:DMessageDlg ('内容不能为空！', [mbOk]);
                  2:DMessageDlg ('输入的'+g_sGameDiaMond+'错误', [mbOk]);
                  3:DMessageDlg (g_sGameDiaMond + '数量不能超过4位', [mbOk]);
                end;
            end;
         end;
      end else begin
         mi := g_MovingItem.Index;
         if (mi >= 0) or (mi <= -57) and (mi > -63) then begin
            ItemClickSound (g_MovingItem.Item.ClientItem.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
               g_ChallengeDlgItem := g_MovingItem.Item;
               FrmMain.SendAddChallengeItem (g_ChallengeDlgItem);
               g_dwChallengeActionTick := GetTickCount + 4000;
            end else
               AddChallengeItem (g_MovingItem.Item);
            g_MovingItem.Item.ClientItem.S.name := '';
         end;
         if mi = -98 then DDGoldClick (self, 0, 0);
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DChallengeCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChallengeActionTick then begin
      CloseChallengeDlg;
      FrmMain.SendCancelChallenge;
   end;
end;

procedure TFrmDlg.DRChallengeGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DRChallengeGrid.ColCount;
  if idx in [0..3] then begin
    g_MouseItem := g_ChallengeRemoteItems[idx];
    with DRChallengeGrid do
    	ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                      	SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DRChallengeGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DRChallengeGrid.ColCount;
  if idx in [0..3] then begin
    if g_ChallengeRemoteItems[idx].ClientItem.s.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_ChallengeRemoteItems[idx].ClientItem.s.Looks);
      if d <> nil then begin
        with DRChallengeGrid do begin
           dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_ChallengeRemoteItems[idx].ClientItem.s.StdMode = 17 then begin
             AspTextureFont.TextOut (SurfaceX(Rect.Left+35-AspTextureFont.TextWidth(IntToStr(g_ChallengeRemoteItems[idx].ClientItem.Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_ChallengeRemoteItems[idx].ClientItem.Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DChallengeOKClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
   if GetTickCount > g_dwChallengeActionTick then begin
      FrmMain.SendChallengeEnd;
      g_dwChallengeActionTick := GetTickCount + 4000;
      g_boChallengeEnd := TRUE;
      if g_boItemMoving then begin
         mi := g_MovingItem.Index;
         if (mi <= -57) and (mi > -61) then begin
            AddChallengeItem (g_MovingItem.Item);
            g_boItemMoving := FALSE;
            g_MovingItem.Item.ClientItem.S.name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DChallengeGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then Exit;
   if not g_boChallengeEnd and (GetTickCount > g_dwChallengeActionTick) then begin
    PlaySound (s_money);
    DialogSize := 1;
    DMessageDlg ('你想抵押多少' +g_sGoldName + '？', [mbOk, mbAbort]);
    GetValidStrVal (DlgEditText, valstr, [' ']);
    dgold := Str_ToInt (valstr, 0);
    if (dgold <= (g_nChallengeGold+g_MySelf.m_nGold)) and (dgold > 0) then begin
       FrmMain.SendChangeChallengeGold (dgold);
       g_dwChallengeActionTick := GetTickCount + 4000;
    end;
   end;
end;

procedure TFrmDlg.btnRecvChrCloseClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
begin
  dwRecoverChr.Visible := False;
  if g_DelChrList <> nil then begin
    if g_DelChrList.Count > 0 then begin//20080629
      for I := 0 to g_DelChrList.Count - 1 do begin //20080304 释放
        if pTDelChr(g_DelChrList.Items[I]) <> nil then Dispose(pTDelChr(g_DelChrList.Items[I]));
      end;
    end;
    FreeAndNil(g_DelChrList);
  end;
end;

procedure TFrmDlg.dgrdRecoverNameGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
   Idx: integer;
   DelChr: pTDelChr;
   sJob: string;
   Color: TColor;
begin
   idx := ACol + ARow * dgrdRecoverName.ColCount;
   if idx in [0..9] then begin
     if g_DelChrList.Count >= idx+1 then begin
       if g_DelChrList.Items[idx] <> nil then begin
         DelChr := pTDelChr(g_DelChrList.Items[idx]);
         if DelChr <> nil then begin
           if DelChr.ChrInfo.Name <> '' then begin
              with dgrdRecoverName do begin
                if Idx = dgrdRecoverName.Tag then begin
                   Color := clRed;
                   AspTextureFont.TextOut (SurfaceX(Rect.Left), SurfaceY(Rect.Top)+4, Color, '√');
                end else Color := clWhite;
                AspTextureFont.TextOut (SurfaceX(Rect.Left) + 14, SurfaceY(Rect.Top)+4, Color, DelChr.ChrInfo.Name);
                AspTextureFont.TextOut (SurfaceX(Rect.Left) + 100, SurfaceY(Rect.Top)+4,Color, IntToStr(DelChr.ChrInfo.Level)+'级');
                case DelChr.ChrInfo.Job of
                  0: sJob := '武士';
                  1: sJob := '法师';
                  2: sJob := '道士';
                end;
                AspTextureFont.TextOut (SurfaceX(Rect.Left) + 140, SurfaceY(Rect.Top)+4, Color, sJob);
                if DelChr.ChrInfo.sex = 0 then
                  AspTextureFont.TextOut (SurfaceX(Rect.Left) + 190, SurfaceY(Rect.Top)+4, Color, '男')
                else
                  AspTextureFont.TextOut (SurfaceX(Rect.Left) + 190, SurfaceY(Rect.Top)+4, Color, '女');
              end;
           end;
         end;
       end;
     end;
   end;
end;

procedure TFrmDlg.dgrdRecoverNameGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx: Integer;
begin
  Idx := ACol + ARow * dgrdRecoverName.ColCount;
  if Idx in [0..9] then begin
    dgrdRecoverName.Tag := Idx;
  end;
end;

procedure TFrmDlg.btnRecoverClick(Sender: TObject; X, Y: Integer);
begin
  if dgrdRecoverName.Tag in [0..9] then begin
    FrmMain.SendResDelChr(pTDelChr(g_DelChrList.Items[dgrdRecoverName.Tag]).ChrInfo.Name);
    dgrdRecoverName.Tag := 20;
    btnRecvChrCloseClick (self, 0, 0);
  end;
end;

procedure TFrmDlg.DWChallengeMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DEdtSdoCommonHpTimerKeyDown(Sender: TObject;
  var Key: Word; Shift: TShiftState);
begin
  if Key = 123 then begin
    frmMain.OpenSdoAssistant();
  end;
end;

procedure TFrmDlg.DCheckSdoExpFiltrateMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  Butt:TAspDCheckBox;
  sMsg:String;
begin
  if g_MySelf = nil then Exit;
  Butt:=TAspDCheckBox(Sender);
  if Sender = DCheckSdoNameShow then sMsg := '选中此项将全屏显示玩家名字';
  if Sender = DCheckSdoDuraWarning then sMsg := '选中此项将在装备低持久时\进行提示';
  if Sender = DCheckSdoAvoidShift then sMsg := '选中此项将不需要按下SHIFT\键也能攻击其他玩家';
  if Sender = DCheckSdoExpFiltrate then sMsg := '选中此项将隐藏聊天框中低\于“右边的编辑框内”的经验值增长提示';
  if Sender = DCheckSdoMapDesc then sMsg := '选中此项将自动显示地图标实';
  if Sender = DCheckAutoButch then sMsg := '选中此项将在使用(Alt+鼠标\左键)时持续探索怪物身上的\宝物';
  if Sender = DCheckAutoUseHuolongzhu then sMsg := '选中此项将自动使用探索得\到的“火龙珠”';
  if Sender = DCheckAutoUseJingyuandan then sMsg := '选中此项将自动使用探索得\到的“精元丹”';
  if Sender =  DCheckScreenShake then sMsg := '勾选此项后触发相应事件屏幕将震动';
  if Sender = DCheckMyHp then sMsg := '勾选此项将高亮自己和英雄\的血条显示';
  if Sender = DCheckHeroBatterNotMob then sMsg := '勾选此项英雄不施放连击打怪，不影响玩家间PK';
  if Sender = DCheckBFilterItemPickUpAll then sMsg := '勾选此项将自动拣取地面掉\落的物品';
  if Sender = DCheckHideHumanWing then sMsg := '勾选此项将不显示人物翅膀效果，可避免\电脑较差且翅膀显示过多而导致卡的问题';
  if Sender = DCheckHideWeaponEffect then sMsg := '勾选此项将不显示武器发光效果，可避免\电脑较差且武器发光显示过多而导致卡的问题';
  if Sender = DCheckBoxUseSuperMedica then sMsg := '根据玩家失血的血量使用药品，而不是剩余血量。\血量设置相同的情况下，排列靠后的药品优先使用\。-HP/-MP设置为0则无效';
  if Sender = DCheckBoxRenewHPSpecial then sMsg := '此类药品名字中包含“特效”';
  if Sender = DCheckBoxRenewMPSpecial then sMsg := '此类药品名字中包含“特效”';
  if Sender = DCheckBoxHideTitle then sMsg := '勾选此项将隐藏自己的称号';
  with Butt as TAspDCheckBox do
    DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop + GHeight), sMsg, clYellow, FALSE);
end;

procedure TFrmDlg.DWNewSdoAssistantMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWNewStateHeroDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  nTitleWidth: Integer;
  sTitleName: string;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHero do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      frmMain.Canvas.Font.Style := [fsBold];
      if g_boIsHeroInternalForce then begin  //有内功
        d := WLib.Images[2245-DPNewStateHeroTab.ActivePage];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+14, SurfaceY(GTop)+55, d.ClientRect, d, True);
        if DPNewStateHeroTab.ActivePage = 0 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+74, SurfaceY(GTop)+59, Color, clBlack, '基础', [fsBold]);
        if DPNewStateHeroTab.ActivePage = 1 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+154, SurfaceY(GTop)+59, Color, clBlack, '内功', [fsBold]);
      end;
      frmMain.Canvas.Font.Style := [];
    end;
    AspTextureFont.TextOut(SurfaceX(GLeft + 142 - frmMain.Canvas.TextWidth(g_HeroSelf.m_sUserName) div 2),
                     SurfaceY(GTop + 38), g_HeroSelf.m_nNameColor, g_HeroSelf.m_sUserName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWNewStateHero.SetImgIndex(g_WUI1Images, 2232);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  g_HeroMouseStateItem.ClientItem.S.Name := '';
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroNGPageTab1 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateHeroNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 47, clSilver, clBlack, '当前内功等级  '+IntToStr(g_dwHeroInternalForceLevel));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 67, clSilver, clBlack, '当前内功经验  '+IntToStr(g_dwHeroExp69));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 87, clSilver, clBlack, '升级内功经验  '+IntToStr(g_dwHeroMaxExp69));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 107, clSilver, clBlack, Format('内 力 值  %d/%d', [g_HeroSelf.m_Skill69NH, g_HeroSelf.m_Skill69MaxNH]));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 127, clSilver, clBlack, '内功恢复速度  '+IntToStr(g_nHeroInternalRecovery));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 147, clSilver, clBlack, '内功伤害增加  '+IntToStr(g_nHeroInternalHurtAdd));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 167, clSilver, clBlack, '内功伤害减免  '+IntToStr(g_nHeroInternalHurtRelief));
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2234);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab2DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateHeroNGPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [HeroInternalForceMagicPage+1, (g_HeroInternalForceMagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab3DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  wXueWeiTiao: Word;
{$IFEND}
begin
{$IF M2Version = 1}
  if g_HeroSelf = nil then exit;
  with DWNewStateHeroNGPageTab3 do begin
    if WLib <> nil then begin //20080701
      if g_HeroSelf.m_btSex = 1 then begin //女
        if HeroStatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 4]
        else d := WLib.Images[FaceIndex + 5];
      end else begin
        if HeroStatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 6]
        else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    //右上角标志
    if HeroStatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1171]
    else d := g_WMainImages.Images[830+HeroStatePulsePage];
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft) + 144, SurfaceY(GTop) + 11, d.ClientRect, d, TRUE);
    //经络穴位条
    if HeroStatePulsePage = 0 then begin//冲脉,冲脉读老资源
      if not g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse then
        wXueWeiTiao := 860
      else wXueWeiTiao := 861+g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[wXueWeiTiao];
      if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d.ClientRect, d);
    end else begin
      if not g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse then
        wXueWeiTiao := 2280
      else wXueWeiTiao := 2281+g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel;
      d := g_WUI1Images.Images[wXueWeiTiao-(HeroStatePulsePage-1) * 10];
      if d <> nil then
        dsurface.DrawBlend(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, d.ClientRect, d);
    end;
    //穴位针位
    if HeroStatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1172]
    else d := g_WMainImages.Images[840+HeroStatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d.ClientRect, d, TRUE);

    if HeroStatePulsePage <> 4 then begin
      if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
        case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
          0: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
          end;
          1: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          2: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          3: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          4: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          5: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
        end;
      end else begin
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab3Initialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2231);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2239);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  ax, ay, Idx: Integer;
  bbx, bby: Integer;
  wm: TAspWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroPageTab1 do begin
    if WLib <> nil then begin
      if g_HeroSelf.m_btSex = 1 then
        d := WLib.Images[FaceIndex-14]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    bbx := GLeft+31;
    bby := GTop+56;
    if g_HeroItems[U_DRESS].ClientItem.S.Name <> '' then begin //衣服
      Idx := g_HeroItems[U_DRESS].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        with g_HeroItems[U_DRESS].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_DRESS].nIndex);
              if g_DrawHeroUseItems[U_DRESS].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
    //自己人物发型  2007.10.16
    Idx := 1799;
    if g_HeroSelf.m_btSex = 1 then  Idx := 2399;
    if g_HeroSelf.m_btSex = 0 then begin  //男
      if g_HeroSelf.m_btHair <> 0 then begin
        if Idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        end;
      end;
    end else if g_HeroSelf.m_btHair <> 1 then begin
      if Idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
    end;
    if g_HeroItems[U_WEAPON].ClientItem.S.Name <> '' then begin
      Idx := g_HeroItems[U_WEAPON].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with g_HeroItems[U_WEAPON].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_WEAPON].nIndex);
              if g_DrawHeroUseItems[U_WEAPON].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
    //斗笠 20080417
    if g_HeroItems[U_ZHULI].ClientItem.S.Name <> '' then begin
      if g_HeroItems[U_ZHULI].ClientItem.S.Shape <> 2  then begin
        Idx := g_HeroItems[U_ZHULI].ClientItem.S.Looks;
        if Idx >= 0 then begin
          d := FrmMain.GetWStateImg(Idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (g_HeroItems[U_HELMET].ClientItem.S.Looks = 103) or (g_HeroItems[U_HELMET].ClientItem.S.Looks = 106) or (g_HeroItems[U_HELMET].ClientItem.S.Looks = 344) or (g_HeroItems[U_HELMET].ClientItem.S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            Idx := g_HeroItems[U_HELMET].ClientItem.S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          Idx := g_HeroItems[U_ZHULI].ClientItem.S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          Idx := g_HeroItems[U_ZHULI].ClientItem.S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            Idx := g_HeroItems[U_HELMET].ClientItem.S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;

      end;
      if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //金牛头盔
        with g_HeroItems[U_HELMET].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_HELMET].nIndex);
              if g_DrawHeroUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d)
              end;
            end;
          end;
        end;
      end;
    end else
    if g_HeroItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
      Idx := g_HeroItems[U_HELMET].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with g_HeroItems[U_HELMET].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_HELMET].nIndex);
              if g_DrawHeroUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWNewStateHeroPageTab1.SetImgIndex(g_WUI1Images, 2247);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab2DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with AspTextureFont do begin
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+32, clSilver, clBlack, Format('职业：%s       等级：%d',
                  [GetJobName(g_HeroSelf.m_btJob), g_HeroSelf.m_Abil.Level]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+47, clSilver, clBlack, '当前经验  ' + IntToStr(g_HeroSelf.m_Abil.Exp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+62, clSilver, clBlack, '升级经验  ' + IntToStr(g_HeroSelf.m_Abil.MaxExp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+91, clSilver, clBlack, Format('体力值：%d/%d', [g_HeroSelf.m_Abil.HP, g_HeroSelf.m_Abil.MaxHP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+106, clSilver, clBlack, Format('魔法值：%d/%d', [g_HeroSelf.m_Abil.MP, g_HeroSelf.m_Abil.MaxMP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+121, clSilver, clBlack, Format('药力值：%d/%d', [g_HeroSelf.m_Abil.MedicineValue, g_HeroSelf.m_Abil.MaxMedicineValue]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+136, clSilver, clBlack, '酒量：' + IntToStr(g_HeroSelf.m_Abil.MaxAlcohol));
    end;
  end;
end;

procedure TFrmDlg.DWNewStateHeroPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2182);
{$IFEND}
end;

function DecToText(Value:Integer):string;
begin
  if Value>=0 then
    Result:='+'+IntToStr(Value) else Result:=IntToStr(Value);
end;

procedure TFrmDlg.DWNewStateHeroPageTab3DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);

{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroPageTab3 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with AspTextureFont do begin
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+35, clSilver, clBlack, Format('防御 %d-%d', [LoWord(g_HeroSelf.m_Abil.AC), HiWord(g_HeroSelf.m_Abil.AC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+50, clSilver, clBlack, Format('魔御 %d-%d', [LoWord(g_HeroSelf.m_Abil.MAC), HiWord(g_HeroSelf.m_Abil.MAC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+65, clSilver, clBlack, Format('攻击 %d-%d', [LoWord(g_HeroSelf.m_Abil.DC), HiWord(g_HeroSelf.m_Abil.DC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+80, clSilver, clBlack, Format('魔法 %d-%d', [LoWord(g_HeroSelf.m_Abil.MC), HiWord(g_HeroSelf.m_Abil.MC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+95, clSilver, clBlack, Format('道术 %d-%d', [LoWord(g_HeroSelf.m_Abil.SC), HiWord(g_HeroSelf.m_Abil.SC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+110, clSilver, clBlack, '精确度     ' + IntToStr(g_nHeroHitPoint));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+125, clSilver, clBlack, '敏捷度     ' + IntToStr(g_nHeroSpeedPoint));

      if g_HeroSelf.m_Abil.Weight > g_HeroSelf.m_Abil.MaxWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clRed, clBlack, Format('背包重量  %d/%d', [g_HeroSelf.m_Abil.Weight, g_HeroSelf.m_Abil.MaxWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clSilver, clBlack, Format('背包重量  %d/%d', [g_HeroSelf.m_Abil.Weight, g_HeroSelf.m_Abil.MaxWeight]));
      if g_HeroSelf.m_Abil.WearWeight > g_HeroSelf.m_Abil.MaxWearWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clRed, clBlack, Format('穿戴重量  %d/%d', [g_HeroSelf.m_Abil.WearWeight, g_HeroSelf.m_Abil.MaxWearWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clSilver, clBlack, Format('穿戴重量  %d/%d', [g_HeroSelf.m_Abil.WearWeight, g_HeroSelf.m_Abil.MaxWearWeight]));
      if g_HeroSelf.m_Abil.HandWeight > g_HeroSelf.m_Abil.MaxHandWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clRed, clBlack, Format('腕力      %d/%d', [g_HeroSelf.m_Abil.HandWeight, g_HeroSelf.m_Abil.MaxHandWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clSilver, clBlack, Format('腕力      %d/%d', [g_HeroSelf.m_Abil.HandWeight, g_HeroSelf.m_Abil.MaxHandWeight]));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+80, clSilver, clBlack, '魔法防御  ' + DecToText(g_nHeroAntiMagic * 10) + '%');

      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+95, clSilver, clBlack, '伤害吸收  ' + DecToText(g_MyHeroSuitAbility.nShangHaiXiShou) + '%');
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+110, clSilver, clBlack, '体力恢复  ' + DecToText(g_nHeroHealthRecover * 10) + '%');  //-
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+125, clSilver, clBlack, '魔法恢复  ' + DecToText(g_nHeroSpellRecover * 10) + '%');  //-
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+140, clSilver, clBlack, '攻击速度  ' + DecToText(g_MyHeroSuitAbility.nGongJiSuDu) );
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+155, clSilver, clBlack, '攻击吸血  ' + DecToText(g_MyHeroSuitAbility.nGongJiXiXue) );
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+170, clSilver, clBlack, '强身等级  ' + DecToText(g_MyHeroSuitAbility.nQiangShenDengJi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+185, clSilver, clBlack, '聚魔等级  ' + DecToText(g_MyHeroSuitAbility.nJuMoDengJi) );
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+200, clSilver, clBlack, '暴击等级  ' + DecToText(g_MyHeroSuitAbility.nBaoJiDengJi ) );
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+215, clSilver, clBlack, '内伤等级  ' + DecToText(g_MyHeroSuitAbility.nNeiShangDengJi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+230, clSilver, clBlack, '合击威力  ' + DecToText(g_MyHeroSuitAbility.nHeJiWeiLi) );
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+245, clSilver, clBlack, '冰冻抗性  ' + DecToText(g_MyHeroSuitAbility.nBingDongKangXing) + '%');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2183);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab5DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateHeroPageTab5 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then 
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [HeroMagicPage+1, (g_HeroMagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;


procedure TFrmDlg.DWNewStateHeroPageTab5Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  nTitleWidth: Integer;
  sTitleName: string;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateUser do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
      if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        sTitleName := UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName;
        if sTitleName <> '' then begin
          nTitleWidth := frmMain.Canvas.TextWidth(sTitleName);
          if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
            if g_WUI1Images <> nil then begin
              d := g_WUI1Images.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks];
              if d <> nil then begin
                if d.Width > 16 then begin
                  nTitleWidth := d.Width;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end else begin
                  nTitleWidth := nTitleWidth + d.Width + 4;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2 - d.Width, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end;
              end;
            end;
          end;
          if d.Width < 17 then 
          AspTextureFont.TextOut(SurfaceX(GLeft) + 150 - nTitleWidth div 2, SurfaceY(GTop) + 19, clYellow, sTitleName);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2185);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  lx,ly:integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  g_MouseUserStateItem.ClientItem.S.Name := '';
  if g_MouseUserTitleList.Count > 0 then
    g_MouseUserTitleList.Clear;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserPageTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  ax, ay, Idx: Integer;
  bbx, bby: Integer;
  Sex, Hair: Byte;
  wm: TAspWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateUserPageTab1 do begin
    Sex := UserState1.Feature.nDress mod 2; //DRESSfeature (UserState1.Feature) mod 2;    //性别
    Hair := UserState1.feature.btHair; //HAIRfeature (UserState1.Feature);
    if WLib <> nil then begin
      if Sex = 1 then
        d := WLib.Images[FaceIndex+1]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    bbx := GLeft+31;
    bby := GTop+56;
    if UserState1.UseItems[U_DRESS].ClientItem.S.Name <> '' then begin //衣服
      Idx := UserState1.UseItems[U_DRESS].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        with UserState1.UseItems[U_DRESS].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_DRESS].nIndex);
              if g_DrawUseItems1[U_DRESS].nIndex > btShapeCount-1 then g_DrawUseItems1[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
    //自己人物发型  2007.10.16
    Idx := 1799;
    if Sex = 1 then idx := 2399;
    if Sex = 0 then begin  //男
      if Hair <> 0 then begin
        if Idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        end;
      end;
    end else if Hair <> 1 then begin
      if Idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
    end;
    if UserState1.UseItems[U_WEAPON].ClientItem.S.Name <> '' then begin
      Idx := UserState1.UseItems[U_WEAPON].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with UserState1.UseItems[U_WEAPON].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_WEAPON].nIndex);
              if g_DrawUseItems1[U_WEAPON].nIndex > btShapeCount-1 then g_DrawUseItems1[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
    //斗笠 20080417
    if UserState1.UseItems[U_ZHULI].ClientItem.S.Name <> '' then begin
      if UserState1.UseItems[U_ZHULI].ClientItem.S.Shape <> 2  then begin
        Idx := UserState1.UseItems[U_ZHULI].ClientItem.S.Looks;
        if Idx >= 0 then begin
          d := FrmMain.GetWStateImg(Idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 103) or (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 106) or (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 344) or (UserState1.UseItems[U_HELMET].ClientItem.S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            Idx := UserState1.UseItems[U_HELMET].ClientItem.S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          Idx := UserState1.UseItems[U_ZHULI].ClientItem.S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          Idx := UserState1.UseItems[U_ZHULI].ClientItem.S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            Idx := UserState1.UseItems[U_HELMET].ClientItem.S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;

      end;
      if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //金牛头盔
        with UserState1.UseItems[U_HELMET].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_HELMET].nIndex);
              if g_DrawUseItems1[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems1[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect,d);
              end;
            end;
          end;
        end;
      end;
    end else
    if UserState1.UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
      Idx := UserState1.UseItems[U_HELMET].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with UserState1.UseItems[U_HELMET].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_HELMET].nIndex);
              if g_DrawUseItems1[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems1[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserPageTab2DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateUserPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      if g_MouseUserTitleList.Count > 0 then begin
        for I:=0 to g_MouseUserTitleList.Count-1 do
          AspTextureFont.TextOut(SurfaceX(GLeft)+140, SurfaceY(GTop)+72+I*14, clYellow, g_MouseUserTitleList[I]);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  nTitleWidth: Integer;
  sTitleName: string;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit; 
  with DWNewStateWin do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      frmMain.Canvas.Font.Style := [fsBold];
      if DBNewStateTab3.Visible then begin //有心法
        d := WLib.Images[2196+DPNewStateWinTab.ActivePage];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+14, SurfaceY(GTop)+51, d.ClientRect, d, True);
        if DPNewStateWinTab.ActivePage = 0 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+54, SurfaceY(GTop)+55, Color, clBlack, '基础', [fsBold]);
        if DPNewStateWinTab.ActivePage = 1 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+134, SurfaceY(GTop)+55, Color, clBlack, '内功', [fsBold]);
        if DPNewStateWinTab.ActivePage = 2 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        if g_boXinFaType then
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+214, SurfaceY(GTop)+55, Color, clBlack, '心法',[fsBold])
        else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+202, SurfaceY(GTop)+55, Color, clBlack, '传承心法')
      end else if g_boIsInternalForce then begin  //有内功
        d := WLib.Images[2245-DPNewStateWinTab.ActivePage];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+14, SurfaceY(GTop)+55, d.ClientRect, d, True);
        if DPNewStateWinTab.ActivePage = 0 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+74, SurfaceY(GTop)+59, Color, clBlack, '基础', [fsBold]);
        if DPNewStateWinTab.ActivePage = 1 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+154, SurfaceY(GTop)+59, Color, clBlack, '内功', [fsBold]);
      end;
      frmMain.Canvas.Font.Style := [];
    end;
    if g_ClientHumTitles.nUseTitleIndex > 0 then begin
      if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
        sTitleName := g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName;
        if sTitleName <> '' then begin
          nTitleWidth := frmMain.Canvas.TextWidth(sTitleName);
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
            if g_WUI1Images <> nil then begin
              d := g_WUI1Images.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks];
              if d <> nil then begin
                if d.Width > 16 then begin
                  nTitleWidth := d.Width;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end else begin
                  nTitleWidth := nTitleWidth + d.Width + 4;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2 - d.Width, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end;
              end;
            end;
          end;
          if d.Width < 17 then 
          AspTextureFont.TextOut(SurfaceX(GLeft) + 150 - nTitleWidth div 2, SurfaceY(GTop) + 19, clYellow, sTitleName);
        end;
      end;
    end;
    AspTextureFont.TextOut(SurfaceX(GLeft + 142 - frmMain.Canvas.TextWidth(FrmMain.CharName) div 2),
                     SurfaceY(GTop + 38), g_MySelf.m_nNameColor, g_MySelf.m_sUserName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2185);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  g_MouseStateItem.ClientItem.S.Name := '';
  if g_MouseTitleList.Count > 0 then
    g_MouseTitleList.Clear;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWinNGPageTab1 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 47, clSilver, clBlack, '当前内功等级  '+IntToStr(g_dwInternalForceLevel));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 67, clSilver, clBlack, '当前内功经验  '+IntToStr(g_dwExp69));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 87, clSilver, clBlack, '升级内功经验  '+IntToStr(g_dwMaxExp69));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 107, clSilver, clBlack, Format('内 力 值  %d/%d', [g_MySelf.m_Skill69NH, g_MySelf.m_Skill69MaxNH]));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 127, clSilver, clBlack, '内功恢复速度  '+IntToStr(g_nInternalRecovery));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 147, clSilver, clBlack, '内功伤害增加  '+IntToStr(g_nInternalHurtAdd));
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 167, clSilver, clBlack, '内功伤害减免  '+IntToStr(g_nInternalHurtRelief));
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2234);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab2DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinNGPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [InternalForceMagicPage+1, (g_InternalForceMagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab3DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version = 1}
var
  d: TAsphyreLockableTexture;
  wXueWeiTiao: Word;
{$IFEND}
begin
{$IF M2Version = 1}
  if g_MySelf = nil then exit;
  with DWNewStateWinNGPageTab3 do begin
    if WLib <> nil then begin //20080701
      if g_MySelf.m_btSex = 1 then begin //女
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 4]
        else d := WLib.Images[FaceIndex + 5];
      end else begin
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 6]
        else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    //右上角标志
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1171]
    else d := g_WMainImages.Images[830+StatePulsePage];
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft) + 144, SurfaceY(GTop) + 11, d.ClientRect, d, TRUE);
    //经络穴位条
    if StatePulsePage = 0 then begin//冲脉,冲脉读老资源
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        wXueWeiTiao := 860
      else wXueWeiTiao := 861+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[wXueWeiTiao];
      if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+33, SurfaceY(GTop)+13,  d.ClientRect, d);
    end else begin
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        wXueWeiTiao := 2280
      else wXueWeiTiao := 2281+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WUI1Images.Images[wXueWeiTiao-(StatePulsePage-1) * 10];
      if d <> nil then
        dsurface.DrawBlend(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, d.ClientRect,d)
    end;
    //穴位针位
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1172]
    else d := g_WMainImages.Images[840+StatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d.ClientRect, d, TRUE);

    if StatePulsePage <> 4 then begin
      if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
        case g_HumanPulseArr[StatePulsePage].nPulseLevel of
          0: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
          end;
          1: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          2: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          3: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          4: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          5: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
        end;
      end else begin
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab3Initialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2231);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2239);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  ax, ay, Idx: Integer;
  bbx, bby: Integer;
  wm: TAspWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWinPageTab1 do begin
    if WLib <> nil then begin
      if g_MySelf.m_btSex = 1 then
        d := WLib.Images[FaceIndex+1]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    bbx := GLeft+31;
    bby := GTop+56;
    if g_UseItems[U_DRESS].ClientItem.S.Name <> '' then begin //衣服
      Idx := g_UseItems[U_DRESS].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        with g_UseItems[U_DRESS].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_DRESS].nIndex);
              if g_DrawUseItems[U_DRESS].nIndex > btShapeCount-1 then g_DrawUseItems[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end;
    //自己人物发型  2007.10.16 
    Idx := 1799;
    if g_MySelf.m_btSex = 1 then  Idx := 2399;
    if g_MySelf.m_btSex = 0 then begin  //男
      if g_MySelf.m_btHair <> 0 then begin
        if Idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        end;
      end;
    end else if g_MySelf.m_btHair <> 1 then begin
      if Idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
    end;
    if g_UseItems[U_WEAPON].ClientItem.S.Name <> '' then begin
      Idx := g_UseItems[U_WEAPON].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with g_UseItems[U_WEAPON].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_WEAPON].nIndex);
              if g_DrawUseItems[U_WEAPON].nIndex > btShapeCount-1 then g_DrawUseItems[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;  
    end;
    //斗笠 20080417
    if g_UseItems[U_ZHULI].ClientItem.S.Name <> '' then begin
      if g_UseItems[U_ZHULI].ClientItem.S.Shape <> 2  then begin
        Idx := g_UseItems[U_ZHULI].ClientItem.S.Looks;
        if Idx >= 0 then begin
          d := FrmMain.GetWStateImg(Idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (g_UseItems[U_HELMET].ClientItem.S.Looks = 103) or (g_UseItems[U_HELMET].ClientItem.S.Looks = 106) or (g_UseItems[U_HELMET].ClientItem.S.Looks = 344) or (g_UseItems[U_HELMET].ClientItem.S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            Idx := g_UseItems[U_HELMET].ClientItem.S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          Idx := g_UseItems[U_ZHULI].ClientItem.S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          Idx := g_UseItems[U_ZHULI].ClientItem.S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
            Idx := g_UseItems[U_HELMET].ClientItem.S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
      if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin
        with g_UseItems[U_HELMET].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_HELMET].nIndex);
              if g_DrawUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect, d);
              end;
            end;
          end;
        end;
      end;
    end else
    if g_UseItems[U_HELMET].ClientItem.S.Name <> '' then begin //头盔
      Idx := g_UseItems[U_HELMET].ClientItem.S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with g_UseItems[U_HELMET].ClientEffec do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_HELMET].nIndex);
              if g_DrawUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                dsurface.DrawBlend(SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d.ClientRect,d);
              end;
            end;
          end;
        end;
      end;
    end;
    AspTextureFont.TextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 6, clSilver, g_sGuildName + ' ' + g_sGuildRankName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2180);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab2DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  if g_MySelf = nil then Exit;
  with DWNewStateWinPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with AspTextureFont do begin
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+16, clSilver, clBlack, '职业      ：' + GetJobName(g_MySelf.m_btJob));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+31, clSilver, clBlack, '等级      ：' + IntToStr(g_MySelf.m_Abil.Level));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+46, clSilver, clBlack, '声望      ：' + IntToStr(g_nCreditPoint));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+61, clSilver, clBlack, '当前经验  ：' + IntToStr(g_MySelf.m_Abil.Exp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+76, clSilver, clBlack, '升级经验  ：' + IntToStr(g_MySelf.m_Abil.MaxExp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+91, clSilver, clBlack, Format('体力值    ：%d/%d', [g_MySelf.m_Abil.HP, g_MySelf.m_Abil.MaxHP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+106, clSilver, clBlack, Format('魔法值    ：%d/%d', [g_MySelf.m_Abil.MP, g_MySelf.m_Abil.MaxMP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+121, clSilver, clBlack, Format('药力值    ：%d/%d', [g_MySelf.m_Abil.MedicineValue, g_MySelf.m_Abil.MaxMedicineValue]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+136, clSilver, clBlack, '酒量      ：' + IntToStr(g_MySelf.m_Abil.MaxAlcohol));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+151, clSilver, clBlack, g_sGameDiaMond + '数  ：' + IntToStr(g_MySelf.m_nGameDiaMond));

      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+181, clSilver, clBlack, g_sGameGird + '数量  ：' + IntToStr(g_MySelf.m_nGameGird));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+196, clYellow, clBlack, g_sGameGoldName + '数量  ：' + IntToStr(g_MySelf.m_nGameGold));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+211, clSilver, clBlack, g_sGamePointName + '    ：' + IntToStr(g_MySelf.m_nGamePoint));
      if g_dGamePointDate <> 32590 then
        BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+226, clYellow, clBlack, g_sGamePointName+'截止时间'+ FormatDateTime('mm月dd日24时', g_dGamePointDate));
    end;
  end;
end;

procedure TFrmDlg.DWNewStateWinPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2182);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab3DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);

  {function GetShangHaiXiShou:Integer;
  var I:Integer;
  begin
    Result:=0;
    for I:=0 to 13 do
    begin
      if g_UseItems[I]<>nil then
      begin
        if g_UseItems[U_DRESS].ClientItem.S.Shape in [188,203] then
          Result:=g_UseItems[U_DRESS].ClientItem.S.Source;
      end;
    end;
  end; }

{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWinPageTab3 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with AspTextureFont do begin
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+35, clSilver, clBlack, Format('防御 %d-%d', [LoWord(g_MySelf.m_Abil.AC), HiWord(g_MySelf.m_Abil.AC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+50, clSilver, clBlack, Format('魔防 %d-%d', [LoWord(g_MySelf.m_Abil.MAC), HiWord(g_MySelf.m_Abil.MAC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+65, clSilver, clBlack, Format('攻击 %d-%d', [LoWord(g_MySelf.m_Abil.DC), HiWord(g_MySelf.m_Abil.DC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+80, clSilver, clBlack, Format('魔法 %d-%d', [LoWord(g_MySelf.m_Abil.MC), HiWord(g_MySelf.m_Abil.MC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+95, clSilver, clBlack, Format('道术 %d-%d', [LoWord(g_MySelf.m_Abil.SC), HiWord(g_MySelf.m_Abil.SC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+110, clSilver, clBlack, '精确度     ' + IntToStr(g_nMyHitPoint));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+125, clSilver, clBlack, '敏捷度     ' + IntToStr(g_nMySpeedPoint));

      if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clRed, clBlack, Format('背包重量  %d/%d', [g_MySelf.m_Abil.Weight, g_MySelf.m_Abil.MaxWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clSilver, clBlack, Format('背包重量  %d/%d', [g_MySelf.m_Abil.Weight, g_MySelf.m_Abil.MaxWeight]));
      if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clRed, clBlack, Format('穿戴重量  %d/%d', [g_MySelf.m_Abil.WearWeight, g_MySelf.m_Abil.MaxWearWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clSilver, clBlack, Format('穿戴重量  %d/%d', [g_MySelf.m_Abil.WearWeight, g_MySelf.m_Abil.MaxWearWeight]));
      if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clRed, clBlack, Format('腕力      %d/%d', [g_MySelf.m_Abil.HandWeight, g_MySelf.m_Abil.MaxHandWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clSilver, clBlack, Format('腕力      %d/%d', [g_MySelf.m_Abil.HandWeight, g_MySelf.m_Abil.MaxHandWeight]));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+80, clSilver, clBlack, '魔法防御  ' + DecToText(g_nMyAntiMagic * 10) + '%');

      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+95, clSilver, clBlack, '伤害吸收  ' + DecToText(g_MySelfSuitAbility.nShangHaiXiShou) + '%');
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+110, clSilver, clBlack, '体力恢复  ' + DecToText(g_nMyHealthRecover * 10) + '%');  //-
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+125, clSilver, clBlack, '魔法恢复  ' + DecToText(g_nMySpellRecover * 10) + '%');  //-
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+140, clSilver, clBlack, '攻击速度  ' + DecToText(g_MySelfSuitAbility.nGongJiSuDu));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+155, clSilver, clBlack, '攻击吸血  ' + DecToText(g_MySelfSuitAbility.nGongJiXiXue));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+170, clSilver, clBlack, '强身等级  ' + DecToText(g_MySelfSuitAbility.nQiangShenDengJi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+185, clSilver, clBlack, '聚魔等级  ' + DecToText(g_MySelfSuitAbility.nJuMoDengJi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+200, clSilver, clBlack, '暴击等级  ' + DecToText(g_MySelfSuitAbility.nBaoJiDengJi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+215, clSilver, clBlack, '内伤等级  ' + DecToText(g_MySelfSuitAbility.nNeiShangDengJi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+230, clSilver, clBlack, '合击威力  ' + DecToText(g_MySelfSuitAbility.nHeJiWeiLi));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+245, clSilver, clBlack, '冰冻抗性  ' + DecToText(g_MySelfSuitAbility.nBingDongKangXing * 10) + '%');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2183);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab4DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinPageTab4 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      if g_MouseTitleList.Count > 0 then begin
        for I:=0 to g_MouseTitleList.Count-1 do
          AspTextureFont.TextOut(SurfaceX(GLeft)+140, SurfaceY(GTop)+72+I*14, clYellow, g_MouseTitleList[I]);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2186);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab5DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinPageTab5 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then 
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [MagicPage+1, (g_MagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab5Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinXFPageTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  pcm: PTClientMagic;
  I: Integer;
const
  XinFaImages: array[0..4] of Word = (1890, 1770, 1830, 1860, 1800);
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinXFPageTab1 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      for I:=0 to g_XinFaMagic.Count-1 do begin
        pcm := pTClientMagic(g_XinFaMagic[I]);
        if pcm <> nil then begin
          if pcm.Def.wMagicId in [105, 106] then begin
            if pcm.Level > 99 then
              AspTextureFont.BoldTextOut(SurfaceX(GLeft)+41, SurfaceY(GTop)+39, $8CC7EF, clBlack, 'MAX')
            else AspTextureFont.BoldTextOut(SurfaceX(GLeft)+41, SurfaceY(GTop)+39, $8CC7EF, clBlack, IntToStr(pcm.Level));
            Break;
          end;
        end;
      end;
      d := g_WUI1Images.Images[2311];
      if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+66, SurfaceY(GTop)+39, d.ClientRect, d);
      with g_LingWuXinFa do begin
        if GetTickCount - dwStartTimeTick > 100 then begin
          dwStartTimeTick := GetTickCount;
          Inc(btCurrentFrame);
          if btCurrentFrame > 19 then btCurrentFrame := 0;
        end;
        d := WLib.Images[XinFaImages[g_HeartAbility.nHeartTpye]+btCurrentFrame];
      end;
      if d <> nil then begin
        dsurface.DrawBlend( SurfaceX(GLeft)+64, SurfaceY(GTop)+66, d.ClientRect, d);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinXFPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWNewStateWinXFPageTab1.SetImgIndex(g_WUI1Images, 2310);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinXFPageTab2DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinXFPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [m_btXinFaPage+1, (g_XinFaMagic.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinXFPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TAspDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;

procedure TFrmDlg.DHeroItemBagMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DStateTabClick(Sender: TObject; X, Y: Integer);
var
  lx: Integer;
begin
  lx := X - DStateTab.GLeft;
  if (lx >= 13) and (lx <= 83) then begin
    StateTab := 0;
    DStateWinPulse.Visible := False;
    DStateWinBatter.Visible := False;
    PageChanged;
  end else
  if (lx >= 84) and (lx <= 152) then begin
    StateTab := 1;
    InternalForcePageChanged;
    {$IF M2Version <> 2}
    DBTitleMan.Visible := False;
    DBTitle1.Visible := False;
    DBTitle2.Visible := False;
    DBTitle3.Visible := False;
    DBTitle4.Visible := False;
    DBPrevTitle.Visible := False;
    DBNextTitle.Visible := False;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DStateTabDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
//var
//   d: TAsphyreLockableTexture;
begin
  { with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if StateTab = 0 then
           d := WLib.Images[FaceIndex]
        else
           d := WLib.Images[FaceIndex+1];
        if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end; }
end;

procedure TFrmDlg.DHeroStateTabDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
//var
//   d: TAsphyreLockableTexture;
begin
{   with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if HeroStateTab = 0 then
           d := WLib.Images[FaceIndex]
        else
           d := WLib.Images[FaceIndex+1];
        if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;}
end;

procedure TFrmDlg.DHeroStateTabClick(Sender: TObject; X, Y: Integer);
var
  lx: Integer;
begin
  lx := X - DStateTab.GLeft;
  if (lx >= 13) and (lx <= 83) then begin
    HeroStateTab := 0;
    DHeroStateWinPulse.Visible := False;
    DHeroStateWinBatter.Visible := False;
    HeroPageChanged;
  end else
  if (lx >= 84) and (lx <= 152) then begin
    HeroStateTab := 1;
    HeroInternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DSighIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not TAspDButton(Sender).Downed then begin
        if GetTickCount - SighIconTimeTick > 500 then begin
          SighIconTimeTick := GetTickCount;
          Inc(SighIconImginsex);
          if SighIconImginsex > 1 then SighIconImginsex := 0;
        end;
        d := WLib.Images[FaceIndex+SighIconImginsex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        d := WLib.Images[FaceIndex+2];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DSighIconClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  DSighIcon.Visible := False;
  msg := MakeDefaultMsg (aa(CM_CLICKSIGHICON, frmMain.TempCertification), 0, 1, 0, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg) + EncodeString(g_sSighIcon));
end;

procedure TFrmDlg.DCrystalExpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
 DScreen.ShowHint(DWExpCrystal.SurfaceX(DWExpCrystal.GLeft) + DWExpCrystal.GWidth - 12, DWExpCrystal.SurfaceY(DWExpCrystal.GTop)+60,
     '经验: ' + IntToStr(g_dwCrystalExp)+ '/' + IntToStr(g_dwCrystalMaxExp) + '\' +
     '内功: ' + IntToStr(g_dwCrystalNGExp)+ '/' + IntToStr(g_dwCrystalNGMaxExp)
     , clWhite, FALSE);
end;

procedure TFrmDlg.DExpCrystalTopMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if  g_btCrystalLevel-1 = 0 then begin
    DScreen.ShowHint(DWExpCrystal.SurfaceX(DWExpCrystal.GLeft) + DWExpCrystal.GWidth - 2, DWExpCrystal.SurfaceY(DWExpCrystal.GTop)+26,
       '当经验池散发光辉时，点击释放经验及内功'
       , clWhite, FALSE);
  end else begin
    DScreen.ShowHint(DWExpCrystal.SurfaceX(DWExpCrystal.GLeft) + DWExpCrystal.GWidth - 2, DWExpCrystal.SurfaceY(DWExpCrystal.GTop)+26,
       '点击释放经验及内功'
       , clWhite, FALSE);
  end;
end;

procedure TFrmDlg.DWExpCrystalMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   al, at: integer;
begin
  if ssLeft in Shift then begin
      if (DWExpCrystal.SpotX <> X) or (DWExpCrystal.SpotY <> Y) then begin
         al := DWExpCrystal.GLeft + (X - DWExpCrystal.SpotX);
         at := DWExpCrystal.GTop + (Y - DWExpCrystal.SpotY);
         if al+DWExpCrystal.GWidth < WINLEFT then al := WINLEFT - DWExpCrystal.GWidth;
         if al > g_D3DConfig.wScreenWidth - 60 then al := g_D3DConfig.wScreenWidth - 60;
         if at+DWExpCrystal.GHeight < WINTOP then at := WINTOP - DWExpCrystal.GHeight;
         if at+DWExpCrystal.GHeight > g_D3DConfig.wScreenHeight - 230 then at := g_D3DConfig.wScreenHeight - 230 -DWExpCrystal.GHeight;
         DWExpCrystal.GLeft := al;
         DWExpCrystal.GTop := at;
         DWExpCrystal.SpotX := X;
         DWExpCrystal.SpotY := Y;
      end;
  end;
  DScreen.ClearHint;
end; 


procedure TFrmDlg.DWFactionAddDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
	d: TAsphyreLockableTexture;
  I: Integer;
  FactionAddInfo: pTClientDivisionInfo;
{$IFEND}
begin
{$IF M2Version <> 2}
	with DWFactionAddDlg do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with dsurface do begin
    	frmMain.Canvas.Font.Style := [fsBold];
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+24, SurfaceY(GTop)+20, $88C4E8, 0 , '师门',[fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+134, SurfaceY(GTop)+20, $88C4E8, 0 ,'师父',[fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+204, SurfaceY(GTop)+20, $88C4E8, 0, '师门人气值',[fsBold]);
      frmMain.Canvas.Font.Style := [];
    end;
    for I:=0 to g_FactionAddList.Count-1 do begin
    	if I > 4 then Break;
    	FactionAddInfo := g_FactionAddList[I];
      if FactionAddInfo <> nil then begin
      	AspTextureFont.BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+48+I*20, $8CC7EF, 0, FactionAddInfo.sDivisionName);
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+130, SurfaceY(GTop)+48+I*20, $8CC7EF, 0, FactionAddInfo.sChrName);
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+48+I*20, $8CC7EF, 0, IntToStr(FactionAddInfo.nPopularity));
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWFactionAddDlgInitialize(Sender: TObject);
begin
	DWFactionAddDlg.SetImgIndex(g_WUI1Images, 2491);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DWFactionApplyManageCloseClick(Sender: TObject; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  if g_FactionApplyManageNameList <> nil then
  FreeAndNil(g_FactionApplyManageNameList);
  DWFactionApplyManage.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DWFactionApplyManageDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
	with DWFactionApplyManage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.TextOut(SurfaceX(GLeft)+91, SurfaceY(GTop)+27, $8CC7EF, '管理师门申请');
      AspTextureFont.TextOut(SurfaceX(GLeft)+164, SurfaceY(GTop)+79, clWhite, '角色名');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWFactionApplyManageInitialize(Sender: TObject);
begin
  DWFactionApplyManage.SetImgIndex(g_WUI1Images, 2490);  
end;

procedure TFrmDlg.DWFactionDlgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);

{$IF M2Version <> 2}
var
	d: TAsphyreLockableTexture;
  bx, by, I: Integer;
const
  AdminNum = '・掌门 (%d人)';
  MemberNum = '・师门弟子 (%d人)';
{$IFEND}

begin
{$IF M2Version <> 2}
	with DWFactionDlg do begin
  	with dsurface do begin
      if WLib <> nil then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
          Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      AspTextureFont.TextOut(SurfaceX(GLeft)+250-frmMain.Canvas.TextWidth(g_FactionDlg.sDivisionName) div 2, SurfaceY(GTop)+29, $8CC7EF, g_FactionDlg.sDivisionName);
      frmMain.Canvas.Font.Style := [fsBold];
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)+49, $8CC7EF, clBlack, g_FactionDlgHint);
      if m_btFactionPage = 0 then begin
        if not g_FactionDlg.boPublic then begin
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+70, clTeal, clBlack, '师门心法：'+g_FactionDlg.sHeartName);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+85, clTeal, clBlack, '师父名称：'+g_FactionDlg.sMasterName);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+70, clTeal, clBlack, '心法属性：'+g_FactionDlg.sHeartTpye);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+85, clTeal, clBlack, '师门人数：'+g_FactionDlg.sMemberCount);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+350, SurfaceY(GTop)+70, clTeal, clBlack, '师门人气：'+IntToStr(g_FactionDlg.nPopularity));
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+350, SurfaceY(GTop)+85, clTeal, clBlack, Format('最高传承心法：%d级', [g_FactionDlg.nHeartLeve]));
        end else begin //公共师门
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+70, clTeal, clBlack, '师门心法：'+g_FactionDlg.sHeartName);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+85, clTeal, clBlack, Format('最高传承心法：%d级', [g_FactionDlg.nHeartLeve]));
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+70, clTeal, clBlack, '心法属性：'+g_FactionDlg.sHeartTpye);
          AspTextureFont.BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+85, clTeal, clBlack, '师门人数：'+g_FactionDlg.sMemberCount);
        end;
        frmMain.Canvas.Font.Style := [];
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+101, clSilver, clBlack, '_______________________________师门公告_______________________________');
        bx := SurfaceX(GLeft) + 39;
        by := SurfaceY(GTop) + 115;
        for I := 0 to g_FactionDlg.NoticeList.Count-1 do begin
          if I*14 > 150 then break;
          AspTextureFont.TextOut (bx, by + I*14, clSilver, g_FactionDlg.NoticeList[I]);
        end;
      end else begin
        frmMain.Canvas.Font.Style := [];
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+27, SurfaceY(GTop)+83, clWhite, clBlack, Format(AdminNum, [g_FactionMember.AdminNum]));
        AspTextureFont.BoldTextOut(SurfaceX(GLeft)+27, SurfaceY(GTop)+123, clWhite, clBlack, Format(MemberNum, [g_FactionMember.MemberNum]));
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWFactionDlgEditNoticeInitialize(Sender: TObject);
begin
  DWFactionDlgEditNotice.SetImgIndex(g_WMainImages, 1740);
end;

procedure TFrmDlg.DWFactionDlgInitialize(Sender: TObject);
begin
  DWFactionDlg.SetImgIndex(g_WUI1Images, 2230);
  with TAspDControl(Sender) do begin
    GLeft := GLeft + ((g_D3DConfig.wScreenWidth - 800) div 2);
    GTop := GTop + ((g_D3DConfig.wScreenHeight - 600) div 2);
  end;
end;

procedure TFrmDlg.DWFactionDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DCrystalExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc:Trect;
begin
  if Sender = DCrystalExp then begin
    case g_btCrystalLevel-1 of
      0: d := g_WMainImages.Images[476];
      1: d := g_WMainImages.Images[478];
      2: d := g_WMainImages.Images[480];
      3: d := g_WMainImages.Images[482];
      4: d := g_WMainImages.Images[482];
      else d := nil;
    end;
    if d <> nil then begin
      rc := d.ClientRect;
      if g_dwCrystalMaxExp > 0 then begin
        if g_dwCrystalExp >= g_dwCrystalMaxExp then
          rc.Top := Round(rc.Bottom / g_dwCrystalMaxExp * (g_dwCrystalMaxExp - g_dwCrystalMaxExp))
        else
          rc.Top := Round(rc.Bottom / g_dwCrystalMaxExp * (g_dwCrystalMaxExp - g_dwCrystalExp));
        dsurface.Draw (DCrystalExp.SurfaceX(DCrystalExp.GLeft) + rc.Left, DCrystalExp.SurfaceY(DCrystalExp.GTop)+rc.Top, rc, d, FALSE);
      end;
    end;
  end;
  if Sender = DCrystalNGExp then begin
    case g_btCrystalLevel-1 of
      0: d := g_WMainImages.Images[477];
      1: d := g_WMainImages.Images[479];
      2: d := g_WMainImages.Images[481];
      3: d := g_WMainImages.Images[483];
      4: d := g_WMainImages.Images[483];
      else d := nil;
    end;
    if d <> nil then begin
      rc := d.ClientRect;
      if g_dwCrystalNGMaxExp > 0 then begin
        if g_dwCrystalNGExp >= g_dwCrystalNGMaxExp then
          rc.Top := Round(rc.Bottom / g_dwCrystalNGMaxExp * (g_dwCrystalNGMaxExp - g_dwCrystalNGMaxExp))
        else
          rc.Top := Round(rc.Bottom / g_dwCrystalNGMaxExp * (g_dwCrystalNGMaxExp - g_dwCrystalNGExp));
        dsurface.Draw (DCrystalNGExp.SurfaceX(DCrystalNGExp.GLeft) + rc.Left, DCrystalNGExp.SurfaceY(DCrystalNGExp.GTop)+rc.Top, rc, d, FALSE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DExpCrystalTopDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  case g_btCrystalLevel-1 of
    1,2,3,4: begin
      with Sender as TAspDButton do begin
        if WLib <> nil then begin //20080701
          if GetTickCount - ExpCrystalTopTimeTick > 800 then begin
           ExpCrystalTopTimeTick := GetTickCount;
           Inc(ExpCrystalTopImginsex);
           if ExpCrystalTopImginsex > 1 then ExpCrystalTopImginsex := 0;
          end;
          d := WLib.Images[FaceIndex+ExpCrystalTopImginsex];
          if d <> nil then
             dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          if g_btCrystalLevel-1 = 4 then begin
            if GetTickCount - ExpCrystalTopEffectTimeTick > 100 then begin
             ExpCrystalTopEffectTimeTick := GetTickCount;
             Inc(ExpCrystalTopEffectImginsex);
             if ExpCrystalTopEffectImginsex > 3 then ExpCrystalTopEffectImginsex := 0;
            end;
            d := WLib.Images[525+ExpCrystalTopEffectImginsex];
            if d <> nil then
            dsurface.DrawBlend(SurfaceX(GLeft)-18, SurfaceY(GTop)-24, d);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DExpCrystalTopClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  if g_btCrystalLevel-1 <> 0 then begin //不为0级
    msg := MakeDefaultMsg (aa(CM_CLICKCRYSTALEXPTOP, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
  end;
end;

function Mz_InternalReadComponentData(var Instance: TComponent; const DfmData: string): Boolean;
var
  StrStream: TStringStream;
begin
  StrStream := nil;

  try
    StrStream := TStringStream.Create(DfmData);
    Instance := StrStream.ReadComponent(Instance);
  finally
    StrStream.Free;
  end;

  Result := True;
end;

procedure TFrmDlg.DBotGroupMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
   if ssRight in Shift then begin
     if GetTickCount > g_dwChangeGroupModeTick then begin
        g_boAllowGroup := not g_boAllowGroup;
        g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
        FrmMain.SendGroupMode (g_boAllowGroup);
     end;
     if g_boAllowGroup then begin
       DScreen.AddChatBoardString('[允许组队]',clGreen, ClWhite);
     end else begin
       DScreen.AddChatBoardString('[拒绝组队]',clGreen, clBlack);
     end;
   end;
end;

procedure TFrmDlg.DNewBoxsHelpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  Int: Integer;
begin
  with DNewBoxsHelp do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
      Int := 14;
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22, clYellow, '1.双击包裹中的宝箱');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int, clYellow, '就可开启宝箱');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*2, clYellow, '2.宝箱中获得的奖励');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*3, clYellow, '将自动进入包裹');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*4, clYellow, '3.勾选自动开启宝箱');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*5, clYellow, '选项可以自动帮您开');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*6, clYellow, '启包裹中的所有同类');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*7, clYellow, '宝箱');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*8, clYellow, '4.当包裹中有同类宝');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*9, clYellow, '箱时上方的三个特殊');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*10, clYellow, '奖励将会自动移到被');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*11, clYellow, '领取的奖励位置上，');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*12, clYellow, '选择再开一个就有机');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*13, clYellow, '会领取到特殊奖励');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*14, clYellow, '5.连续开启四个宝箱');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*15, clYellow, '后所有奖励会自动进');
      AspTextureFont.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*16, clYellow, '行更换');
  end;
end;

procedure TFrmDlg.DBNewHBExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*5+5, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 71) and (pm.Level < 100) then begin
            rc := d.ClientRect;
            if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
              rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*5+5, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 71) then begin
      if pm.Level < 100 then begin
        sMsg := '当前经验:%d/%d';
        with DBNewHBExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), clWhite, FALSE);
      end else begin
        sMsg := '当前经验:%d/-';
        with DBNewHBExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain]), clWhite, FALSE);
      end;
      Break;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHelpBtnClick(Sender: TObject; X, Y: Integer);
begin
  DNewBoxsHelp.GTop := 0;
  DNewBoxsHelp.GLeft := DBoxs.GWidth-4;
  DNewBoxsHelp.Visible := not DNewBoxsHelp.Visible;
end;

procedure TFrmDlg.DNewBoxsHelpCloseClick(Sender: TObject; X, Y: Integer);
begin
  DNewBoxsHelp.Visible := False;
end;

procedure TFrmDlg.DCheckAutoOpenBoxsDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TAspDCheckBox do begin
    if not TAspDCheckBox(Sender).Checked then begin
      d := g_WMain2Images.Images[228];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end else begin
      d := g_WMain2Images.Images[229];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end
  end;
end;

procedure TFrmDlg.DCheckBoxBookHPProClick(Sender: TObject; X, Y: Integer);
begin
  case m_btProPage of
    0: begin
      if Sender = DCheckBoxBookHPPro then
        g_Config.boHp1Chk := DCheckBoxBookHPPro.Checked
      else if Sender = DCheckBoxBookMPPro then
        g_Config.boMp1Chk := DCheckBoxBookMPPro.Checked
      else if Sender = DCheckBoxRenewHP then
        g_Config.boRenewHPIsAuto := DCheckBoxRenewHP.Checked
      else if Sender = DCheckBoxRenewMP then
        g_Config.boRenewMPIsAuto := DCheckBoxRenewMP.Checked
      else if Sender = DCheckBoxRenewHPSpecial then
        g_Config.boRenewSpecialHPIsAuto := DCheckBoxRenewHPSpecial.Checked
      else if Sender = DCheckBoxRenewMPSpecial then
        g_Config.boRenewSpecialMPIsAuto := DCheckBoxRenewMPSpecial.Checked
      else if Sender = DCheckBoxUseSuperMedica then
        g_Config.BoUseSuperMedica := DCheckBoxUseSuperMedica.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName1 then
        g_Config.SuperMedicaUses[0] := DCheckBoxUseSuperMedicaItemName1.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName2 then
        g_Config.SuperMedicaUses[1] := DCheckBoxUseSuperMedicaItemName2.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName3 then
        g_Config.SuperMedicaUses[2] := DCheckBoxUseSuperMedicaItemName3.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName4 then
        g_Config.SuperMedicaUses[3] := DCheckBoxUseSuperMedicaItemName4.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName5 then
        g_Config.SuperMedicaUses[4] := DCheckBoxUseSuperMedicaItemName5.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName6 then
        g_Config.SuperMedicaUses[5] := DCheckBoxUseSuperMedicaItemName6.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName7 then
        g_Config.SuperMedicaUses[6] := DCheckBoxUseSuperMedicaItemName7.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName8 then
        g_Config.SuperMedicaUses[7] := DCheckBoxUseSuperMedicaItemName8.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName9 then
        g_Config.SuperMedicaUses[8] := DCheckBoxUseSuperMedicaItemName9.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName10 then
        g_Config.SuperMedicaUses[9] := DCheckBoxUseSuperMedicaItemName10.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName11 then
        g_Config.SuperMedicaUses[10] := DCheckBoxUseSuperMedicaItemName11.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName12 then
        g_Config.SuperMedicaUses[11] := DCheckBoxUseSuperMedicaItemName12.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName13 then
        g_Config.SuperMedicaUses[12] := DCheckBoxUseSuperMedicaItemName13.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName14 then
      g_Config.SuperMedicaUses[13] := DCheckBoxUseSuperMedicaItemName14.Checked;
    end;
  end;
end;

procedure TFrmDlg.DBoxsNewCloseClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(aa(CM_OPENNEWBOXS, frmMain.TempCertification), 0, 0, 1, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket(EncodeMessage(msg));
  DBoxS.Visible := False;
end;

procedure TFrmDlg.DCheckAutoOpenBoxsClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if DCheckAutoOpenBoxs.Checked then begin
    if not g_boBoxsShowPosition then begin
      msg := MakeDefaultMsg(aa(CM_ROTATIONBOX, frmMain.TempCertification), 1{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
      FrmMain.SendSocket(EncodeMessage(msg));
    end;
  end;
end;

function Mz_InitInheritedComponent(Instance: TComponent; RootAncestor: TClass; const DfmData: string): Boolean;
  function Mz_InitComponent(ClassType: TClass; const DfmData: string): Boolean;
  begin
    Result := False;
    if (ClassType = TComponent) or (ClassType = RootAncestor) then Exit;
    Result := Mz_InitComponent(ClassType.ClassParent, DfmData);
    Result := Mz_InternalReadComponentData(Instance, DfmData) or Result; // **
  end;
var
  LocalizeLoading: Boolean;
begin
  GlobalNameSpace.BeginWrite;  // hold lock across all ancestor loads (performance)
  try
    LocalizeLoading := (Instance.ComponentState * [csInline, csLoading]) = [];
    if LocalizeLoading then BeginGlobalLoading;       // push new loadlist onto stack
    try
      Result := Mz_InitComponent(Instance.ClassType, DfmData); // **
      if LocalizeLoading then NotifyGlobalLoading;    // call Loaded
    finally
      if LocalizeLoading then EndGlobalLoading;       // pop loadlist off stack
    end;
  finally
    GlobalNameSpace.EndWrite;
  end;
end;
{.$if Version <> 0}
{constructor TFrmDlg.Create(AOwner: TComponent);
begin
  GlobalNameSpace.BeginWrite;
  try
    CreateNew(AOwner);
    if (ClassType <> TForm) and not (csDesigning in ComponentState) then
    begin
      Include(FFormState, fsCreating);
      try
        if (Mz_InitInheritedComponent(Self, TForm, DemoDfm) = False) then // **
          ShowMessage('注意, 初始化界面失败, 请检查DataUnit.DfmData, :~)');
      finally
        Exclude(FFormState, fsCreating);
      end;
      if OldCreateOrder then DoCreate;
    end;
  finally
    GlobalNameSpace.EndWrite;
  end;
end; }
{.$IFEND}
procedure TFrmDlg.DSdoMemoDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  s18: string;
begin
  with DSdoMemo do begin
    ElemCount:= (GHeight - 2) div LinesHeight;  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for i:= 0 to ElemCount - 1 do begin
      s18 := Lines.Strings[i+TopIndex];
      if s18 <> '' then begin
        if s18[1] = ' ' then
          AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clSilver, clBlack, s18)
        else
          AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clWhite, clBlack, s18);
      end;
    end;
  end;
end;

procedure TFrmDlg.DSdoMemoScrollBarDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   Rc:Trect;
begin
  with Sender as TAspDMemoScrollBar do begin
    d := g_WMain2Images.Images[574];
    if d <> nil then begin
      Rc := d.ClientRect;
      Rc.Bottom := GHeight;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, True);
      Rc := d.ClientRect;
      Rc.Top := d.Height-GHeight;
      Rc.Bottom := d.Height;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)+1, Rc, d, True);
    end;
  end;
end;

procedure TFrmDlg.m_EdIdKeyPress(Sender: TObject; var Key: Char);
begin
   if Key = #13 then begin
      Key := #0;
      LoginScene.m_sLoginId := LowerCase(m_EdId.Text);
      if LoginScene.m_sLoginId <> '' then begin
         m_EdPasswd.SetFocus;
      end;
   end;
end;

procedure TFrmDlg.m_EdPasswdKeyPress(Sender: TObject; var Key: Char);
begin
   if (Key = '~') or (Key = '''') then Key := '_';
   if Key = #13 then begin
      Key := #0;
      LoginScene.m_sLoginId := LowerCase(m_EdId.Text);
      LoginScene.m_sLoginPasswd := m_EdPasswd.Text;
      if (LoginScene.m_sLoginId <> '') and (LoginScene.m_sLoginPasswd <> '') then begin
         //发送到服务器验证密码
         FrmMain.SendLogin (LoginScene.m_sLoginId, LoginScene.m_sLoginPasswd);
         m_EdId.Text := '';
         m_EdPasswd.Text := '';
         //m_EdId.Visible := FALSE;
         //m_EdPasswd.Visible := FALSE;
      end else
         if (m_EdId.Visible) and (m_EdId.Text = '') then m_EdId.SetFocus;
   end;
end;

procedure TFrmDlg.m_EdIdKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = VK_TAB then begin
     m_EdPasswd.SetFocus;
   end;
end;

procedure TFrmDlg.m_EdPasswdKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = VK_TAB then begin
     m_EdId.SetFocus;
   end;
end;

procedure TFrmDlg.DCBBookHPManChange(Sender: TObject);
begin
  if Sender = DCBBookHPMan then
    g_Config.btHp1Man := DCBBookHPMan.ItemIndex
  else if Sender = DCBBookMPMan then
    g_Config.btMp1Man := DCBBookMPMan.ItemIndex;
  
end;

procedure TFrmDlg.DCBBookHPManDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   FontColor: Tcolor;
begin
  with Sender as TAspDComboBox do begin
    {if TAspDComboBox(Sender).Moveed then begin
      Color := $00387B9C;
      FontColor := clYellow;
    end else begin
      Color := $00498394;
      FontColor := clWhite;
    end;    }
    {with dsurface.Canvas do begin
      pen.Color := Color;
      Brush.Color := clBlack;
               //左                               //上                            //右
      Rectangle(SurfaceX(GLeft),SurfaceY(GTop),SurfaceX(GLeft)+TAspDButton(Sender).GWidth,SurfaceY(GTop)+TAspDButton(Sender).GHeight);
      Brush.Color := Color;
      if TAspDButton(Sender).Downed then
        Polygon([Point(SurfaceX(GLeft)+73+3,   SurfaceY(GTop)+12),   Point(SurfaceX(GLeft)+73,   SurfaceY(GTop)+9),   Point(SurfaceX(GLeft)+73+6,   SurfaceY(GTop)+9)])   //画三角形
      else
        Polygon([Point(SurfaceX(GLeft)+73+3,   SurfaceY(GTop)+11),   Point(SurfaceX(GLeft)+73,   SurfaceY(GTop)+8),   Point(SurfaceX(GLeft)+73+6,   SurfaceY(GTop)+8)]);   //画三角形
      //Release;
       AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 2, SurfaceY(GTop) + 4, FontColor, clBlack, DComSdoRandomName.Text);     
    end;}  
  end;
end;

procedure TFrmDlg.DCBBookHPManInitialize(Sender: TObject);
begin
  with Sender as TAspDComboBox do begin
    ItemIndex := 0;
  end;
end;

procedure TFrmDlg.DAdjustAbilOkDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
   with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DGDWarClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  DMessageDlg ('请输入对方行会的名称', [mbOk, mbAbort]);
  if DlgEditText <> '' then begin
    msg := MakeDefaultMsg(aa(CM_REQUESTGUILDWAR, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg)+EncodeString(DlgEditText));
  end;
end;

procedure TFrmDlg.DWNQStateMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   al, at: integer;
begin
  if ssLeft in Shift then begin
      if (DWNQState.SpotX <> X) or (DWNQState.SpotY <> Y) then begin
         al := DWNQState.GLeft + (X - DWNQState.SpotX);
         at := DWNQState.GTop + (Y - DWNQState.SpotY);
         if al+DWNQState.GWidth < DWNQState.GWidth then al := 0;
         if al > g_D3DConfig.wScreenWidth-DWNQState.GWidth then al := g_D3DConfig.wScreenWidth-DWNQState.GWidth;
         if at+DWNQState.GHeight < DWNQState.GHeight then at := 0;
         if at+DWNQState.GHeight > g_D3DConfig.wScreenHeight - 230 then at := g_D3DConfig.wScreenHeight - 230-DWNQState.GHeight;
         DWNQState.GLeft := al;
         DWNQState.GTop := at;
         DWNQState.SpotX := X;
         DWNQState.SpotY := Y;
      end;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DNQBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  if Sender = DNQBoxs then begin
    DScreen.ShowHint(DWNQState.SurfaceX(DWNQState.GLeft) - 18, DWNQState.SurfaceY(DWNQState.GTop)+40,
       '每满一个节点槽，可开启宝箱一次\每亮起一颗灯，宝箱中的奖励就更好'
       , clWhite, FALSE);
  end else begin
    DScreen.ShowHint(DWNQState.SurfaceX(DWNQState.GLeft)+18, DWNQState.SurfaceY(DWNQState.GTop)+40,
       format('牛气值：%d/%d',[g_dwNQExp,g_dwNQMaxExp])
       , clWhite, FALSE);
  end;
end;

procedure TFrmDlg.DNQExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc:Trect;
begin
  with DNQExp do begin
    if WLib <> nil then begin //20080701
      if boShowNQExpFalsh then begin
        if GetTickCount - ShowNQExpTimeTick > 300 then begin
          ShowNQExpTimeTick := GetTickCount;
          Inc(ShowNQExpInc);
          Inc(ShowNQExpInc1);
          if ShowNQExpInc > 1 then ShowNQExpInc := 0;
          if ShowNQExpInc1 > 9 then boShowNQExpFalsh := False;
        end;
        if ShowNQExpInc <> 0 then
          d := WLib.Images[FaceIndex]
        else d := nil;
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
    case g_btNQLevel-1 of
      0: d := g_WMainImages.Images[565];
      1: d := g_WMainImages.Images[571];
      2: d := g_WMainImages.Images[577];
      3: d := g_WMainImages.Images[583];
      else d := nil;
    end;
    if d <> nil then begin
      rc := d.ClientRect;
      if g_dwNQMaxExp > 0 then begin
        rc.Right := Round((rc.Right-rc.Left) / g_dwNQMaxExp * g_dwNQExp);
        dsurface.Draw (SurfaceX(DNQExp.GLeft) + rc.Left, SurfaceY(DNQExp.GTop)+rc.Top, rc, d, FALSE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWNQStateDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DWNQState do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if GetTickCount - ExpNQTimeTick > 500 then begin
     ExpNQTimeTick := GetTickCount;
     Inc(ExpNQImginsex);
     if ExpNQImginsex > 1 then ExpNQImginsex := 0;
    end;
    if g_dwNQMaxExp > 0 then begin
      case g_btNQLevel-1 of
        0: begin
          d := g_WMainImages.Images[587+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+90, SurfaceY(GTop)+7, d.ClientRect, d, true);
        end;
        1: begin
          d := g_WMainImages.Images[587];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+130, SurfaceY(GTop)+7, d.ClientRect, d, true);
          d := g_WMainImages.Images[589+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+130, SurfaceY(GTop)+15, d.ClientRect, d, true);
        end;
        2: begin
          d := g_WMainImages.Images[587];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+190, SurfaceY(GTop)+7, d.ClientRect, d, true);
          d := g_WMainImages.Images[589];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+190, SurfaceY(GTop)+15, d.ClientRect, d, true);
          d := g_WMainImages.Images[591+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+190, SurfaceY(GTop)+23, d.ClientRect, d, true);
        end;
        3: begin
          d := g_WMainImages.Images[587];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+7, d.ClientRect, d, true);
          d := g_WMainImages.Images[589];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+15, d.ClientRect, d, true);
          d := g_WMainImages.Images[591];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+23, d.ClientRect, d, true);
          d := g_WMainImages.Images[593+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+31, d.ClientRect, d, true);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKimNeedleHelpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d{,dd}: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not DStartKimNeedle.ShowHint then begin
        if TAspDButton(Sender).Downed then
          d := WLib.Images[FaceIndex+1]
        else
          d := WLib.Images[FaceIndex];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWKimNeedleDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  {$IF M2Version = 1}
  with DWKimNeedle do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    d := g_WMainImages.Images[750];
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+12, SurfaceY(GTop)+18, d.ClientRect, d, TRUE);
    d := g_WMainImages.Images[753];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+95, SurfaceY(GTop)+187, d.ClientRect, d, TRUE);
    AspTextureFont.TextOut (SurfaceX(GLeft+19), SurfaceY(GTop+125), clWhite, '金针锻造师');
  end;
  {$IFEND}
end;

procedure TFrmDlg.DKimNeedleLogoDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  procedure PomiTextOut (dsurface: TAsphyreCanvas; x, y: integer; str: string);
  var
     i, n, J: integer;
     d: TAsphyreLockableTexture;
  begin
     if Length(str)<=0 then Exit;    //20080629
     J := Length(str);
     for i:=1 to Length(str) do begin
        n := byte(str[i]) - byte('0');
        if (n >= 0) and (n <= 9) then begin
           d := g_WMainImages.Images[970 + n];
           if d <> nil then
              dsurface.Draw (x + i*20 - J*20, y, d.ClientRect, d, TRUE);
        end;
     end;
  end;
var
  d: TAsphyreLockableTexture;
  I, nImg: Integer;
  J: Byte;
begin
  with DKimNeedleLogo do begin
    if DKimNeedleHelp.ShowHint then begin
      d := g_WMainImages.Images[754];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      d := g_WMain2Images.Images[148];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+268, SurfaceY(GTop)-16, d.ClientRect, d, TRUE);
    end else
    if DKimNeedleMemo.ShowHint then begin
      d := g_WMainImages.Images[755];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      d := g_WMain2Images.Images[148];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+268, SurfaceY(GTop)-16, d.ClientRect, d, TRUE);
    end else begin
      if WLib <> nil then begin //20080701
        if GetTickCount - KimNeedleLogoTimeTick > 200 then begin
         KimNeedleLogoTimeTick := GetTickCount;
         Inc(KimNeedleLogoImginsex);
         if KimNeedleLogoImginsex > 29 then KimNeedleLogoImginsex := 0;
        end;
        d := WLib.Images[1000+KimNeedleLogoImginsex];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if g_btKimNeedleSuccess = 0 then begin
        PomiTextOut(dsurface,SurfaceX(GLeft)+178, SurfaceY(GTop)+115, IntToStr(g_nKimSuccessRate));
        d := g_WMainImages.Images[991];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+30, SurfaceY(GTop)+110, d.ClientRect, d, TRUE);
        d := g_WMainImages.Images[990];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+198, SurfaceY(GTop)+115, d.ClientRect, d, TRUE);
        J:= 0;
        for I:=0 to 4 do begin
          if g_KimNeedleItem[I].ClientItem.s.Name <> '' then begin
            Inc(J);
            d := g_WMainImages.Images[760 + g_KimNeedleItem[I].ClientItem.s.Shape - 1];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft)+ J * 50 - 108, SurfaceY(GTop)-53, d.ClientRect, d, TRUE);
            if DStartKimNeedle.ShowHint then begin
              if GetTickCount - KimNeedleStartFlameTimeTick > 200 then begin
               KimNeedleStartFlameTimeTick := GetTickCount;
               Inc(KimNeedleStartFlameImginsex);
               if KimNeedleStartFlameImginsex > 8 then KimNeedleStartFlameImginsex := 0;
              end;
              d := WLib.Images[1030+KimNeedleStartFlameImginsex];
              if d <> nil then
              dsurface.DrawBlend( SurfaceX(GLeft)+ J * 50 - 108, SurfaceY(GTop)-53, d);
            end;
          end;
        end;
      end else begin
        if g_btKimNeedleSuccessShape in [2..6] then begin //显示锻造成功后logo上的针动画
          if g_btKimNeedleSuccessExplImginsex > 3 then begin
            d := g_WMainImages.Images[759+g_btKimNeedleSuccessShape];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft) + 30, SurfaceY(GTop) - 49, d.ClientRect, d, TRUE);  //针的图
            if GetTickCount - g_dwKimNeedleSuccessStarsTimeTick > 120 then begin
              g_dwKimNeedleSuccessStarsTimeTick := GetTickCount();
              Inc(g_btKimNeedleSuccessStarsImginsex);
            end;
            if g_btKimNeedleSuccessStarsImginsex > 13 then g_btKimNeedleSuccessStarsImginsex := 0;
            d := g_WMainImages.Images[1050+g_btKimNeedleSuccessStarsImginsex];
            if d <> nil then
              dsurface.DrawBlend( SurfaceX(GLeft)- 8, SurfaceY(GTop), d);  //星星
          end else begin
            if GetTickCount - g_dwKimNeedleSuccessExplTimeTick > 120 then begin
              g_dwKimNeedleSuccessExplTimeTick := GetTickCount();
              Inc(g_btKimNeedleSuccessExplImginsex);
            end;
            d := g_WMainImages.Images[1040+g_btKimNeedleSuccessExplImginsex];
            if d <> nil then
              dsurface.DrawBlend( SurfaceX(GLeft), SurfaceY(GTop), d);   //为爆炸的那个图
          end;
        end;
        if g_btKimNeedleSuccess = 1 then nImg := 1073
        else nImg := 1103;
        d := g_WMainImages.Images[nImg];
        if d <> nil then begin
          if g_btKimNeedleSuccess = 1 then
            dsurface.Draw (SurfaceX(GLeft)-8, SurfaceY(GTop)+2, d.ClientRect, d, TRUE)
          else dsurface.Draw (SurfaceX(GLeft)-8, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKimNeedle1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d, dTemp: TAsphyreLockableTexture;
  idx: Integer;
  Butt:TAspDButton;
begin
  Butt:=TAspDButton(Sender);
  if Butt.Tag in [0..4] then begin
    with Butt do begin
      if g_KimNeedleItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_KimNeedleItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_btKimItemOneLevel > 1) and ((g_btKimItemOneLevel <= 5)) then d := g_WMainImages.Images[780 + g_btKimItemOneLevel -2]
        else d := g_WMainImages.Images[790];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if DStartKimNeedle.ShowHint then begin
          d := g_WMainImages.Images[758];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
          if (g_MovingItem.Item.ClientItem.S.StdMode = 17) and (g_MovingItem.Item.ClientItem.S.Shape in [1..5]) and (g_MovingItem.Item.ClientItem.Dura = 1) and g_boItemMoving then begin
            if (g_MovingItem.Item.ClientItem.S.Shape = g_btKimItemOneLevel) or (g_btKimItemOneLevel = 0) then begin
              dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
            end else begin
              dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), GetRGB(56), 90);
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKimNeedle6DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d, dTemp: TAsphyreLockableTexture;
  idx: Integer;
  Butt:TAspDButton;
begin
  Butt:=TAspDButton(Sender);
  if Butt.Tag in [5..7] then begin
    with Butt do begin
      if g_KimNeedleItem[Butt.Tag].ClientItem.s.Name <> '' then begin
        idx := g_KimNeedleItem[Butt.Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_btKimItemOneLevel > 1) and (g_btKimItemOneLevel <= 5) then d := g_WMainImages.Images[785 + g_btKimItemOneLevel - 2]
        else d := g_WMainImages.Images[791];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if DStartKimNeedle.ShowHint then begin
          d := g_WMainImages.Images[758];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
          if (g_MovingItem.Item.ClientItem.S.StdMode = 18) and g_boItemMoving then begin
            if (g_MovingItem.Item.ClientItem.S.Shape = g_btKimItemOneLevel) or (g_btKimItemOneLevel = 0) then begin
              dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), $0046B5FF, 90);
            end else begin
              dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), 33, 31), GetRGB(56), 90);
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWKimNeedleMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DKimNeedle1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ShowHint(TAspDButton(Sender).SurfaceX(TAspDButton(Sender).GLeft), TAspDButton(Sender).SurfaceY(TAspDButton(Sender).GTop)-19, '金针' , clWhite, FALSE);
end;

procedure TFrmDlg.DKimNeedle6MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ShowHint(TAspDButton(Sender).SurfaceX(TAspDButton(Sender).GLeft)-2, TAspDButton(Sender).SurfaceY(TAspDButton(Sender).GTop)-19, '幸运符' , clWhite, FALSE);
end;

procedure TFrmDlg.ShowKimNeedle(Bool: Boolean);
begin
  DKimNeedle1.Visible := Bool;
  DKimNeedle2.Visible := Bool;
  DKimNeedle3.Visible := Bool;
  DKimNeedle4.Visible := Bool;
  DKimNeedle5.Visible := Bool;
  DKimNeedle6.Visible := Bool;
  DKimNeedle7.Visible := Bool;
  DKimNeedle8.Visible := Bool;
end;

procedure TFrmDlg.DKimNeedleHelpClick(Sender: TObject; X, Y: Integer);
begin
  if DStartKimNeedle.ShowHint then Exit;
  DKimNeedleMemo.ShowHint := False;
  DKimNeedleHelp.ShowHint := True;
  ShowKimNeedle(False);
  DKimNeedleBar.Visible := False;
end;

procedure TFrmDlg.DKimNeedleMemoClick(Sender: TObject; X, Y: Integer);
begin
  if DStartKimNeedle.ShowHint then Exit;
  DKimNeedleHelp.ShowHint := False;
  DKimNeedleMemo.ShowHint := True;
  ShowKimNeedle(True);
  DKimNeedleBar.Visible := False;
end;

procedure TFrmDlg.DStartKimNeedleClick(Sender: TObject; X, Y: Integer);
var
  I, nItemMakeIdx: Integer;
  sStr: string;
begin
  if DStartKimNeedle.ShowHint then Exit;
  DKimNeedleHelp.ShowHint := False;
  DKimNeedleMemo.ShowHint := False;
  ShowKimNeedle(True);
  DKimNeedleBar.Visible := True;
  sStr := '';
  nItemMakeIdx:= 0;
  for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
    if g_KimNeedleItem[I].ClientItem.s.Name <> '' then begin
      if (g_KimNeedleItem[I].ClientItem.s.StdMode = 17) and (nItemMakeIdx = 0) then nItemMakeIdx:= g_KimNeedleItem[I].ClientItem.MakeIndex
      else if g_KimNeedleItem[I].ClientItem.MakeIndex > 0 then sStr := sStr + IntToStr(g_KimNeedleItem[I].ClientItem.MakeIndex) + '/';
    end;
  end;
  if nItemMakeIdx >0 then begin
    DStartKimNeedle.ShowHint := True;
    DKimNeedleBar.ShowHint := True;
    boKimShowBarSend := True;
    KimShowBarImginsex := g_nKimSuccessRate;
  end;
end;

procedure TFrmDlg.DKimNeedleCloseClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
begin
  if DStartKimNeedle.ShowHint then Exit;
  DWKimNeedle.Visible := False;
  DItemBag.Visible := FALSE;
  for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
    if g_KimNeedleItem[I].ClientItem.s.Name <> '' then begin
      AddItemBag(g_KimNeedleItem[I]);
      g_KimNeedleItem[I].ClientItem.s.Name := '';
    end;
  end;
end;

{-97..-98是金币
-45..-46是请酒里的烧酒物品
-47..-53是酿酒物品
-54..63是挑战物品
-64..71是金针物品}
procedure TFrmDlg.DKimNeedle1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientEffecItem;
   butt: TAspDButton;
   I: Integer;
begin
   if DStartKimNeedle.ShowHint then Exit;
   butt := TAspDButton(Sender);
   if not g_boItemMoving then begin
      if g_KimNeedleItem[butt.Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_KimNeedleItem[butt.Tag].ClientItem.s);
         if g_MovingItem.Item.ClientItem.S.Name <> '' then exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(butt.Tag + 64);
         g_MovingItem.Item := g_KimNeedleItem[butt.Tag];
         if g_nKimSuccessRate >= g_KimNeedleItem[butt.Tag].ClientItem.s.AniCount then begin
           Dec(g_nKimSuccessRate, g_KimNeedleItem[butt.Tag].ClientItem.s.AniCount);
         end else g_nKimSuccessRate := 0;
         g_KimNeedleItem[butt.Tag].ClientItem.s.Name := '';
         if g_btKimItemNum > 0 then Dec(g_btKimItemNum);
         if (g_btKimNeedleNum > 0) and (g_MovingItem.Item.ClientItem.S.StdMode = 17) then Dec(g_btKimNeedleNum);
         if g_btKimItemNum = 0 then begin
           g_btKimItemOneLevel:= 0;
           g_nKimSuccessRate := 0;
           g_btKimNeedleNum:= 0;
         end;
      end;
   end else begin
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -64) or (g_MovingItem.Index = -65) or (g_MovingItem.Index = -66)
         or (g_MovingItem.Index = -67) or (g_MovingItem.Index = -68) or (g_MovingItem.Index = -69) or (g_MovingItem.Index = -70) or (g_MovingItem.Index = -71) then begin
           case butt.Tag of
             0..4: begin
               if (g_MovingItem.Item.ClientItem.S.StdMode <> 17) or (not (g_MovingItem.Item.ClientItem.S.Shape in [1..5])) or (g_MovingItem.Item.ClientItem.Dura <> 1) then Exit;
               if (g_MovingItem.Item.ClientItem.S.Shape = g_btKimItemOneLevel) and (g_btKimNeedleNum > 1) then begin
                 case g_btKimItemOneLevel of
                   2: if g_btKimNeedleNum >= 3 then Exit;
                   3..5: if g_btKimNeedleNum >= 2 then Exit;
                 end;
               end;
             end;
             5..7: if (g_MovingItem.Item.ClientItem.S.StdMode <> 18) then Exit;
           end;
           if (g_btKimItemNum <> 0) then begin
             if (g_MovingItem.Item.ClientItem.S.Shape <> g_btKimItemOneLevel) then begin
               for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
                 if g_KimNeedleItem[I].ClientItem.s.Name <> '' then begin
                   AddItemBag(g_KimNeedleItem[I]);
                   g_KimNeedleItem[I].ClientItem.s.Name := '';
                 end;
               end;
               g_btKimItemNum:= 0;
               g_btKimNeedleNum := 0;
               g_nKimSuccessRate := 0;
             end;
           end;
           if (g_btKimItemNum = 0) then g_nKimSuccessRate := 0;
           ItemClickSound (g_MovingItem.Item.ClientItem.S);
           if g_KimNeedleItem[butt.Tag].ClientItem.s.Name <> '' then begin
              temp := g_KimNeedleItem[butt.Tag];
              g_KimNeedleItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(butt.Tag + 64);
              g_MovingItem.Item := temp
           end else begin
              g_KimNeedleItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.ClientItem.S.name := '';
              g_boItemMoving := FALSE;
              Inc(g_nKimSuccessRate, g_KimNeedleItem[butt.Tag].ClientItem.s.AniCount);
              if g_nKimSuccessRate >= 100 then  g_nKimSuccessRate := 100;
           end;
          if g_btKimItemNum < 9 then begin
            if (g_btKimNeedleNum < 5) and (g_KimNeedleItem[butt.Tag].ClientItem.s.StdMode = 17) then Inc(g_btKimNeedleNum);
            Inc(g_btKimItemNum);
            if g_btKimItemNum = 1 then begin
              g_btKimItemOneLevel := g_KimNeedleItem[butt.Tag].ClientItem.s.Shape;
              FrmDlg.DKimNeedleBar.ShowHint := False;
              g_btKimNeedleSuccessShape := 0;
              g_btKimNeedleSuccess := 0;
            end;
          end;
      end;
   end;
end;

procedure TFrmDlg.DKimNeedleBarDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  I, nItemMakeIdx: Integer;
  sStr: string;
  d: TAsphyreLockableTexture;
  Rc: TRect;
begin
  with DKimNeedleBar do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_nKimSuccessRate > 0 then begin
      if not DKimNeedleBar.ShowHint{not g_boShowKimBar} then begin
        d := g_WMainImages.Images[759];
        if d <> nil then begin
           rc := d.ClientRect;
           rc.Right := Round((rc.Right-rc.Left) / 100 * g_nKimSuccessRate);
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end else begin
        if KimShowBarImginsex < 100 then begin
          if GetTickCount - KimShowBarTimeTick > 70 then begin
            KimShowBarTimeTick := GetTickCount();
            Inc(KimShowBarImginsex);
          end;
        end;
        if KimShowBarImginsex >= 100 then begin
          if boKimShowBarSend then begin
            sStr := '';
            nItemMakeIdx:= 0;
            for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
              if g_KimNeedleItem[I].ClientItem.s.Name <> '' then begin
                if (g_KimNeedleItem[I].ClientItem.s.StdMode = 17) and (nItemMakeIdx = 0) then nItemMakeIdx:= g_KimNeedleItem[I].ClientItem.MakeIndex
                else if g_KimNeedleItem[I].ClientItem.MakeIndex > 0 then sStr := sStr + IntToStr(g_KimNeedleItem[I].ClientItem.MakeIndex) + '/';
              end;
            end;
            if nItemMakeIdx >0 then begin
              frmMain.SendKimItems(nItemMakeIdx, sStr);
            end else begin //显示锻造失败
              g_btKimNeedleSuccess := 2;
              FillChar (g_KimNeedleItem, sizeof(TClientEffecItem)*8, #0);
              DStartKimNeedle.ShowHint := False;
              g_btKimItemNum := 0;
              g_btKimNeedleNum := 0;
              g_nKimSuccessRate := 0;
              g_btKimItemOneLevel := 0;
              g_btKimNeedleSuccessShape := 0;
            end;
            boKimShowBarSend := False;
          end;
        end;
        d := g_WMainImages.Images[757];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Right := Round((rc.Right-rc.Left) / 100 * KimShowBarImginsex);
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateSsasDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
  {$IF M2Version <> 2} //不能去掉
  {$IFEND}
end;

procedure TFrmDlg.DStateSsasClick(Sender: TObject; X, Y: Integer);
var
  ly: Integer;
begin
  ly := Y - DStateSsas.GTop;
  if (ly >= 13) and (ly <= 55) then begin
    if StateTab = 0 then begin
      StatePage := 0;
      PageChanged;
    end else begin
      InternalForcePage := 0;
      InternalForcePageChanged;
    end;
  end else
  if (ly >= 56) and (ly <= 100) then begin
    if StateTab = 0 then begin
      StatePage := 1;
      PageChanged;
    end else begin
      InternalForcePage := 1;
      InternalForcePageChanged;
    end;
  end else
  if (ly >= 101) and (ly <= 144) then begin
    if StateTab = 0 then begin
      StatePage := 2;
      PageChanged;
    end else begin
      InternalForcePage := 2;
      InternalForcePageChanged;
    end;
  end else
  if (ly >= 145) and (ly <= 188) then begin
    if StateTab = 0 then begin
      StatePage := 3;
      PageChanged;
    end else begin
      InternalForcePage := 3;
      InternalForcePageChanged;
    end;
  end;
  if (ly >= 189) and (ly <= 233) then begin
    if StateTab = 0 then begin
      StatePage := 4;
      PageChanged;
    end;
  end;
end;

procedure TFrmDlg.DStateWinPulseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  hcolor: integer;
  btX, btY: Byte;
  sStr: string;
begin
  {$IF M2Version = 1}
  if g_MySelf = nil then exit;
  with DStateWinPulse do begin
    if WLib <> nil then begin //20080701
      if g_MySelf.m_btSex = 1 then begin //女
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 3]
        else if StatePulsePage = 4 then //奇经
          d := WLib.Images[1188]
        else d := WLib.Images[FaceIndex + 2];
      end else begin
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 1]
        else if StatePulsePage = 4 then //奇经
          d := WLib.Images[1186]
        else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1171]
    else d := g_WMainImages.Images[830+StatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft) + 92, SurfaceY(GTop) + 6, d.ClientRect, d, TRUE);
    if StatePulsePage = 4 then begin//奇经
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        hcolor := 1180
      else hcolor := 1181+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[hcolor];
    end else begin
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        hcolor := 860
      else hcolor := 861+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[hcolor+StatePulsePage * 10];
    end;
    if d <> nil then
    dsurface.DrawBlend( SurfaceX(GLeft), SurfaceY(GTop), d);
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1172]
    else d := g_WMainImages.Images[840+StatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    
    if ((g_btPulseOriginPage = StatePulsePage) or (StatePulsePage = 4){奇经}) and (g_btPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;
    //-----------------穴位位置---------------------
    case StatePulsePage of
      0: begin
        btX := 37;
        btY := 30;
      end;
      1: begin
        btX := 48;
        btY := 24;
      end;
      2: begin
        btX := 47;
        btY := 38;
      end;
      3: begin
        btX := 48;
        btY := 20;
      end;
      4: begin
        btX := 47;
        btY := 16;
      end;
      else begin
        btX := 0;
        btY := 0;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then
      d := g_WMainImages.Images[851]
    else if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1)) or (StatePulsePage = 4){奇经} then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1)) or ((StatePulsePage = 4) and (g_HumanPulseArr[StatePulsePage].nPulsePoint = 0)){奇经} then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
      end;
    end;
    case StatePulsePage of
      0: begin
        btX := 36;
        btY := 59;
      end;
      1: begin
        btX := 48;
        btY := 64;
      end;
      2: begin
        btX := 41;
        btY := 68;
      end;
      3: begin
        btX := 48;
        btY := 40;
      end;
      4: begin
        btX := 92;
        btY := 102;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (StatePulsePage <> 4{奇经}) and (g_btPulsePoint = 2) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if ((g_btPulseOriginPage = StatePulsePage) and (StatePulsePage <> 4{奇经})) and (g_btPulsePoint = 2) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
      end;
    end;

    case StatePulsePage of
      0: begin
        btX := 38;
        btY := 84;
      end;
      1: begin
        btX := 54;
        btY := 104;
      end;
      2: begin
        btX := 41;
        btY := 106;
      end;
      3: begin
        btX := 48;
        btY := 61;
      end;
      4: begin
        btX := 3;
        btY := 101;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
      end;
    end;
    case StatePulsePage of
      0: begin
        btX := 45;
        btY := 106;
      end;
      1: begin
        btX := 61;
        btY := 143;
      end;
      2: begin
        btX := 36;
        btY := 139;
      end;
      3: begin
        btX := 48;
        btY := 85;
      end;
      4: begin
        btX := 65;
        btY := 185;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
      end;
    end;
    case StatePulsePage of
      0: begin
        btX := 52;
        btY := 88;
      end;
      1: begin
        btX := 64;
        btY := 184;
      end;
      2: begin
        btX := 33;
        btY := 175;
      end;
      3: begin
        btX := 48;
        btY := 109;
      end;
      4: begin
        btX := 29;
        btY := 186;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
      end;
    end;
    //------------------导航显示----------------------
    if StatePulsePage = 0 then
      d := g_WMainImages.Images[812]
    else d := g_WMainImages.Images[813];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+23, d.ClientRect, d, TRUE);
    if g_HumanPulseArr[0].boOpenPulse then begin
      if StatePulsePage = 1 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+47, d.ClientRect, d, TRUE);
    end;
    if g_HumanPulseArr[1].boOpenPulse then begin
      if StatePulsePage = 2 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+71, d.ClientRect, d, TRUE);
    end;
    if g_HumanPulseArr[2].boOpenPulse then begin
      if StatePulsePage = 3 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+95, d.ClientRect, d, TRUE);
    end;
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[812]
    else d := g_WMainImages.Images[813];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop), d.ClientRect, d, TRUE);
    //----------------鼠标移过导航--------------------
    btX := 140;
    btY := 28;
    if g_btStateWinPulseMoving = 1 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $008BC4ED;
        btX := 141;
        btY := 29;
      end else if StatePulsePage = 0 then hcolor := $008BC4ED
      else hcolor := $006C849A;
    end else if StatePulsePage = 0 then hcolor := $008BC4ED
    else hcolor := $006C849A;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '冲脉');
    if g_HumanPulseArr[0].boOpenPulse then begin
      btX := 140;
      btY := 52;
      if g_btStateWinPulseMoving = 2 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 53;
        end else if StatePulsePage = 1 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if StatePulsePage = 1 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴跷');
    end;
    if g_HumanPulseArr[1].boOpenPulse then begin
      btX := 140;
      btY := 75;
      if g_btStateWinPulseMoving = 3 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 76;
        end else if StatePulsePage = 2 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if StatePulsePage = 2 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴维');
    end;
    if g_HumanPulseArr[2].boOpenPulse then begin
      btX := 140;
      btY := 99;
      if g_btStateWinPulseMoving = 4 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 100;
        end else if StatePulsePage = 3 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if StatePulsePage = 3 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '任脉');
    end;
    btX := 140;
    btY := 5;
    if g_btStateWinPulseMoving = 11 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $008BC4ED;
        btX := 141;
        btY := 6;
      end else if StatePulsePage = 4 then hcolor := $008BC4ED
      else hcolor := $006C849A;
    end else if StatePulsePage = 4 then hcolor := $008BC4ED
    else hcolor := $006C849A;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '奇经');
    //-----------------------------------
    case StatePulsePage of
      0: begin
        btX := 81;
        btY := 35;
      end;
      1: begin
        btX := 4;
        btY := 29;
      end;
      2: begin
        btX := 2;
        btY := 41;
      end;
      3: begin
        btX := 2;
        btY := 25;
      end;
      4: begin
        btX := 4;
        btY := 22;
      end;
    end;
    if g_btStateWinPulseMoving = 5 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,0));
    case StatePulsePage of
      0: begin
        btX := 80;
        btY := 64;
      end;
      1: begin
        btX := 4;
        btY := 68;
      end;
      2: begin
        btX := 82;
        btY := 73;
      end;
      3: begin
        btX := 93;
        btY := 45;
      end;
      4: begin
        btX := 68;
        btY := 94;
      end;
    end;
    if g_btStateWinPulseMoving = 6 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,1));
    case StatePulsePage of
      0: begin
        btX := 2;
        btY := 89;
      end;
      1: begin
        btX := 92;
        btY := 108;
      end;
      2: begin
        btX := 1;
        btY := 110;
      end;
      3: begin
        btX := 3;
        btY := 67;
      end;
      4: begin
        btX := 26;
        btY := 116;
      end;
    end;
    if g_btStateWinPulseMoving = 7 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,2));
    case StatePulsePage of
      0: begin
        btX := 6;
        btY := 111;
      end;
      1: begin
        btX := 24;
        btY := 146;
      end;
      2: begin
        btX := 70;
        btY := 144;
      end;
      3: begin
        btX := 93;
        btY := 90;
      end;
      4: begin
        btX := 42;
        btY := 178;
      end;
    end;
    if g_btStateWinPulseMoving = 8 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,3));
    case StatePulsePage of
      0: begin
        btX := 86;
        btY := 92;
      end;
      1: begin
        btX := 29;
        btY := 189;
      end;
      2: begin
        btX := 66;
        btY := 180;
      end;
      3: begin
        btX := 4;
        btY := 114;
      end;
      4: begin
        btX := 3;
        btY := 190;
      end;
    end;
    if g_btStateWinPulseMoving = 9 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,4));

    if StatePulsePage <> 4 then begin
      if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
        case g_HumanPulseArr[StatePulsePage].nPulseLevel of
          0: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
          end;
          1: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          2: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          3: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          4: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          5: begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
        end;
      end else begin
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
      end;
    end;

    if g_btStateWinPulseMoving = 10 then begin
      if g_boStateWinPulseDowning then
        d := g_WMainImages.Images[815]
      else d := g_WMainImages.Images[814];
    end else d := g_WMainImages.Images[814];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+7, SurfaceY(GTop)+210, d.ClientRect, d, TRUE);
    case StatePulsePage of
      0: sStr := '修炼冲脉';
      1: sStr := '修炼阴跷';
      2: sStr := '修炼阴维';
      3: sStr := '修炼任脉';
      4: sStr := '修炼奇经';
    end;
    btX := 13;
    btY := 214;
    if (g_HumanPulseArr[StatePulsePage].nPulseLevel >= 5) or ((g_HumanPulseArr[StatePulsePage].nPulsePoint = 0) and (StatePulsePage = 4)) then begin
      hcolor := clGray{00777C7B};
    end else begin
      if g_btStateWinPulseMoving = 10 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
    end;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, sStr);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStateWinPulseMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwInternalForceLevel >= nlevel then Result := '~y';
  end;
var
  lx, ly: Integer;
  str: string;
begin
  {$IF M2Version = 1}
  DScreen.ClearHint;

  g_boStateWinPulseDowning := False;
  g_btStateWinPulseMoving := 0;
  lx := X - DStateWinPulse.GLeft;
  ly := Y - DStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    g_btStateWinPulseMoving := 1;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[0].boOpenPulse then begin
      if g_HumanPulseArr[0].nPulseLevel = 1 then begin
        str := GetPulsDesc(Format('冲脉%d-%d',[g_HumanPulseArr[0].nPulseLevel,g_MySelf.m_btJob]));
      end else begin
        if g_HumanPulseArr[0].nPulseLevel = 0 then str := GetPulsDesc('冲脉已通')
        else str := GetPulsDesc(Format('冲脉%d',[g_HumanPulseArr[0].nPulseLevel]));
      end;
      if str <> '' then begin
        with g_BatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end else begin
      str := GetPulsDesc('冲脉未通');
      if str <> '' then begin
        with g_BatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    g_btStateWinPulseMoving := 2;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[0].boOpenPulse then begin
      if g_HumanPulseArr[1].boOpenPulse then begin
        if g_HumanPulseArr[1].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('阴跷%d-%d',[g_HumanPulseArr[1].nPulseLevel,g_MySelf.m_btJob]));
        end else begin
          if g_HumanPulseArr[1].nPulseLevel = 0 then str := GetPulsDesc('阴跷已通')
          else str := GetPulsDesc(Format('阴跷%d',[g_HumanPulseArr[1].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴跷未通');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    g_btStateWinPulseMoving := 3;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[1].boOpenPulse then begin
      if g_HumanPulseArr[2].boOpenPulse then begin
        if g_HumanPulseArr[2].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('阴维%d-%d',[g_HumanPulseArr[2].nPulseLevel,g_MySelf.m_btJob]));
        end else begin
          if g_HumanPulseArr[2].nPulseLevel = 0 then str := GetPulsDesc('阴维已通')
          else str := GetPulsDesc(Format('阴维%d',[g_HumanPulseArr[2].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴维未通');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    g_btStateWinPulseMoving := 4;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[2].boOpenPulse then begin
      if g_HumanPulseArr[3].boOpenPulse then begin
        if g_HumanPulseArr[3].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('任脉%d-%d',[g_HumanPulseArr[3].nPulseLevel,g_MySelf.m_btJob]));
        end else begin
          if g_HumanPulseArr[3].nPulseLevel = 0 then str := GetPulsDesc('任脉已通')
          else str := GetPulsDesc(Format('任脉%d',[g_HumanPulseArr[3].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('任脉未通');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if  (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24)  then begin //奇经
    g_btStateWinPulseMoving := 11;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    str := GetPulsDesc('奇经');
    {if g_HumanPulseArr[4].nPulseLevel = 0 then str := GetPulsDesc('奇经已通')
    else str := GetPulsDesc(Format('奇经%d',[g_HumanPulseArr[3].nPulseLevel]));  }
    if str <> '' then begin
      with g_BatterDesc do begin
        sName := GetPulsePageName(4);
        str := GetValidStr3 (str, sLine1, ['\']);
        str := GetValidStr3 (str, sLine2, ['\']);
        str := GetValidStr3 (str, sLine3, ['\']);
      end;
    end;
  end else
  if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
    g_btStateWinPulseMoving := 10;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    with g_BatterDesc do begin
      sName := ' ';
      sLine1 := '欲练连击，必练内功；打通五穴';
      sLine2 := '，经络自通。欲强连击，锻造金';
      sLine3 := '针；修炼经络，威力提升。';
    end;
  end;
  case StatePulsePage of
    0: begin
      //1
      if (lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47){字} then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 106, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+34, format('%s穴:已打通',[GetPulseName(StatePulsePage,0)]) , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 106, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+34,
                      format('%s穴:待打通',[GetPulseName(StatePulsePage,0)])+'~y\'+format('需要内功等级：%d',[g_btPulseLevel])+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 106, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+34,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 62, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+29, '幽门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 62, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+29,
                      '幽门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 62, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+29,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);;//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76){字} then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 105, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 105, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 105, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+58, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+58,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+58,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      // x 24 y 12
      if (lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+88, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+88,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+88,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 63, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+83, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 63, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+83,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 63, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+83,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 31, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+110, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 31, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+110,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 31, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+110,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 70, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 70, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 70, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 111, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+91, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 111, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+91,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 111, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+91,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 77, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+87, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 77, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+87,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 77, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+87,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    1: begin
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+28, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+28,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+28,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+23, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+23,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+23,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+107, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+107,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+107,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 79, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+103, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 79, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+103,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
           DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 79, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+103,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 49, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+145, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 49, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+145,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 49, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+145,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 87, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+142, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 87, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+142,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 87, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+142,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+188, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+188,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+188,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 89, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+183, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 89, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+183,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 89, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+183,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    2: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+40, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+40,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+40,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+37, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+37,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+37,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 107, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+72, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 107, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+72,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 107, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+72,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 26, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+109, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 26, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+109,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 26, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+109,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 95, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+143, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 95, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+143,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 95, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+143,
                  '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+138, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+138,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+138,
                      '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 91, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+179, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 91, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+179,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 91, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+179,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 58, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+174, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 58, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+174,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 58, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+174,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    3: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+24, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+24,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+24,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+19, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+19,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+19,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+44, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+44,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+44,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+39, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+39,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+39,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+66, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+66,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+66,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+60, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+60,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+60,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+89, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+89,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+89,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+84, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+84,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+84,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+113, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+113,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+113,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+108, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+108,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+108,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    4: begin //奇经
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+21, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin//if {(g_btPulseOriginPage = StatePulsePage) and }(g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+21,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel)}, FALSE, FALSE, 0);
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+21,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end; }
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+15, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin//if {(g_btPulseOriginPage = StatePulsePage) and }(g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+15,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel)}, FALSE, FALSE, 0);
          {str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+15,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;}
      end;
      //2
      if (lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 93, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+93, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 93, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+93,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 93, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+93,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;   }
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'夹脊穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+101, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+101,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+101,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //3
      if (lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 51, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+115, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 51, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+115,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 51, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+115,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+100, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+100,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+100,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //4
      if (lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 67, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+177, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 67, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+177,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 67, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+177,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end;
        str := GetPulsDesc('八风');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 90, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+184, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 90, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+184,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 90, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+184,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('八风');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //5
      if (lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+189, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+189,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+189,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+185, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+185,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+185,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStateWinPulseClick(Sender: TObject; X, Y: Integer);
var
  lx, ly: Integer;
begin
  {$IF M2Version = 1}
  lx := X - DStateWinPulse.GLeft;
  ly := Y - DStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    StatePulsePage := 0;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    if g_HumanPulseArr[0].boOpenPulse then StatePulsePage := 1;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    if g_HumanPulseArr[1].boOpenPulse then StatePulsePage := 2;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    if g_HumanPulseArr[2].boOpenPulse then StatePulsePage := 3;
  end;
  if (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24) then begin
    StatePulsePage := 4;
  end;
  case StatePulsePage of
    0: begin
      //1
      //x24 y23
      if ((lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47)){字} or ((lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      // x 24 y 12
      if ((lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101)){字} or ((lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123)){字} or ((lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104)){字} or ((lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    1: begin
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120)){字} or ((lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158)){字} or ((lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201)){字} or ((lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    2: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192)){字} or ((lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    3: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    4: begin //奇经
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenPulsePoint(StatePulsePage, 1);
        end else begin
          ShowQJPractice(False);
        end;
      end;
      //2
      (*if ((lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106)){字} or ((lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128)){字} or ((lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190)){字} or ((lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202)){字} or ((lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;      *)
    end;
  end;
  if ((lx >= 7) and (lx <= 67) and (ly >= 210) and (ly <= 231)) then begin
    if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
      if g_HumanPulseArr[StatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendPracticePulse(StatePulsePage);
      end;
    end else begin
      case StatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HumanPulseArr[StatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(False);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  icon: Integer;
begin
  {$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if Sender = DWinBatterTopMag4 then begin
      if not g_boOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft-4), SurfaceY(TAspDButton(Sender).GTop-4), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;

    if g_WinBatterMagicList.Count > 0 then begin
      if g_WinBatterTopMagic[TAspDButton(Sender).Tag].Def.sMagicName <> '' then begin
        case g_WinBatterTopMagic[TAspDButton(Sender).Tag].Def.btEffect of
         102:icon := 952;//三绝杀
         103:icon := 944;//双龙破
         104:icon := 934;//虎啸诀
         105:icon := 950;//追心刺
         106:icon := 942;//凤舞祭
         107:icon := 936;//八卦掌
         108:icon := 956;//断岳斩
         109:icon := 946;//惊雷爆
         110:icon := 932;//三焰咒
         111:icon := 954;//横扫千军
         112:icon := 940;//冰天雪地
         113:icon := 930;//万剑归宗
        else icon := -1;
        end;
        if TAspDButton(Sender).Downed then
          d := g_WMainImages.Images[icon+1]
        else d := g_WMainImages.Images[icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
      end else begin
        if TAspDButton(Sender).Downed then begin
          if g_WinBatterTopMagic[TAspDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TAspDButton(Sender).Tag*2+1];
          end;
        end else begin
          if g_WinBatterTopMagic[TAspDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TAspDButton(Sender).Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
        if (g_WinBatterTopMagic[0].Def.sMagicName = '') and (g_WinBatterTopMagic[1].Def.sMagicName = '') and (g_WinBatterTopMagic[2].Def.sMagicName = '') and (g_WinBatterTopMagic[3].Def.sMagicName = '')
           and (g_WinBatterTopMagic[0].CurTrain <> 1) and (g_WinBatterTopMagic[1].CurTrain <> 1) and (g_WinBatterTopMagic[2].CurTrain <> 1) and (g_WinBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DWinBatterTopMag1 then begin
            if (not TAspDButton(Sender).Downed) and (not DWinBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft)+10, SurfaceY(TAspDButton(Sender).GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStateWinBatterDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  bbx, bby, I, icon, trainlv: Integer;
  magtop, magline, m: Byte;
  pm: PTClientMagic;
begin
  {$IF M2Version = 1}
  with DStateWinBatter do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

        d := g_WMainImages.Images[912];
        if d <> nil then
         dsurface.Draw (SurfaceX(GLeft)+118, SurfaceY(GTop)+6, d.ClientRect, d, TRUE);

        bbx := SurfaceX(GLeft) - 2;
        bby := SurfaceY(GTop) + 81;

        magtop := 0;//InternalForceMagicPage * 6;
        magline := _MIN(4, g_WinBatterMagicList.count);//_MIN(InternalForceMagicPage*6+6, g_InternalForceMagicList.Count);
        for i:=magtop to magline-1 do begin
           pm := PTClientMagic (g_WinBatterMagicList[i]);
           m := i - magtop;
           case pm.Def.btEffect of
             102:icon := 952;//三绝杀
             103:icon := 944;//双龙破
             104:icon := 934;//虎啸诀
             105:icon := 950;//追心刺
             106:icon := 942;//凤舞祭
             107:icon := 936;//八卦掌
             108:icon := 956;//断岳斩
             109:icon := 946;//惊雷爆
             110:icon := 932;//三焰咒
             111:icon := 954;//横扫千军
             112:icon := 940;//冰天雪地
             113:icon := 930;//万剑归宗
             else icon := -1;
           end;
           d := g_WMainImages.Images[icon];
           if d <> nil then
              dsurface.Draw (bbx + 9, bby+7+m*38, d.ClientRect, d, TRUE);
                      
           d := g_WMainImages.Images[112]; //lv
           if d <> nil then
              dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);

           d := g_WMainImages.Images[111]; //exp
           if d <> nil then begin
              dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
           end;
        end;
           for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_WinBatterMagicList[i]);
              m := i - magtop;
              if not (pm.Level in [0..5]) then pm.Level := 0;
              case pm.Def.btEffect of
                102..104: begin
                  case Ord(pm.Key) of
                    1:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+15%暴击');
                    end;
                    3: begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+25%暴击');
                    end;
                    4: begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+30%暴击');
                    end;
                    else
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%暴击');
                  end;
                end;
                105..107: begin
                  case Ord(pm.Key) of
                     1:begin
                        AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+10%暴击');
                     end;
                     2:begin
                        AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+15%暴击');
                     end;
                     3:begin
                        AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+25%暴击');
                     end;
                     4:begin
                        AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+30%暴击');
                     end;
                     else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%暴击');
                  end;
                end;
                108..110: begin
                  case Ord(pm.Key) of
                    1:begin
                       AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                       AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+15%暴击');
                    end;
                    3:begin
                       AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+25%暴击');
                    end;
                    4:begin
                       AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+30%暴击');
                    end;
                    else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%暴击');
                  end;
                end;
                111..113: begin
                  case Ord(pm.Key) of
                    1:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+15%暴击');
                    end;
                    3:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+25%暴击');
                    end;
                    4:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+30%暴击');
                    end;
                    else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%暴击');
                  end;
                end;
              end;
              if pm.Level in [0..3,5] then trainlv := pm.Level
              else if pm.Level = 4 then trainlv := 3
              else trainlv := 0;
              AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                 if trainlv < 5 then
                    AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                 else AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
              end;
           end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterComDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  I: Integer;
  btLine: Byte;
  sStr: string;
begin
  with DWinBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if WinBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+WinBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+WinBatterComIndex*15+19) ,clNavy);
    end;
    btLine := _MIN(4, g_WinBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_WinBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_WinBatterMagicList.Items[I]).Def.sMagicName;
        if I = WinBatterComIndex then
          AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if WinBatterComIndex = btLine then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if WinBatterComIndex = btLine +1 then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
end;

procedure TFrmDlg.DHeroSpleenDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{var
  d: TAsphyreLockableTexture;}
begin
{  with DHeroSpleen do begin
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1127];
      if d = nil then d := g_WMain3Images.Images[410];
    end else d := g_WMain3Images.Images[410];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;  }
end;

procedure TFrmDlg.DBatterShowImgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DBatterShowImg do begin
    if WLib <> nil then begin
      if {(not DHeroSpleen.Visible) and} (g_WinBatterMagicList.Count > 0)then begin
        d := g_WMainImages.Images[1120];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          if g_boCanUseBatter then begin
            if GetTickCount - BatterShowTimeTick > 200 then begin
              BatterShowTimeTick := GetTickCount;
              Inc(BatterShowImginsex);
              if BatterShowImginsex > 1 then BatterShowImginsex := 0;
            end;
            d := g_WMainImages.Images[1121+BatterShowImginsex];
            if d<>nil then
             dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWinBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  btLine: Byte;
  ss: Integer;
begin
  with DWinBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_WinBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    WinBatterComIndex := ss;
  end;
end;

procedure TFrmDlg.DWinBatterComMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
begin
  if WinBatterComIndex <> - 1 then begin
    if g_WinBatterMagicList.Count - WinBatterComIndex > 0 then begin
      for I:=Low(g_WinBatterTopMagic) to High(g_WinBatterTopMagic) do begin
        if g_WinBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_WinBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_WinBatterTopMagic[BatterTopMagIndex] := pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^;
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 0;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_WinBatterMagicList[WinBatterComIndex]);
      pm.Key := Chr(BatterTopMagIndex + 1);
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, Chr(BatterTopMagIndex + 1), str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = 0 then begin//空
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = -1 then begin//随机
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 1;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end;
    DWinBatterCom.Visible := False;
  end;
end;

procedure TFrmDlg.DWinBatterRandomDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  {$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if not TAspDButton(Sender).Downed then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + GWidth div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 5, $008CC6EF, clBlack, Hint);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + GWidth div 2 + 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 6, $0040BBF1, clBlack, Hint);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterRandomClick(Sender: TObject; X, Y: Integer);
var
  pm: PTClientMagic;
  I: Integer;
begin
  FillChar (g_WinBatterTopMagic, sizeof(TClientMagic)*4, #0);
  if g_WinBatterMagicList.Count > 0 then begin
    for i:=0 to g_WinBatterMagicList.Count-1 do begin
      pm := PTClientMagic (g_WinBatterMagicList[i]);
      if (Ord(pm.Key) = 1) or (Ord(pm.Key) = 2) or (Ord(pm.Key) = 3) or (Ord(pm.Key) = 4) then begin
        pm.Key := #0;
        FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
      end;
    end;
  end;
  g_WinBatterTopMagic[0].CurTrain := 1;
  g_WinBatterTopMagic[1].CurTrain := 1;
  g_WinBatterTopMagic[2].CurTrain := 1;
  g_WinBatterTopMagic[3].CurTrain := 1;
  FrmMain.SendMagicKeyChange (-1, #0, '1/1/1/1');
end;

procedure TFrmDlg.DWinBatterSetKeyClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  g_btSdoAssistantPage := 5;
  NewSdoAssistantPageChanged();
  frmMain.OpenSdoAssistant();
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DWinBatterTopMag1 then begin
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterTopMag2 then begin
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterTopMag3 then begin
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterTopMag4 then begin
    if not g_boOpen4BatterSkill then Exit;
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterRandom then begin
    DScreen.ShowHint(DWinBatterRandom.SurfaceX(DWinBatterRandom.GLeft), DWinBatterRandom.SurfaceY(DWinBatterRandom.GTop+DWinBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterSetKey then begin
    DScreen.ShowHint(DWinBatterSetKey.SurfaceX(DWinBatterSetKey.GLeft) - 60, DWinBatterSetKey.SurfaceY(DWinBatterSetKey.GTop+DWinBatterSetKey.GHeight),
       '设置施展连击的快捷键'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterTopMag1MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Button = mbLeft then begin
    if Sender = DWinBatterTopMag4 then begin
      if not g_boOpen4BatterSkill then Exit;
    end;
    if g_WinBatterMagicList.Count > 0 then begin
      DWinBatterCom.GLeft := TAspDButton(Sender).GLeft-2;
      DWinBatterCom.GTop := TAspDButton(Sender).GTop+TAspDButton(Sender).GHeight+1;
      BatterTopMagIndex := TAspDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
      WinBatterComIndex := -1;
      DWinBatterCom.Visible := True;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  pm: PTClientMagic;
begin
  if g_WinBatterMagicList.Count - 1 >= TAspDButton(Sender).Tag then begin
    pm := PTClientMagic (g_WinBatterMagicList[TAspDButton(Sender).Tag]);
    case pm.Def.btEffect of
      102: begin  //三绝杀
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      111: begin //横扫千军
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以自身为';
          sLine2 := '中心，对5*5范围内的目标造成';
          sLine3 := '伤害';
        end;
      end;
      105: begin //追心刺
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，冲撞单体';
          sLine2 := '目标，在迫使其后退的同时，造';
          sLine3 := '成伤害';
        end;
      end;
      108: begin //断岳斩
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对三步内';
          sLine2 := '的单体目标造成伤害';
          sLine3 := '';
        end;
      end;
      112, 113: begin //冰天雪地 万剑归宗
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以目标为';
          sLine2 := '中心，对5*5范围内造成持续伤 ';
          sLine3 := '害';
        end;
      end;
      else g_BatterDesc.sName := '';
    end;
  end;
end;

procedure TFrmDlg.DStateWinBatterMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DHeroStateSsasClick(Sender: TObject; X, Y: Integer);
var
  ly: Integer;
begin
  ly := Y - DHeroStateSsas.GTop;
  if (ly >= 13) and (ly <= 55) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 0;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 0;
      HeroInternalForcePageChanged;
    end;
  end else
  if (ly >= 56) and (ly <= 100) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 1;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 1;
      HeroInternalForcePageChanged;
    end;
  end else
  if (ly >= 101) and (ly <= 144) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 2;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 2;
      HeroInternalForcePageChanged;
    end;
  end else
  if (ly >= 145) and (ly <= 188) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 3;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 3;
      HeroInternalForcePageChanged;
    end;
  end;
  if (ly >= 189) and (ly <= 233) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 4;
      HeroPageChanged;
    end;
  end;
end;

procedure TFrmDlg.DHeroStateSsasDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
{$IF M2Version <> 2} //不能去掉
{$IFEND}
end;

procedure TFrmDlg.DMemoWhisperListDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  pcp: pTClickSLPoint;
  data: string;
  Color: TColor;
begin
  with DMemoWhisperList do begin
    dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clWindowText);
    Color := $00638494;    //画边界线
    if TAspDEdit(Sender).Focused then Color := $005993BD;
    dsurface.FrameRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), Color);
    
    ElemCount:= (GHeight - 2) div LinesHeight;  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for I:= 0 to ElemCount - 1 do begin
      data := Lines.Strings[I+TopIndex];
      if data <> '' then begin
        if WhisperAddPoints then begin
           new (pcp);
           pcp.rc := Rect (4, I*LinesHeight+4, 336, I*LinesHeight + 14);
           pcp.RStr := data+inttostr(I+TopIndex);
           pcp.SStr := data;
           WhisperPoints.Add (pcp);
        end;
        if WhisperSelectStr = data+inttostr(I+TopIndex) then
          AspTextureFont.BoldTextOut (SurfaceX(GLeft+3), SurfaceY(GTop+I*LinesHeight+3), clRed, clBlack, data)
        else
        if WhisperMoveedStr = data+inttostr(I+TopIndex) then
          AspTextureFont.BoldTextOut (SurfaceX(GLeft+3), SurfaceY(GTop+I*LinesHeight+3), clYellow, clBlack, data)
        else AspTextureFont.BoldTextOut (SurfaceX(GLeft+3), SurfaceY(GTop+I*LinesHeight+3), clWhite, clBlack, data);
      end;
    end;
    WhisperAddPoints := False;
  end; 
end;

procedure TFrmDlg.AddWhisper(str: string);
var
   i, len, aline: integer;
   temp: string;
const
   BOXWIDTH = 260; //41 聊天框文字宽度
begin
   //str:= FormatDateTime('hh:mm:ss',Now)+ ' ' + str;
   len := Length (str);
   temp := '';
   i := 1;
   while TRUE do begin
      if i > len then break;
      if byte (str[i]) >= 128 then begin
         temp := temp + str[i];
         Inc (i);
         if i <= len then temp := temp + str[i]
         else break;
      end else
         temp := temp + str[i];

      aline := AspTextureFont.TextWidth (temp);
      if aline > BOXWIDTH then begin
         DMemoWhisperList.Lines.Add (temp);
         str := Copy (str, i+1, Len-i);
         temp := '';
         break;
      end;
      Inc (i);
   end;
   if temp <> '' then begin
      DMemoWhisperList.Lines.Add ({FormatDateTime('hh:mm:ss',Now)+ ' ' +}temp);
      str := '';
   end;
   {if ChatStrs.Count > 200 then begin
      ChatStrs.Delete (0);
      ChatBks.Delete (0);
      if ChatStrs.Count - ChatBoardTop < VIEWCHATLINE then Dec(ChatBoardTop);
   end else if (ChatStrs.Count-ChatBoardTop) > VIEWCHATLINE then begin
      Inc (ChatBoardTop);
   end;    }
   if WhisperPoints.Count > 0 then
    for i:=0 to FrmDlg.WhisperPoints.Count-1 do
      Dispose (pTClickSLPoint (FrmDlg.WhisperPoints[i]));
    FrmDlg.WhisperPoints.Clear;
   WhisperAddPoints := True;
   if str <> '' then
      AddWhisper ('         ' + str);

end;

procedure TFrmDlg.AspDButton1Initialize(Sender: TObject);
begin
  with Sender as TAspDButton do
	  SetImgIndex(g_WMainImages, 1614);
end;

procedure TFrmDlg.DMemoWhisperListMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: pTClickSLPoint;
begin
  WhisperMoveedStr := '';
  with DMemoWhisperList do begin
    L := GLeft;
    T := GTop;
    if WhisperPoints.Count > 0 then  begin//20080629
      for i:=0 to WhisperPoints.Count-1 do begin
        p := pTClickSLPoint (WhisperPoints[i]);
        if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          WhisperMoveedStr := p.RStr;
          break;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DMemoWhisperListClick(Sender: TObject; X, Y: Integer);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      line := Copy(line, 10, Length(line)-1);
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':', '[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
var
  i, L, T: integer;
  p: pTClickSLPoint;
begin
  L := DMemoWhisperList.GLeft;
  T := DMemoWhisperList.GTop;
  with DMemoWhisperList do begin
    if WhisperPoints.Count > 0 then //20080629
    for i:=0 to WhisperPoints.Count-1 do begin
       p := pTClickSLPoint (WhisperPoints[i]);
       if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          WhisperSelectStr := p.RStr;
          if not PlayScene.EdChat.Visible then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.SetFocus;
          end;
          PlayScene.EdChat.Text := '/' + ExtractUserName (p.SStr) + ' ';
          PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          PlayScene.EdChat.SelLength := 0;
          //FrmMain.SendMissionSelect (p.RStr);
          break;
       end;
    end;
  end;
end;

procedure TFrmDlg.DMemoWhisperListScrollBarChange(Sender: TObject);
var
  I: Integer;
begin
  if WhisperPoints.Count > 0 then //20080629
  for i:=0 to WhisperPoints.Count-1 do
    Dispose (pTClickSLPoint (WhisperPoints[i]));
  WhisperPoints.Clear;
  WhisperAddPoints := True;
end;

procedure TFrmDlg.DWhisperCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWWhisper.Visible := False;
end;

procedure TFrmDlg.DBWhisperClick(Sender: TObject; X, Y: Integer);
begin
  DWWhisper.Visible := not DWWhisper.Visible;
  //PlayScene.EdChat.Visible := False;
end;

procedure TFrmDlg.AutoWhisper(str: string);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
begin
  FrmMain.SendSay ('/' + ExtractUserName (str) + ' '+FrmDlg.DEdtWhisper.Text);
end;

procedure TFrmDlg.DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx: integer;
  pm: PTClientMagic;
{$IF M2Version <> 2}
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    pm := nil;
    {$IF M2Version = 2} //1.76
      idx := _Max(Tag + MagicPage * 5, 0);
      if idx < g_MagicList.Count then begin
        pm := PTClientMagic (g_MagicList[idx]);
        if pm <> nil then begin
          DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y\(点击技能按钮设置快捷键)', FALSE, True, 40);
        end;
      end;
    {$ELSE}
    if (StateTab = 1) and (InternalForcePage = 1) then begin
      idx := _Max(Tag + InternalForceMagicPage * 6, 0);
      if idx < g_InternalForceMagicList.Count then begin
         pm := PTClientMagic (g_InternalForceMagicList[idx]);
        if pm <> nil then begin
        	if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          	DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
          else
						DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);
        end;
      end;
    end else begin
      idx := _Max(Tag + MagicPage * 6, 0);
      if idx < g_MagicList.Count then begin
        pm := PTClientMagic (g_MagicList[idx]);
        if pm <> nil then begin
          DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y\(点击技能按钮设置快捷键)', FALSE, True, 40);
        end;
      end;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DStMagHero1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  idx: integer;
  pm: PTClientMagic;
//{$IF M2Version <> 2}
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
//{$IFEND}
begin
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    pm := nil;
    if (HeroStateTab = 1) and (HeroInternalForcePage = 1) then begin
      idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
      if idx < g_HeroInternalForceMagicList.Count then begin
         pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        if pm <> nil then begin
        	if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          	DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
          else
 						DScreen.ShowTzHint (SurfaceX(GLeft)-120, SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);
        end;
      end;
    end else begin
      idx := _Max(Tag + HeroMagicPage * 6, 0);
      if idx < g_HeroMagicList.Count then begin
        pm := PTClientMagic (g_HeroMagicList[idx]);
        if pm <> nil then begin
          DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y', FALSE, True, 40);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKeySelDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

//参数4为触发QM里的[@Help] 作用
procedure TFrmDlg.DHelpClick(Sender: TObject; X, Y: Integer);
var
  msg : TDefaultMessage;
begin
  if GetTickCount - g_dwHelpQMTick > 500 then begin
    g_dwHelpQMTick := GetTickCount();
    msg := MakeDefaultMsg (aa(CM_CLICKSIGHICON, frmMain.TempCertification), 0, 4, 0, 0, frmMain.m_nSendMsgCount);
    frmMain.SendSocket (EncodeMessage (msg)+ EncodeString('?'));
  end;
end;

procedure TFrmDlg.DHeroStateWinPulseDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  hcolor: integer;
  btX, btY: Byte;
  sStr: string;
begin
  {$IF M2Version = 1}
  if g_HeroSelf = nil then exit;
  with DHeroStateWinPulse do begin
    if g_boHeroPulseOpen then begin //英雄是否开通了经脉
      if WLib <> nil then begin //20080701
        if g_HeroSelf.m_btSex = 1 then begin //女
          if HeroStatePulsePage = 0 then
            d := WLib.Images[FaceIndex + 3]
          else if HeroStatePulsePage = 4 then  //奇经
            d := WLib.Images[1188]
          else d := WLib.Images[FaceIndex + 2];
        end else begin
          if HeroStatePulsePage = 0 then
            d := WLib.Images[FaceIndex + 1]
          else if HeroStatePulsePage = 4 then //奇经
            d := WLib.Images[1186]
          else d := WLib.Images[FaceIndex];
        end;
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if HeroStatePulsePage = 4 then //奇经
        d := g_WMainImages.Images[1171]
      else d := g_WMainImages.Images[830+HeroStatePulsePage];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft) + 92, SurfaceY(GTop) + 6, d.ClientRect, d, TRUE);

      if HeroStatePulsePage = 4 then begin//奇经
        if not g_HumanPulseArr[HeroStatePulsePage].boOpenPulse then
          hcolor := 1180
        else hcolor := 1181+g_HumanPulseArr[HeroStatePulsePage].nPulseLevel;
        d := g_WMainImages.Images[hcolor];
      end else begin
        if not g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse then
          hcolor := 860
        else hcolor := 861+g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel;
        d := g_WMainImages.Images[hcolor+HeroStatePulsePage * 10];
      end;
      if d <> nil then
      dsurface.DrawBlend( SurfaceX(GLeft), SurfaceY(GTop), d);

      if HeroStatePulsePage = 4 then //奇经
        d := g_WMainImages.Images[1172]
      else d := g_WMainImages.Images[840+HeroStatePulsePage];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end else begin
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+20, SurfaceY(GTop)+270, clWhite, clBlack, '请到NPC处开启英雄经络');
    end;
    if ((g_btHeroPulseOriginPage = HeroStatePulsePage) or (HeroStatePulsePage = 4){奇经}) and (g_btHeroPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;
    //-----------------穴位位置---------------------
    if g_boHeroPulseOpen then begin //英雄是否开通了经脉
      case HeroStatePulsePage of
        0: begin
          btX := 37;
          btY := 30;
        end;
        1: begin
          btX := 48;
          btY := 24;
        end;
        2: begin
          btX := 47;
          btY := 38;
        end;
        3: begin
          btX := 48;
          btY := 20;
        end;
        4: begin
          btX := 47;
          btY := 16;
        end;
        else begin
          btX := 0;
          btY := 0;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then
        d := g_WMainImages.Images[851]
      else if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1)) or (HeroStatePulsePage = 4{奇经}) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);

      if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1)) or ((HeroStatePulsePage = 4) and (g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0)){奇经} then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 36;
          btY := 59;
        end;
        1: begin
          btX := 48;
          btY := 64;
        end;
        2: begin
          btX := 41;
          btY := 68;
        end;
        3: begin
          btX := 48;
          btY := 40;
        end;
        4: begin
          btX := 92;
          btY := 102;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (HeroStatePulsePage <> 4{奇经}) and (g_btHeroPulsePoint = 2) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (HeroStatePulsePage <> 4{奇经})) and (g_btHeroPulsePoint = 2) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 38;
          btY := 84;
        end;
        1: begin
          btX := 54;
          btY := 104;
        end;
        2: begin
          btX := 41;
          btY := 106;
        end;
        3: begin
          btX := 48;
          btY := 61;
        end;
        4: begin
          btX := 3;
          btY := 101;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 45;
          btY := 106;
        end;
        1: begin
          btX := 61;
          btY := 143;
        end;
        2: begin
          btX := 36;
          btY := 139;
        end;
        3: begin
          btX := 48;
          btY := 85;
        end;
        4: begin
          btX := 65;
          btY := 185;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 52;
          btY := 88;
        end;
        1: begin
          btX := 64;
          btY := 184;
        end;
        2: begin
          btX := 33;
          btY := 175;
        end;
        3: begin
          btX := 48;
          btY := 109;
        end;
        4: begin
          btX := 29;
          btY := 186;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          dsurface.DrawBlend( SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d);
        end;
      end;

      //------------------导航显示----------------------
      if HeroStatePulsePage = 0 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+23, d.ClientRect, d, TRUE);
      if g_HeroHumanPulseArr[0].boOpenPulse then begin
        if HeroStatePulsePage = 1 then
          d := g_WMainImages.Images[812]
        else d := g_WMainImages.Images[813];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+47, d.ClientRect, d, TRUE);
      end;
      if g_HeroHumanPulseArr[1].boOpenPulse then begin
        if HeroStatePulsePage = 2 then
          d := g_WMainImages.Images[812]
        else d := g_WMainImages.Images[813];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+71, d.ClientRect, d, TRUE);
      end;
      if g_HeroHumanPulseArr[2].boOpenPulse then begin
        if HeroStatePulsePage = 3 then
          d := g_WMainImages.Images[812]
        else d := g_WMainImages.Images[813];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+95, d.ClientRect, d, TRUE);
      end;
      if HeroStatePulsePage = 4 then //奇经
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_boHeroPulseOpen then begin //英雄是否开通了经脉
      btX := 140;
      btY := 28;
      if g_btHeroStateWinPulseMoving = 1 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 29;
        end else if HeroStatePulsePage = 0 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if HeroStatePulsePage = 0 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '冲脉');

      if g_HeroHumanPulseArr[0].boOpenPulse then begin
        btX := 140;
        btY := 51;
        if g_btHeroStateWinPulseMoving = 2 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $008BC4ED;
            btX := 141;
            btY := 52;
          end else if HeroStatePulsePage = 1 then hcolor := $008BC4ED
          else hcolor := $006C849A;
        end else if HeroStatePulsePage = 1 then hcolor := $008BC4ED
        else hcolor := $006C849A;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴跷');
      end;
      if g_HeroHumanPulseArr[1].boOpenPulse then begin
        btX := 140;
        btY := 75;
        if g_btHeroStateWinPulseMoving = 3 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $008BC4ED;
            btX := 141;
            btY := 76;
          end else if HeroStatePulsePage = 2 then hcolor := $008BC4ED
          else hcolor := $006C849A;
        end else if HeroStatePulsePage = 2 then hcolor := $008BC4ED
        else hcolor := $006C849A;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴维');
      end;
      if g_HeroHumanPulseArr[2].boOpenPulse then begin
        btX := 140;
        btY := 99;
        if g_btHeroStateWinPulseMoving = 4 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $008BC4ED;
            btX := 141;
            btY := 100;
          end else if HeroStatePulsePage = 3 then hcolor := $008BC4ED
          else hcolor := $006C849A;
        end else if HeroStatePulsePage = 3 then hcolor := $008BC4ED
        else hcolor := $006C849A;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '任脉');
      end;
      btX := 140;
      btY := 5;
      if g_btHeroStateWinPulseMoving = 11 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 6;
        end else if HeroStatePulsePage = 4 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if HeroStatePulsePage = 4 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '奇经');
      //------------------------------------------------
      case HeroStatePulsePage of
        0: begin
          btX := 81;
          btY := 35;
          //sStr := '幽门';
        end;
        1: begin
          btX := 4;
          btY := 29;
          //sStr := '晴明';
        end;
        2: begin
          btX := 2;
          btY := 41;
          //sStr := '廉泉';
        end;
        3: begin
          btX := 2;
          btY := 25;
          //sStr := '承浆';
        end;
        4: begin
          btX := 4;
          btY := 22;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 5 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,0));
      case HeroStatePulsePage of
        0: begin
          btX := 80;
          btY := 64;
          //sStr := '通谷';
        end;
        1: begin
          btX := 4;
          btY := 68;
          //sStr := '盘缺';
        end;
        2: begin
          btX := 82;
          btY := 73;
          //sStr := '期门';
        end;
        3: begin
          btX := 93;
          btY := 45;
          //sStr := '天突';
        end;
        4: begin
          btX := 68;
          btY := 94;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 6 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,1));
      case HeroStatePulsePage of
        0: begin
          btX := 2;
          btY := 89;
          //sStr := '商曲';
        end;
        1: begin
          btX := 92;
          btY := 108;
          //sStr := '交信';
        end;
        2: begin
          btX := 1;
          btY := 110;
          //sStr := '府舍';
        end;
        3: begin
          btX := 3;
          btY := 67;
          //sStr := '鸠尾';
        end;
        4: begin
          btX := 26;
          btY := 116;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 7 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,2));
      case HeroStatePulsePage of
        0: begin
          btX := 6;
          btY := 111;
          //sStr := '四满';
        end;
        1: begin
          btX := 24;
          btY := 146;
          //sStr := '照海';
        end;
        2: begin
          btX := 70;
          btY := 144;
          //sStr := '冲门';
        end;
        3: begin
          btX := 93;
          btY := 90;
          //sStr := '气海';
        end;
        4: begin
          btX := 42;
          btY := 178;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 8 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,3));
      case HeroStatePulsePage of
        0: begin
          btX := 86;
          btY := 92;
          //sStr := '横骨';
        end;
        1: begin
          btX := 29;
          btY := 189;
          //sStr := '然谷';
        end;
        2: begin
          btX := 66;
          btY := 180;
          //sStr := '筑宾';
        end;
        3: begin
          btX := 4;
          btY := 114;
          //sStr := '曲骨';
        end;
        4: begin
          btX := 3;
          btY := 190;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 9 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,4));

      if HeroStatePulsePage <> 4 then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
            end;
            1: begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            2: begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            3: begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            4: begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            5: begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
          end;
        end else begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
          AspTextureFont.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
        end;
      end;
      //{$IFEND}

      if g_btHeroStateWinPulseMoving = 10 then begin
        if g_boHeroStateWinPulseDowning then
          d := g_WMainImages.Images[815]
        else d := g_WMainImages.Images[814];
      end else d := g_WMainImages.Images[814];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+7, SurfaceY(GTop)+210, d.ClientRect, d, TRUE);
      case HeroStatePulsePage of
        0: sStr := '修炼冲脉';
        1: sStr := '修炼阴跷';
        2: sStr := '修炼阴维';
        3: sStr := '修炼任脉';
        4: sStr := '修炼奇经';
      end;
      btX := 13;
      btY := 214;
      if (g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel >= 5) or ((HeroStatePulsePage = 4) and (g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0)) then begin
        hcolor := clGray;
      end else begin
        if g_btHeroStateWinPulseMoving = 10 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $0048A4E8;
            btX := btX + 1;
            btY := btY + 1;
          end else hcolor := $00A8D4E8;
        end else hcolor := $0088C4E8;  //普通颜色
      end;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, sStr);
    //{$IFEND}
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroStateWinPulseClick(Sender: TObject; X, Y: Integer);
var
  lx, ly: Integer;
begin
  {$IF M2Version = 1}
  if (g_HeroSelf = nil) or (not g_boHeroPulseOpen) then Exit;
  lx := X - DHeroStateWinPulse.GLeft;
  ly := Y - DHeroStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    HeroStatePulsePage := 0;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    if g_HeroHumanPulseArr[0].boOpenPulse then HeroStatePulsePage := 1;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    if g_HeroHumanPulseArr[1].boOpenPulse then HeroStatePulsePage := 2;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    if g_HeroHumanPulseArr[2].boOpenPulse then HeroStatePulsePage := 3;
  end;
  if (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24) then begin
    HeroStatePulsePage := 4;
  end;
  case HeroStatePulsePage of
    0: begin
      //1
      //x24 y23
      if ((lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47)){字} or ((lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      // x 24 y 12
      if ((lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101)){字} or ((lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123)){字} or ((lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104)){字} or ((lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    1: begin
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120)){字} or ((lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158)){字} or ((lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201)){字} or ((lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    2: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192)){字} or ((lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    3: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    4: begin //奇经
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
        end else begin
          ShowQJPractice(True);
        end;
      end;
      //2
      (*if ((lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106)){字} or ((lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128)){字} or ((lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190)){字} or ((lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202)){字} or ((lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;   *)
    end;
  end;
  if ((lx >= 7) and (lx <= 67) and (ly >= 210) and (ly <= 231)) then begin
    if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendHeroPracticePulse(HeroStatePulsePage);
      end;
    end else begin
      case HeroStatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(True);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroStateWinPulseMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwHeroInternalForceLevel >= nlevel then Result := '~y';
  end;
var
  lx, ly: Integer;
  str: string;
begin
  {$IF M2Version = 1}
  if not g_boHeroPulseOpen then Exit; //英雄是否开通了经脉
  DScreen.ClearHint;
  g_boHeroStateWinPulseDowning := False;
  g_btHeroStateWinPulseMoving := 0;
  lx := X - DHeroStateWinPulse.GLeft;
  ly := Y - DHeroStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    g_btHeroStateWinPulseMoving := 1;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[0].boOpenPulse then begin
      if g_HeroHumanPulseArr[0].nPulseLevel = 1 then begin
        str := GetPulsDesc(Format('H冲脉%d-%d',[g_HeroHumanPulseArr[0].nPulseLevel,g_HeroSelf.m_btJob]));
      end else begin
        if g_HeroHumanPulseArr[0].nPulseLevel = 0 then str := GetPulsDesc('冲脉已通')
        else str := GetPulsDesc(Format('H冲脉%d',[g_HeroHumanPulseArr[0].nPulseLevel]));
      end;
      if str <> '' then begin
        with g_HeroBatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end else begin
      str := GetPulsDesc('冲脉未通');
      if str <> '' then begin
        with g_HeroBatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    g_btHeroStateWinPulseMoving := 2;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[0].boOpenPulse then begin
      if g_HeroHumanPulseArr[1].boOpenPulse then begin
        if g_HeroHumanPulseArr[1].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('H阴跷%d-%d',[g_HeroHumanPulseArr[1].nPulseLevel,g_HeroSelf.m_btJob]));
        end else begin
          if g_HeroHumanPulseArr[1].nPulseLevel = 0 then str := GetPulsDesc('阴跷已通')
          else str := GetPulsDesc(Format('H阴跷%d',[g_HeroHumanPulseArr[1].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴跷未通');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    g_btHeroStateWinPulseMoving := 3;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[1].boOpenPulse then begin
      if g_HeroHumanPulseArr[2].boOpenPulse then begin
        if g_HeroHumanPulseArr[2].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('H阴维%d-%d',[g_HeroHumanPulseArr[2].nPulseLevel,g_HeroSelf.m_btJob]));
        end else begin
          if g_HeroHumanPulseArr[2].nPulseLevel = 0 then str := GetPulsDesc('阴维已通')
          else str := GetPulsDesc(Format('H阴维%d',[g_HeroHumanPulseArr[2].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴维未通');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    g_btHeroStateWinPulseMoving := 4;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[2].boOpenPulse then begin
      if g_HeroHumanPulseArr[3].boOpenPulse then begin
        if g_HeroHumanPulseArr[3].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('H任脉%d-%d',[g_HeroHumanPulseArr[3].nPulseLevel,g_HeroSelf.m_btJob]));
        end else begin
          if g_HeroHumanPulseArr[3].nPulseLevel = 0 then str := GetPulsDesc('任脉已通')
          else str := GetPulsDesc(Format('H任脉%d',[g_HeroHumanPulseArr[3].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('任脉未通');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24) then begin
    g_btHeroStateWinPulseMoving := 11;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    str := GetPulsDesc('奇经');
    {if g_HeroHumanPulseArr[4].nPulseLevel = 0 then str := GetPulsDesc('奇经已通')
    else str := GetPulsDesc(Format('H奇经%d',[g_HeroHumanPulseArr[3].nPulseLevel])); }
    if str <> '' then begin
      with g_HeroBatterDesc do begin
        sName := GetPulsePageName(4);
        str := GetValidStr3 (str, sLine1, ['\']);
        str := GetValidStr3 (str, sLine2, ['\']);
        str := GetValidStr3 (str, sLine3, ['\']);
      end;
    end;
  end else
  if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
    g_btHeroStateWinPulseMoving := 10;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    with g_HeroBatterDesc do begin
      sName := ' ';
      sLine1 := '欲练连击，必练内功；打通五穴';
      sLine2 := '，经络自通。欲强连击，锻造金';
      sLine3 := '针；修炼经络，威力提升。';
    end;
  end;
  case HeroStatePulsePage of
    0: begin
      //1
      if (lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47){字} then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 106, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+34, format('%s穴:已打通',[GetPulseName(HeroStatePulsePage,0)]) , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 106, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+34,
                      format('%s穴:待打通',[GetPulseName(HeroStatePulsePage,0)])+'~y\'+format('需要内功等级：%d',[g_btHeroPulseLevel])+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 106, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+34,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 62, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+29, '幽门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 62, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+29,
                      '幽门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 62, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+29,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);;//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76){字} then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 105, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 105, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 105, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+58, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+58,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+58,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      // x 24 y 12
      if (lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+88, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+88,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+88,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 63, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+83, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 63, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+83,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 63, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+83,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 31, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+110, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 31, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+110,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 31, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+110,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 70, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 70, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 70, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 111, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+91, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 111, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+91,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 111, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+91,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 77, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+87, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 77, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+87,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 77, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+87,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP冲脉已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP冲脉1');
            2: str := GetPulsDesc('HP冲脉2');
            3: str := GetPulsDesc('HP冲脉3');
            4: str := GetPulsDesc('HP冲脉4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP冲脉未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    1: begin
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+28, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+28,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+28,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+23, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+23,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+23,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+107, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+107,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+107,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 79, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+103, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 79, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+103,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
           DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 79, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+103,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 49, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+145, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 49, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+145,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 49, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+145,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 87, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+142, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 87, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+142,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 87, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+142,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+188, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+188,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+188,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 89, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+183, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 89, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+183,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 89, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+183,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP阴跷已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP阴跷1');
            2: str := GetPulsDesc('HP阴跷2');
            3: str := GetPulsDesc('HP阴跷3');
            4: str := GetPulsDesc('HP阴跷4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP阴跷未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    2: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+40, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+40,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+40,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+37, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+37,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+37,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 107, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+72, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 107, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+72,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 107, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+72,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 26, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+109, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 26, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+109,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 26, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+109,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 95, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+143, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 95, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+143,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 95, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+143,
                  '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+138, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+138,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+138,
                      '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 91, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+179, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 91, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+179,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 91, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+179,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 58, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+174, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 58, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+174,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 58, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+174,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP阴维已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP阴维1');
            2: str := GetPulsDesc('HP阴维2');
            3: str := GetPulsDesc('HP阴维3');
            4: str := GetPulsDesc('HP阴维4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP阴维未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    3: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+24, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+24,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+24,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+19, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+19,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+19,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+44, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+44,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+44,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+39, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+39,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+39,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+66, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+66,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+66,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+60, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+60,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+60,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+89, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+89,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+89,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+84, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+84,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+84,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+113, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+113,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+113,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+108, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+108,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+108,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP任脉已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP任脉1');
            2: str := GetPulsDesc('HP任脉2');
            3: str := GetPulsDesc('HP任脉3');
            4: str := GetPulsDesc('HP任脉4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP任脉未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    4: begin //奇经
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+21, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin//if {(g_btHeroPulseOriginPage = HeroStatePulsePage) and }(g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+21,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel)}, FALSE, FALSE, 0);
          {str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+21,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;  }
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+15, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin//if {(g_btHeroPulseOriginPage = HeroStatePulsePage) and }(g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+15,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel)}, FALSE, FALSE, 0);
          {str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+15,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;}
      end;
      //2
      if (lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 93, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+93, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 93, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+93,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 93, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+93,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+101, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+101,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+101,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //3
      if (lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 51, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+115, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 51, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+115,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 51, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+115,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+100, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+100,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+100,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //4
      if (lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 67, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+177, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 67, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+177,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 67, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+177,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('八风');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 90, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+184, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 90, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+184,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 90, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+184,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end;
        str := GetPulsDesc('气海');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //5
      if (lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+189, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+189,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+189,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+185, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+185,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+185,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroStateWinBatterDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  bbx, bby, I, icon, trainlv: Integer;
  magtop, magline, m: Byte;
  pm: PTClientMagic;
begin
  {$IF M2Version = 1}
  with DHeroStateWinBatter do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

        d := g_WMainImages.Images[912];
        if d <> nil then
         dsurface.Draw (SurfaceX(GLeft)+118, SurfaceY(GTop)+6, d.ClientRect, d, TRUE);

        bbx := SurfaceX(GLeft) - 2;
        bby := SurfaceY(GTop) + 81;

        //虐 钎矫, lv, exp
        magtop := 0;//InternalForceMagicPage * 6;
        magline := _MIN(4, g_HeroBatterMagicList.count);//_MIN(InternalForceMagicPage*6+6, g_InternalForceMagicList.Count);
        for i:=magtop to magline-1 do begin
           pm := PTClientMagic (g_HeroBatterMagicList[i]);
           m := i - magtop;
           case pm.Def.btEffect of
             102:icon := 952;//三绝杀
             103:icon := 944;//双龙破
             104:icon := 934;//虎啸诀
             105:icon := 950;//追心刺
             106:icon := 942;//凤舞祭
             107:icon := 936;//八卦掌
             108:icon := 956;//断岳斩
             109:icon := 946;//惊雷爆
             110:icon := 932;//三焰咒
             111:icon := 954;//横扫千军
             112:icon := 940;//冰天雪地
             113:icon := 930;//万剑归宗
             else icon := -1;
           end;
           d := g_WMainImages.Images[icon];
           if d <> nil then
              dsurface.Draw (bbx + 9, bby+7+m*38, d.ClientRect, d, TRUE);
                      
           d := g_WMainImages.Images[112]; //lv
           if d <> nil then
              dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);

           d := g_WMainImages.Images[111]; //exp
           if d <> nil then begin
              dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
           end;
        end;
         for i:=magtop to magline-1 do begin
            pm := PTClientMagic (g_HeroBatterMagicList[i]);
            m := i - magtop;
            if not (pm.Level in [0..5]) then pm.Level := 0;
            case pm.Def.btEffect of
              102..104: begin
                case Ord(pm.Key) of
                  1:begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+10%暴击');
                  end;
                  2:begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+15%暴击');
                  end;
                  3: begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+25%暴击');
                  end;
                  4: begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+30%暴击');
                  end;
                  else
                  AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%暴击');
                end;
              end;
              105..107: begin
                case Ord(pm.Key) of
                   1:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+10%暴击');
                   end;
                   2:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+15%暴击');
                   end;
                   3:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+25%暴击');
                   end;
                   4:begin
                      AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+30%暴击');
                   end;
                   else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%暴击');
                end;
              end;
              108..110: begin
                case Ord(pm.Key) of
                  1:begin
                     AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+10%暴击');
                  end;
                  2:begin
                     AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+15%暴击');
                  end;
                  3:begin
                     AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+25%暴击');
                  end;
                  4:begin
                     AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+30%暴击');
                  end;
                  else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                        clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%暴击');
                end;
              end;
              111..113: begin
                case Ord(pm.Key) of
                  1:begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+10%暴击');
                  end;
                  2:begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+15%暴击');
                  end;
                  3:begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+25%暴击');
                  end;
                  4:begin
                    AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+30%暴击');
                  end;
                  else AspTextureFont.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%暴击');
                end;
              end;
            end;
            if pm.Level in [0..3,5] then trainlv := pm.Level
            else if pm.Level = 4 then trainlv := 3
            else trainlv := 0;
            AspTextureFont.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
            if pm.Def.MaxTrain[trainlv] > 0 then begin
               if trainlv < 5 then
                  AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
               else AspTextureFont.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
            end;
         end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  icon: Integer;
begin
  {$IF M2Version = 1}
  with Sender as TAspDButton do begin
    if Sender = DHeroBatterTopMag4 then begin
      if not g_boHeroOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft-4), SurfaceY(TAspDButton(Sender).GTop-4), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;
    if g_HeroBatterMagicList.Count > 0 then begin
      if g_HeroBatterTopMagic[TAspDButton(Sender).Tag].Def.sMagicName <> '' then begin
        case g_HeroBatterTopMagic[TAspDButton(Sender).Tag].Def.btEffect of
         102:icon := 952;//三绝杀
         103:icon := 944;//双龙破
         104:icon := 934;//虎啸诀
         105:icon := 950;//追心刺
         106:icon := 942;//凤舞祭
         107:icon := 936;//八卦掌
         108:icon := 956;//断岳斩
         109:icon := 946;//惊雷爆
         110:icon := 932;//三焰咒
         111:icon := 954;//横扫千军
         112:icon := 940;//冰天雪地
         113:icon := 930;//万剑归宗
        else icon := -1;
        end;
        if TAspDButton(Sender).Downed then
          d := g_WMainImages.Images[icon+1]
        else d := g_WMainImages.Images[icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
      end else begin
        if TAspDButton(Sender).Downed then begin
          if g_HeroBatterTopMagic[TAspDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DHeroBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TAspDButton(Sender).Tag*2+1];
          end;
        end else begin
          if g_HeroBatterTopMagic[TAspDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DHeroBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TAspDButton(Sender).Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
        if (g_HeroBatterTopMagic[0].Def.sMagicName = '') and (g_HeroBatterTopMagic[1].Def.sMagicName = '') and (g_HeroBatterTopMagic[2].Def.sMagicName = '') and (g_HeroBatterTopMagic[3].Def.sMagicName = '')
           and (g_HeroBatterTopMagic[0].CurTrain <> 1) and (g_HeroBatterTopMagic[1].CurTrain <> 1) and (g_HeroBatterTopMagic[2].CurTrain <> 1) and (g_HeroBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DHeroBatterTopMag1 then begin
            if (not TAspDButton(Sender).Downed) and (not DWinBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft)+10, SurfaceY(TAspDButton(Sender).GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(TAspDButton(Sender).GLeft), SurfaceY(TAspDButton(Sender).GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DHeroBatterTopMag1 then begin
    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterTopMag2 then begin
    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterTopMag3 then begin
    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterTopMag4 then begin


    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterRandom then begin
    DScreen.ShowHint(DHeroBatterRandom.SurfaceX(DHeroBatterRandom.GLeft), DHeroBatterRandom.SurfaceY(DHeroBatterRandom.GTop+DHeroBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterTopMag1MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Button = mbLeft then begin
    if Sender = DHeroBatterTopMag4 then begin
      if not g_boHeroOpen4BatterSkill then Exit;
    end;
    if g_HeroBatterMagicList.Count > 0 then begin
      DHeroBatterCom.GLeft := TAspDButton(Sender).GLeft-2;
      DHeroBatterCom.GTop := TAspDButton(Sender).GTop+TAspDButton(Sender).GHeight+1;
      HeroBatterTopMagIndex := TAspDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
      HeroBatterComIndex := -1;
      DHeroBatterCom.Visible := True;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
var
  pm: PTClientMagic;
  I: Integer;
begin
  {$IF M2Version = 1}
  FillChar (g_HeroBatterTopMagic, sizeof(TClientMagic)*4, #0);
  if g_HeroBatterMagicList.Count > 0 then begin
    for i:=0 to g_HeroBatterMagicList.Count-1 do begin
      pm := PTClientMagic (g_HeroBatterMagicList[i]);
      if (Ord(pm.Key) = 1) or (Ord(pm.Key) = 2) or (Ord(pm.Key) = 3) or (Ord(pm.Key) = 4) then begin
        pm.Key := #0;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
      end;
    end;
  end;
  g_HeroBatterTopMagic[0].CurTrain := 1;
  g_HeroBatterTopMagic[1].CurTrain := 1;
  g_HeroBatterTopMagic[2].CurTrain := 1;
  g_HeroBatterTopMagic[3].CurTrain := 1;
  FrmMain.SendHeroMagicKeyChange (-1, #0, '1/1/1/1');
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterComDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  I: Integer;
  btLine: Byte;
  sStr: string;
begin
  with DHeroBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if HeroBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+HeroBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+HeroBatterComIndex*15+19) ,clNavy);
    end;
    btLine := _MIN(4, g_HeroBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_HeroBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_HeroBatterMagicList.Items[I]).Def.sMagicName;
        if I = HeroBatterComIndex then
          AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if HeroBatterComIndex = btLine then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if HeroBatterComIndex = btLine +1 then
      AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else AspTextureFont.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
end;

procedure TFrmDlg.DHeroBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  btLine: Byte;
  ss: Integer;
begin
  with DHeroBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_HeroBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    HeroBatterComIndex := ss;
  end;
end;

procedure TFrmDlg.DHeroBatterComMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
begin
  if HeroBatterComIndex <> - 1 then begin
    if g_HeroBatterMagicList.Count - HeroBatterComIndex > 0 then begin
      for I:=Low(g_HeroBatterTopMagic) to High(g_HeroBatterTopMagic) do begin
        if g_HeroBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_HeroBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex] := pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 0;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_HeroBatterMagicList[HeroBatterComIndex]);
      pm.Key := Chr(HeroBatterTopMagIndex + 1);
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, Chr(HeroBatterTopMagIndex + 1), str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = 0 then begin//空
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = -1 then begin//随机
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 1;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end;
    DHeroBatterCom.Visible := False;
  end;
end;

procedure TFrmDlg.DHeroBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  pm: PTClientMagic;
begin
  if g_HeroBatterMagicList.Count - 1 >= TAspDButton(Sender).Tag then begin
    pm := PTClientMagic (g_HeroBatterMagicList[TAspDButton(Sender).Tag]);
    case pm.Def.btEffect of
      102: begin  //三绝杀
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      111: begin //横扫千军
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以自身为';
          sLine2 := '中心，对5*5范围内的目标造成';
          sLine3 := '伤害';
        end;
      end;
      105: begin //追心刺
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，冲撞单体';
          sLine2 := '目标，在迫使其后退的同时，造';
          sLine3 := '成伤害';
        end;
      end;
      108: begin //断岳斩
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对三步内';
          sLine2 := '的单体目标造成伤害';
          sLine3 := '';
        end;
      end;
      112, 113: begin //冰天雪地 万剑归宗
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以目标为';
          sLine2 := '中心，对5*5范围内造成持续伤 ';
          sLine3 := '害';
        end;
      end;
      else g_HeroBatterDesc.sName := '';
    end;
  end;
end;

procedure TFrmDlg.HBExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*6+6, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 71) and (pm.Level < 100) then begin
            rc := d.ClientRect;
            if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
              rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.HBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
begin
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*6+6, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 71) and (pm.Level < 100) then begin
      sMsg := '当前经验:%d/%d';
      with HBExp do
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), clWhite, FALSE);
      Break;
    end;
  end;
end;

procedure TFrmDlg.JQExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      magline := _MIN(MagicPage*6+6, g_MagicList.Count);
      for i:=magtop to magline-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if (pm.Def.wMagicId = 68) then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
          d := g_WMain2Images.Images[578];
          if (pm.Level < 100) and (d<>nil) then begin
            rc := d.ClientRect;
            if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
              rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
            end;
          end;
          Break;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.JQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
begin
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*6+6, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 68) and (pm.Level < 100) then begin
      sMsg := '当前经验:%d/%d';
      with JQExp do
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      Break;
    end;
  end;
end;

procedure TFrmDlg.DWHeroAssessDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  function GetHeroIcon(Job,Sex: Byte): Integer;
  var
    Icon: Integer;
  begin
    case Job of
      0:Icon := 502;
      1:Icon := 506;
      2:Icon := 504;
      else Icon := 502;
    end;
    if Sex = 1 then Result := Icon +1
    else Result := Icon;
  end;
var
  d: TAsphyreLockableTexture;
  Icon: Integer;
begin
  with DWHeroAssess do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if not DHeroAssessSign.ShowHint then begin //评定界面
      AspTextureFont.TextOut (SurfaceX(GLeft)+113, SurfaceY(GTop)+28, clWhite, '请确保酒馆中寄存两位未经评定的英雄，否');
      AspTextureFont.TextOut (SurfaceX(GLeft)+113, SurfaceY(GTop)+28+14, clWhite, '则资质评定无法进行。等级较高者将成为主');
      AspTextureFont.TextOut (SurfaceX(GLeft)+113, SurfaceY(GTop)+28+28, clWhite, '将英雄，等级较低者将成为副将英雄。');
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 21, SurfaceY(GTop) + 124, $0088C4E8, clBlack, '试炼场长老');
      if g_GetDeputyHeroData[0].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[0].btJob, g_GetDeputyHeroData[0].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 118, SurfaceY(GTop) + 108, d.ClientRect, d, TRUE);
        AspTextureFont.TextOut(SurfaceX(GLeft) + 160 - AspTextureFont.TextWidth(g_GetDeputyHeroData[0].sChrName) div 2 , SurfaceY(GTop) + 89, $0088C4E8, g_GetDeputyHeroData[0].sChrName);
        AspTextureFont.TextOut(SurfaceX(GLeft) + 160 - AspTextureFont.TextWidth(ForMat('等级：%d',[g_GetDeputyHeroData[0].Level])) div 2 , SurfaceY(GTop) + 203, $0088C4E8, ForMat('等级：%d',[g_GetDeputyHeroData[0].Level]));
      end;
      if g_GetDeputyHeroData[1].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[1].btJob, g_GetDeputyHeroData[1].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 267, SurfaceY(GTop) + 108, d.ClientRect, d, TRUE);
        AspTextureFont.TextOut(SurfaceX(GLeft) + 310 - AspTextureFont.TextWidth(g_GetDeputyHeroData[1].sChrName) div 2 , SurfaceY(GTop) + 89, $0088C4E8, g_GetDeputyHeroData[1].sChrName);
        AspTextureFont.TextOut(SurfaceX(GLeft) + 310 - AspTextureFont.TextWidth(ForMat('等级：%d',[g_GetDeputyHeroData[1].Level])) div 2 , SurfaceY(GTop) + 203, $0088C4E8, ForMat('等级：%d',[g_GetDeputyHeroData[1].Level]));
      end;
    end else begin //出战界面
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 21, SurfaceY(GTop) + 106, $0088C4E8, clBlack, '试炼场长老');
      if g_GetDeputyHeroData[0].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[0].btJob, g_GetDeputyHeroData[0].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 13, SurfaceY(GTop) + 157, d.ClientRect, d, TRUE);
        AspTextureFont.TextOut(SurfaceX(GLeft) + 55 - AspTextureFont.TextWidth(g_GetDeputyHeroData[0].sChrName) div 2 , SurfaceY(GTop) + 140, $0088C4E8, g_GetDeputyHeroData[0].sChrName);
        if g_GetDeputyHeroData[0].Level > g_GetDeputyHeroData[1].Level then begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 55 - AspTextureFont.TextWidth(ForMat('主将%d级',[g_GetDeputyHeroData[0].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('主将%d级',[g_GetDeputyHeroData[0].Level]));
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 55 - AspTextureFont.TextWidth(ForMat('副将%d级',[g_GetDeputyHeroData[0].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('副将%d级',[g_GetDeputyHeroData[0].Level]));
        end;
      end;
      if g_GetDeputyHeroData[1].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[1].btJob, g_GetDeputyHeroData[1].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 283, SurfaceY(GTop) + 157, d.ClientRect, d, TRUE);
        AspTextureFont.TextOut(SurfaceX(GLeft) + 326 - AspTextureFont.TextWidth(g_GetDeputyHeroData[1].sChrName) div 2 , SurfaceY(GTop) + 140, $0088C4E8, g_GetDeputyHeroData[1].sChrName);
        if g_GetDeputyHeroData[0].Level < g_GetDeputyHeroData[1].Level then begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 326 - AspTextureFont.TextWidth(ForMat('主将%d级',[g_GetDeputyHeroData[1].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('主将%d级',[g_GetDeputyHeroData[1].Level]));
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 326 - AspTextureFont.TextWidth(ForMat('副将%d级',[g_GetDeputyHeroData[1].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('副将%d级',[g_GetDeputyHeroData[1].Level]));
        end;
      end;
      case g_btHeroAssessMenuIndex of
        0: begin
          if g_GetDeputyHeroData[0].Level > g_GetDeputyHeroData[1].Level then begin
            AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, g_GetDeputyHeroData[0].sChrName+'为主将英雄');
            AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, g_GetDeputyHeroData[1].sChrName+'为副将英雄');
          end else begin
            AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, g_GetDeputyHeroData[0].sChrName+'为副将英雄');
            AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, g_GetDeputyHeroData[1].sChrName+'为主将英雄');
          end;
        end;
        1: begin
          //上
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '评定主将、副将后，我二人虽不');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '可同时出战，但可轮番参与战斗');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '。');
          //下
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '界面右下角英雄包裹按钮旁的副');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '将英雄召唤键可收回英雄和召唤');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '副将英雄。');
        end;
        2: begin
          //上
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '主将英雄获得经验、内功经验后');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '，召唤副将英雄。主将英雄将自');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '动为副将英雄传输双倍经验。');
          //下
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '副将英雄能够以战士、道士、法');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '师三种不同的职业状态出战。合');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '理利用将对战局产生重大影响。');
        end;
        3: begin
          //上
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '主将英雄收回后再次召出的时间');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '间隔为1分钟。副将英雄收回后再');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '次召出时间间隔为5分钟。');
          //下
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '主将英雄与副将英雄之间的召唤');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '，没有特殊限制。合理利用召唤');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '时间，将成为战斗的重要角色。');
        end;
        4: begin
          //上
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '主将英雄死亡后，在1分钟内召唤');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '副将英雄，副将英雄将获得复仇');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '状态，其属性将大幅提高。');
          //下
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '副将英雄的复仇状态效果只能维');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '持3分钟。当把握时机，奋勇杀敌');
          AspTextureFont.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '，英雄同心，其利断金。');
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroAssessSign1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   bby: Byte;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if DHeroAssessSign.ShowHint or (Sender = DStartHeroAutoPra) then bby:=5 else bby:=0; //界面变量区分
      if not TAspDButton(Sender).ShowHint then begin
        if TAspDButton(Sender).Downed then begin
          d := WLib.Images[FaceIndex + 1];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 38 - bby - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 6, $0048A4E8, clBlack, TAspDButton(Sender).Hint);
        end else begin
          if TAspDButton(Sender).MouseMoveing then begin
            d := WLib.Images[FaceIndex];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 36 - bby - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $00A8D4E8, clBlack, TAspDButton(Sender).Hint);
          end else begin
            d := WLib.Images[FaceIndex];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 36 - bby - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0088C4E8, clBlack, TAspDButton(Sender).Hint);
          end;
        end;
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
        end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 36 - 5 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0099A8AC, clBlack, TAspDButton(Sender).Hint);
      end;
      if DHeroAssessSign.ShowHint then begin //界面变量区分
        if Sender = DHeroAssessSign1 then begin
          if GetTickCount - HeroAssessSignTimeTick > 300 then begin
           HeroAssessSignTimeTick := GetTickCount;
           Inc(HeroAssessSignImginsex);
           if HeroAssessSignImginsex > 7 then HeroAssessSignImginsex := 0;
          end;
          d := WLib.Images[1580+HeroAssessSignImginsex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)-4, d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DCheckDeputyHeroWarrClick(Sender: TObject; X,
  Y: Integer);
var
 msg: TDefaultMessage;
begin
  if Sender = DCheckDeputyHeroWarr then begin
    DCheckDeputyHeroWarr.Checked := True;
    DCheckDeputyHeroWiz.Checked := False;
    DCheckDeputyHeroTaos.Checked := False;
  end else if Sender = DCheckDeputyHeroWiz then begin
    DCheckDeputyHeroWarr.Checked := False;
    DCheckDeputyHeroWiz.Checked := True;
    DCheckDeputyHeroTaos.Checked := False;
  end else begin
    DCheckDeputyHeroWarr.Checked := False;
    DCheckDeputyHeroWiz.Checked := False;
    DCheckDeputyHeroTaos.Checked := True;
  end;
  m_btDeputyHeroJob := TAspDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_CHOOSEHEROJOB, frmMain.TempCertification), m_btDeputyHeroJob, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket(EncodeMessage (msg));
end;

procedure TFrmDlg.DCheckHeroDeputyHeroWarrClick(Sender: TObject; X,
  Y: Integer);
var
 msg: TDefaultMessage;
begin
  if Sender = DCheckHeroDeputyHeroWarr then begin
    DCheckHeroDeputyHeroWarr.Checked := True;
    DCheckHeroDeputyHeroWiz.Checked := False;
    DCheckHeroDeputyHeroTaos.Checked := False;
  end else if Sender = DCheckHeroDeputyHeroWiz then begin
    DCheckHeroDeputyHeroWarr.Checked := False;
    DCheckHeroDeputyHeroWiz.Checked := True;
    DCheckHeroDeputyHeroTaos.Checked := False;
  end else begin
    DCheckHeroDeputyHeroWarr.Checked := False;
    DCheckHeroDeputyHeroWiz.Checked := False;
    DCheckHeroDeputyHeroTaos.Checked := True;
  end;
  m_btDeputyHeroJob := TAspDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_CHOOSEHEROJOB, frmMain.TempCertification), m_btDeputyHeroJob, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket(EncodeMessage (msg));
end;

procedure TFrmDlg.DHeroAssessSignClick(Sender: TObject; X, Y: Integer);
var
  str: string;
begin
  if DHeroAssessSign1.ShowHint then Exit;   //按钮变黑
  if not DHeroAssessSign.ShowHint then begin
    if (g_GetDeputyHeroData[0].sChrName = '') or (g_GetDeputyHeroData[1].sChrName = '') then begin
      DMessageDlg ('您需要在酒馆寄存白日门英雄和卧龙英雄，才能进行评定。\（苍月岛仓库内的神秘人处领取白日门英雄，盟重酒馆外翔天等人处领取\卧龙英雄）', [mbOk]);
    end else begin
      if g_GetDeputyHeroData[0].Level = g_GetDeputyHeroData[1].Level then begin
        DMessageDlg ('您的英雄现在不满足成为副将英雄的条件！\可能原因：两位英雄等级相同无法进行评定', [mbOk]);
      end else begin
        DHeroAssessSign.ShowHint := True; //进入出战界面
        DWHeroAssess.SetImgIndex(g_WMainImages, 1541);
        DHeroAssessSign.Visible := False;
        DHeroAssessSign1.SetImgIndex(g_WMainImages, 1548);
        DHeroAssessSign1.Hint := '确定出战';
        DHeroAssessSign1.GLeft := 302;
        DHeroAssessSign1.GTop := 44;
        DHeroAssessClose1.SetImgIndex(g_WMainImages, 1548);
        DHeroAssessClose1.Hint := '暂不出战';
        DHeroAssessClose1.GLeft := 302;
        DHeroAssessClose1.GTop := 85;
        DWHeroAssess.GLeft := 400-DWHeroAssess.GWidth div 2;
        DWHeroAssess.GTop := 300-DWHeroAssess.GHeight div 2;
        DHeroAssessMenu.Visible := True;
      end;
    end;
  end else begin
    if g_GetDeputyHeroData[0].Level > g_GetDeputyHeroData[1].Level then begin
      str := ForMat('评定结果：%s为主将英雄。%s为副将英雄。你同\意该结果吗？\ \注意：一旦同意，将再无法更改结果，且英雄不能被删除。慎重！', [g_GetDeputyHeroData[0].sChrName, g_GetDeputyHeroData[1].sChrName]);
    end else begin
      str := ForMat('评定结果：%s为副将英雄。%s为主将英雄。你同\意该结果吗？\ \注意：一旦同意，将再无法更改结果，且英雄不能被删除。慎重！', [g_GetDeputyHeroData[0].sChrName, g_GetDeputyHeroData[1].sChrName]);
    end;
    if mrOk = FrmDlg.DMessageDlg (str, [mbOk, mbCancel]) then begin
      DHeroAssessSign1.ShowHint := True;
      DHeroAssessClose1.ShowHint := True;
      frmMain.SendAssessmentMainHero(ForMat('%s/%s',[g_GetDeputyHeroData[0].sChrName, g_GetDeputyHeroData[1].sChrName]), g_GetDeputyHeroData[0].Level, g_GetDeputyHeroData[1].Level);
    end;
  end;
end;

procedure TFrmDlg.DHeroAssessMenuDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  hcolor: Integer;
begin
  with DHeroAssessMenu do begin
    AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop), {clMaroon}clRed, '选择出战，结果不可更改！请详查');
    if g_btHeroAssessMenuMoving = 1 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+16, hcolor, '评定作用', [fsUnderline]);
    if g_btHeroAssessMenuMoving = 2 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+30, hcolor, '副将特色', [fsUnderline]);
    if g_btHeroAssessMenuMoving = 3 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+44, hcolor, '协同作战', [fsUnderline]);
    if g_btHeroAssessMenuMoving = 4 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+58, hcolor, '复仇模式', [fsUnderline]);
    if g_btHeroAssessMenuMoving = 5 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    AspTextureFont.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+72, hcolor, '宣布人选（最终结果）', [fsUnderline]);
  end;
end;

procedure TFrmDlg.DHeroAssessMenuMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  lx, ly: Integer;
begin
  g_boHeroAssessMenuDowning := False;
  g_btHeroAssessMenuMoving := 0;
  lx := X - DHeroAssessMenu.GLeft;
  ly := Y - DHeroAssessMenu.GTop;
  if (lx >= 0) and (lx <= 46) and (ly >= 16) and (ly <= 27) then begin
    g_btHeroAssessMenuMoving := 1;
    if ssLeft in Shift then g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 46) and (ly >= 29) and (ly <= 41) then begin
    g_btHeroAssessMenuMoving := 2;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 46) and (ly >= 43) and (ly <= 55) then begin
    g_btHeroAssessMenuMoving := 3;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 46) and (ly >= 57) and (ly <= 69) then begin
    g_btHeroAssessMenuMoving := 4;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 118) and (ly >= 71) and (ly <= 83) then begin
    g_btHeroAssessMenuMoving := 5;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end;
end;

procedure TFrmDlg.DHeroAssessMenuMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: Integer;
begin
  lx := X - DHeroAssessMenu.GLeft;
  ly := Y - DHeroAssessMenu.GTop;
  if Button = mbLeft then begin
    if (lx >= 0) and (lx <= 46) and (ly >= 16) and (ly <= 27) then begin
      g_btHeroAssessMenuIndex := 1;
    end else
    if (lx >= 0) and (lx <= 46) and (ly >= 29) and (ly <= 41) then begin
      g_btHeroAssessMenuIndex := 2;
    end else
    if (lx >= 0) and (lx <= 46) and (ly >= 43) and (ly <= 55) then begin
      g_btHeroAssessMenuIndex := 3;
    end else
    if (lx >= 0) and (lx <= 46) and (ly >= 57) and (ly <= 69) then begin
      g_btHeroAssessMenuIndex := 4;
    end else
    if (lx >= 0) and (lx <= 118) and (ly >= 71) and (ly <= 83) then begin
      g_btHeroAssessMenuIndex := 0;
    end;
  end;
end;

procedure TFrmDlg.DHeroAssessCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWHeroAssess.Visible := False;
end;

procedure TFrmDlg.DWHeroAutoPracticeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
  function GetHeroIcon(Job,Sex: Byte): Integer;
  var
    Icon: Integer;
  begin
    case Job of
      0:Icon := 502;
      1:Icon := 506;
      2:Icon := 504;
      else Icon := 502;
    end;
    if Sex = 1 then Result := Icon +1
    else Result := Icon;
  end;
var
  d: TAsphyreLockableTexture;
  Icon: Integer;
  str, str1: string;
begin
  with DWHeroAutoPractice do begin
    if WLib <> nil then begin //20080701

      case g_btHeroAutoPracticePlace of
        0: begin
          d := WLib.Images[1571];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          str := '封魔谷';
          str1 := '获得经验内功经验';
        end;
        1: begin
          d := WLib.Images[1570];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          str := '雷炎洞穴';
          str1 := '获得大量经验';
        end;
        2: begin
          d := WLib.Images[1572];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          str := '雪域地图';
          str1 := '获得大量内功经验';
        end;
      end;
      AspTextureFont.TextOut(SurfaceX(GLeft)+316 - AspTextureFont.TextWidth(str) div 2, SurfaceY(GTop)+73, $0088C4E8, str);
      AspTextureFont.TextOut(SurfaceX(GLeft)+316 - AspTextureFont.TextWidth(str1) div 2, SurfaceY(GTop)+96, $0088C4E8, str1);
      case g_btHeroAutoPracticeStrength of
        0: AspTextureFont.TextOut(SurfaceX(GLeft)+298 , SurfaceY(GTop)+154, $0088C4E8, '低强度');
        1: AspTextureFont.TextOut(SurfaceX(GLeft)+298 , SurfaceY(GTop)+154, $0088C4E8, '中强度');
        2: AspTextureFont.TextOut(SurfaceX(GLeft)+298 , SurfaceY(GTop)+154, $0088C4E8, '高强度');
      end;
      if g_sHeroAutoPracticeChrName <> '' then begin
        AspTextureFont.TextOut(SurfaceX(GLeft) + 62 - AspTextureFont.TextWidth(g_sHeroAutoPracticeChrName) div 2 , SurfaceY(GTop) + 124, $0088C4E8, g_sHeroAutoPracticeChrName);
        Icon := GetHeroIcon(g_btHeroAutoPracticeJob, g_btHeroAutoPracticeSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 19, SurfaceY(GTop) + 144, d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroAutoPracticeMemoDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
  with DHeroAutoPracticeMemo do begin
    //dsurface.FillRect(Rect(SurfaceX(GLeft), SurfaceY(Top), SurfaceX(GLeft+GWidth), SurfaceY(Top+GHeight)), clred);
    case g_btHeroAutoPracticeStrength of
      0: begin
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop), clWhite, '低强度：获得较低经验和');
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14, clWhite, '内功经验，使用金币辅助');
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14+14, clWhite, '修炼');
      end;
      1: begin
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop), clWhite, '中强度：获得较多经验和');
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14, clWhite, '内功经验，每10秒需要金');
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14+14, clWhite, '币和'+IntToStr(g_btHeroAutoPracticeGameGird1)+'个灵符辅助修炼');
      end;
      2: begin
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop), clWhite, '高强度：获得极多经验和');
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14, clWhite, '内功经验，每10秒需要金');
        AspTextureFont.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14+14, clWhite, '币和'+IntToStr(g_btHeroAutoPracticeGameGird2)+'个灵符辅助修炼');
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroAutoPraMapPrevClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DHeroAutoPraMapNext then begin
    Inc (g_btHeroAutoPracticePlace);
    if g_btHeroAutoPracticePlace > 2 then g_btHeroAutoPracticePlace := 0;
  end else begin
    Dec (g_btHeroAutoPracticePlace);
    if g_btHeroAutoPracticePlace < 0 then
      g_btHeroAutoPracticePlace := 2;
  end;
end;

procedure TFrmDlg.DHeroAutoPraYDSPrevClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DHeroAutoPraYDSNext then begin
    Inc (g_btHeroAutoPracticeStrength);
    if g_btHeroAutoPracticeStrength > 2 then g_btHeroAutoPracticeStrength := 0;
  end else begin
    Dec (g_btHeroAutoPracticeStrength);
    if g_btHeroAutoPracticeStrength < 0 then
      g_btHeroAutoPracticeStrength := 2;
  end;
end;

procedure TFrmDlg.DHeroAutoPraCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWHeroAutoPractice.Visible := False;
end;

procedure TFrmDlg.DStartHeroAutoPraClick(Sender: TObject; X, Y: Integer);
begin
  if DStartHeroAutoPra.ShowHint then Exit;
  DStartHeroAutoPra.ShowHint := True;
  frmMain.SendHeroAutoPractice(g_btHeroAutoPracticePlace, g_btHeroAutoPracticeStrength);
end;

procedure TFrmDlg.DCheckHeroLevelHintClick(Sender: TObject; X, Y: Integer);
var
   msg: TDefaultMessage;
begin
  if not DCheckHeroLevelHint.Checked then
    msg := MakeDefaultMsg (aa(CM_SHOWHEROLEVEL, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount)
  else msg := MakeDefaultMsg (aa(CM_SHOWHEROLEVEL, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DHeroJQExpDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(HeroMagicPage*6+6, g_HeroMagicList.Count);
        for i:=HeroMagTop to magline-1 do begin
          pm := PTClientMagic (g_HeroMagicList[i]);
          if (pm.Def.wMagicId = 68) then begin
            if (pm.Level < 100) then begin
              rc := d.ClientRect;
              if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
                rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
              end;
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroJQExpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
begin
  if g_HeroSelf = nil then Exit;
  magline := _MIN(HeroMagicPage*6+6, g_HeroMagicList.Count);
  for i:=Heromagtop to magline-1 do begin
    pm := PTClientMagic (g_HeroMagicList[i]);
    if (pm.Def.wMagicId = 68) then begin
      if (pm.Level < 100) then begin
        sMsg := '当前经验:%d/%d';
        with DHeroJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      end;
      Break;
    end;
  end;
end;

procedure TFrmDlg.DWJenniferLongBoxDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  BackImages, I: Integer; //宝箱背景图
begin
  with DWJenniferLongBox do begin
    if g_boNewBoxs =2 then begin
      BackImages := 660;
      if FaceIndex = BackImages then begin
        if WLib <> nil then begin //20080701
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if g_BoxsIsFill = 3 then begin  //开始选择动画
            if GetTickCount - g_dwBoxsFlashTick > 100 then begin
            g_dwBoxsFlashTick := GetTickCount;
            Inc(g_BoxsFlashImg);
            if g_BoxsFlashImg > 9 then begin
              g_BoxsFlashImg := 0;
              g_BoxsIsFill := 8;
              ShowBoxsGird(True,g_boNewBoxs); //显示宝箱格
              g_boBoxsMiddleItems := True;
            end;
          end;
          if g_BoxsIsFill = 3 then begin
            d := g_WMainImages.Images[670+g_BoxsFlashImg];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)+32, d.ClientRect, d, True);
          end;
        end;
        if g_nFilledGetItmesID = 0 then begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 304 , SurfaceY(GTop) + 106, clYellow, '您将获得开启免费奖励机会');
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 340 , SurfaceY(GTop) + 106, clYellow, Format('还剩余%d张开启',[g_nFilledGetItmesID]));
        end;
        if g_boBoxsMiddleItems then begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 55 , SurfaceY(GTop) + 106, clYellow, '双击上方暗格选择');
        end;
      end;
      if g_boPutBoxsKey then begin
        if GetTickCount - g_dwBoxsTick > 200 then begin
          g_dwBoxsTick := GetTickCount;
          Inc(g_nBoxsImg);
          if g_nBoxsImg > 6 then begin
            g_nBoxsImg := 0;
            g_boPutBoxsKey := False;
            SetImgIndex(g_WMainImages, BackImages);
            GLeft := 148;
            GTop  := 250;
            d := g_WMainImages.Images[BackImages];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
            ShowBoxsGird(True, g_boNewBoxs); //显示宝箱格
            MyPlaySound(BoxonCeagain_ground);
            DJenniferLongBoxClose.Visible := True;
            DJLChangeItem.Visible := True;
            DJLBoxFlash.Visible := True;
            DJLStartItem.Visible := True;
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 2;
            g_boJLBoxSelToTime := True;
            g_nBoxsImg := 20;
          end;
        end;
      end;
      if DJenniferLongBoxClose.Visible then Exit;
      //SetImgIndex(g_WMainImages, 720);
      d := g_WMainImages.Images[720+g_nBoxsImg];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
      d := g_WMainImages.Images[720+7+g_nBoxsImg];
      if d <> nil then
        dsurface.DrawBlend(SurfaceX(GLeft), SurfaceY(GTop), d);
    end else if g_boNewBoxs = 3 then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if g_boBoxsMiddleItems then begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 53 , SurfaceY(GTop) + 250, clYellow, '点击上方暗格选择');
        end else if g_BoxsIsFill = 254 then begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 53 , SurfaceY(GTop) + 250, clYellow, '天赐开启结束');
        end;
        if g_BoxsIsFill = 7 then  begin //覆盖前动画
          if GetTickCount - g_dwBoxsFlashTick > 200 then begin
            g_dwBoxsFlashTick := GetTickCount;
            Inc(g_BoxsFlashImg);
            if g_BoxsFlashImg > 7 then begin
              g_BoxsFlashImg := 0;
              for I:=Low(g_JLBoxFreeItems) to High(g_JLBoxFreeItems) do begin
                g_JLBoxFreeItems[I].boCloak := True;
              end;
              g_boBoxsLockGetItems := True;
              g_BoxsIsFill := 0;
              DGJLBoxFreeItem.Visible := True;
              g_BoxsMoveDegree := 20;
              g_boBoxsMiddleItems := True;
            end;
          end;
          if g_BoxsIsFill = 7 then begin
            d := g_WMainImages.Images[690+g_BoxsFlashImg];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft+42), SurfaceY(GTop+40), d.ClientRect, d, TRUE);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DJLChangeItemMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if g_BoxsFirstMove then Exit;
  DScreen.ShowHint(DJLChangeItem.SurfaceX(DJLChangeItem.GLeft)+DJLChangeItem.GWidth, DJLChangeItem.SurfaceY(DJLChangeItem.GTop),
       '换取奖励按钮\只有在第一次\选择前有效。'
       , clWhite, FALSE);
end;

procedure TFrmDlg.DJLBoxBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  JLBoxRunning(dsurface);
  with Sender as TAspDButton do begin
    if not g_boBoxsLockGetItems or ((g_BoxsMoveDegree = Tag) and (g_nPlayGetItmesID = 1)) then begin //显示双击上方暗格选择   显示选中物品
      if ShowHint then begin
          d := WLib.Images[662];
          if d <> nil then
             dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        JLBoxItemBelt(Sender, dsurface);
      end;
    end else begin
      if g_BoxsMoveDegree = Tag then begin
        d := WLib.Images[669];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        if g_JLBoxItems[Tag].stdItem.ClientItem.MakeIndex <> 0 then begin
          d := WLib.Images[662];
          if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
          JLBoxItemBelt(Sender, dsurface);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DJLBoxBelt1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  iname: string;
begin
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    iname := g_JLBoxItems[Tag].stdItem.ClientItem.S.Name + '\' + '数量: '+IntToStr(g_JLBoxItems[Tag].nItemNum);
    if g_boBoxsLockGetItems then begin
      if g_JLBoxItems[Tag].stdItem.ClientItem.MakeIndex = 0 then begin
        DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname+'\(已经领取)', clRed, FALSE);
      end else begin
        if g_BoxsFirstMove then Exit;
        if (g_BoxsMoveDegree = Tag) and (g_nPlayGetItmesID = 1) then begin
          DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname+'\(双击获得)', clYellow, FALSE);
        end else begin
          DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), '双击领取', clWhite, FALSE);
        end;
      end;
    end else begin
      if g_BoxsFirstMove then Exit;
      if g_JLBoxItems[Tag].stdItem.ClientItem.MakeIndex = 0 then begin
        DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname+'\(已经领取)', clRed, FALSE);
      end else begin
        DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname, clWhite, FALSE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWJenniferLongBoxMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWJenniferLongBoxClick(Sender: TObject; X, Y: Integer);
begin
  if (not g_boItemMoving) and (g_MovingItem.Item.ClientItem.S.Name = '') and (not g_boPutBoxsKey) and (not DJenniferLongBoxClose.Visible) then  begin
    AddItemBag (g_EatingItem);
    DWJenniferLongBox.Visible := False;
    ShowBoxsGird(False, g_boNewBoxs); //显示宝箱格
  end;
end;

procedure TFrmDlg.DJenniferLongBoxCloseClick(Sender: TObject; X,
  Y: Integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(aa(CM_OPEN9YEARSBOXS, frmMain.TempCertification), 0, 0, 1, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket(EncodeMessage(msg));
  DWJenniferLongBox.Visible := False;
end;

procedure TFrmDlg.DJLChangeItemDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  if Sender = DJLStartItem then begin
    if g_boJLBoxSelToTime and (not DJLStartItem.ShowHint) then begin //开始到记时
      if GetTickCount - g_dwBoxsTick > 999 then begin
        g_dwBoxsTick := GetTickCount;
        Dec(g_nBoxsImg);
        if g_nBoxsImg < 1 then begin
          g_nBoxsImg := 0;
          g_boJLBoxSelToTime := False;
          DJLStartItemClick(DJLStartItem, 0, 0);
        end;
        DJLStartItem.Hint := Format('开始选择(%d)',[g_nBoxsImg]);
      end;
    end;
  end;
  with Sender as TAspDButton do begin
    {if ShowHint then begin   remark by liuzhigang on 2011-12-29 
      if WLib <> nil then begin //20080701
       d := WLib.Images[668];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 5, $0099A8AC, clBlack, Hint);
      Exit;
    end;}

    if WLib <> nil then begin
      if TAspDButton(Sender).Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 6, $0048A4E8, clBlack, Hint);
      end else begin
        if TAspDButton(Sender).MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 5, $00A8D4E8, clBlack, Hint);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 5, $0088C4E8, clBlack, Hint);
        end;
      end;
    end;
  end;
end;

//珍珑宝箱更换奖励
procedure TFrmDlg.JLBoxRunning(dsurface: TAsphyreCanvas);
var
  msg: TDefaultMessage;
begin
  if g_boBoxsShowPosition then begin
    if GetTickCount - g_BoxsShowPositionTick > 220 then begin
     g_BoxsShowPositionTick := GetTickCount;
     Inc(g_BoxsShowPosition);
      if g_BoxsShowPosition > 7 then begin
        g_BoxsShowPosition := -1;
        g_boBoxsShowPosition := False;
        g_BoxsFirstMove := False;
      end;
      if not g_boBoxsShowPosition then Exit;
      if g_nPlayGetItmesID = 2 then begin
        while True do begin
          if (g_BoxsShowPosition < 0) or (g_BoxsShowPosition > 7) then break;
          if g_JLBoxItems[g_BoxsShowPosition].stdItem.ClientItem.MakeIndex = 0 then begin
            Inc(g_BoxsShowPosition);
          end else break;
        end;
        if g_BoxsShowPosition < 8 then g_JLBoxAllItemTag := g_BoxsShowPosition;
      end;
      case g_BoxsShowPosition of
        0: DJLBoxBelt1.ShowHint := g_nPlayGetItmesID <> 2;
        1: DJLBoxBelt2.ShowHint := g_nPlayGetItmesID <> 2;
        2: DJLBoxBelt3.ShowHint := g_nPlayGetItmesID <> 2;
        3: DJLBoxBelt4.ShowHint := g_nPlayGetItmesID <> 2;
        4: DJLBoxBelt5.ShowHint := g_nPlayGetItmesID <> 2;
        5: DJLBoxBelt6.ShowHint := g_nPlayGetItmesID <> 2;
        6: DJLBoxBelt7.ShowHint := g_nPlayGetItmesID <> 2;
        7: begin
          DJLBoxBelt8.ShowHint := g_nPlayGetItmesID <> 2;
          if g_nPlayGetItmesID <> 2 then begin
            msg := MakeDefaultMsg (aa(CM_UPDATA9YEARSBOXSITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
            FrmMain.SendSocket(EncodeMessage(msg));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DJLChangeItemClick(Sender: TObject; X, Y: Integer);
begin
  if DJLChangeItem.ShowHint then Exit;
  g_BoxsFirstMove := True;
  DJLChangeItem.ShowHint := True;
  DJLStartItem.ShowHint := True;
  g_boBoxsShowPosition := True;
end;

procedure TFrmDlg.DJLStartItemClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if DJLStartItem.ShowHint then Exit;
  g_boJLBoxSelToTime := False;
  if g_nPlayGetItmesID = 3 then begin
    msg := MakeDefaultMsg (aa(CM_OPENNEW9YEARSBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  end else begin
    if g_nFilledGetItmesID = 0 then begin
      msg := MakeDefaultMsg (aa(CM_OPENFREE9YEARSBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    end else begin
      msg := MakeDefaultMsg (aa(CM_CHECK9YEARSBOXSKEY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    end;
  end;
  FrmMain.SendSocket(EncodeMessage(msg));
end;

procedure TFrmDlg.DJLBoxBelt1Click(Sender: TObject; X, Y: Integer);
begin
  if not g_boBoxsMiddleItems then Exit;
  if g_JLBoxItems[TAspDButton(Sender).Tag].stdItem.ClientItem.MakeIndex > 0 then g_BoxsMoveDegree := TAspDButton(Sender).Tag;
end;

procedure TFrmDlg.DJLBoxBelt1DblClick(Sender: TObject);
var
  I: Integer;
  temp:TBoxsInfo;
begin
  if not g_boBoxsMiddleItems then Exit;
  if g_JLBoxItems[TAspDButton(Sender).Tag].stdItem.ClientItem.MakeIndex = 0 then Exit;
  if g_JLBoxItems[TAspDButton(Sender).Tag].stdItem.ClientItem.MakeIndex > 0 then g_BoxsMoveDegree := TAspDButton(Sender).Tag;
  g_boBoxsMiddleItems := False;
  g_BoxsFirstMove := True;
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    if g_BoxsMakeIndex > 0 then begin
      for I:=0 to 7 do begin
        if g_JLBoxItems[I].stdItem.ClientItem.MakeIndex = g_BoxsMakeIndex then begin  //制造ID为M2定好的
          temp := g_JLBoxItems[I];
          g_JLBoxItems[I] := g_JLBoxItems[Tag];
          g_JLBoxItems[Tag] := temp;
          break;
        end;
      end;
      g_BoxsFilleFlashImg := 0;
      g_BoxsIsFill := 4;  //显示选择完动画
    end;
  end;
end;

procedure TFrmDlg.DJLBoxFlashDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  bbx: Integer;
  d: TAsphyreLockableTexture;
  msg: TDefaultMessage;
begin
  if g_BoxsIsFill = 4 then begin
    with DJLBoxFlash do begin
      case g_BoxsMoveDegree of
        0: bbx := DJLBoxBelt1.GLeft;
        1: bbx := DJLBoxBelt2.GLeft;
        2: bbx := DJLBoxBelt3.GLeft;
        3: bbx := DJLBoxBelt4.GLeft;
        4: bbx := DJLBoxBelt5.GLeft;
        5: bbx := DJLBoxBelt6.GLeft;
        6: bbx := DJLBoxBelt7.GLeft;
        7: bbx := DJLBoxBelt8.GLeft;
      end;
      if GetTickCount - g_dwBoxsFilleFlashTick > 200 then begin
        g_dwBoxsFilleFlashTick := GetTickCount;
        Inc(g_BoxsFilleFlashImg);
        if g_BoxsFilleFlashImg = 8 then begin
          g_nPlayGetItmesID := 1;
          g_BoxsFirstMove := False;
        end;
        if g_BoxsFilleFlashImg > 9 then begin
          g_BoxsFilleFlashImg := 0;
          g_BoxsIsFill := 5;
          msg := MakeDefaultMsg (aa(CM_GET9YEARSBOXSITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
          FrmMain.SendSocket(EncodeMessage(msg));
        end;
      end;
      if g_BoxsIsFill = 5 then Exit;
      d := g_WMainImages.Images[700+g_BoxsFilleFlashImg];
      if d <> nil then
        dsurface.DrawBlend(SurfaceX(bbx-26),SurfaceY(DJLBoxBelt1.GTop-26), d);
    end;
  end;
end;

procedure TFrmDlg.JLBoxItemBelt(Sender: TObject; dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  idx: Integer;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_JLBoxItems[Tag].stdItem.ClientItem.S.Name <> '' then begin
      idx := g_JLBoxItems[Tag].stdItem.ClientItem.S.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        if g_JLBoxItems[Tag].stdItem.ClientItem.MakeIndex <> 0 then begin
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                       SurfaceY(GTop + (GHeight - d.Height) div 2),
                       d.ClientRect, d, TRUE)
          end;
        end else begin
          if d <> nil then begin
            dsurface.DrawAlpha(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2), Rect(0, 0, d.Width, d.Height), d, 150);
          end;
          d := g_WMainImages.Images[666];
          if d <> nil then begin
            dsurface.DrawAlpha(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2), Rect(0, 0, d.Width, d.Height), d, 150);
          end;
        end;
      end;
      if (g_BoxsIsFill = 8) and (g_JLBoxItems[Tag].stdItem.ClientItem.MakeIndex <> 0) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 4 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill = 0 then Exit;
        d := g_WMain2Images.Images[250+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(GLeft-14),SurfaceY(GTop-14), d);
      end;
      if (g_BoxsIsFill = 7) and (g_nPlayGetItmesID = 2) and (g_JLBoxAllItemTag = Tag) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 9 then begin
            if g_nFilledGetItmesID  <> 0 then DJLStartItem.Hint := '再开一张';
            DJLStartItem.ShowHint := False;
            g_BoxsFilleFlashImg := 0;
            g_nPlayGetItmesID := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill = 0 then Exit;
        d := g_WMain2Images.Images[240+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(GLeft-14),SurfaceY(GTop-14), d);
      end;
      if (g_BoxsIsFill = 6) and (g_BoxsMoveDegree = Tag) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 5 then begin
            g_boBoxsLockGetItems := False;
            DJLBoxBelt1.ShowHint := g_JLBoxItems[0].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt2.ShowHint := g_JLBoxItems[1].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt3.ShowHint := g_JLBoxItems[2].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt4.ShowHint := g_JLBoxItems[3].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt5.ShowHint := g_JLBoxItems[4].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt6.ShowHint := g_JLBoxItems[5].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt7.ShowHint := g_JLBoxItems[6].stdItem.ClientItem.MakeIndex <> 0;
            DJLBoxBelt8.ShowHint := g_JLBoxItems[7].stdItem.ClientItem.MakeIndex <> 0;
            g_nPlayGetItmesID := 2;
            g_boBoxsShowPosition := True;
            g_BoxsFirstMove := True;
            g_boBoxsMiddleItems := False;
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 7;
          end;
        end;
        if g_BoxsIsFill = 7 then Exit;
        d := g_WMain2Images.Images[231+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(GLeft-14),SurfaceY(GTop-14), d);
      end;
      if (g_BoxsIsFill = 5) and (g_BoxsMoveDegree = Tag) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 5 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill = 0 then Exit;
        d := g_WMain2Images.Images[260+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(GLeft-14),SurfaceY(GTop-14), d);
      end;
      if not (g_BoxsIsFill in [0,4,5,6,7]) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 7 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill in [0,4,5,6,7] then Exit;
        d := g_WMain2Images.Images[250+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(GLeft-14),SurfaceY(GTop-14), d);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGJLBoxFreeItemGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
   idx, looks: integer;
   d: TAsphyreLockableTexture;
   msg: TDefaultMessage;
begin
  JLBoxFreeRunning(dsurface);
  idx := ACol + ARow * DGJLBoxFreeItem.ColCount;
  with DGJLBoxFreeItem do  begin
    d := g_WMainImages.Images[661];
    dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                    SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                    d.ClientRect,
                    d, TRUE);
    if idx in [0..19] then begin
      if g_JLBoxFreeItems[idx].Item.stdItem.ClientItem.S.Name <> '' then begin
        looks := g_JLBoxFreeItems[idx].Item.stdItem.ClientItem.S.Looks;
        if looks >= 0 then begin
          if g_JLBoxFreeItems[idx].boCloak then begin
            if {g_boBoxsMiddleItems and} (idx = g_BoxsMoveDegree) then begin
              d := g_WMainImages.Images[669];
            end else d := g_WMainImages.Images[662];
          end else d := frmMain.GetBagItemImg(looks);
          if g_JLBoxFreeItems[idx].Item.stdItem.ClientItem.MakeIndex <> 0 then begin
            if d <> nil then begin
              dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                    SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                    d.ClientRect,
                    d, TRUE)
            end;
          end else begin
            if d <> nil then begin
              dsurface.DrawAlpha(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), Classes.Rect(0, 0, d.Width, d.Height), d, 150);
            end;
            d := g_WMainImages.Images[666];
            if d <> nil then begin
              dsurface.DrawAlpha(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2), Classes.Rect(0,0,d.Width, d.Height), d, 150);
            end;
          end;
        end;
      end;
      if g_BoxsIsFill = 3 then begin //换物品动画
        if GetTickCount - g_dwBoxsFlashTick > 130 then begin
          g_dwBoxsFlashTick := GetTickCount;
          Inc(g_BoxsFlashImg);
          if g_BoxsFlashImg > 15 then begin
            g_BoxsFlashImg := 0;
            Visible := False;
            g_boBoxsMiddleItems := False;
            g_BoxsIsFill := 7;
          end;
        end;
        if g_BoxsFlashImg < 6 then begin
          d := g_WMain2Images.Images[250+g_BoxsFlashImg];
          if d <> nil then
            dsurface.DrawBlend(SurfaceX(Rect.Left-16),SurfaceY(Rect.Top-16), d);
        end;
      end;
      if g_BoxsIsFill = 4 then begin
        if idx = g_BoxsMoveDegree then begin
          if GetTickCount - g_dwBoxsFilleFlashTick > 200 then begin
            g_dwBoxsFilleFlashTick := GetTickCount;
            Inc(g_BoxsFilleFlashImg);
            if g_BoxsFilleFlashImg = 8 then begin
              g_JLBoxFreeItems[idx].boCloak := False;
            end;
            if g_BoxsFilleFlashImg > 9 then begin
              g_BoxsFilleFlashImg := 0;                      
              g_BoxsIsFill := 5;
              msg := MakeDefaultMsg (aa(CM_GETFREE9YEARSBOXSITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
              FrmMain.SendSocket(EncodeMessage(msg));
            end;
          end;
          if g_BoxsIsFill = 5 then Exit;
          d := g_WMainImages.Images[700+g_BoxsFilleFlashImg];
          if d <> nil then
            dsurface.DrawBlend(SurfaceX(Rect.Left-26),SurfaceY(Rect.Top-26), d);
        end;
      end;
      if g_BoxsIsFill = 5 then begin
        if g_BoxsMoveDegree = Idx then begin
          if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
            g_dwBoxsFilleFlashTick := GetTickCount;
            Inc(g_BoxsFilleFlashImg);
            if g_BoxsFilleFlashImg > 5 then begin
              g_BoxsFilleFlashImg := 0;
              g_BoxsIsFill := 0;
            end;
          end;
          if g_BoxsIsFill = 0 then Exit;
          d := g_WMain2Images.Images[260+g_BoxsFilleFlashImg];
          if d <> nil then
            dsurface.DrawBlend(SurfaceX(Rect.Left-14),SurfaceY(Rect.Top-14), d);
        end;
      end;
      if (g_BoxsIsFill = 6) and (g_BoxsMoveDegree = idx) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 5 then begin
            g_BoxsFilleFlashImg := 0;
            g_boBoxsLockGetItems := False;
            g_boBoxsShowPosition := True;
            g_BoxsFirstMove := True;
            g_nPlayGetItmesID := 2;
            g_BoxsIsFill := 8;
          end;
        end;
        if g_BoxsIsFill = 8 then Exit;
        d := g_WMain2Images.Images[231+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(Rect.Left-14),SurfaceY(Rect.Top-14), d);
      end;
      if (g_BoxsIsFill = 8) and (g_nPlayGetItmesID = 2) and (g_JLBoxAllItemTag = idx) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          Inc(g_nFilledGetItmesID);
          if g_BoxsFilleFlashImg > 9 then begin
            g_BoxsFilleFlashImg := 0;
          end;
          if g_nFilledGetItmesID > 19 then begin
            DJLStartItem.Hint := '开启新天赐';
            DJLStartItem.GLeft := 137;
            DJLStartItem.GTop := 258;
            DJLStartItem.Visible := True;
            g_BoxsFirstMove := False;
            g_nPlayGetItmesID := 3;
            g_nFilledGetItmesID := 0;
            g_BoxsIsFill := 254;
          end;
        end;
        if g_BoxsIsFill = 254 then Exit;
        d := g_WMain2Images.Images[240+g_BoxsFilleFlashImg];
        if d <> nil then
          dsurface.DrawBlend(SurfaceX(Rect.Left-14),SurfaceY(Rect.Top-14), d);
      end;
    end;
  end;  
end;

procedure TFrmDlg.DGJLBoxFreeItemGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  iname: string;
  idx: Byte;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DGJLBoxFreeItem.ColCount;
  with DGJLBoxFreeItem do begin
    if idx in [0..19] then begin
      iname := g_JLBoxFreeItems[idx].Item.stdItem.ClientItem.S.Name + '\' + '数量: '+IntToStr(g_JLBoxFreeItems[idx].Item.nItemNum);
      if g_boBoxsLockGetItems then begin
        if g_BoxsFirstMove then Exit;
        if (g_BoxsMoveDegree = idx) and (not g_JLBoxFreeItems[idx].boCloak) then begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), iname+'\(双击获得)', clYellow, FALSE);
        end else begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), '双击选择奖励', clWhite, FALSE);
        end;
      end else begin
        if g_BoxsFirstMove then Exit;
        if g_JLBoxFreeItems[idx].Item.stdItem.ClientItem.MakeIndex = 0 then begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), iname+'\(已经领取)', clRed, FALSE);
        end else begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), iname, clWhite, FALSE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGJLBoxFreeItemGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Byte;
begin
  if not g_boBoxsMiddleItems then Exit;
  idx := ACol + ARow * DGJLBoxFreeItem.ColCount;
  if idx in [0..19] then g_BoxsMoveDegree := idx;
end;

procedure TFrmDlg.DGJLBoxFreeItemDblClick(Sender: TObject);
var
  I, idx: Integer;
  temp:TJLBoxFreeItem;
begin
  if not g_boBoxsMiddleItems then Exit;
  idx := DGJLBoxFreeItem.Col + DGJLBoxFreeItem.Row * DGJLBoxFreeItem.ColCount;
  if idx in [0..19] then g_BoxsMoveDegree := idx;
  g_boBoxsMiddleItems := False;
  g_BoxsFirstMove := True;
  with DGJLBoxFreeItem do begin
    if idx in [0..19] then begin
      if (g_JLBoxFreeItems[idx].Item.stdItem.ClientItem.MakeIndex > 0) and (g_BoxsMakeIndex > 0)then begin
        for I:=0 to 19 do begin
          if g_JLBoxFreeItems[I].Item.stdItem.ClientItem.MakeIndex = g_BoxsMakeIndex then begin  //制造ID为M2定好的
            temp := g_JLBoxFreeItems[I];
            g_JLBoxFreeItems[I] := g_JLBoxFreeItems[idx];
            g_JLBoxFreeItems[idx] := temp;
            break;
          end;
        end;
        g_BoxsFilleFlashImg := 0;
        g_BoxsIsFill := 4;  //显示选择完动画
      end;
    end;
  end;
end;
//珍珑免费宝箱翻牌
procedure TFrmDlg.JLBoxFreeRunning(dsurface: TAsphyreCanvas);
begin
  if g_boBoxsShowPosition then begin
    if GetTickCount - g_BoxsShowPositionTick > 220 then begin
     g_BoxsShowPositionTick := GetTickCount;
     Inc(g_BoxsShowPosition);
      if g_BoxsShowPosition > 19 then begin
        g_BoxsShowPosition := -1;
        g_boBoxsShowPosition := False;
      end;
      if not g_boBoxsShowPosition then Exit;
      if g_nPlayGetItmesID = 2 then begin
        while True do begin
          if (g_BoxsShowPosition < 0) or (g_BoxsShowPosition > 19) then break;
          if g_JLBoxFreeItems[g_BoxsShowPosition].Item.stdItem.ClientItem.MakeIndex = 0 then begin
            Inc(g_BoxsShowPosition);
          end else break;
        end;
        if g_BoxsShowPosition < 20 then g_JLBoxAllItemTag := g_BoxsShowPosition;
      end;
      if g_BoxsShowPosition in [0..19] then begin
        g_JLBoxFreeItems[g_BoxsShowPosition].boCloak := False;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBCallDeputyHeroClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  if GetTickCount - g_CallHeroTick > 1000 then begin
    if g_HeroSelf = nil then begin
      g_CallHeroTick := GetTickCount();
      //召唤副将英雄
      msg := MakeDefaultMsg (aa(CM_RECALLHERO, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
      frmMain.SendSocket(EncodeMessage (msg));
    end;
  end;
end;


procedure TFrmDlg.DBCallHeroClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if GetTickCount - g_CallHeroTick > 5000 then begin
    g_CallHeroTick := GetTickCount();
    if FrmDlg.DBCallHero.ShowHint then
        msg := MakeDefaultMsg (aa(CM_RECALLHERO, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount) //召唤英雄
    else
        msg := MakeDefaultMsg (aa(CM_HEROLOGOUT, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount); //英雄退出
     FrmMain.SendSocket (EncodeMessage (msg));
  end;
end;

procedure TFrmDlg.DBCallHeroInitialize(Sender: TObject);
begin
  DBCallHero.SetImgIndex(g_qingqingImages,30);    //召唤英雄
end;

procedure TFrmDlg.DBCommandFrameDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  I: Integer;
begin
  d := g_WMainImages.Images[403];
  if d <> nil then begin
    with DBCommandFrame do begin
      dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), Rect(0, 0, GWidth, GHeight ), d, 120);
      if g_CommandList.Count > 0 then begin
        if g_ComMandIndex <> -1 then
          dsurface.FillRect(Rect(SurfaceX(GLeft)+2, SurfaceY(GTop)+g_ComMandIndex*20+2 ,SurfaceX(GLeft)+GWidth-2,SurfaceY(GTop)+g_ComMandIndex*20+20+2), $00400000);
        for I:=0 to g_CommandList.Count - 1 do begin
          AspTextureFont.TextOut(SurfaceX(GLeft) + 12, SurfaceY(GTop)+I*20+6, clWhite, g_CommandList[i]);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBCommandMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  g_ComMandIndex := -1;
  DBCommandFrame.GTop := DBCommand.GTop - DBCommandFrame.GHeight; 
  DBCommandFrame.Visible := True;
end;

procedure TFrmDlg.DBCommandFrameMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  ss: Integer;
begin
  with DBCommandFrame do begin
    if g_CommandList.Count >0 then begin
      ss := ((Y - GTop) - 1) div 20;
      if ss >= g_CommandList.Count then ss := g_CommandList.Count - 1;
      if ss <= 0 then ss := 0;
      g_ComMandIndex := ss;
    end else g_ComMandIndex := -1;
  end;
end;

procedure TFrmDlg.DBCommandFrameMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  Str: string;
begin
  Str := '';
  case g_ComMandIndex of
    2,5,8,11: Str := '-';
    0: Str := '@加入门派';
    1: Str := '@退出门派';
    3: Str := '@允许收徒';
    4: Str := '@拒绝收徒';
    6: Str := '@拒绝求婚';
    7: Str := '@允许求婚';
    9: Str := '@天地合一';
    10: Str := '@允许天地合一';
    13: Str := '!';
    14: Str := '!~';
    15: Str := '!!';
    16: Str := '/ ';
    17: Str := '@传 ';
  end;
  if Str <> '-' then begin
    if not PlayScene.EdChat.Visible then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
    end;
    PlayScene.EdChat.Text := Str;
    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
    PlayScene.EdChat.SelLength := 0;
  end;
end;

procedure TFrmDlg.DBCommandInitialize(Sender: TObject);
begin
  DBCommand.SetImgIndex(g_WchantkkImages, 36); //游戏命令
end;

procedure TFrmDlg.DCBFilterItemStdModeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  I, X1, Y1, X2, Y2: Integer;
  FontColor: Tcolor;
  Pt1, Pt2, Pt3: TPoint;
begin
  with Sender as TAspDComboBox do begin
    X1 := SurfaceX(GLeft) + (GWidth - 16) + 5;
    Y1 := SurfaceY(GTop) + (GHeight - 5) div 2;

    if Downed then Y1 := Y1 + 1;
    X2 := X1 + 3;
    Y2 := Y1 + 4;

    Pt1 := Point(X1, Y1);
    Pt2 := Point(X1+7, Y1);
    Pt3 := Point(X2, Y2+2);
    dsurface.FillTri(Pt1, Pt2, Pt3, $00488184, $00488184, $00488184);
  end;
end;

procedure TFrmDlg.DEdtFilterItemStdModeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  Color: TColor;
begin
  with Sender as TAspDEdit do begin
    if Moveed then Color := $00387B9C
    else Color := $00638494;
    if Focused then Color := $005993BD;
    dsurface.FillRect(ClientRect, clBlack);
    dsurface.FrameRect(ClientRect, Color);
    if TAspDEdit(Sender).Text = '' then  AspTextureFont.TextOut(SurfaceX(GLeft)+2, SurfaceY(GTop)+4, $00808080, '[输入物品关键字查找]');
  end;
end;

procedure TFrmDlg.DBtnDefaultFilterItemDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
  with Sender as TAspDButton do begin
    if not Downed then begin
      AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop) + 5, clYellow, TAspDButton(Sender).Hint, [fsUnderline]);
    end else begin
      AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop) + 6, clRed, TAspDButton(Sender).Hint, [fsUnderline]);
    end;
  end;
end;

procedure TFrmDlg.DEdtBookHPProChange(Sender: TObject);
begin
  if TAspDEdit(Sender).Text <> '' then begin
    case m_btProPage of
      0: begin
        if Sender = DEdtBookHPPro then begin
          g_Config.wHp1Hp := Str_ToInt(DEdtBookHPPro.Text, 0);
        end else if Sender = DEdtBookMPPro then begin
          g_Config.wMp1Mp := Str_ToInt(DEdtBookMPPro.Text, 0);
        end else if Sender = DEdtRenewHP then begin
          g_Config.wRenewHPPercent := Str_ToInt(DEdtRenewHP.Text, g_Config.wRenewHPPercent);
        end else if Sender = DEdtRenewMP then begin
          g_Config.wRenewMPPercent := Str_ToInt(DEdtRenewMP.Text, g_Config.wRenewMPPercent);
        end else if Sender = DEdtRenewHPTime then begin
          g_Config.wRenewHPTime := Str_ToInt(DEdtRenewHPTime.Text, g_Config.wRenewHPTime);
        end else if Sender = DEdtRenewMpTime then begin
          g_Config.wRenewMpTime := Str_ToInt(DEdtRenewMpTime.Text, g_Config.wRenewMpTime);
        end else if Sender = DEdtRenewHPSpecial then begin
          g_Config.wRenewSpecialHPPercent := Str_ToInt(DEdtRenewHPSpecial.Text, g_Config.wRenewSpecialHPPercent);
        end else if Sender = DEdtRenewMpSpecial then begin
          g_Config.wRenewSpecialMpPercent := Str_ToInt(DEdtRenewMpSpecial.Text, g_Config.wRenewSpecialMpPercent);
        end else if Sender = DEdtRenewHPSpecialTime then begin
          g_Config.wRenewSpecialHPTime := Str_ToInt(DEdtRenewHPSpecialTime.Text, g_Config.wRenewSpecialHPTime);
        end else if Sender = DEdtRenewMpSpecialTime then begin
          g_Config.wRenewSpecialMpTime := Str_ToInt(DEdtRenewMpSpecialTime.Text, g_Config.wRenewSpecialMpTime);
        end else if Sender = DEditSuperMedicaHP1 then begin
          g_Config.SuperMedicaHPs[0] := Str_ToInt(DEditSuperMedicaHP1.Text, g_Config.SuperMedicaHPs[0]);
        end else if Sender = DEditSuperMedicaHP2 then begin
          g_Config.SuperMedicaHPs[1] := Str_ToInt(DEditSuperMedicaHP2.Text, g_Config.SuperMedicaHPs[1]);
        end else if Sender = DEditSuperMedicaHP3 then begin
          g_Config.SuperMedicaHPs[2] := Str_ToInt(DEditSuperMedicaHP3.Text, g_Config.SuperMedicaHPs[2]);
        end else if Sender = DEditSuperMedicaHP4 then begin
          g_Config.SuperMedicaHPs[3] := Str_ToInt(DEditSuperMedicaHP4.Text, g_Config.SuperMedicaHPs[3]);
        end else if Sender = DEditSuperMedicaHP5 then begin
          g_Config.SuperMedicaHPs[4] := Str_ToInt(DEditSuperMedicaHP5.Text, g_Config.SuperMedicaHPs[4]);
        end else if Sender = DEditSuperMedicaHP6 then begin
          g_Config.SuperMedicaHPs[5] := Str_ToInt(DEditSuperMedicaHP6.Text, g_Config.SuperMedicaHPs[5]);
        end else if Sender = DEditSuperMedicaHP7 then begin
          g_Config.SuperMedicaHPs[6] := Str_ToInt(DEditSuperMedicaHP7.Text, g_Config.SuperMedicaHPs[6]);
        end else if Sender = DEditSuperMedicaHP8 then begin
          g_Config.SuperMedicaHPs[7] := Str_ToInt(DEditSuperMedicaHP8.Text, g_Config.SuperMedicaHPs[7]);
        end else if Sender = DEditSuperMedicaHP9 then begin
          g_Config.SuperMedicaHPs[8] := Str_ToInt(DEditSuperMedicaHP9.Text, g_Config.SuperMedicaHPs[8]);
        end else if Sender = DEditSuperMedicaHP10 then begin
          g_Config.SuperMedicaHPs[9] := Str_ToInt(DEditSuperMedicaHP10.Text, g_Config.SuperMedicaHPs[9]);
        end else if Sender = DEditSuperMedicaHP11 then begin
          g_Config.SuperMedicaHPs[10] := Str_ToInt(DEditSuperMedicaHP11.Text, g_Config.SuperMedicaHPs[10]);
        end else if Sender = DEditSuperMedicaHP12 then begin
          g_Config.SuperMedicaHPs[11] := Str_ToInt(DEditSuperMedicaHP12.Text, g_Config.SuperMedicaHPs[11]);
        end else if Sender = DEditSuperMedicaHP13 then begin
          g_Config.SuperMedicaHPs[12] := Str_ToInt(DEditSuperMedicaHP13.Text, g_Config.SuperMedicaHPs[12]);
        end else if Sender = DEditSuperMedicaHP14 then begin
          g_Config.SuperMedicaHPs[13] := Str_ToInt(DEditSuperMedicaHP14.Text, g_Config.SuperMedicaHPs[13]);
        end else if Sender = DEditSuperMedicaMP1 then begin
          g_Config.SuperMedicaMPs[0] := Str_ToInt(DEditSuperMedicaMP1.Text, g_Config.SuperMedicaMPs[0]);
        end else if Sender = DEditSuperMedicaMP2 then begin
          g_Config.SuperMedicaMPs[1] := Str_ToInt(DEditSuperMedicaMP2.Text, g_Config.SuperMedicaMPs[1]);
        end else if Sender = DEditSuperMedicaMP3 then begin
          g_Config.SuperMedicaMPs[2] := Str_ToInt(DEditSuperMedicaMP3.Text, g_Config.SuperMedicaMPs[2]);
        end else if Sender = DEditSuperMedicaMP4 then begin
          g_Config.SuperMedicaMPs[3] := Str_ToInt(DEditSuperMedicaMP4.Text, g_Config.SuperMedicaMPs[3]);
        end else if Sender = DEditSuperMedicaMP5 then begin
          g_Config.SuperMedicaMPs[4] := Str_ToInt(DEditSuperMedicaMP5.Text, g_Config.SuperMedicaMPs[4]);
        end else if Sender = DEditSuperMedicaMP6 then begin
          g_Config.SuperMedicaMPs[5] := Str_ToInt(DEditSuperMedicaMP6.Text, g_Config.SuperMedicaMPs[5]);
        end else if Sender = DEditSuperMedicaMP7 then begin
          g_Config.SuperMedicaMPs[6] := Str_ToInt(DEditSuperMedicaMP7.Text, g_Config.SuperMedicaMPs[6]);
        end else if Sender = DEditSuperMedicaMP8 then begin
          g_Config.SuperMedicaMPs[7] := Str_ToInt(DEditSuperMedicaMP8.Text, g_Config.SuperMedicaMPs[7]);
        end else if Sender = DEditSuperMedicaMP9 then begin
          g_Config.SuperMedicaMPs[8] := Str_ToInt(DEditSuperMedicaMP9.Text, g_Config.SuperMedicaMPs[8]);
        end else if Sender = DEditSuperMedicaMP10 then begin
          g_Config.SuperMedicaMPs[9] := Str_ToInt(DEditSuperMedicaMP10.Text, g_Config.SuperMedicaMPs[9]);
        end else if Sender = DEditSuperMedicaMP11 then begin
          g_Config.SuperMedicaMPs[10] := Str_ToInt(DEditSuperMedicaMP11.Text, g_Config.SuperMedicaMPs[10]);
        end else if Sender = DEditSuperMedicaMP12 then begin
          g_Config.SuperMedicaMPs[11] := Str_ToInt(DEditSuperMedicaMP12.Text, g_Config.SuperMedicaMPs[11]);
        end else if Sender = DEditSuperMedicaMP13 then begin
          g_Config.SuperMedicaMPs[12] := Str_ToInt(DEditSuperMedicaMP13.Text, g_Config.SuperMedicaMPs[12]);
        end else if Sender = DEditSuperMedicaMP14 then begin
          g_Config.SuperMedicaMPs[13] := Str_ToInt(DEditSuperMedicaMP14.Text, g_Config.SuperMedicaMPs[13]);
        end else if Sender = DEditSuperMedicaHPTime1 then begin
          g_Config.SuperMedicaHPTimes[0] := Str_ToInt(DEditSuperMedicaHPTime1.Text, g_Config.SuperMedicaHPTimes[0]);
        end else if Sender = DEditSuperMedicaHPTime2 then begin
          g_Config.SuperMedicaHPTimes[1] := Str_ToInt(DEditSuperMedicaHPTime2.Text, g_Config.SuperMedicaHPTimes[1]);
        end else if Sender = DEditSuperMedicaHPTime3 then begin
          g_Config.SuperMedicaHPTimes[2] := Str_ToInt(DEditSuperMedicaHPTime3.Text, g_Config.SuperMedicaHPTimes[2]);
        end else if Sender = DEditSuperMedicaHPTime4 then begin
          g_Config.SuperMedicaHPTimes[3] := Str_ToInt(DEditSuperMedicaHPTime4.Text, g_Config.SuperMedicaHPTimes[3]);
        end else if Sender = DEditSuperMedicaHPTime5 then begin
          g_Config.SuperMedicaHPTimes[4] := Str_ToInt(DEditSuperMedicaHPTime5.Text, g_Config.SuperMedicaHPTimes[4]);
        end else if Sender = DEditSuperMedicaHPTime6 then begin
          g_Config.SuperMedicaHPTimes[5] := Str_ToInt(DEditSuperMedicaHPTime6.Text, g_Config.SuperMedicaHPTimes[5]);
        end else if Sender = DEditSuperMedicaHPTime7 then begin
          g_Config.SuperMedicaHPTimes[6] := Str_ToInt(DEditSuperMedicaHPTime7.Text, g_Config.SuperMedicaHPTimes[6]);
        end else if Sender = DEditSuperMedicaHPTime8 then begin
          g_Config.SuperMedicaHPTimes[7] := Str_ToInt(DEditSuperMedicaHPTime8.Text, g_Config.SuperMedicaHPTimes[7]);
        end else if Sender = DEditSuperMedicaHPTime9 then begin
          g_Config.SuperMedicaHPTimes[8] := Str_ToInt(DEditSuperMedicaHPTime9.Text, g_Config.SuperMedicaHPTimes[8]);
        end else if Sender = DEditSuperMedicaHPTime10 then begin
          g_Config.SuperMedicaHPTimes[9] := Str_ToInt(DEditSuperMedicaHPTime10.Text, g_Config.SuperMedicaHPTimes[9]);
        end else if Sender = DEditSuperMedicaHPTime11 then begin
          g_Config.SuperMedicaHPTimes[10] := Str_ToInt(DEditSuperMedicaHPTime11.Text, g_Config.SuperMedicaHPTimes[10]);
        end else if Sender = DEditSuperMedicaHPTime12 then begin
          g_Config.SuperMedicaHPTimes[11] := Str_ToInt(DEditSuperMedicaHPTime12.Text, g_Config.SuperMedicaHPTimes[11]);
        end else if Sender = DEditSuperMedicaHPTime13 then begin
          g_Config.SuperMedicaHPTimes[12] := Str_ToInt(DEditSuperMedicaHPTime13.Text, g_Config.SuperMedicaHPTimes[12]);
        end else if Sender = DEditSuperMedicaHPTime14 then begin
          g_Config.SuperMedicaHPTimes[13] := Str_ToInt(DEditSuperMedicaHPTime14.Text, g_Config.SuperMedicaHPTimes[13]);
        end else if Sender = DEditSuperMedicaMPTime1 then begin
          g_Config.SuperMedicaMPTimes[0] := Str_ToInt(DEditSuperMedicaMPTime1.Text, g_Config.SuperMedicaMPTimes[0]);
        end else if Sender = DEditSuperMedicaMPTime2 then begin
          g_Config.SuperMedicaMPTimes[1] := Str_ToInt(DEditSuperMedicaMPTime2.Text, g_Config.SuperMedicaMPTimes[1]);
        end else if Sender = DEditSuperMedicaMPTime3 then begin
          g_Config.SuperMedicaMPTimes[2] := Str_ToInt(DEditSuperMedicaMPTime3.Text, g_Config.SuperMedicaMPTimes[2]);
        end else if Sender = DEditSuperMedicaMPTime4 then begin
          g_Config.SuperMedicaMPTimes[3] := Str_ToInt(DEditSuperMedicaMPTime4.Text, g_Config.SuperMedicaMPTimes[3]);
        end else if Sender = DEditSuperMedicaMPTime5 then begin
          g_Config.SuperMedicaMPTimes[4] := Str_ToInt(DEditSuperMedicaMPTime5.Text, g_Config.SuperMedicaMPTimes[4]);
        end else if Sender = DEditSuperMedicaMPTime6 then begin
          g_Config.SuperMedicaMPTimes[5] := Str_ToInt(DEditSuperMedicaMPTime6.Text, g_Config.SuperMedicaMPTimes[5]);
        end else if Sender = DEditSuperMedicaMPTime7 then begin
          g_Config.SuperMedicaMPTimes[6] := Str_ToInt(DEditSuperMedicaMPTime7.Text, g_Config.SuperMedicaMPTimes[6]);
        end else if Sender = DEditSuperMedicaMPTime8 then begin
          g_Config.SuperMedicaMPTimes[7] := Str_ToInt(DEditSuperMedicaMPTime8.Text, g_Config.SuperMedicaMPTimes[7]);
        end else if Sender = DEditSuperMedicaMPTime9 then begin
          g_Config.SuperMedicaMPTimes[8] := Str_ToInt(DEditSuperMedicaMPTime9.Text, g_Config.SuperMedicaMPTimes[8]);
        end else if Sender = DEditSuperMedicaMPTime10 then begin
          g_Config.SuperMedicaMPTimes[9] := Str_ToInt(DEditSuperMedicaMPTime10.Text, g_Config.SuperMedicaMPTimes[9]);
        end else if Sender = DEditSuperMedicaMPTime11 then begin
          g_Config.SuperMedicaMPTimes[10] := Str_ToInt(DEditSuperMedicaMPTime11.Text, g_Config.SuperMedicaMPTimes[10]);
        end else if Sender = DEditSuperMedicaMPTime12 then begin
          g_Config.SuperMedicaMPTimes[11] := Str_ToInt(DEditSuperMedicaMPTime12.Text, g_Config.SuperMedicaMPTimes[11]);
        end else if Sender = DEditSuperMedicaMPTime13 then begin
          g_Config.SuperMedicaMPTimes[12] := Str_ToInt(DEditSuperMedicaMPTime13.Text, g_Config.SuperMedicaMPTimes[12]);
        end else if Sender = DEditSuperMedicaMPTime14 then begin
          g_Config.SuperMedicaMPTimes[13] := Str_ToInt(DEditSuperMedicaMPTime14.Text, g_Config.SuperMedicaMPTimes[13]);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DEdtFilterItemStdModeChange(Sender: TObject);
var
  I: Integer;
  List: TList;

  ShowItem: pTShowItem1;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
  sText: string;
begin
  if DEdtFilterItemStdMode.Text = '' then begin
    DCBFilterItemStdModeChange(Sender);
  end else begin
    sText := DEdtFilterItemStdMode.Text;
    List := TList.Create;
    try
      g_ShowItemList.Get(TItemType(DCBFilterItemStdMode.ItemIndex), List);
      DListViewFilterItem.Clear;
      DListViewFilterItem.ColCount := 4;
      DListViewFilterItem.HScrollBar.MaxValue := 0;
      for I := 0 to List.Count - 1 do begin
        ShowItem := List.Items[I];
        if AnsiContainsText(sText, ShowItem.SItemName) or AnsiContainsText(ShowItem.SItemName, sText) then begin
          ListItem := DListViewFilterItem.Add;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Caption := ShowItem.SItemName;
          ViewItem.Data := ShowItem;
          ViewItem.Style := bsButton; //bsRadio;
          ViewItem.Color.Up.Color := clWhite;
          ViewItem.Color.Hot.Color := clRed; //clWhite;
          ViewItem.Color.Down.Color := clRed;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Style := bsCheckBox;
          ViewItem.ImageIndex.Up := 228;
          ViewItem.ImageIndex.Down := 229;
          ViewItem.Checked := ShowItem.boHintMsg;
          ViewItem.WLib := g_WMain2Images;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Style := bsCheckBox;
          ViewItem.ImageIndex.Up := 228;
          ViewItem.ImageIndex.Down := 229;
          ViewItem.Checked := ShowItem.boPickup;
          ViewItem.WLib := g_WMain2Images;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Style := bsCheckBox;
          ViewItem.ImageIndex.Up := 228;
          ViewItem.ImageIndex.Down := 229;
          ViewItem.Checked := ShowItem.boShowName;
          ViewItem.WLib := g_WMain2Images;
        end;
      end;
      DListViewFilterItem.HScrollBar.RemoveSize := DListViewFilterItem.HScrollBar.ItemHeight * 8;
      DListViewFilterItem.HScrollBar.MaxValue := DListViewFilterItem.Count * DListViewFilterItem.HScrollBar.ItemHeight;
    finally
      List.Free;
    end;
  end;
end;

procedure TFrmDlg.DCBFilterItemStdModeChange(Sender: TObject);
var
  I: Integer;
  List: TList;

  ShowItem: pTShowItem1;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
begin
  List := TList.Create;
  try
    g_ShowItemList.Get(TItemType(DCBFilterItemStdMode.ItemIndex), List);
    DListViewFilterItem.Clear;
    DListViewFilterItem.ColCount := 4;
    DListViewFilterItem.HScrollBar.MaxValue := 0;
    for I := 0 to List.Count - 1 do begin
      ShowItem := List.Items[I];
      ListItem := DListViewFilterItem.Add;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Caption := ShowItem.SItemName;
      ViewItem.Data := ShowItem;
      ViewItem.Style := bsButton; //bsRadio;
      ViewItem.Color.Up.Color := clWhite;
      ViewItem.Color.Hot.Color := clRed; //clWhite;
      ViewItem.Color.Down.Color := clRed;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Style := bsCheckBox;
      ViewItem.ImageIndex.Up := 228;
      ViewItem.ImageIndex.Down := 229;
      ViewItem.Checked := ShowItem.boHintMsg;
      ViewItem.WLib := g_WMain2Images;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Style := bsCheckBox;
      ViewItem.ImageIndex.Up := 228;
      ViewItem.ImageIndex.Down := 229;
      ViewItem.Checked := ShowItem.boPickup;
      ViewItem.WLib := g_WMain2Images;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Style := bsCheckBox;
      ViewItem.ImageIndex.Up := 228;
      ViewItem.ImageIndex.Down := 229;
      ViewItem.Checked := ShowItem.boShowName;
      ViewItem.WLib := g_WMain2Images;
    end;
    DListViewFilterItem.HScrollBar.RemoveSize := DListViewFilterItem.HScrollBar.ItemHeight * 8;
    DListViewFilterItem.HScrollBar.MaxValue := DListViewFilterItem.Count * DListViewFilterItem.HScrollBar.ItemHeight;
  finally
    List.Free;
  end;
end;

procedure TFrmDlg.DBtnDefaultFilterItemClick(Sender: TObject; X,
  Y: Integer);
var
  I: Integer;
  List: TList;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
  ShowItem: pTShowItem1;
begin
  if mrOk = DMessageDlg('你想恢复成系统默认设置吗 ?', [mbOk, mbCancel]) then begin
    g_ShowItemList.BackUp;
    List := TList.Create;
    try
      g_ShowItemList.Get(TItemType(DCBFilterItemStdMode.ItemIndex), List);
      DListViewFilterItem.Clear;
      DListViewFilterItem.ColCount := 4;
      DListViewFilterItem.HScrollBar.MaxValue := 0;
      for I := 0 to List.Count - 1 do begin
        ShowItem := List.Items[I];
        ListItem := DListViewFilterItem.Add;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Caption := ShowItem.SItemName;
        ViewItem.Data := ShowItem;
        ViewItem.Style := bsButton; //bsRadio;
        ViewItem.Color.Up.Color := clWhite;
        ViewItem.Color.Hot.Color := clRed; //clWhite;
        ViewItem.Color.Down.Color := clRed;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Style := bsCheckBox;
        ViewItem.ImageIndex.Up := 228;
        ViewItem.ImageIndex.Down := 229;
        ViewItem.Checked := ShowItem.boHintMsg;
        ViewItem.WLib := g_WMain2Images;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Style := bsCheckBox;
        ViewItem.ImageIndex.Up := 228;
        ViewItem.ImageIndex.Down := 229;
        ViewItem.Checked := ShowItem.boPickup;
        ViewItem.WLib := g_WMain2Images;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Style := bsCheckBox;
        ViewItem.ImageIndex.Up := 228;
        ViewItem.ImageIndex.Down := 229;
        ViewItem.Checked := ShowItem.boShowName;
        ViewItem.WLib := g_WMain2Images;
      end;
      DListViewFilterItem.HScrollBar.MaxValue := List.Count * DListViewFilterItem.HScrollBar.ItemHeight;
    finally
      List.Free;
    end;
    g_ShowItemList.SaveToFile;
    DListViewFilterItem.HScrollBar.First;
  end;
end;

procedure TFrmDlg.DListViewFilterItemListItemClick(Sender: TObject; ARow,
  ACol: Integer; ListItem: TDListItem; ViewItem: pTViewItem);
var
  ShowItem: pTShowItem1;
  I : Integer;
begin
  ShowItem := ListItem.Items[0].Data;
  case ACol of
    0: begin
      ViewItem.Checked := not ViewItem.Checked;
      for I := 0 to ListItem.Count - 1 do
        ListItem.Items[I].Checked := ViewItem.Checked;
      if ViewItem.Checked then begin
        ShowItem.boHintMsg := True;
        ShowItem.boPickup := True;
        ShowItem.boShowName := True;
      end else begin
        ShowItem.boHintMsg := False;
        ShowItem.boPickup := False;
        ShowItem.boShowName := False;
      end;
    end;
    1: ShowItem.boHintMsg := ViewItem.Checked;
    2: ShowItem.boPickup := ViewItem.Checked;
    3: ShowItem.boShowName := ViewItem.Checked;
  end;
  g_ShowItemList.SaveToFile;
end;

procedure TFrmDlg.DLLingWUXinFaClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    btPage := TAspDLabel(Sender).Tag;
    DLXinFaChangeSelName.Visible := boChangeXinFa and (btPage = 0);
    DBLingWuXinFaName.Visible := not boChangeXinFa and (btPage = 0);
    DLXinFaMakeName.Visible := DBLingWuXinFaName.Visible;
    DBXinFaNameNext.Visible := btPage = 0;
    DBXinFaNamePrev.Visible := btPage = 0;
    DLHelpXinfa.Visible := btPage = 1;
    DLLingwuZhaoshi.Visible := btPage = 1;
    if btPage = 1 then btHelpPage := 0;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLLingWUXinFaInitialize(Sender: TObject);
begin
  with Sender as TAspDLabel do
    SetImgIndex(g_WUI1Images, 2144);
end;

procedure TFrmDlg.DLLingWuXinFaKeyChangeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    if sKeySelCaption <> '' then
      sKeySelCaption := Copy(sKeySelCaption, 1, Length(sKeySelCaption)-2);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLLingWuXinFaKeyOKClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWuXinFaKey.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DLLingWuXinFaKeyPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    if Sender = DLLingWuXinFaKeyPrev then begin
      if btKeyPage > 0 then Dec (btKeyPage);
    end else begin
      if btKeyPage < 2 then
         Inc (btKeyPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLLingWuXinFaKeyPrevInitialize(Sender: TObject);
begin
  with Sender as TAspDLabel do
    SetImgIndex(g_WUI1Images, 2324);
end;

procedure TFrmDlg.DBotMemoDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  {$IF M2Version = 2}//1.76
  if FrmDlg.DBotMemo.Visible then begin
    with Sender as TAspDButton do begin
      if WLib <> nil then begin //20080701
        if TAspDButton(Sender).Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           d := WLib.Images[307];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft-4), SurfaceY(GTop-2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
  {$ELSE}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if TAspDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWWStallPriceDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  str: string;
begin
  with DWWStallPrice do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFont.TextOut(SurfaceX(GLeft)+35, SurfaceY(GTop)+59, clLime, g_UseShopItem.Item.ClientItem.S.Name);
    AspTextureFont.TextOut(SurfaceX(GLeft)+123, SurfaceY(GTop)+59, $008CC7EF, '金额范围');
    if DBWStallPriceTab2.Tag = 0 then begin
      str := Format(' 150,000,000 %s',[g_sGoldName]);
    end else begin
      str := Format(' 8,000,000 %s',[g_sGameGoldName]);
    end;
    AspTextureFont.TextOut(SurfaceX(GLeft)+177, SurfaceY(GTop)+59, $008CC7EF, str);
    AspTextureFont.TextOut(SurfaceX(GLeft)+35, SurfaceY(GTop)+79, $008CC7EF, '输入物品价格：');
  end;
end;

procedure TFrmDlg.DBWStallPriceTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if TAspDButton(Sender).Tag = 0 then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop) - 2, d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 50 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 1, $008CC7EF, clBlack, Hint);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 50 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, $007396B5, clBlack, Hint);
    end;
  end;
end;

procedure TFrmDlg.DBWStallPriceTab1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DBWStallPriceTab1 then begin
    DBWStallPriceTab1.Tag := 0;
    DBWStallPriceTab2.Tag := 1;
    DEdtWStallPrice.MaxLength := 7;
  end else begin
    DBWStallPriceTab1.Tag := 1;
    DBWStallPriceTab2.Tag := 0;
    DEdtWStallPrice.MaxLength := 9;
  end;
  DEdtWStallPrice.Text := '';
end;

procedure TFrmDlg.DBotStallClick(Sender: TObject; X, Y: Integer);
begin
  if DWStall.Visible then begin
    DItemBag.Visible := False;
  end else begin
    if not g_MySelf.m_boIsShop then begin
      DItemBag.GLeft := 380;
      DItemBag.GTop := 90;
      DItemBag.Visible := True;
    end;
    DEdtStallName.Text := Format('[%s]的商店',[g_MySelf.m_sUserName]);
  end;
  DWStall.Visible := not DWStall.Visible;
end;

procedure TFrmDlg.DGStallGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TAspDGridDrawState; dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DGStall.ColCount;
  if idx in [0..9] then begin
    if g_ShopItems[idx].Item.ClientItem.S.Name <> '' then begin
      d := FrmMain.GetBagItemImg(g_ShopItems[idx].Item.ClientItem.S.Looks);
      if d <> nil then begin
        with DGStall do begin
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2),
            d.ClientRect,
            d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGStallGridSelect(Sender: TObject; ACol, ARow: Integer;
  Shift: TShiftState);
var
  idx, mi: integer;
begin
  if g_MySelf.m_boIsShop then Exit;
  if DBotStall.Visible then begin
    idx := ACol + ARow * DGStall.ColCount;
    if idx in [0..9] then begin
      if not g_boItemMoving then begin
        if g_ShopItems[idx].Item.ClientItem.S.Name <> '' then begin
          g_boItemMoving := TRUE;
          g_MovingItem.Index := -(72+idx);
          g_MovingItem.Item := g_ShopItems[idx].Item;
          //g_MovingItem.Hero := False;
          g_ShopItems[idx].Item.ClientItem.S.Name := '';
          ItemClickSound(g_ShopItems[idx].Item.ClientItem.S);
        end;
      end else begin
        mi := g_MovingItem.Index;
        if (mi = -97) or (mi = -98) then Exit; //金币...
        if (mi <= -72) and (mi > -81) then begin
          g_UseShopItem.Item := g_MovingItem.Item;
          AddShopItem(g_UseShopItem);
          CancelItemMoving;
        end else begin
          if GetShopItemRoom then begin
            g_UseShopItem.Item := g_MovingItem.Item;
            CancelItemMoving;
            if DBWStallPriceTab2.Tag = 0 then begin //元宝
              DEdtWStallPrice.MaxLength := 7;
            end else begin
              DEdtWStallPrice.MaxLength := 9;
            end;
            DEdtWStallPrice.Text := '';
            DEdtWStallPrice.SetFocus;
            DWWStallPrice.Show;
          end else begin
            DMessageDlg ('摊位物品已满，无法继续添加物品！', [mbOk]);
          end;
        end;
      end;
    end;
  end;
  //ArrangeItemBag;
end;

procedure TFrmDlg.DBStallCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWStall.Visible := False;
end;

procedure TFrmDlg.DBWStallPriceCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWWStallPrice.Visible := False;
end;

procedure TFrmDlg.DBWStallPriceOKClick(Sender: TObject; X, Y: Integer);
var
  nPic: Integer;
begin
  if DEdtWStallPrice.Text <> '' then begin
    nPic := Str_ToInt(DEdtWStallPrice.Text, 0);
    if DBWStallPriceTab1.Tag = 0 then begin //元宝
      if (nPic > 8000000) or (nPic < 1) then begin
        DMessageDlg ('输入'+g_sGameGoldName+'价格错误，请输入一个在 1~8,000,000 之间的数字！', [mbOk]);
        DEdtWStallPrice.Text := '8000000';
        Exit;
      end;
    end else begin  //金币
      if (nPic > 150000000) or (nPic < 1) then begin
        DMessageDlg ('输入'+g_sGoldName+'价格错误，请输入一个在 1~150,000,000 之间的数字！', [mbOk]);
        DEdtWStallPrice.Text := '150000000';
        Exit;
      end;
    end;
    g_UseShopItem.nPic := Str_ToInt(DEdtWStallPrice.Text, 0);
    g_UseShopItem.boCls := DBWStallPriceTab1.Tag = 0;
    AddShopItem(g_UseShopItem);
    AddItemBagLock(g_UseShopItem.Item.ClientItem);
    DWWStallPrice.Visible := False;
    FillChar (g_UseShopItem, SizeOf(TClientEffecItem), #0);
  end;
end;

procedure TFrmDlg.DBtnStallStartClick(Sender: TObject; X, Y: Integer);
  function ShopItemExists(): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I:= Low(g_ShopItems) to High(g_ShopItems) do begin
      if g_ShopItems[I].Item.ClientItem.S.Name <> '' then begin
        Result := True;
        Break;
      end;
    end;
  end;
var
  btDir: Byte;
begin
  if g_MySelf.m_boIsShop then Exit;
  if DBotStall.Visible then begin
    if GetTickCount > DlgShopTime then begin
      if ShopItemExists then begin
        btDir := g_MySelf.m_btDir;
        if (g_MySelf.m_nState and $04000000 = 0){非麻痹}and (g_MySelf.m_nState and $1000000 = 0){非冰冻} then begin
          if btDir in [0, 2, 4, 6] then begin
            Inc(btDir);
            if frmMain.CanNextAction and frmMain.ServerAcceptNextAction then begin
              g_MySelf.SendMsg (CM_TURN, g_MySelf.m_nCurrX, g_MySelf.m_nCurrY, btDir, 0, 0, '', 0, g_nilFeature);
            end;
          end;
          FrmMain.SendShopItems(DEdtStallName.Text);
          DlgShopTime := GetTickCount + 5000;
        end else begin
          DScreen.AddChatBoardString('麻痹中不允许摆摊！',  clWhite, clRed);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBtnStallStopClick(Sender: TObject; X, Y: Integer);
var
  i: integer;
begin
  try //程序自动增加
    for I := Low(g_ShopItems) to High(g_ShopItems) do begin
      if g_ShopItems[i].Item.ClientItem.S.Name <> '' then DelItemBagLock(g_ShopItems[i].Item.ClientItem);
    end;
    ArrangeItemBag;
    FillChar(g_ShopItems, Sizeof(TShopItem) * 10, #0);
    //DSelfShop.Visible := False;
    if g_MySelf.m_boIsShop then FrmMain.SendCloseShopItems;
    DWStall.Visible := False;
  except //程序自动增加
    DebugOutStr('[Exception] TFrmDlg.DShopCloseClick'); //程序自动增加
  end; //程序自动增加
end;

procedure TFrmDlg.DGStallGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  sGold: string;
begin
  DScreen.ClearHint;
  iname := '';
  sGold := '';
  idx := ACol + ARow * DGStall.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_ShopItems[idx].Item;
    GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
    g_MouseItem.ClientItem.S.Name := '';
    if iname <> '' then begin
      with DGStall do begin
        if g_ShopItems[idx].boCls then begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_ShopItems[idx].nPic), g_sGameGoldName]);
        end else begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_ShopItems[idx].nPic), g_sGoldName]);
        end;
        DScreen.ShowSpecialHint(SurfaceX(GLeft+(ACol)*ColWidth),
                                SurfaceY(GTop+(ARow+1)*RowHeight),
                                Format('<%s/c=$000075EA fontsize=12 fontstyle=bold><%s/c=Red fontsize=12 fontstyle=bold>\ \%s\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Lime>',
                                [iname, iname1, d1, d2, d3, d4, d5, d6, d7, sGold]), False);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGUserStallGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TAspDGridDrawState;
  dsurface: TAsphyreCanvas);
var
  idx: integer;
  d: TAsphyreLockableTexture;
begin
  idx := ACol + ARow * DGUserStall.ColCount;
  if idx in [0..9] then begin
    if g_UserShopItem[idx].Item.ClientItem.S.Name <> '' then begin
      d := FrmMain.GetBagItemImg(g_UserShopItem[idx].Item.ClientItem.S.Looks);
      if d <> nil then begin
        with DGUserStall do begin
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2),
            d.ClientRect,
            d, TRUE);
          if g_btShopIdx = idx then begin
            dsurface.FillRectAlpha(Bounds(SurfaceX(Rect.Left), SurfaceY(Rect.Top), 34, 32), $00004000, 120);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGUserStallGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  sGold: string;
begin
  DScreen.ClearHint;
  iname := '';
  sGold := '';
  idx := ACol + ARow * DGUserStall.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_UserShopItem[idx].Item;
    GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
    g_MouseItem.ClientItem.S.Name := '';
    if iname <> '' then begin
      with DGUserStall do begin
        if g_UserShopItem[idx].boCls then begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_UserShopItem[idx].nPic), g_sGameGoldName]);
        end else begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_UserShopItem[idx].nPic), g_sGoldName]);
        end;
        DScreen.ShowSpecialHint(SurfaceX(GLeft+(ACol)*ColWidth),
                                SurfaceY(GTop+(ARow+1)*RowHeight),
                                Format('<%s/c=$000075EA fontsize=12 fontstyle=bold><%s/c=Red fontsize=12 fontstyle=bold>\ \%s\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Lime>',
                                [iname, iname1, d1, d2, d3, d4, d5, d6, d7, sGold]), False);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWUserStall.Visible := False;
end;

procedure TFrmDlg.DWUserStallDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with DWUserStall do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_sShopName <> '' then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+29, SurfaceY(GTop)+35, clWhite, clBlack, g_sShopName);
    end;
  end;
end;

procedure TFrmDlg.DWStallMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWUserStallMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DGUserStallGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
begin
  idx := ACol + ARow * DGUserStall.ColCount;
  if idx in [0..9] then begin
    if g_UserShopItem[idx].Item.ClientItem.S.Name <> '' then begin
      g_btShopIdx := idx;
    end;
  end;
end;

procedure TFrmDlg.DBBuyUserStallItemClick(Sender: TObject; X, Y: Integer);
var
  sGold: string;
begin
  if g_btShopIdx in [0..9] then begin
    if g_UserShopItem[g_btShopIdx].Item.ClientItem.S.Name <> '' then begin
      if g_UserShopItem[g_btShopIdx].boCls then begin
        sGold := g_sGameGoldName;
      end else begin
        sGold := g_sGoldName;
      end;
      if mrOk = FrmDlg.DMessageDlg (Format('你将以 %s %s购买 %s，确定吗？',[GetGoldStr(g_UserShopItem[g_btShopIdx].nPic), sGold, g_UserShopItem[g_btShopIdx].Item.ClientItem.S.Name]), [mbOk, mbCancel]) then begin
        if g_SelfShopItem.ClientItem.S.Name = '' then begin
          g_SelfShopItem := g_UserShopItem[g_btShopIdx].Item;
          FrmMain.SendSelfShopBuy(g_nShopActorIdx, g_nShopX, g_nShopY,
            g_UserShopItem[g_btShopIdx].Item.ClientItem.MakeIndex);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWMiniMapDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  mx, my, nx, ny, i: Integer;
  rc: TRect;
  actor: TActor;
  btColor: TColor;
  Automx,Automy: Integer; //自动寻路 20080617
  MapDesc: pMapDesc; //小地图注释格式
begin
  if GetTickCount > m_dwBlinkTime + 300 then begin  //当前玩家在小地图上的位置，每300毫秒闪一次
    m_dwBlinkTime := GetTickCount;
    m_boViewBlink := not m_boViewBlink;
  end;
  if g_nMiniMapIndex < 0 then exit;
  if GetMiniMapNum(g_nMiniMapIndex) <> nil then  //新小地图
    d:= GetMiniMapNum(g_nMiniMapIndex)
  else
    d := g_WMMapImages.Images[g_nMiniMapIndex];
  if d = nil then Exit;
  mx := (g_MySelf.m_nCurrX*48) div 32;
  my := (g_MySelf.m_nCurrY*32) div 32;
  rc.Left := _MAX(0, mx-60);
  rc.Top := _MAX(0, my-60);
  rc.Right := _MIN(d.ClientRect.Right, rc.Left + 120);
  rc.Bottom := _MIN(d.ClientRect.Bottom, rc.Top + 120);
  if g_nViewMinMapLv = 1 then begin
    if not g_boTransparentMiniMap then
      dsurface.Draw ((g_D3DConfig.wScreenWidth-120), 0, rc, d, FALSE)
    else begin
      dsurface.DrawAlpha(g_D3DConfig.wScreenWidth-120, 0, rc, d, 150);
    end;
    if g_boShowMimiMapDesc or ((g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0)) then begin
      for I:=0 to g_MapDescList.Count -1 do begin
        if pMapDesc(g_MapDescList[I]) <> nil then begin
          MapDesc := pMapDesc(g_MapDescList[I]);
          if (MapDesc.sMapName = g_sMapTitle) and not MapDesc.boMaxMap then begin
            if (680 + (MapDesc.m_nMapX * 48) div 32 - rc.Left >= 680){左} and ((MapDesc.m_nMapY * 32) div 32 - rc.Top >= 0){上} and ((MapDesc.m_nMapY * 32) div 32 - rc.Top <= 120){下} and (680 + (MapDesc.m_nMapX * 48) div 32 - rc.Left <= 800){右} then begin
                AspTextureFont.BoldTextOut ((g_D3DConfig.wScreenWidth-121) + (MapDesc.m_nMapX * 48) div 32 - rc.Left - AspTextureFont.TextWidth(MapDesc.sMainMapName) div 2
                  , (MapDesc.m_nMapY * 32) div 32 - rc.Top - 7, MapDesc.btColor, clBlack,MapDesc.sMainMapName);
            end;
          end;
        end;
      end;
    end;
    if (g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0) then
      AspTextureFont.BoldTextOut (DWMiniMap.GLeft + 120 - AspTextureFont.TextWidth(IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY))
        , DWMiniMap.GTop + 108, clWhite, clBlack,IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY));
    //小地图画自动寻路路径 20080617
    if LegendMap.StartFind then begin
      for I := 0 to Length(LegendMap.Path) - 1 do begin
        Automx := (g_D3DConfig.wScreenWidth-120) + (LegendMap.Path[I].X * 48) div 32 - rc.Left;
        AutomY := (LegendMap.Path[I].Y * 32) div 32 - rc.Top;
        dsurface.PutPixel(Point2(Automx, Automy), cColor1(clYellow));
      end;
    end;
  //雷达
  if m_boViewBlink then begin
    mx := (g_D3DConfig.wScreenWidth-120) + (g_MySelf.m_nCurrX * 48) div 32 - rc.Left;
    my := (g_MySelf.m_nCurrY * 32) div 32 - rc.Top;
    dsurface.FillRect(Bounds(mx - 2, my - 2, 3, 3), GetRGB(255));
  end;
  for nx:=g_MySelf.m_nCurrX - 10  to g_MySelf.m_nCurrX + 10 do begin
    for ny:=g_MySelf.m_nCurrY - 10 to g_MySelf.m_nCurrY + 10 do begin
      actor := PlayScene.FindActorXY(nx,ny);
      if (actor <> nil) and (actor <> g_MySelf) and (not actor.m_boDeath) then begin
        mx := (g_D3DConfig.wScreenWidth-120) + (actor.m_nCurrX * 48) div 32 - rc.Left;
        my := (actor.m_nCurrY * 32) div 32 - rc.Top;
        case actor.m_btRace of    //
          50,12: btColor:=215;
          0,150: btColor:=251;
          else btColor:=249;
        end;    // case
        if (actor.m_btRace= 1) then btColor := actor.m_btMiniMapHeroColor;
        dsurface.FillRect(Bounds(mx, my, 3, 3), GetRGB(btColor));
      end;
    end;
  end;
  end else begin
    if (d <> nil) and (d.Width <> 0) and (d.Height <> 0)then begin
      if not g_boTransparentMiniMap then
        dsurface.StretchDraw(Bounds(g_D3DConfig.wScreenWidth-200, 0, 200, 200), d.ClientRect, d, False)
      else dsurface.StretchDrawAlpha(Bounds(g_D3DConfig.wScreenWidth-200, 0, 200, 200), d.ClientRect, d, 150,False);
      rc := d.ClientRect;
      mx := UpInt((295 / d.Width) * g_MySelf.m_nCurrX) + g_D3DConfig.wScreenWidth - 200;
      my := UpInt((198 / d.Height) * g_MySelf.m_nCurrY);
    end;
    if g_boShowMimiMapDesc or ((g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0)) then begin
      for I:=0 to g_MapDescList.Count -1 do begin
        if pMapDesc(g_MapDescList[I]) <> nil then begin
          MapDesc := pMapDesc(g_MapDescList[I]);
          if (MapDesc.sMapName = g_sMapTitle) and MapDesc.boMaxMap then begin
              AspTextureFont.BoldTextOut (UpInt((295 / d.Width) * MapDesc.m_nMapX) + (g_D3DConfig.wScreenWidth - 200) - AspTextureFont.TextWidth(MapDesc.sMainMapName) div 2
                , UpInt((198 / d.Height) * MapDesc.m_nMapY), MapDesc.btColor, clBlack,MapDesc.sMainMapName);
          end;
        end;
      end;
    end;
    if (g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0) then
      AspTextureFont.BoldTextOut (DWMiniMap.GLeft + 200 - AspTextureFont.TextWidth(IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY))
        , DWMiniMap.GTop + 188, clWhite, clBlack,IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY));
    //大地图画自动寻路路径 20080617
    if LegendMap.StartFind then begin
      for I := 0 to Length(LegendMap.Path) - 1 do begin
        Automx := UpInt((295 / d.Width) * LegendMap.Path[I].X) + g_D3DConfig.wScreenWidth - 200;
        Automy := UpInt((198 / d.Height) * LegendMap.Path[I].Y);
        dsurface.PutPixel(Point2(Automx, Automy), cColor1(clYellow));
      end;
    end;
    if m_boViewBlink then dsurface.FillRect(Bounds(mx, my, 3, 3), GetRGB(255));
  end;    
end;

procedure TFrmDlg.DWMiniMapMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if ssLeft in Shift then begin
    if g_boViewMiniMap then begin
      if g_nViewMinMapLv >= 2 then begin
         g_nViewMinMapLv:=1;
         DWMiniMap.GLeft := g_D3DConfig.wScreenWidth - 120; //20080323
         DWMiniMap.GWidth := 120; //20080323
         DWMiniMap.GHeight:= 120; //20080323
      end else begin
        Inc(g_nViewMinMapLv);
        DWMiniMap.GLeft := g_D3DConfig.wScreenWidth - 200; //20080323
        DWMiniMap.GWidth := 200; //20080323
        DWMiniMap.GHeight:= 200; //20080323
      end;
    end;
  end;
  if Button = mbRight then begin
    g_boTransparentMiniMap := not g_boTransparentMiniMap;
  end;
end;

procedure TFrmDlg.DWMiniMapMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  d: TAsphyreLockableTexture;
  rc: TRect;
  nx, ny: Integer;
begin
  try
  if GetMiniMapNum(g_nMiniMapIndex) <> nil then  //新小地图
    d:= GetMiniMapNum(g_nMiniMapIndex)
  else
    d := g_WMMapImages.Images[g_nMiniMapIndex];
    if d <> nil then begin
      rc := d.ClientRect;
      if g_nViewMinMapLv = 1 then begin
        if x < 60 then nx := -(60-x) else nx:= x-60;
        g_nMouseMinMapX := (g_MySelf.m_nCurrX * 32) div 32 - rc.Left + nx - (g_D3DConfig.wScreenWidth - 120);
        if y < 60 then ny := -(60-y) else ny:= y-60;
        g_nMouseMinMapY := (g_MySelf.m_nCurrY * 32) div 32 - rc.Top + ny;
      end else
        if g_nViewMinMapLv = 2 then begin
          g_nMouseMinMapX := _MAX(0, Round((X - (g_D3DConfig.wScreenWidth - 200)) * d.Width / 295));  //全景 坐标对的
          g_nMouseMinMapY := Round(Y * d.Height / 198);
        end;
    end;
  except
    DebugOutStr ('MiniMapMouseMove');
  end;
end;

procedure TFrmDlg.ClientGetMissionSay(nParam: Integer; Text: string);
var
  I: Integer;
  nPos: Integer;
  DMemo: TAspDTreeView;
  TextList: TStringList;
  sText, sCmd: string;
  TreeNode: TDTreeNode;
  ChildTreeNode: TDTreeNode;
  function NewNpcLabel(ACaption, ACmd: string; Up, Hot, Down: TColor; Style: TFontStyles): TDTreeNode;
  var
    DLabel: TMissionLabel;
  begin
    DLabel := TMissionLabel.Create;
    DLabel.Caption := ACaption;
    DLabel.CaptionColor.Up.Color := Up;
    DLabel.CaptionColor.Hot.Color := Hot;
    DLabel.CaptionColor.Down.Color := Down;
    DLabel.CaptionColor.Up.Style := Style;
    DLabel.CaptionColor.Hot.Style := Style;
    DLabel.CaptionColor.Down.Style := Style;
    DLabel.m_sCmd := ACmd;
    Result := DLabel;
  end;

begin
//  DScreen.AddChatBoardString(Text, clYellow, clRed);
  if Text <> '' then begin
    if nParam = 0 then begin
      DMemo := DTreeViewMission1;
      DMemo.Clear;

      TextList := TStringList.Create;
      ExtractStrings(['\'], [' '], PChar(Text), TextList);

      for I := TextList.Count - 1 downto 0 do begin
        TextList[I] := Trim(TextList[I]);
        if TextList[I] = '' then begin
          TextList.Delete(I);
        end;
      end;

      TreeNode := nil;
      ChildTreeNode := nil;

      for I := 0 to TextList.Count - 1 do begin
        sText := TextList[I];
        sText := Trim(sText);
        if sText[1] = '<' then sText := Copy(sText, 2, Length(sText) - 1);
        if sText[Length(sText)] = '>' then sText := Copy(sText, 1, Length(sText) - 1);
        sCmd := '';
        nPos := Pos('/@', sText);
        if nPos > 0 then begin
          sCmd := Copy(sText, nPos + 1, Length(sText) - nPos);
          sText := Copy(sText, 1, nPos - 1);
        end;

        if sCmd <> '' then begin
          if TreeNode = nil then begin
            TreeNode := NewNpcLabel('', '', clWhite, clYellow, clRed, []);
            DMemo.Add(TreeNode);
          end;
          ChildTreeNode := NewNpcLabel(sText, sCmd, clWhite, clYellow, clRed, []);
          TreeNode.Add(ChildTreeNode);
        end else begin
          TreeNode := NewNpcLabel(sText, sCmd, clWhite, clYellow, clRed, []);
          DMemo.Add(TreeNode);
        end;
      end;
      if DMemo.Count > 0 then begin
        DMemo.Items[0].Expand := True;
      end;
      TextList.Free;
    end else begin
      sText := Text;
      sCmd := '';
      DMemoMissionBottom.Lines.Clear;
      while TRUE do begin
         if sText = '' then break;   //为空了则退出循环
         sText := GetValidStr3 (sText, sCmd, ['\']); //获取内容
         if sCmd <> '' then DMemoMissionBottom.Lines.Add(sCmd);
      end;

      if MissionBottomPoints.Count > 0 then //20080629
      for i:=0 to MissionBottomPoints.Count-1 do
        Dispose (pTClickPoint (MissionBottomPoints[i]));
      MissionBottomPoints.Clear;
      MissionBottomAddPoints := True;
    end;
  end;
end;

procedure TFrmDlg.DTreeViewMission1Select(Sender: TObject; TreeNode: TDTreeNode);
begin
  PlaySound(s_glass_button_click);
  if CompareText(TMissionLabel(TreeNode).m_sCmd, '@EXIT') = 0 then begin
    DWMission.Visible := False;
  end else begin
    if TMissionLabel(TreeNode).m_sCmd <> '' then
      SendMissionSelect (TMissionLabel(TreeNode).m_sCmd);
  end;
end;

procedure TFrmDlg.DMemoMissionBottomDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  data, fdata, cmdstr, cmdparam: string;
  sx: integer;
  pcp: PTClickPoint;
  Color: TColor;
  sColor, cmdtitle, sTemp: string;
begin
  with DMemoMissionBottom do begin
    ElemCount:= (GHeight - 2) div LinesHeight;  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for I:= 0 to ElemCount - 1 do begin
      sx := 0;
      fdata := '';
      data := Lines.Strings[I+TopIndex];
      while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin  //如果是连接
        if data[1] <> '<' then begin
          data := '<' + GetValidStr3 (data, fdata, ['<']);
        end;
        data := ArrestStringEx (data, '<', '>', cmdstr);//得到"<"和">" 号之间的字   赋予给 cmdstr
        if cmdstr <> '' then begin
          cmdparam := GetValidStr3 (cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
        end;
        if fdata <> '' then begin
          AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, fdata);
          sx := sx + AspTextureFont.TextWidth(fdata);
        end;
        if (cmdstr <> '') then begin
          if CompareLStr(cmdparam, 'FCOLOR=', length('FCOLOR=')) then begin
            sColor := GetValidStr3(cmdparam, sTemp, ['=']);
            Color := GetRGB(Lobyte(Str_ToInt(sColor, 255)));
            AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), Color, clBlack, cmdstr)  //显示颜色文字
          end else begin
            if MissionBottomAddPoints and (cmdparam <> '') then begin
              cmdtitle := '';
              if Pos('|', cmdparam) > 0 then begin
                sTemp := GetValidStr3(cmdparam, sTemp, ['|']);
                if CompareLStr(sTemp, 'TITLE=', length('TITLE=')) then begin
                  cmdtitle := GetValidStr3(sTemp, sTemp, ['=']);
                end;
              end;
              new (pcp);
              pcp.rc := Rect (sx, I*LinesHeight, sx + AspTextureFont.TextWidth(cmdstr), I*LinesHeight + 14);
              pcp.RStr := cmdparam;
              pcp.TStr := cmdtitle;
              MissionBottomPoints.Add (pcp);
            end;
            if (MissionMoveedBottomStr = cmdparam) then begin
              AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), GetRGB(223), clBlack, cmdstr, [fsUnderline]);
            end else AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clYellow, clBlack, cmdstr, [fsUnderline]);
          end;
          sx := sx + AspTextureFont.TextWidth(cmdstr);
        end;
      end;
      if data <> '' then
         AspTextureFont.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, data);
    end;
    MissionBottomAddPoints := False;
  end;
end;

procedure TFrmDlg.DMemoMissionBottomMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
  MissionMoveedBottomStr := '1';
  L := DMemoMissionBottom.GLeft;
  T := DMemoMissionBottom.GTop;
  with DMemoMissionBottom do begin
    if MissionBottomPoints.Count > 0 then  begin//20080629
      for i:=0 to MissionBottomPoints.Count-1 do begin
        p := PTClickPoint (MissionBottomPoints[i]);
        if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          MissionMoveedBottomStr := p.RStr;
          break;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DMemoMissionBottomClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  sData: string;
begin
  L := DMemoMissionBottom.GLeft;
  T := DMemoMissionBottom.GTop;
  with DMemoMissionBottom do begin
    if MissionBottomPoints.Count > 0 then //20080629
    for i:=0 to MissionBottomPoints.Count-1 do begin
       p := PTClickPoint (MissionBottomPoints[i]);
       if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          if DMerchantDlgSelect(p.RStr, p.TStr, sData) then SendMissionSelect(sData);
          //LastestClickTime := GetTickCount + 2000; //20080803修改 以前为5000
          break;
       end;
    end;
  end;
end;

procedure TFrmDlg.SendMissionSelect(rstr: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg (aa(CM_CLICKMMISSION, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg) + EncodeString (rstr));
end;

procedure TFrmDlg.DMemoMissionBottomScrollBarChange(Sender: TObject);
var
  I: Integer;
begin
  if MissionBottomPoints.Count > 0 then //20080629
  for i:=0 to MissionBottomPoints.Count-1 do
    Dispose (pTClickPoint (MissionBottomPoints[i]));
  MissionBottomPoints.Clear;
  MissionBottomAddPoints := True;
end;

procedure TFrmDlg.DBMissionCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWMission.Visible := False;
end;

procedure TFrmDlg.DBMission1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  d := nil;
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if TAspDButton(Sender).Tag <> m_btMissionPage then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 28 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 4, clWhite, clBlack, Hint);
  end;
end;

procedure TFrmDlg.DBMission1Click(Sender: TObject; X, Y: Integer);
begin
  if m_btMissionPage <> TAspDButton(Sender).Tag then begin
    m_btMissionPage := TAspDButton(Sender).Tag;
    MissionPageChanged();
  end;
end;

procedure TFrmDlg.MissionPageChanged;
var
  msg: TDefaultMessage;
  StrSel: string;
begin
  case m_btMissionPage of
    0: begin
      {DTreeViewMission1.Visible := True; DScrollBarMission1.Visible := True;
      DTreeViewMission2.Visible := False; DScrollBarMission2.Visible := False;
      DTreeViewMission3.Visible := False; DScrollBarMission3.Visible := False;    }
     // if DTreeViewMission1.Count = 0 then Exit;
      StrSel := '@主线任务';
    end;
    1: begin
      {DTreeViewMission1.Visible := False; DScrollBarMission1.Visible := False;
      DTreeViewMission2.Visible := True; DScrollBarMission2.Visible := True;
      DTreeViewMission3.Visible := False; DScrollBarMission3.Visible := False;    }
     // if DTreeViewMission2.Count = 0 then Exit;
      StrSel := '@支线任务';
    end;
    2: begin
      {DTreeViewMission1.Visible := False; DScrollBarMission1.Visible := False;
      DTreeViewMission2.Visible := False; DScrollBarMission2.Visible := False;
      DTreeViewMission3.Visible := True; DScrollBarMission3.Visible := True;  }
     // if DTreeViewMission3.Count = 0 then Exit;
      StrSel := '@操作指南';
    end;
    else begin
      {DTreeViewMission1.Visible := False; DScrollBarMission1.Visible := False;
      DTreeViewMission2.Visible := False; DScrollBarMission2.Visible := False;
      DTreeViewMission3.Visible := False; DScrollBarMission3.Visible := False;    }
      StrSel := '';
    end;
  end;

  if StrSel <> '' then begin
    msg := MakeDefaultMsg(aa(CM_CLICKMMISSION, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg) + EncodeString(StrSel));
  end;
end;
procedure TFrmDlg.DBMissionClick(Sender: TObject; X, Y: Integer);
begin
  DWMission.Visible := not DWMission.Visible;
  if DWMission.Visible then begin
    if m_boMissionEff then m_boMissionEff := False;
    MissionPageChanged();
  end;
end;

procedure TFrmDlg.DBMissionDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if TAspDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TAspDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;


    if WLib <> nil then begin //20080701
      if TAspDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TAspDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else begin
        if m_boMissionEff then begin
          if GetTickCount - m_dwMissionEffTick > 180 then begin
            m_dwMissionEffTick := GetTickCount;
            Inc(m_btMissionEffImg);
            if m_btMissionEffImg > 1 then m_btMissionEffImg := 0;
          end;
          d := WLib.Images[FaceIndex+m_btMissionEffImg];
        end else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBMissionClose1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 4, $0048A4E8, clBlack, Hint);
    end else begin
      if MouseMoveing then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, $00A8D4E8, clBlack, Hint);
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, $0088C4E8, clBlack, Hint);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWSkillMemoDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  {$IF M2Version <> 2}
  with DWSkillMemo do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFonts.SetFont(g_sCurFontName, 15);
    AspTextureFont.BoldTextOut(SurfaceX(GLeft)+64, SurfaceY(GTop)+10, $00A8D4E8, clBlack, SkillMemoName, [fsBold]);
    AspTextureFonts.SetFont(g_sCurFontName, 9);
    if SkillMemoId = 100 then begin //神秘解读
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+53, $0088C4E8, clBlack, g_MySelf.m_sUserName, [fsBold]);
      d := g_WUI1Images.Images[920];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft) + 30, SurfaceY(GTop) + 152, d.ClientRect, d, True);
      end;
      d := g_WUI1Images.Images[921];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft) + 30, SurfaceY(GTop) + 170, d.ClientRect, d, True);
      end;
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 152, $008CC7EF, clBlack, IntToStr(SkillMemoLevel), [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 170, $008CC7EF, clBlack, Format('%d/999', [g_nProficiency]), [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 228, clWhite, clBlack, '神秘解读：学习后用来制作相应等');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 243, clWhite, clBlack, '级的神秘卷轴。在寻宝的过程中来');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 258, clWhite, clBlack, '提升技能等级。随着技能提升人物');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 273, clWhite, clBlack, '的血量也将会有一定的提升。');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 289, clWhite, clBlack, '熟练度：制作神秘卷轴可以提升您');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 303, clWhite, clBlack, '的熟练度，熟练度的增加相应解读');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 23, SurfaceY(GTop) + 318, clWhite, clBlack, '卷轴的成功率也会越高。');
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+53, $0088C4E8, clBlack, g_MySelf.m_sUserName, [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 131, $0088C4E8, clBlack, SkillMemoName, [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 149, $0088C4E8, clBlack, '0', [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 185, $0088C4E8, clBlack, '0/300', [fsBold]);

      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 131, clSilver, clBlack, '当前技能：');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 149, clSilver, clBlack, '当前等级：');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 167, clSilver, clBlack, '（升级到下一级血量增加）');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 185, clSilver, clBlack, '当前经验：');
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 203, clSilver, clBlack, Format('（1 %s = 1 技能经验）', [g_sGameGird]));
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSkillMemoIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  wm: TAspWMImages;
begin
  {$IF M2Version <> 2}
  with DBSkillMemoIcon do begin
    wm := GetMagicIcon(SkillMemoEffect, 0, SkillMemoId, 0, SkillMemoIcon);
    if wm <> nil then begin
      if not Downed then begin
        d := wm.Images[SkillMemoIcon];
      end else begin
        d := wm.Images[SkillMemoIcon + 1];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSkillMemoCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWSkillMemo.Visible := False;
end;

procedure TFrmDlg.DBHeroSkillMemoCloseClick(Sender: TObject; X,
  Y: Integer);
begin
  DWHeroSkillMemo.Visible := False;
end;

procedure TFrmDlg.DBJDSeeDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  with TAspDButton(Sender) do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 2];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2 + 1, SurfaceY(GTop) + 4, $0048A4E8, clBlack, Hint);
      end else begin
        if MouseMoveing then begin
          d := WLib.Images[FaceIndex + 1];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, $00A8D4E8, clBlack, Hint);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, $0088C4E8, clBlack, Hint);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBJDSeeClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
  pm: PTClientMagic;
begin
  {$IF M2Version <> 2}
  if g_MagicList.Count > 0 then begin
    for I:=0 to g_MagicList.Count - 1 do begin
      pm := PTClientMagic (g_MagicList[I]);
      if pm.Def.wMagicId = 100 then begin //神秘解读
        SetSkillMemoDlg(100, pm.Level, pm.Def.btEffect, pm.Def.sMagicName, '神秘解读');
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBJDSeeMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  with TAspDButton(Sender) do begin
    if Sender = DBJDSee then begin
      DScreen.ShowHint(SurfaceX(GLeft) - 50, SurfaceY(GTop)+ 10, '点击可以查看神秘解\读的熟练度', clYellow, FALSE);
    end else if Sender = DBHeroQSSSee then begin
      DScreen.ShowHint(SurfaceX(GLeft) - 50, SurfaceY(GTop)+ 10, '点击可以修炼强身术', clYellow, FALSE);
    end;
  end;
end;
{$IF M2Version <> 2}
procedure TFrmDlg.SetSkillMemoDlg(MagID, MagLevel: Word; Effect: Byte; magname, magTitle: string);
var
  msg: TDefaultMessage;
begin
  if (MagID = 100) and not DWSkillMemo.Visible then begin //神秘解读
    msg := MakeDefaultMsg (aa(CM_OPENQUERYPROFICIENCY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket(EncodeMessage (msg));
  end;
  SkillMemoID := MagID;
  SkillMemoLevel := MagLevel; 
  SkillMemoEffect := Effect;
  SkillMemoName := magname;
  SkillMemoTitle := magTitle;
  DBSkillMemoLink.Visible := SkillMemoId <> 100;
  DWSkillMemo.Visible := not DWSkillMemo.Visible;
end;

procedure TFrmDlg.SetHeroSkillMemoDlg(MagID: Word; Effect: Byte; magname, magTitle: string);
var
  I: Integer;
  pm: PTClientMagic;
begin
  HeroSkillMemoID := MagID;
  HeroSkillMemoEffect := Effect;
  HeroSkillMemoName := magname;
  HeroSkillMemoTitle := magTitle;
  if g_HeroSelf <> nil then begin
    HeroSkillMemoUserName := g_HeroSelf.m_sUserName;
  end;
  pm := nil;
  if g_HeroMagicList.Count > 0 then begin
    for I:=0 to g_HeroMagicList.Count - 1 do begin
      if pTClientMagic(g_HeroMagicList[i]).Def.wMagicId = HeroSkillMemoId then begin
        pm := g_HeroMagicList[i];
        Break;
      end;
    end;
  end;

  if pm <> nil then begin
    if (pm.Level < 99) then begin
      HeroSkillMemoAddHp := GetHeroSkillMemoAddHp(pm.Level);
    end else HeroSkillMemoAddHp := 0;
  end;
  DWHeroSkillMemo.Visible := not DWHeroSkillMemo.Visible;
end;
{$IFEND}

procedure TFrmDlg.DBHelpClick(Sender: TObject; X, Y: Integer);
var
  msg : TDefaultMessage;
begin
  if GetTickCount - g_dwHelpQMTick > 500 then begin
    g_dwHelpQMTick := GetTickCount();
    msg := MakeDefaultMsg (aa(CM_CLICKSIGHICON, frmMain.TempCertification), 0, 4, 0, 0, frmMain.m_nSendMsgCount);
    frmMain.SendSocket (EncodeMessage (msg)+ EncodeString('?'));
  end;
end;

procedure TFrmDlg.DBHelpDirectPaint(Sender: TObject; dsurface: TAsphyreCanvas);
var
   d: TAsphyreLockableTexture;
begin
  with Sender as TAspDButton do
  begin
    if WLib <> nil then begin //20080701
      if TAspDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TAspDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBHelpInitialize(Sender: TObject);
begin
  DBHelp.SetImgIndex(g_WMain2Images,495);
end;

procedure TFrmDlg.DBHeroPackageClick(Sender: TObject; X, Y: Integer);
begin
   if g_HeroSelf = nil then exit;
   DHeroItemBag.Visible := not DHeroItemBag.Visible;
   if DHeroItemBag.Visible then
   ArrangeHeroItemBag;
end;

procedure TFrmDlg.DBHeroPackageInitialize(Sender: TObject);
begin
  DBHeroPackage.SetImgIndex(g_qingqingImages,32);   //英雄包裹
end;

procedure TFrmDlg.DBHeroQSSSeeClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  SetHeroSkillMemoDlg(99, 92, '白日门强身术', '强身术修炼');
  {$IFEND}
end;

procedure TFrmDlg.DWHeroSkillMemoDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  I: Integer;
  pm: PTClientMagic;
begin
  {$IF M2Version <> 2}
  with DWHeroSkillMemo do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    AspTextureFonts.SetFont(g_sCurFontName, 15);
    AspTextureFont.BoldTextOut(SurfaceX(GLeft)+64, SurfaceY(GTop)+10, $00A8D4E8, clBlack, HeroSkillMemoTitle, [fsBold]);
    AspTextureFonts.SetFont(g_sCurFontName, 9);

    AspTextureFont.BoldTextOut(SurfaceX(GLeft)+80, SurfaceY(GTop)+53, $0088C4E8, clBlack, HeroSkillMemoUserName+'（英雄）', [fsBold]);
    pm := nil;
    if g_HeroMagicList.Count > 0 then begin
      for I:=0 to g_HeroMagicList.Count - 1 do begin
        if pTClientMagic(g_HeroMagicList[i]).Def.wMagicId = HeroSkillMemoId then begin
          pm := g_HeroMagicList[i];
          Break;
        end;
      end;
    end;

    if pm <> nil then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 131, $0088C4E8, clBlack, pm.Def.sMagicName, [fsBold]);
      AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 149, $0088C4E8, clBlack, IntToStr(pm.Level), [fsBold]);
      if pm.Level = 99 then begin
        AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 185, $0088C4E8, clBlack, '-', [fsBold]);
      end else begin
        AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 185, $0088C4E8, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]){'0/300'}, [fsBold]);
      end;
    end;
    AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 131, clSilver, clBlack, '当前技能：');
    AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 149, clSilver, clBlack, '当前等级：');
    AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 167, clSilver, clBlack, Format('（升级到下一级血量增加%d）',[HeroSkillMemoAddHp]));
    AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 185, clSilver, clBlack, '当前经验：');
    AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 203, clSilver, clBlack, Format('（1 %s = 1 技能经验）', [g_sGameGird]));
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  wm: TAspWMImages;
begin
  {$IF M2Version <> 2}
  with DBHeroSkillMemoIcon do begin
    wm := GetMagicIcon(HeroSkillMemoEffect, 0, HeroSkillMemoId, 0, HeroSkillMemoIcon);
    if wm <> nil then begin
      if not Downed then begin
        d := wm.Images[HeroSkillMemoIcon];
      end else begin
        d := wm.Images[HeroSkillMemoIcon + 1];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoLinkDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
begin
  {$IF M2Version <> 2}
  with DBHeroSkillMemoLink do begin
    if HeroSkillMemoLinkIdx = 1 then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop), clRed, clBlack, Format('使用1800张%s自动修炼180次', [g_sGameGird]), [fsUnderline]);
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, clBlack, Format('使用1800张%s自动修炼180次', [g_sGameGird]), [fsUnderline]);
    end;
    if HeroSkillMemoLinkIdx = 2 then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+17, clRed, clBlack, Format('使用3600张%s自动修炼360次', [g_sGameGird]), [fsUnderline]);
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+17, clYellow, clBlack, Format('使用3600张%s自动修炼360次', [g_sGameGird]), [fsUnderline]);
    end;
    if HeroSkillMemoLinkIdx = 3 then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+34, clRed, clBlack, Format('使用5400张%s自动修炼180次', [g_sGameGird]), [fsUnderline]);
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+34, clYellow, clBlack, Format('使用5400张%s自动修炼180次', [g_sGameGird]), [fsUnderline]);
    end;
    if HeroSkillMemoLinkIdx = 4 then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+51, clRed, clBlack, Format('使用10800张%s自动修炼360次', [g_sGameGird]), [fsUnderline]);
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+51, clYellow, clBlack, Format('使用10800张%s自动修炼360次', [g_sGameGird]), [fsUnderline]);
    end;
    if HeroSkillMemoLinkIdx = 5 then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+68, clRed, clBlack, Format('取消自动修炼', [g_sGameGird]), [fsUnderline]);
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+68, clYellow, clBlack, Format('取消自动修炼', [g_sGameGird]), [fsUnderline]);
    end;
    if HeroSkillMemoLinkIdx = 6 then begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+85, clRed, clBlack, Format('查询剩余修炼次数', [g_sGameGird]), [fsUnderline]);
    end else begin
      AspTextureFont.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+85, clYellow, clBlack, Format('查询剩余修炼次数', [g_sGameGird]), [fsUnderline]);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoLinkClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  with DBHeroSkillMemoLink do begin
    if (X >= GLeft) and (X <= GLeft+GWidth) then begin
      if (Y >= GTop) and (Y <= GTop+13) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+17) and (Y <= GTop+30) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 2, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+34) and (Y <= GTop+47) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 3, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+51) and (Y <= GTop+64) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 4, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+68) and (Y <= GTop+81) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_CLOSEGAMEGIRDUPSKILL99, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+85) and (Y <= GTop+98) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_QUERYGAMEGIRDUPSKILL99, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
    end;
  end;
end;

procedure TFrmDlg.DBHeroSkillMemoLinkMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  HeroSkillMemoLinkIdx := 0;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSpleenImgDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
  rc:Trect;
  nTop: Byte;
begin
  with DBHeroSpleenImg do begin
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1127];
      if d = nil then d := g_WMain3Images.Images[410];
    end else d := g_WMain3Images.Images[410];
    if d <> nil then
    begin
      rc:=d.ClientRect;
      //rc.Top:=rc.Top+10;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
    end;

    nTop := 0;
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1128];
      if d = nil then d := g_WMain3Images.Images[411] else nTop := 14;
    end else d := g_WMain3Images.Images[411];
    rc := d.ClientRect;
    if d <> nil then begin
      if nMaxFirDragonPoint > 0 then begin
       rc.Top := Round(rc.Bottom / nMaxFirDragonPoint * (nMaxFirDragonPoint - m_nFirDragonPoint));
       dsurface.Draw (SurfaceX(GLeft)+2, SurfaceY(GTop)+rc.Top+nTop+21, rc, d, FALSE);
      end;
    end;
    if m_nFirDragonPoint >= nMaxFirDragonPoint then begin
      typeTimeimg;//显示时间间隔
      if g_WinBatterMagicList.Count > 0 then begin
        d := g_WMainImages.Images[1128 + imginsex];
        if d = nil then  g_WMain3Images.Images[imginsex + 411] else nTop := 14;
      end else d := g_WMain3Images.Images[imginsex + 411];
      if d <> nil then
       dsurface.Draw (SurfaceX(GLeft)+2, SurfaceY(GTop)+rc.Top+nTop+21, d.ClientRect, d, false);
    end;
  end;
end;

procedure TFrmDlg.DBHeroStateClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then exit;
  if g_boNewNewHeroState then begin
    DWNewStateHero.Visible := not DWNewStateHero.Visible;
  end else begin
    DStateHero.Visible := not DStateHero.Visible;
    DScreen.AddChatBoardString ('由于你的客户端资源过旧，强化技能、心法将无法使用，请更新最新资源！',clLime, clBlack);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBHeroStateInitialize(Sender: TObject);
begin
  DBHeroState.SetImgIndex(g_qingqingImages,31); //英雄状态信息
end;

procedure TFrmDlg.DBInternetClick(Sender: TObject; X, Y: Integer);
begin
  if g_sGameESystem <> '' then frmBrowser.Open(frmMain, g_sGameESystem);
end;

procedure TFrmDlg.DBInternetInitialize(Sender: TObject);
begin
  DBInternet.SetImgIndex(g_WMain2Images,498);
end;

procedure TFrmDlg.DBItemLevelBelt1Click(Sender: TObject; X, Y: Integer);
  {$IF M2Version <> 2}
var
  ItemLevelSort: pTItemLevelSort;
  {$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if g_UserItemLevelList.Count >= Tag+1 then begin
      if g_UserItemLevelList[Tag] <> nil then begin
        ItemLevelSort := pTItemLevelSort(g_UserItemLevelList[Tag]);
        g_MouseItem.ClientItem := ItemLevelSort.Item;
        ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                          SurfaceY(GTop) + GHeight, '', 1, False);
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBItemLevelBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  ItemLevelSort: pTItemLevelSort;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if g_UserItemLevelList.Count >= Tag+1 then begin
      if g_UserItemLevelList[Tag] <> nil then begin
        ItemLevelSort := pTItemLevelSort(g_UserItemLevelList[Tag]);
        if ItemLevelSort.Item.S.Name <> '' then begin
          if Downed then begin
            AspTextureFont.TextOut (SurfaceX(GLeft) + 46-AspTextureFont.TextWidth(ItemLevelSort.Item.S.Name) div 2, SurfaceY(GTop), clRed, ItemLevelSort.Item.S.Name, [fsUnderline]);
          end else if MouseMoveing then begin
            AspTextureFont.TextOut (SurfaceX(GLeft) + 46-AspTextureFont.TextWidth(ItemLevelSort.Item.S.Name) div 2, SurfaceY(GTop), $0000E7F7, ItemLevelSort.Item.S.Name, [fsUnderline]);
          end else begin
            AspTextureFont.TextOut (SurfaceX(GLeft) + 46-AspTextureFont.TextWidth(ItemLevelSort.Item.S.Name) div 2, SurfaceY(GTop), clYellow, ItemLevelSort.Item.S.Name);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoLinkMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  HeroSkillMemoLinkIdx := 0;
  with DBHeroSkillMemoLink do begin
    if (X >= GLeft) and (X <= SurfaceX(GLeft)+GWidth) then begin
      if (Y >= GTop) and (Y <= GTop+13) then HeroSkillMemoLinkIdx := 1;
      if (Y >= GTop+17) and (Y <= GTop+30) then HeroSkillMemoLinkIdx := 2;
      if (Y >= GTop+34) and (Y <= GTop+47) then HeroSkillMemoLinkIdx := 3;
      if (Y >= GTop+51) and (Y <= GTop+64) then HeroSkillMemoLinkIdx := 4;
      if (Y >= GTop+68) and (Y <= GTop+81) then HeroSkillMemoLinkIdx := 5;
      if (Y >= GTop+85) and (Y <= GTop+98) then HeroSkillMemoLinkIdx := 6;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWSignedItemsDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with DWSignedItems do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    AspTextureFont.BoldTextOut(SurfaceX(GLeft) + 44, SurfaceY(GTop) + 141, $0088C4E8, clBlack, '鉴宝师');
    case m_btSignedItemsPage of
      1: begin
        if m_btSignedHint = 3 then begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, Format('我已经给了你一把没鉴定过的%s，跟你原',[g_SignedItem[0].ClientItem.s.Name]));
          AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+56, clWhite, Format('来的%s没鉴定过之前是一模一样的！',[g_SignedItem[0].ClientItem.s.Name]));
        end else if m_btSignedHint = 4 then begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, '更换失败！');
        end else begin
          if g_SignedItem[0].ClientItem.s.Name <> '' then begin
            AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, Format('这个%s看上去不错，我这里正好有没有',[g_SignedItem[0].ClientItem.s.Name]));
            AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+56, clWhite, Format('鉴定过的各种%s你可以挑一把，要换的',[g_SignedItem[0].ClientItem.s.Name]));
            AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+71, clWhite, '话，你要给我一个幸运符');
          end else begin
            AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, '如果你不喜欢已经鉴定过了的宝物，你可以把');
            AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+56, clWhite, '他给我，我平素最爱收藏各种宝物，我会给你');
            AspTextureFont.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+71, clWhite, '一个一模一样的没鉴定过的装备作为补偿。');
          end;
          d := g_WUI1Images.Images[892];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+222, SurfaceY(GTop)+145, d.ClientRect, d, True);
            dsurface.Draw(SurfaceX(GLeft)+292, SurfaceY(GTop)+153, d.ClientRect, d, True);
          end;
          if g_SignedItem[0].ClientItem.s.Name <> '' then begin
            d := g_WUI1Images.Images[890];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(GLeft)+237, SurfaceY(GTop)+124, d.ClientRect, d, True);
            end;
          end;
          if g_SignedItem[1].ClientItem.s.Name <> '' then begin
            d := g_WUI1Images.Images[891];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(GLeft)+304, SurfaceY(GTop)+150, d.ClientRect, d, True);
            end;
          end;
        end;
      end;
      2: begin
        dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+134, SurfaceY(GTop)+109, 300, 120), clBlack, 150);
        AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '宝物除了能给你带来意外的财富，还能给');
        AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '你的装备附加强效属性。');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+113, clWhite, '1、只有标识可鉴定的物品才能进行鉴定');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+128, clWhite, '2、每件物品最多可以鉴定三次，但是在鉴定过程中有可');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+143, clWhite, '能获得追加的鉴定机会，还有可能获得让庄主帮忙鉴定');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+158, clWhite, '的机会');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+173, clWhite, '3、鉴定出来的宝物一般是带有额外属性加成，宝物等级');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+188, clWhite, '越高，属性越多，属性越好');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+203, clWhite, '4、鉴定失败，鉴定师会返还一定的经验或者荣耀点。');
        dsurface.FrameRect(Bounds(SurfaceX(GLeft)+134, SurfaceY(GTop)+109, 300, 120), $00488490);
      end;
      3: begin
        dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+134, SurfaceY(GTop)+109, 300, 120), clBlack, 150);
        AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '宝物除了能给你带来意外的财富，还能给');
        AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '你的装备附加强效属性。');

        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+113, clWhite, '1、如果你对鉴定出来的附加属性不满意，你可以和我更');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+128, clWhite, '换，我会挑一件和你鉴定之前一模一样的装备给你的。');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+143, clWhite, '2、更换后装备幸运值和已升级的点数保留，例如你给我');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+158, clWhite, '一个三鉴的幸运+7，攻击12-87，暴击等级+10的传奇战');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+173, clWhite, '刃，我会换给你一个没鉴定过的幸运+7，攻击12-87，暴');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+188, clWhite, '击等级+10的传奇战刃。');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+203, clWhite, '3、和我更换装备需要给我一个幸运符，幸运符可以从商');
        AspTextureFont.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+218, clWhite, '城购买。');
        dsurface.FrameRect(Bounds(SurfaceX(GLeft)+134, SurfaceY(GTop)+109, 300, 120), $00488490);
      end;
      else begin
        if g_SignedItem[0].ClientItem.s.Name <> '' then begin
          if m_btSignedHint = 1 then begin //成功
            AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '借助卷轴的力量，我已经帮你发现了你这');
            AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, Format('%s的潜能。', [g_SignedItem[0].ClientItem.s.Name]));
          end else if m_btSignedHint = 2 then begin //失败
            AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, Format('我并没能从你的这个%s上发现更多的', [g_SignedItem[0].ClientItem.s.Name]));
            AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '潜能。你不要沮丧，我会给你额外的补偿');
            AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+80, clWhite, '。');
          end else begin
            if g_SignedItem[0].ClientItem.btUnKnowValue[0] in [1..4,11..14,21..24,31..34,41..44,51..54] then begin  //可鉴定
              case g_SignedItem[0].ClientItem.btUnKnowValue[0] of
                1,11,21,31,41,51: begin
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '第一次鉴定我需要一个一级鉴定卷轴，你');
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '快去收集一个吧！');
                end;
                2,12,22,32,42,52: begin
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '第二次鉴定我需要一个二级鉴定卷轴，你');
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '快去收集一个吧！');
                end;
                3,13,23,33,43,53: begin
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '第三次鉴定我需要一个三级鉴定卷轴，你');
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '快去收集一个吧！');
                end;
                4,14,24,34,44,54: begin
                  AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, Format('你的这件%s已经不能再鉴定了。',[g_SignedItem[0].ClientItem.s.Name]));
                end;
              end;
            end else begin
              AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '标志了不可鉴定的物品我是鉴定不了的，');
              AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '你换一个吧。');
            end;
          end;
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '我收藏天下的奇珍异宝，走南闯北几十年');
          AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '了，各种神器见过不少，把你要鉴定的装');
          AspTextureFont.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+80, clWhite, '备放在桌子上吧！');
        end;
        d := g_WUI1Images.Images[892];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(GLeft)+222, SurfaceY(GTop)+145, d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(GLeft)+292, SurfaceY(GTop)+153, d.ClientRect, d, True);
        end;
        if g_SignedItem[0].ClientItem.s.Name <> '' then begin
          d := g_WUI1Images.Images[890];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+237, SurfaceY(GTop)+124, d.ClientRect, d, True);
          end;
        end;
        if g_SignedItem[1].ClientItem.s.Name <> '' then begin
          d := g_WUI1Images.Images[891];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+304, SurfaceY(GTop)+150, d.ClientRect, d, True);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSignedItemDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with TAspDButton(Sender) do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 37 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 6, $0048A4E8, clBlack, TAspDButton(Sender).Hint);
        end;
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          if MouseMoveing then begin
            AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 36 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $00A8D4E8, clBlack, TAspDButton(Sender).Hint);
          end else AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 36 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0088C4E8, clBlack, TAspDButton(Sender).Hint);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSignedItemClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if m_boSignedLock then Exit;
  if m_btSignedItemsPage <> TAspDButton(Sender).Tag then begin
    m_btSignedItemsPage := TAspDButton(Sender).Tag;
    case m_btSignedItemsPage of
      1: begin
        DBSignedBelt1.Visible := True;
        DBSignedBelt2.Visible := True;
        DBOrdSigned.Visible := False;
        DBHighSigned.Visible := False;
        DBSignedChange.Visible := True;
        if (g_SignedItem[1].ClientItem.s.Name <> '') and (g_SignedItem[1].ClientItem.s.StdMode <> 18) and (g_SignedItem[1].ClientItem.s.Shape <> 1) then begin
          AddItemBag(g_SignedItem[1]);
          g_SignedItem[1].ClientItem.s.Name := '';
        end;
      end;
      2: begin
        DBSignedBelt1.Visible := False;
        DBSignedBelt2.Visible := False;
        DBOrdSigned.Visible := False;
        DBHighSigned.Visible := False;
        DBSignedChange.Visible := False;
      end;
      3: begin
        DBSignedBelt1.Visible := False;
        DBSignedBelt2.Visible := False;
        DBOrdSigned.Visible := False;
        DBHighSigned.Visible := False;
        DBSignedChange.Visible := False;
      end;
      else begin
        DBSignedBelt1.Visible := True;
        DBSignedBelt2.Visible := True;
        DBOrdSigned.Visible := True;
        DBHighSigned.Visible := True;
        DBSignedChange.Visible := False;
        if g_SignedItem[0].ClientItem.s.Name <> '' then begin
          case g_SignedItem[0].ClientItem.btUnKnowValue[0] of
            1,11,21,31,41,51: begin
              DBOrdSigned.Hint := '普通一鉴';
              DBHighSigned.Hint := '高级一鉴';
              DBOrdSigned.Enabled := True;
              DBHighSigned.Enabled := True;
              if (g_SignedItem[1].ClientItem.s.Name = '') and not ((g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767))  then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[I].Item.ClientItem.S.Shape = 239) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.ClientItem.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
            2,12,22,32,42,52: begin
              DBOrdSigned.Hint := '普通二鉴';
              DBHighSigned.Hint := '高级二鉴';
              DBOrdSigned.Enabled := True;
              DBHighSigned.Enabled := True;
              if (g_SignedItem[1].ClientItem.s.Name = '') and not ((g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767))  then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[I].Item.ClientItem.S.Shape = 240) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.ClientItem.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
            3,13,23,33,43,53: begin
              DBOrdSigned.Hint := '普通三鉴';
              DBHighSigned.Hint := '高级三鉴';
              DBOrdSigned.Enabled := True;
              DBHighSigned.Enabled := True;
              if (g_SignedItem[1].ClientItem.s.Name = '') and not ((g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767))  then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[I].Item.ClientItem.S.Shape = 241) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.ClientItem.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
            else begin
              DBOrdSigned.Hint := '普通鉴定';
              DBHighSigned.Hint := '高级鉴定';
              DBOrdSigned.Enabled := False;
              DBHighSigned.Enabled := False;
            end;
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBOrdSignedDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin //20080701
      if not Enabled then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2, SurfaceY(GTop) + d.Height div 2 - AspTextureFont.TextHeight(Hint) div 2{+ 5}, $0099A8AC, clBlack, Hint);
        Exit;
      end;
      if TAspDButton(Sender).Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(Hint) div 2+1, SurfaceY(GTop) + d.Height div 2 - AspTextureFont.TextHeight(Hint) div 2 + 1{SurfaceY(GTop) + 6}, $0048A4E8, clBlack, Hint);
      end else begin
        if TAspDButton(Sender).MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + d.Height div 2 - AspTextureFont.TextHeight(Hint) div 2, $00A8D4E8, clBlack, TAspDButton(Sender).Hint);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - AspTextureFont.TextWidth(TAspDButton(Sender).Hint) div 2, SurfaceY(GTop) + d.Height div 2 - AspTextureFont.TextHeight(Hint) div 2, $0088C4E8, clBlack, TAspDButton(Sender).Hint);
        end;
      end;
    end;
  end;
{$IFEND}  
end;

procedure TFrmDlg.DBSignedBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if m_btSignedItemsPage = 1 then begin
        d := g_WUI1Images.Images[883];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      if g_SignedItem[Tag].ClientItem.s.Name <> '' then begin
        idx := g_SignedItem[Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
        dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, 35, 33), $0046B5FF, 90);
      end;
      if Sender = DBSignedBelt1 then begin
        case m_btSignedSuccess of
          1: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[940+m_btSignedImginsex];
            if d <> nil then
              dsurface.DrawBlend( DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d);
          end;
          2: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[970+m_btSignedImginsex];
            if d <> nil then
              dsurface.DrawBlend( DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d);
          end;
          3: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[1000+m_btSignedImginsex];
            if d <> nil then
              dsurface.DrawBlend( DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d);
          end;
          4: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[1030+m_btSignedImginsex];
            if d <> nil then
              dsurface.DrawBlend( DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBSignedBelt1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientEffecItem;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boSignedLock then Exit;
    m_btSignedHint := 0;
  with Sender as TAspDButton do begin
    if not g_boItemMoving then begin
      if g_SignedItem[Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_SignedItem[Tag].ClientItem.s);
         if g_MovingItem.Item.ClientItem.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_SignedItem[Tag];
         g_SignedItem[Tag].ClientItem.s.Name := '';
         if g_SignedItem[0].ClientItem.s.Name = '' then begin
           DBOrdSigned.Hint := '普通鉴定';
           DBHighSigned.Hint := '高级鉴定';
           DBOrdSigned.Enabled := False;
           DBHighSigned.Enabled := False;
           DBSignedChange.Enabled := False;
         end;
      end;
    end else begin
      if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
        ItemClickSound (g_MovingItem.Item.ClientItem.S);
        if g_SignedItem[Tag].ClientItem.s.Name <> '' then begin
          temp := g_SignedItem[Tag];
          g_SignedItem[Tag] := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_SignedItem[Tag] := g_MovingItem.Item;
          g_MovingItem.Item.ClientItem.S.name := '';
          g_boItemMoving := FALSE;
        end;

        if m_btSignedItemsPage = 1 then begin
          if Sender = DBSignedBelt1 then begin
            if not (g_SignedItem[0].ClientItem.btUnKnowValue[0] in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
              DBSignedChange.Enabled := False;
              AddItemBag(g_SignedItem[0]);
              g_SignedItem[0].ClientItem.s.Name := '';
              Exit;
            end else begin
              if (g_SignedItem[1].ClientItem.s.Name = '') then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 18) and (g_ItemArr[I].Item.ClientItem.S.Shape = 1) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.ClientItem.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
          end else begin
            if (g_SignedItem[1].ClientItem.s.StdMode <> 18) and (g_SignedItem[1].ClientItem.s.Shape <> 1) then begin
              DBSignedChange.Enabled := False;
              AddItemBag(g_SignedItem[1]);
              g_SignedItem[1].ClientItem.s.Name := '';
              Exit;
            end;
          end;
        end else begin
          if Sender = DBSignedBelt1 then begin
            case g_SignedItem[0].ClientItem.btUnKnowValue[0] of
              1,11,21,31,41,51: begin
                DBOrdSigned.Hint := '普通一鉴';
                DBHighSigned.Hint := '高级一鉴';
                DBOrdSigned.Enabled := True;
                DBHighSigned.Enabled := True;
                if (g_SignedItem[1].ClientItem.s.Name = '') and not ((g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767))  then begin
                  for I:=6 to MAXBAGITEMCL-1 do begin
                    if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[I].Item.ClientItem.S.Shape = 239) then begin
                      g_SignedItem[1] := g_ItemArr[I].Item;
                      g_ItemArr[I].Item.ClientItem.S.Name := '';
                      Break;
                    end;
                  end;
                end;
              end;
              2,12,22,32,42,52: begin
                DBOrdSigned.Hint := '普通二鉴';
                DBHighSigned.Hint := '高级二鉴';
                DBOrdSigned.Enabled := True;
                DBHighSigned.Enabled := True;
                if (g_SignedItem[1].ClientItem.s.Name = '') and not ((g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767))  then begin
                  for I:=6 to MAXBAGITEMCL-1 do begin
                    if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[I].Item.ClientItem.S.Shape = 240) then begin
                      g_SignedItem[1] := g_ItemArr[I].Item;
                      g_ItemArr[I].Item.ClientItem.S.Name := '';
                      Break;
                    end;
                  end;
                end;
              end;
              3,13,23,33,43,53: begin
                DBOrdSigned.Hint := '普通三鉴';
                DBHighSigned.Hint := '高级三鉴';
                DBOrdSigned.Enabled := True;
                DBHighSigned.Enabled := True;
                if (g_SignedItem[1].ClientItem.s.Name = '') and not ((g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767))  then begin
                  for I:=6 to MAXBAGITEMCL-1 do begin
                    if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and (g_ItemArr[I].Item.ClientItem.S.Shape = 241) then begin
                      g_SignedItem[1] := g_ItemArr[I].Item;
                      g_ItemArr[I].Item.ClientItem.S.Name := '';
                      Break;
                    end;
                  end;
                end;
              end;
              else begin
                DBOrdSigned.Hint := '普通鉴定';
                DBHighSigned.Hint := '高级鉴定';
                DBOrdSigned.Enabled := False;
                DBHighSigned.Enabled := False;
              end;
            end;
          end;
        end;
        DBSignedChange.Enabled := g_SignedItem[0].ClientItem.s.Name <> '';
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBSignedItemsCloseClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boSignedLock then Exit;
  for I:=Low(g_SignedItem) to High(g_SignedItem) do begin
    if g_SignedItem[I].ClientItem.s.Name <> '' then begin
      AddItemBag(g_SignedItem[I]);
      g_SignedItem[I].ClientItem.s.Name := '';
    end;
  end;
  DWSignedItems.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DWJudgeItemsDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWJudgeItems do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    case m_btJudjeItemsPage of
      1: begin
        dsurface.FillRect(Bounds(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, 329, 196), 0);
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+52, clWhite, '1、宝物品评可以让你看到宝物的真实战斗力分数');
        if g_boJudgeUseGold then begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, Format('2、品评装备一次需要花费%d%s', [g_nJudgePrice, g_sGoldName]));
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, Format('2、品评装备一次需要花费%d%s', [g_nJudgePrice, g_sGameGoldName]));
        end;
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+78, clWhite, '3、如果你的宝物足够强大，在我品评后，可以帮你放入排');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+91, clWhite, '   行榜的装备榜，受宗仁瞻仰');
      end;
      else begin
        AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '宝物的基础属性，附加基础属性，附加神秘');
        AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '属性，升级次数，幸运值等都会影响宝物的');
        AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '评分，评分越高，宝物在装备排行榜的排行');
        AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+83, clWhite, '也越高');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWJudgeItemsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBJudgeBelt1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientEffecItem;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if not g_boItemMoving then begin
      if g_JudgeItems.ClientItem.s.Name <> '' then begin
         ItemClickSound (g_JudgeItems.ClientItem.s);
         if g_MovingItem.Item.ClientItem.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_JudgeItems;
         g_JudgeItems.ClientItem.s.Name := '';
      end;
    end else begin
      if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.ClientItem.btUnKnowValue[0] in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
        ItemClickSound (g_MovingItem.Item.ClientItem.S);
        if g_JudgeItems.ClientItem.s.Name <> '' then begin
          temp := g_JudgeItems;
          g_JudgeItems := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_JudgeItems := g_MovingItem.Item;
          g_MovingItem.Item.ClientItem.S.name := '';
          g_boItemMoving := FALSE;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
        d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      if g_JudgeItems.ClientItem.s.Name <> '' then begin
        idx := g_JudgeItems.ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.ClientItem.btUnKnowValue[0] in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
        dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, 35, 33), $0046B5FF, 90);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    g_MouseItem := g_JudgeItems;
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeItemClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if m_btJudjeItemsPage <> Tag then begin
      m_btJudjeItemsPage := Tag;
      DBJudgeBelt1.Visible := m_btJudjeItemsPage = 0;
      DBJudgeStart.Visible := m_btJudjeItemsPage = 0;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeItemsCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_JudgeItems.ClientItem.s.Name <> '' then begin
    AddItemBag(g_JudgeItems);
    g_JudgeItems.ClientItem.s.Name := '';
  end;
  DWJudgeItems.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeStartClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_boJudgeUseGold then begin
    str := Format('您确定用%d%s品评这个装备吗？', [g_nJudgePrice, g_sGoldName]);
  end else begin
    str := Format('您确定用%d%s品评这个装备吗？', [g_nJudgePrice, g_sGameGoldName]);
  end;

  if mrOk = DMessageDlg (str, [mbOk, mbCancel]) then begin
    FrmMain.SendUserJudge(g_JudgeItems.ClientItem.MakeIndex, g_JudgeItems.ClientItem.s.Name);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWMakeSignedDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWMakeSigned do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    d := g_WUI1Images.Images[893];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(GLeft)+118, SurfaceY(GTop)+14, d.ClientRect, d, True);
    end;
    case m_btMakeSignedPage of
      1: begin
        if m_btMakeSignedHint = 1 then begin //成功
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '神秘卷轴制作成功');
        end else if m_btMakeSignedHint = 2 then begin //失败
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '这次制作不幸的失败了，可能是因为你的神');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '秘解读技能等级还不够高，或者是你制作的');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '卷轴等级太高了');
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '你可以把你对鉴宝的心得还有你的鉴定经验');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '写在神秘卷轴上，这样的话，就可以帮助更');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '多人解读神秘属性');
        end;
      end;
      2: begin
        dsurface.FillRect(Bounds(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, 329, 196), 0);
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+52, clWhite, '1、神秘属性可以通过使用的神秘卷轴进行解读');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, '2、神秘卷轴的等级决定了可以解读的神秘属性个数，等级');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+78, clWhite, '   一的神秘卷轴可以解读第一个神秘属性，等级二的神秘卷');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+91, clWhite, '   轴可以解读第一个和第二个神秘属性，等级三的神秘卷轴');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+104, clWhite, '   可以解读前三个神秘属性，等级四的神秘卷轴可以解读前');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+117, clWhite, '   四个神秘属性');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+130, clWhite, '3、解读神秘属性有一定的成功率，使用的神秘卷轴等级越高');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+143, clWhite, '   、熟练度越高，解读的成功率也越高');
      end;
      3: begin
        dsurface.FillRect(Bounds(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, 329, 196), 0);
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+52, clWhite, '1、制作神秘卷轴需要使用羊皮卷，羊皮卷可以从商城进行购');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, '   买');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+78, clWhite, '2、制作神秘卷轴有一定的成功率，成功率由幸运值、要制作');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+91, clWhite, '   的卷轴等级和玩家的神秘解读技能的等级相关，制作面页');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+104, clWhite, '   中的红色进度条为玩家的幸运值，每次制作失败都会增加');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+117, clWhite, '   幸运值');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+130, clWhite, '3、每次制作成功都会消耗一定的精力值，精力值不足的时候');
        AspTextureFont.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+143, clWhite, '   不能制作卷轴，精力值会随着在线时间的延长有所增长。');
      end;
      else begin
        if m_btMakeSignedHint = 3 then begin //成功
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '借助神秘卷轴的帮助，已经帮你解读出了一');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '个神秘属性');
        end else if m_btMakeSignedHint = 4 then begin //失败
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '这次解读不幸失败，解读幸运值、神秘卷轴');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '的等级和熟练度过低可能导致解读失败，不');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '要失望，再接再厉吧。');
        end else if g_SignedItem[0].ClientItem.s.Name <> '' then begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '等级越高，熟练度越高的神秘卷轴，解读成');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '功的概率越高，放入你要使用的神秘卷轴吧');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '。');
        end else begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '你可以跟别人购买神秘卷轴，也可以自己制');
          AspTextureFont.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '作神秘卷轴来解读宝物的神秘属性。');
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedExp1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if Sender = DBMakeSignedExp1 then begin
      DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop) - 3, Format(' 精力值 %d/%d' ,[g_btEnergyValue,100]) , clWhite, FALSE);
    end else begin
      DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop) - 3, Format(' 幸运值 %d/%d' ,[g_btLuckyValue,100]) , clWhite, FALSE);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWMakeSignedMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBMakeSignedReadClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  with Sender as TAspDButton do begin
    if m_btMakeSignedPage <> Tag then begin
      m_btMakeSignedPage := Tag;
      DBMakeSignedBelt1.Visible := m_btMakeSignedPage = 0;
      DBMakeSignedBelt2.Visible := m_btMakeSignedPage = 0;
      DBMakeSignedReadStart.Visible := m_btMakeSignedPage = 0;
      DBMakeSignedBelt3.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve1.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve2.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve3.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve4.Visible := m_btMakeSignedPage = 1;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLevelOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  LevelOrderPage := 6;
  LevelOrderPageChanged;
  nLevelOrderPage := TAspDButton(Sender).Tag;
  nLevelOrderTypePage := TAspDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderPage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DBOrdSignedClick(Sender: TObject; X, Y: Integer);
var
  btLevel : Byte;
  boTrainee  : Boolean;
begin
{$IF M2Version <> 2}
  if m_boSignedLock then Exit;
  if not TAspDButton(Sender).Enabled then Exit;
  if g_SignedItem[1].ClientItem.s.Name = '' then begin
    DMessageDlg ('请放置鉴定卷轴，鉴定卷轴可以在日常活动中获得，包括祝福点活动、灵\符仙子追加奖励、九周年大使处的烟花兑换及5元礼包等各种活动', [mbOK]);
    Exit;
  end;
  btLevel := g_SignedItem[0].ClientItem.btUnKnowValue[0] mod 10;
  boTrainee := (g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767);
  if ((not boTrainee) and (g_SignedItem[1].ClientItem.s.StdMode = 17) and (g_SignedItem[1].ClientItem.s.Shape = 238 + btLevel))
  or (boTrainee and (g_SignedItem[1].ClientItem.s.StdMode = 44) and (g_SignedItem[1].ClientItem.s.Shape = 348 + btLevel))
  then begin
    DBOrdSigned.Enabled := False;
    DBHighSigned.Enabled := False;
    m_boSignedLock := True;
    FrmMain.SendSginedItem(g_SignedItem[0].ClientItem.MakeIndex, g_SignedItem[1].ClientItem.MakeIndex, TAspDButton(Sender).Tag);
  end else DMessageDlg ('鉴定的装备与卷轴不匹配！', [mbOK]);
{$IFEND}
end;

procedure TFrmDlg.DBSignedBelt1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    g_MouseItem := g_SignedItem[Tag];
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWSignedItemsMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBSignedChangeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if not TAspDButton(Sender).Enabled then Exit;
  if m_boSignedLock then Exit;
  if (g_SignedItem[0].ClientItem.s.StdMode = 5) and (g_SignedItem[0].ClientItem.s.Need = 32767) then begin   //见习
    DMessageDlg ('无法更换这个物品！', [mbOK]);
    AddItemBag(g_SignedItem[0]);
    g_SignedItem[0].ClientItem.s.Name := '';
    DBSignedChange.Enabled := False;
    Exit;
  end;
  if not (g_SignedItem[0].ClientItem.btUnKnowValue[0] in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
    DMessageDlg ('你的宝物没有鉴定过，无需更换！', [mbOK]);
    AddItemBag(g_SignedItem[0]);
    g_SignedItem[0].ClientItem.s.Name := '';
    DBSignedChange.Enabled := False;
    Exit;
  end;
  if g_SignedItem[1].ClientItem.s.Name = '' then begin
    DMessageDlg ('缺少幸运符，请从商铺中购买！', [mbOK]);
    AddItemBag(g_SignedItem[1]);
    g_SignedItem[1].ClientItem.s.Name := '';
    Exit;
  end;
  DBSignedChange.Enabled := False;
  m_boSignedLock := True;
  FrmMain.SendChangeSginedItem(g_SignedItem[0].ClientItem.MakeIndex, g_SignedItem[1].ClientItem.MakeIndex);
{$IFEND}
end;

procedure TFrmDlg.DscStartDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
  d := nil;
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if MouseMoveing then d := WLib.Images[FaceIndex]
      else if Downed then d := WLib.Images[FaceIndex + 1]
      else d := g_qingqingImages.Images[20];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    if not Enabled then begin
      if d <> nil then begin
        //if g_boReSelConnect then
        begin
          dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
          dsurface.FillRectAlpha(g_ReSelClientRect, clBlack, 150);
          if GetTickCount - g_dwReSelConnectTick > 100 then begin
            g_dwReSelConnectTick := GetTickCount;
            g_ReSelClientRect.Top := g_ReSelClientRect.Top + 1;
            if g_ReSelClientRect.Top > g_ReSelClientRect.Bottom then begin
              //g_boReSelConnect := False;
              Enabled := True;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBMakeSignedBelt3DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
        d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      if g_MakeSignedBelt3.ClientItem.s.Name <> '' then begin
        idx := g_MakeSignedBelt3.ClientItem.S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.ClientItem.S.StdMode = 44) and
                  (g_MovingItem.Item.ClientItem.S.Shape = 254) then begin
        if d<>nil then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, 35, 33), $0046B5FF, 90);
        end;
      end;
      case m_btMakeSignedSuccess of
        1: begin
          if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
            m_dwMakeSignedTimeTick := GetTickCount();
            Inc(m_btMakeSignedImginsex);
          end;
          if m_btMakeSignedImginsex > 21 then begin
            m_btMakeSignedImginsex := 0;
            m_btMakeSignedSuccess := 0; //停止动画
            m_boMakeSignedLock := False;
          end;
          d := g_WUI1Images.Images[1000+m_btMakeSignedImginsex];
          if d <> nil then
            dsurface.DrawBlend(DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d);
        end;
        2: begin
          if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
            m_dwMakeSignedTimeTick := GetTickCount();
            Inc(m_btMakeSignedImginsex);
          end;
          if m_btMakeSignedImginsex > 21 then begin
            m_btMakeSignedImginsex := 0;
            m_btMakeSignedSuccess := 0; //停止动画
            m_boMakeSignedLock := False;
          end;
          d := g_WUI1Images.Images[1030+m_btMakeSignedImginsex];
          if d <> nil then
            dsurface.DrawBlend(DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d);
        end;
      end;
    end;
  end;  
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt3Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientEffecItem;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  with Sender as TAspDButton do begin
    if not g_boItemMoving then begin
      if g_MakeSignedBelt3.ClientItem.s.Name <> '' then begin
         ItemClickSound (g_MakeSignedBelt3.ClientItem.s);
         if g_MovingItem.Item.ClientItem.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_MakeSignedBelt3;
         g_MakeSignedBelt3.ClientItem.s.Name := '';
      end;
    end else begin
      if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.ClientItem.S.StdMode = 44) and
         (g_MovingItem.Item.ClientItem.S.Shape = 254) then begin
        ItemClickSound (g_MovingItem.Item.ClientItem.S);
        if g_MakeSignedBelt3.ClientItem.s.Name <> '' then begin
          temp := g_MakeSignedBelt3;
          g_MakeSignedBelt3 := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_MakeSignedBelt3 := g_MovingItem.Item;
          g_MovingItem.Item.ClientItem.S.name := '';
          g_boItemMoving := FALSE;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedLeve1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  str := '';
  if not FrmMain.GetMagicByID(100) then str := str + '缺少神秘解读技能\';
  if g_btEnergyValue = 0 then str := str + '缺少精力值\';
  if g_MakeSignedBelt3.ClientItem.s.Name = '' then str := str + '缺少羊皮卷\';
  if str <> '' then begin
    DMessageDlg (str, [mbOK]);
    Exit;
  end;
  m_boMakeSignedLock := True;
  frmMain.SendMakeScroll(g_MakeSignedBelt3.ClientItem.MakeIndex, TAspDButton(Sender).Tag);
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;

      if g_MakeSignedBelt[Tag].ClientItem.s.Name <> '' then begin
        idx := g_MakeSignedBelt[Tag].ClientItem.s.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if Sender = DBMakeSignedBelt1 then begin  //检测神秘属性装备
        with g_MovingItem.Item.ClientItem do
        if (s.Name <> '') and (g_MovingItem.Index >= 0) and ((btUnKnowValue[6] = 255) or
           (btUnKnowValue[7] = 255) or (btUnKnowValue[8] = 255) or (btUnKnowValue[9] = 255)) then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, 35, 33), $0046B5FF, 90);
        end;
      end else begin //检测是否为神秘卷轴
        with g_MovingItem.Item.ClientItem do
        if (s.Name <> '') and (g_MovingItem.Index >= 0) and (s.StdMode = 44) and ((s.Shape = 255) and (s.NeedIdentify > 0)) or (s.Shape = 252) then begin
          dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, 35, 33), $0046B5FF, 90);
        end;
      end;
      if Sender = DBMakeSignedBelt1 then begin
        case m_btMakeSignedSuccess of
          3: begin
            if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
              m_dwMakeSignedTimeTick := GetTickCount();
              Inc(m_btMakeSignedImginsex);
            end;
            if m_btMakeSignedImginsex > 21 then begin
              m_btMakeSignedImginsex := 0;
              m_btMakeSignedSuccess := 0; //停止动画
              m_boMakeSignedLock := False;
            end;
            d := g_WUI1Images.Images[1000+m_btMakeSignedImginsex];
            if d <> nil then
              dsurface.DrawBlend( DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d);
          end;
          4: begin
            if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
              m_dwMakeSignedTimeTick := GetTickCount();
              Inc(m_btMakeSignedImginsex);
            end;
            if m_btMakeSignedImginsex > 21 then begin
              m_btMakeSignedImginsex := 0;
              m_btMakeSignedSuccess := 0; //停止动画
              m_boMakeSignedLock := False;
            end;
            d := g_WUI1Images.Images[1030+m_btMakeSignedImginsex];
            if d <> nil then
              dsurface.DrawBlend( DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedCloseClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  if g_MakeSignedBelt3.ClientItem.s.Name <> '' then begin
    AddItemBag(g_MakeSignedBelt3);
    g_MakeSignedBelt3.ClientItem.s.Name := '';
  end;
  for I:=Low(g_MakeSignedBelt) to High(g_MakeSignedBelt) do begin
    if g_MakeSignedBelt[I].ClientItem.s.Name <> '' then begin
      AddItemBag(g_MakeSignedBelt[I]);
      g_MakeSignedBelt[I].ClientItem.s.Name := '';
    end;
  end;
  DWMakeSigned.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientEffecItem;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
    m_btSignedHint := 0;
  with Sender as TAspDButton do begin
    if not g_boItemMoving then begin
      if g_MakeSignedBelt[Tag].ClientItem.s.Name <> '' then begin
         ItemClickSound (g_MakeSignedBelt[Tag].ClientItem.s);
         if g_MovingItem.Item.ClientItem.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_MakeSignedBelt[Tag];
         g_MakeSignedBelt[Tag].ClientItem.s.Name := '';
      end;
    end else begin
      if (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
        if Sender = DBMakeSignedBelt1 then begin
          with g_MovingItem.Item.ClientItem do
          if (btUnKnowValue[6] <> 255) and (btUnKnowValue[7] <> 255) and
             (btUnKnowValue[8] <> 255) and (btUnKnowValue[9] <> 255) then Exit;
        end else begin
          with g_MovingItem.Item.ClientItem do
          if (s.StdMode <> 44) or (((s.Shape <> 255) or (s.NeedIdentify = 0)) and (s.Shape <> 252)) then Exit;
        end;
        ItemClickSound (g_MovingItem.Item.ClientItem.S);
        if g_MakeSignedBelt[Tag].ClientItem.s.Name <> '' then begin
          temp := g_MakeSignedBelt[Tag];
          g_MakeSignedBelt[Tag] := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_MakeSignedBelt[Tag] := g_MovingItem.Item;
          g_MovingItem.Item.ClientItem.S.name := '';
          g_boItemMoving := FALSE;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt3MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    g_MouseItem := g_MakeSignedBelt3;
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
    
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    g_MouseItem := g_MakeSignedBelt[Tag];
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedReadStartClick(Sender: TObject; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  str: string;
  n1: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  str := '';
  n1 := 0;
  if g_MakeSignedBelt[1].ClientItem.s.Name = '' then str := '缺少神秘卷轴\';
  if g_MakeSignedBelt[0].ClientItem.s.Name = '' then str := str + '缺少待解读物品\';
  if (g_MakeSignedBelt[0].ClientItem.s.Name <> '') and (g_MakeSignedBelt[1].ClientItem.s.Name <> '') then begin
    if (g_MakeSignedBelt[0].ClientItem.btUnKnowValue[1] > 0) and (g_MakeSignedBelt[0].ClientItem.btUnKnowValue[1] < 5) then begin//判断是否存在神秘属性
      if g_MakeSignedBelt[0].ClientItem.btUnKnowValue[6]= 255 then n1:= 1
      else if g_MakeSignedBelt[0].ClientItem.btUnKnowValue[7]= 255 then n1:= 2
      else if g_MakeSignedBelt[0].ClientItem.btUnKnowValue[8]= 255 then n1:= 3
      else if g_MakeSignedBelt[0].ClientItem.btUnKnowValue[9]= 255 then n1:= 4;
    end;
    if not n1 in [1..4] then begin
      str := str + '无需解读物品\';
    end else begin
      if not ((g_MakeSignedBelt[1].ClientItem.s.StdMode = 44) and (g_MakeSignedBelt[1].ClientItem.s.Shape = 252)) then begin
        if (n1 > g_MakeSignedBelt[1].ClientItem.s.NeedIdentify) then begin
          str := str + Format('神秘卷轴等级无法解读，需等级%d的神秘卷轴\', [n1]);
        end;
      end;
    end;
  end;

  if str <> '' then begin
    DMessageDlg (str, [mbOK]);
    Exit;
  end;
  m_boMakeSignedLock := True;
  frmMain.SendMakeReadScroll(g_MakeSignedBelt[0].ClientItem.MakeIndex, g_MakeSignedBelt[1].ClientItem.MakeIndex);
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedExp1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  Rc: TRect;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if Sender = DBMakeSignedExp1 then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
           Rc := d.ClientRect;
           Rc.Right := Round((Rc.Right-Rc.Left) / 100 * g_btEnergyValue);
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
           Rc := d.ClientRect;
           Rc.Right := Round((Rc.Right-Rc.Left) / 100 * g_btLuckyValue);
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltDblClick(Sender: TObject);
begin
{$IF M2Version <> 2}
  UseLingMeiItem();
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  d := nil;
  with Sender as TAspDButton do begin
    if g_LingMeiBelt.ClientItem.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_LingMeiBelt.ClientItem.S.Looks);
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft+(GWidth-d.Width) div 2), SurfaceY(GTop+(GHeight-d.Height) div 2), d.ClientRect, d, TRUE);
    end else begin
      //TasNat 2012-03-04 11:04:46修改鼠标移动物品为 灵煤才让灵煤框显示效果
      if (g_boItemMoving) and (g_MovingItem.Item.ClientItem.S.Name <> '') and (g_WaitingUseItem.Item.ClientItem.S.Name = '') then
      if ((g_MovingItem.Item.ClientItem.S.StdMode = 44) and (g_MovingItem.Item.ClientItem.S.Shape = 253)) or CheckItemSpiritMedia(g_MovingItem.Item.ClientItem) then begin
      //if (g_MovingItem.Item.ClientItem.S.Name <> '') then begin
        dsurface.FillRectAlpha(Bounds(SurfaceX(GLeft)+2, SurfaceY(GTop)+2, 35, 33), $0046B5FF, 90);
      end;
    end;
    if m_boLingMeiEffect then begin
      if GetTickCount - m_dwLingMeiTimeTick > 120 then begin
        m_dwLingMeiTimeTick := GetTickCount();
        Inc(m_btLingMeiImgFrame);
      end;
      if m_btLingMeiImgFrame > 5 then begin
        m_btLingMeiImgFrame := 0;
        m_boLingMeiEffect := False; //停止动画
      end;
      d := g_WMain2Images.Images[260+m_btLingMeiImgFrame];
      if d <> nil then
        dsurface.DrawBlend( SurfaceX(GLeft)-20, SurfaceY(GTop)-20, d);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  iname, iname1, d1, d2, d3, d4, d5, d6, d7, hcolor: string;
  useable: Boolean;
  nY: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  if m_boLingMeiEffect then Exit;
  if g_LingMeiBelt.ClientItem.S.Name <> '' then begin
    g_MouseItem := g_LingMeiBelt;
    GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
    g_MouseItem.ClientItem.S.Name := '';
    nY := 0;
    if iname <> '' then nY := nY+25;
    if d1 <> '' then nY := nY+25;
    if d2 <> '' then nY := nY+25;
    if d3 <> '' then nY := nY+25;
    if d4 <> '' then nY := nY+25;
    with Sender as TAspDButton do begin
      DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth,
                              SurfaceY(GTop)-nY-23,
                              Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\<使用灵媒快捷键为/c=Yellow><Ctrl+X/c=Red>',
                              [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
    end;
  end else begin
    with Sender as TAspDButton do begin
      DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth,
                              SurfaceY(GTop)+6,'<可以放入灵媒，/c=Yellow>\<使用灵媒快捷键为/c=Yellow><Ctrl+X/c=Red>', False);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingWUXinFaCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWUXinFa.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBLingWUXinFaCloseInitialize(Sender: TObject);
begin
  with Sender as TAspDButton do
    SetImgIndex(g_WMainImages, 371);
end;

procedure TFrmDlg.DBLingWuXinFaKeyCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWuXinFaKey.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBLingWuXinFaNameClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with DWLingWuXinFaKey do begin
    if not Visible then begin
      GLeft := 186;
      GTop := 350;
      g_LingWuXinFa.nKeySelIndex := 0;
      g_LingWuXinFa.btKeyPage := 0;
      Visible := True;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_boHeroItemMoving then Exit;
  if m_boLingMeiEffect then Exit;
  if g_boItemMoving then begin
    if (g_MovingItem.Item.ClientItem.S.Name = '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then exit;
    if ((g_MovingItem.Item.ClientItem.S.StdMode = 44) and (g_MovingItem.Item.ClientItem.S.Shape = 253)) or CheckItemSpiritMedia(g_MovingItem.Item.ClientItem) then begin
      if g_MovingItem.Index >= 0 then begin
        ItemClickSound (g_MovingItem.Item.ClientItem.S);
        g_WaitingUseItem := g_MovingItem;
        g_WaitingUseItem.Index := -255;
        FrmMain.SendTakeOnLingMei (g_MovingItem.Item.ClientItem.MakeIndex, g_MovingItem.Item.ClientItem.S.Name);
        g_MovingItem.Item.ClientItem.S.Name := '';
        g_boItemMoving := FALSE;
      end else begin
        if g_MovingItem.Index = -255 then begin
          ItemClickSound (g_MovingItem.Item.ClientItem.S);
          g_LingMeiBelt := g_MovingItem.Item;
          g_MovingItem.Item.ClientItem.S.Name := '';
          g_boItemMoving := FALSE;
         end;
      end;
    end else begin
      DMessageDlg ('必须放入灵媒才有效！', [mbOK]);
    end;
  end else begin
    if (g_MovingItem.Item.ClientItem.S.Name <> '') or (g_WaitingUseItem.Item.ClientItem.S.Name <> '') then Exit;
    if g_LingMeiBelt.ClientItem.S.Name <> '' then begin
      ItemClickSound (g_LingMeiBelt.ClientItem.S);
      g_MovingItem.Index := -255;
      g_MovingItem.Item := g_LingMeiBelt;
      g_LingMeiBelt.ClientItem.S.Name := '';
      g_boItemMoving := TRUE;
    end;
  end;
{$IFEND}
end;

{$IF M2Version <> 2}
procedure TFrmDlg.UseLingMeiItem();
begin
  if not m_boLingMeiEffect then m_boLingMeiEffect := True;
  if g_LingMeiBelt.ClientItem.S.Name = '' then begin
    DScreen.AddChatBoardString('[请将灵媒装备在探索位]', clWhite, clBlue);
    Exit;
  end;
  if g_LingMeiBelt.ClientItem.Aura = 0 then begin
    DMessageDlg ('灵媒的灵气值已经不足，请补充灵气后再使用！', [mbOK]);
    Exit;
  end;
  FrmMain.SendUseUserLingMei(g_LingMeiBelt.ClientItem.MakeIndex, g_LingMeiBelt.ClientItem.S.Name);
end;
{$IFEND}
{$IF M2Version = 1}
procedure TFrmDlg.ShowQJPractice(boIsHero: Boolean);
var
  I: Integer;
  function GetMagicLevel(): Byte;                  
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_MySelf <> nil then begin
      for I:=0 to g_MagicList.Count - 1 do begin
        pm := PTClientMagic(g_MagicList[I]);
        if pm <> nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
  function GetHeroMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_HeroSelf <> nil then begin
      for I:=0 to g_HeroMagicList.Count - 1 do begin
        pm := PTClientMagic(g_HeroMagicList[I]);
        if pm <>nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
begin
  m_boQJPracticeHero := boIsHero;
  FillChar(g_QJPracticeItems, SizeOf(TClientEffecItem), #0);
  if m_boQJPracticeHero then begin
    m_sQJPracticeObjectName := g_HeroSelf.m_sUserName+'（英雄）';
    if (GetHeroMagicLevel < 64) or (g_boQJHeroDZXY99 and (GetHeroMagicLevel < 99)) then begin
      for I:=0 to g_HeroBagCount-1 do begin
        if (g_HeroItemArr[I].ClientItem.S.Name <> '') and (g_HeroItemArr[I].ClientItem.S.StdMode = 17) and
          (g_HeroItemArr[I].ClientItem.S.Shape = 238) then begin
          g_QJPracticeItems := g_HeroItemArr[I];
          g_HeroItemArr[I].ClientItem.S.Name := '';
          Break;
        end;
      end;
    end else if (GetHeroMagicLevel = 64) and not g_boQJHeroDZXY99 then begin
      for I:=0 to g_HeroBagCount-1 do begin
        if (g_HeroItemArr[I].ClientItem.S.Name <> '') and (g_HeroItemArr[I].ClientItem.S.StdMode = 44) and
          (g_HeroItemArr[I].ClientItem.S.Shape = 248) then begin
          g_QJPracticeItems := g_HeroItemArr[I];
          g_HeroItemArr[I].ClientItem.S.Name := '';
          Break;
        end;
      end;
    end;
  end else begin
    m_sQJPracticeObjectName := g_MySelf.m_sUserName;
    if (GetMagicLevel < 64) or (g_boQJDZXY99 and (GetMagicLevel < 99)) then begin
      for I:=6 to MAXBAGITEMCL-1 do begin
        if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 17) and
          (g_ItemArr[I].Item.ClientItem.S.Shape = 238) then begin
          g_QJPracticeItems := g_ItemArr[I].Item;
          g_ItemArr[I].Item.ClientItem.S.Name := '';
          Break;
        end;
      end;
    end else if (GetMagicLevel = 64) and not g_boQJHeroDZXY99 then begin
      for I:=6 to MAXBAGITEMCL-1 do begin
        if (g_ItemArr[I].Item.ClientItem.S.Name <> '') and (g_ItemArr[I].Item.ClientItem.S.StdMode = 44) and
          (g_ItemArr[I].Item.ClientItem.S.Shape = 248) then begin
          g_QJPracticeItems := g_ItemArr[I].Item;
          g_ItemArr[I].Item.ClientItem.S.Name := '';
          Break;
        end;
      end;
    end;
  end;
  DWQJPractice.Visible := True;
end;
{$IFEND}

procedure TFrmDlg.DBTitleManDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

{$IF M2Version <> 2}
function TFrmDlg.GetTitlePageIdx(btMaxPage: Byte): Byte;
begin
  Result := 0;
  if g_ClientHumTitles.nUseTitleIndex > 0 then begin
    if m_btTitlePage > 0 then begin
      if g_ClientHumTitles.nUseTitleIndex > btMaxPage then begin
        Result := g_ClientHumTitles.nUseTitleIndex - btMaxPage;
      end;
    end else begin
      Result := g_ClientHumTitles.nUseTitleIndex;
    end;
  end;
end;

function TFrmDlg.GetUserTitlePageIdx(): Byte;
begin
  Result := 0;
  if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
    if m_btUserTitlePage > 0 then begin
      if UserState1.wHumTitles.nUseTitleIndex > 4 then begin
        Result := UserState1.wHumTitles.nUseTitleIndex - 4;
      end;
    end else begin
      Result := UserState1.wHumTitles.nUseTitleIndex;
    end;
  end;
end;

procedure TFrmDlg.NGUpLevelState(boIsHero: Boolean);
var
	I, idx: Integer;
  pm: PTClientMagic;
  boIsNG: Boolean;
begin
	if boIsHero then begin
  	for I:=0 to 6-1 do begin
     	idx := _Max(I + HeroInternalForceMagicPage * 6, 0);
    	if (idx >= 0) and (idx < g_HeroInternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwHeroInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLHeroNGUpLevel1.Visible := True;
              DLHeroNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLHeroNGUpLevel2.Visible := True;
              DLHeroNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLHeroNGUpLevel3.Visible := True;
              DLHeroNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLHeroNGUpLevel4.Visible := True;
              DLHeroNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLHeroNGUpLevel5.Visible := True;
              DLHeroNGUpLevel5.Enabled := boIsNG;
            end;
            5: begin
              DLHeroNGUpLevel6.Visible := True;
              DLHeroNGUpLevel6.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLHeroNGUpLevel1.Visible := False;
          1: DLHeroNGUpLevel2.Visible := False;
          2: DLHeroNGUpLevel3.Visible := False;
          3: DLHeroNGUpLevel4.Visible := False;
          4: DLHeroNGUpLevel5.Visible := False;
          5: DLHeroNGUpLevel6.Visible := False;
        end;
      end;
    end;
  end else begin
  	for I:=0 to 6-1 do begin
     	idx := _Max(I + InternalForceMagicPage * 6, 0);
    	if (idx >= 0) and (idx < g_InternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_InternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLNGUpLevel1.Visible := True;
              DLNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLNGUpLevel2.Visible := True;
              DLNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLNGUpLevel3.Visible := True;
              DLNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLNGUpLevel4.Visible := True;
              DLNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLNGUpLevel5.Visible := True;
              DLNGUpLevel5.Enabled := boIsNG;
            end;
            5: begin
              DLNGUpLevel6.Visible := True;
              DLNGUpLevel6.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLNGUpLevel1.Visible := False;
          1: DLNGUpLevel2.Visible := False;
          2: DLNGUpLevel3.Visible := False;
          3: DLNGUpLevel4.Visible := False;
          4: DLNGUpLevel5.Visible := False;
          5: DLNGUpLevel6.Visible := False;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.NewNGUpLevelState(boIsHero: Boolean);
var
	I, idx: Integer;
  pm: PTClientMagic;
  boIsNG: Boolean;
begin
	if boIsHero then begin
  	for I:=0 to 5-1 do begin
     	idx := _Max(I + HeroInternalForceMagicPage * 5, 0);
    	if (idx >= 0) and (idx < g_HeroInternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwHeroInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLNewHeroNGUpLevel1.Visible := True;
              DLNewHeroNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLNewHeroNGUpLevel2.Visible := True;
              DLNewHeroNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLNewHeroNGUpLevel3.Visible := True;
              DLNewHeroNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLNewHeroNGUpLevel4.Visible := True;
              DLNewHeroNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLNewHeroNGUpLevel5.Visible := True;
              DLNewHeroNGUpLevel5.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLNewHeroNGUpLevel1.Visible := False;
          1: DLNewHeroNGUpLevel2.Visible := False;
          2: DLNewHeroNGUpLevel3.Visible := False;
          3: DLNewHeroNGUpLevel4.Visible := False;
          4: DLNewHeroNGUpLevel5.Visible := False;
        end;
      end;
    end;   
  end else begin
  	for I:=0 to 5-1 do begin
     	idx := _Max(I + InternalForceMagicPage * 5, 0);
    	if (idx >= 0) and (idx < g_InternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_InternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLNewNGUpLevel1.Visible := True;
              DLNewNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLNewNGUpLevel2.Visible := True;
              DLNewNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLNewNGUpLevel3.Visible := True;
              DLNewNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLNewNGUpLevel4.Visible := True;
              DLNewNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLNewNGUpLevel5.Visible := True;
              DLNewNGUpLevel5.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLNewNGUpLevel1.Visible := False;
          1: DLNewNGUpLevel2.Visible := False;
          2: DLNewNGUpLevel3.Visible := False;
          3: DLNewNGUpLevel4.Visible := False;
          4: DLNewNGUpLevel5.Visible := False;
        end;
      end;
    end;
  end;
end;
{$IFEND}

procedure TFrmDlg.DBTitle1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if (GetTitlePageIdx(4)-1 = Tag) and (GetTitlePageIdx(4) <> 0) then Exit;
    idx := _Max(Tag + m_btTitlePage * 4, 0);
    if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('你确定要将'+g_ClientHumTitles.ClientHumTitles[idx].sTitleName+'设置为当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[idx].MakeIndex, 1);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBTitleManClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  if g_ClientHumTitles.nUseTitleIndex > 0 then begin
    if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('是否取消当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].MakeIndex, 0);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(g_ClientHumTitles.ClientHumTitles) to High(g_ClientHumTitles.ClientHumTitles) do begin
      if g_ClientHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBPrevTitle then begin
    if m_btTitlePage > 0 then Dec (m_btTitlePage);
  end else begin
    if m_btTitlePage < (GetTitleCount+3) div 4 -1 then
       Inc (m_btTitlePage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBTitle1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      idx := _Max(Tag + m_btTitlePage * 4, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if g_ClientHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetTitlePageIdx(4)-1 = Tag) and (GetTitlePageIdx(4) <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                {g_ImgMixSurface.SetSize(d.Width, d.Height);   // 要调整
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale);}
                dsurface.DrawAlpha(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True, 124);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBUserTitle1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture; 
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      idx := _Max(Tag + m_btUserTitlePage * 4, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        if UserState1.wHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if UserState1.wHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetUserTitlePageIdx-1 = Tag) and (GetUserTitlePageIdx <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
                dsurface.FillRect(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight), clGray1, deInvMultiply);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;


procedure TFrmDlg.DBUserTitleManDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBUserPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(UserState1.wHumTitles.ClientHumTitles) to High(UserState1.wHumTitles.ClientHumTitles) do begin
      if UserState1.wHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBUserPrevTitle then begin
    if m_btUserTitlePage > 0 then Dec (m_btUserTitlePage);
  end else begin
    if m_btUserTitlePage < (GetTitleCount+3) div 4 -1 then
       Inc (m_btUserTitlePage);
  end;
  {$IFEND}
end;

{$IF M2Version <> 2}
function TFrmDlg.GetTitleInfo(TitleItem: TClientHumTitle; var List: TStringList; boNewState: Boolean): string;
var
  str1: string;
  sTime: string;
  sDesc: string;
  nTime: Integer;
begin
  with TitleItem do begin
    if (wDC > 0) and (not (AniCount in [5,10])) then str1 := '攻击上限+'+IntToStr(wDC) + '\';//2011030
    if wMC > 0 then str1 := str1 + '魔法上限+'+IntToStr(wMC) + '\';
    if wSC > 0 then str1 := str1 + '道术上限+'+IntToStr(wSC) + '\';
    if wHP > 0 then str1 := str1 + '生命上限+'+IntToStr(wHP) + '\';


    if nHours <> High(nHours) then begin
      nTime := nHours div 24;
      if nTime > 0 then begin
        sTime := '剩余时间：<'+IntToStr(nTime)+'/c=Yellow>天';
      end else begin
        sTime := '剩余时间：<'+IntToStr(nHours)+'/c=Yellow>小时';
      end;
    end;
    if boNewState then begin
      sDesc := '';
      List.Clear;
      List.Delimiter := '|';
      case TitleItem.Looks of
        1275: List.DelimitedText := '灌注玛法传奇力|量的水晶，可在|水晶特使处赠送|给女性玩家';
        else List.DelimitedText := GetNewStateTitleDesc(sTitleName);
      end;
    end else begin
      case TitleItem.Looks of
        1275: sDesc := '<灌注玛法传奇力量的水晶/c=Yellow>\<，可在水晶特使处赠送给/c=Yellow>\<女性玩家/c=Yellow>';
        else sDesc := '<'+GetTitleDesc(sTitleName)+'/c=Yellow>';
      end;
    end;
    if (wDura > 0) and (AniCount in [1,5]) then str1 := str1 + format('有效次数%d次', [wDura]);
    if sTitleName <> '' then
      Result := ForMat('<%s/c=Lime fontstyle=bold>\%s\%s\%s', [sTitleName, sDesc, str1, sTime]);
  end;
end;
{$IFEND}
procedure TFrmDlg.DBTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    if Sender = DBTitleMan then begin
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then str := '\(单击图标取消当前称号)' else str := '';
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1], g_MouseTitleList, False)+str, False);
        end;
      end;
    end else begin
      if (GetTitlePageIdx(4)-1 = Tag) and (GetTitlePageIdx(4) <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btTitlePage * 4, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then str := '\(单击图标设为当前称号)' else str := ''; 
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(g_ClientHumTitles.ClientHumTitles[idx], g_MouseTitleList, False)+str, False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBUserTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    if Sender = DBUserTitleMan then begin
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1], g_MouseTitleList, False), False);
        end;
      end;
    end else begin
      if (GetUserTitlePageIdx-1 = Tag) and (GetUserTitlePageIdx <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btUserTitlePage * 4, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[idx], g_MouseTitleList, False), False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWPFLingPaiDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWPFLingPai do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        AspTextureFont.TextOut(SurfaceX(GLeft)+50, SurfaceY(GTop)+123, clWhite, '・我任命的护花使者');
        AspTextureFont.TextOut(SurfaceX(GLeft)+194, SurfaceY(GTop)+354, $005894B8, Format('%d/%d', [m_btPJLingPaiPage+1, g_TitleHumNameList.Count div 5 + 1]));
        AspTextureFont.TextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+374, clYellow, '回收护花使者称号:');
        AspTextureFont.TextOut(SurfaceX(GLeft)+224, SurfaceY(GTop)+374, clWhite, m_sSelPJLingPaiName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCloseInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
  with Sender as TAspDButton do
  SetImgIndex(g_WMain2Images, 148);
  {$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiIcon1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if g_WUI1Images <> nil then begin
      idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
      if idx < g_TitleHumNameList.Count then begin
        pm := pTClientHumName (g_TitleHumNameList[idx]);
        if pm <> nil then begin
          if pm.boOnline then begin
            if MouseMoveing then d := g_WUI1Images.Images[1]
            else if Downed then d := g_WUI1Images.Images[2]
            else d := g_WUI1Images.Images[0];
          end else begin
            if MouseMoveing then d := g_WUI1Images.Images[7]
            else if Downed then d := g_WUI1Images.Images[8]
            else d := g_WUI1Images.Images[6];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if pm.boOnline then
          str := '在线'
        else str := '离线';
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, str, clYellow, False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWPFLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWPFLingPai.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DLPFLingPaiPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DLPFLingPaiPrev then begin
    if m_btPJLingPaiPage > 0 then
       Dec (m_btPJLingPaiPage);
  end else begin
    if m_btPJLingPaiPage < (g_TitleHumNameList.Count+4) div 5 - 1 then
       Inc (m_btPJLingPaiPage);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiName1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if MouseMoveing then AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, pm.sChrName)
        else if Downed then AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, pm.sChrName)
        else AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clWhite, pm.sChrName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCall1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      if Downed then AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '召唤', [fsUnderline])
      else AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '召唤', [fsUnderline]);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiMove1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  idx: Integer;
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      if Downed then AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '传送', [fsUnderline])
      else AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '传送', [fsUnderline]);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCall1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要召唤“'+pm.sChrName+'"到你身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(0, 0, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiMove1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要传送到“'+pm.sChrName+'"身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(0, 1, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiName1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if (pm.sChrName <> '') then begin
          m_sSelPJLingPaiName := pm.sChrName;
          DLabel12.Visible := True;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLabel12Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if mrOk = FrmDlg.DMessageDlg ('你确定回收“'+m_sSelPJLingPaiName+'”的称号吗？', [mbOk, mbCancel]) then begin
    frmMain.SendReFenghao(0, m_sSelPJLingPaiName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiTab1Click(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  with Sender as TAspDButton do
  ChangeZZLingPaiPage(Tag);
  {$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiTab1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if Tag <> m_btZZLingPaiPage then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 34 - AspTextureFont.TextWidth(Caption) div 2, SurfaceY(GTop) + 5, clWhite, clBlack, Caption);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 34 - AspTextureFont.TextWidth(Caption) div 2, SurfaceY(GTop) + 5, clWhite, clBlack, Caption);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWZZLingPaiDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWZZLingPai do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      case m_btZZLingPaiPage of
        0: begin
          d := WLib.Images[551];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+26, SurfaceY(GTop)+96, d.ClientRect, d, TRUE);
        end;
        2: begin
          AspTextureFont.TextOut(SurfaceX(GLeft)+50, SurfaceY(GTop)+123, clWhite, '・我任命的主宰龙卫');
          AspTextureFont.TextOut(SurfaceX(GLeft)+194, SurfaceY(GTop)+354, $005894B8, Format('%d/%d', [m_btZZHWLingPaiPage+1, g_HuWeiJunList.Count div 5 + 1]));
          AspTextureFont.TextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+374, clYellow, '回收近卫军称号:');
          AspTextureFont.TextOut(SurfaceX(GLeft)+224, SurfaceY(GTop)+374, clWhite, m_sSelHWLingPaiName);
        end;
      end;
    end;
  end;
{$IFEND}
end;
{$IF M2Version <> 2}
procedure TFrmDlg.ChangeZZLingPaiPage(btPage: Byte);
begin
  if m_btZZLingPaiPage <> btPage then begin
    m_btZZLingPaiPage := btPage;
    DBZZLingPaiMapName1.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName2.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName3.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName4.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName5.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName6.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName7.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName8.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName9.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName10.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName11.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName12.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName13.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName14.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName15.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName16.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName17.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName18.Visible := m_btZZLingPaiPage = 0;
    DMZZLingPai.Visible := m_btZZLingPaiPage = 1;
    DBZZLingPaiIcon1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon5.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName5.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall5.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove5.Visible := m_btZZLingPaiPage = 2;
    DLZZLingPaiPrev.Visible := m_btZZLingPaiPage = 2;
    DLZZLingPaiDown.Visible := m_btZZLingPaiPage = 2;
    if m_btZZLingPaiPage = 2 then
      DLabel15.Visible := m_sSelHWLingPaiName <> ''
    else DLabel15.Visible := False;
  end;
end;
{$IFEND}
procedure TFrmDlg.DBZZLingPaiTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
    SetImgIndex(g_WUI1Images, 555);
{$IFEND}
end;

procedure TFrmDlg.DMZZLingPaiDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  s18: string;
begin
  with DMZZLingPai do begin
    ElemCount:= (GHeight - 2) div LinesHeight;  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for i:= 0 to ElemCount - 1 do begin
      s18 := Lines.Strings[i+TopIndex];
      if s18 <> '' then begin
        if s18[1] = ' ' then
          AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clSilver, clBlack, s18)
        else
          AspTextureFont.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clWhite, clBlack, s18);
      end;
    end;
  end;
end;

procedure TFrmDlg.DMZZLingPaiInitialize(Sender: TObject);
begin
  DMZZLingPai.DScroll := DMZZLingPaiScrollBar;
  DMZZLingPai.DScroll.GTop := -19;
  DMZZLingPai.DScroll.GLeft := 322;
  DMZZLingPai.DScroll.GHeight := 304;
  DMZZLingPai.DScroll.GWidth := 16;
  DMZZLingPai.DScroll.Bar.GTop := 17;
  DMZZLingPai.DScroll.BDown.GTop := 287;
  DMZZLingPai.DScroll.BUp.GTop := 2;
  if FileExists(g_ParamDir+'\Data\explain4.dat') then begin
    try
      DMZZLingPai.Lines.LoadFromFile(g_ParamDir+'\Data\explain4.dat');
    except
    end;
  end;
end;

procedure TFrmDlg.DMZZLingPaiScrollBarInitialize(Sender: TObject);
begin
  DMZZLingPaiScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DMZZLingPaiScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DMZZLingPaiScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;

procedure TFrmDlg.DBZZLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if pm.boOnline then
          str := '在线'
        else str := '离线';
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, str, clYellow, False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiIcon1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if g_WUI1Images <> nil then begin
      idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
      if idx < g_HuWeiJunList.Count then begin
        pm := pTClientHumName (g_HuWeiJunList[idx]);
        if pm <> nil then begin
          if pm.boOnline then begin
            if MouseMoveing then d := g_WUI1Images.Images[1]
            else if Downed then d := g_WUI1Images.Images[2]
            else d := g_WUI1Images.Images[0];
          end else begin
            if MouseMoveing then d := g_WUI1Images.Images[7]
            else if Downed then d := g_WUI1Images.Images[8]
            else d := g_WUI1Images.Images[6];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiName1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if (pm.sChrName <> '') then begin
          m_sSelHWLingPaiName := pm.sChrName;
          DLabel15.Visible := True;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiName1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if MouseMoveing then AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, pm.sChrName)
        else if Downed then AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, pm.sChrName)
        else AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clWhite, pm.sChrName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiCall1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要召唤“'+pm.sChrName+'"到你身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(1, 0, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiCall1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      if Downed then AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '召唤', [fsUnderline])
      else AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '召唤', [fsUnderline]);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiCloseClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version <> 2}
  msg := MakeDefaultMsg (aa(CM_CLOSEDOMINATETOKEN, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg));
  DWZZLingPai.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMove1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要传送到“'+pm.sChrName+'"身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(1, 1, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMove1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  idx: Integer;
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      if Downed then AspTextureFont.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '传送', [fsUnderline])
      else AspTextureFont.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '传送', [fsUnderline]);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLabel15Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if mrOk = FrmDlg.DMessageDlg ('你确定回收“'+m_sSelHWLingPaiName+'”的称号吗？', [mbOk, mbCancel]) then begin
    frmMain.SendReFenghao(1, m_sSelHWLingPaiName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLabelProCapInitialize(Sender: TObject);
begin
  with TAspDControl(Sender) do begin
    GLeft := GLeft - 34;
  end;
end;

procedure TFrmDlg.DLZZLingPaiPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DLZZLingPaiPrev then begin
    if m_btZZHWLingPaiPage > 0 then
       Dec (m_btZZHWLingPaiPage);
  end else begin
    if m_btZZHWLingPaiPage < (g_HuWeiJunList.Count+4) div 5 - 1 then
       Inc (m_btZZHWLingPaiPage);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMapName1DirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
{$IF M2Version <> 2}
var
  d: TAsphyreLockableTexture;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if Caption <> '' then begin
        if Downed then begin
          d := WLib.Images[FaceIndex+1];
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 30 - AspTextureFont.TextWidth(Caption) div 2 + 1, SurfaceY(GTop) +6, $0048A4E8, clBlack, Caption);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          AspTextureFont.BoldTextOut (SurfaceX(GLeft) + 30 - AspTextureFont.TextWidth(Caption) div 2, SurfaceY(GTop)+ 5, $0048A4E8, clBlack, Caption);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMapName1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do
    SetImgIndex(g_WUI1Images, 552);
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMapName1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TAspDButton do begin
    if Caption <> '' then frmMain.SendSelDominatMap(Caption);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
const
	Lines = '<技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + InternalForceMagicPage * 6, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then
      	DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+10,
        			Format(Lines, [pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 5, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, True);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewHeroNGUpLevel1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version <> 2}
const
	Lines = '<技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+10,
        			Format(Lines, [pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + InternalForceMagicPage * 5, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewStateUserGuildNameClick(Sender: TObject; X, Y: Integer);
begin
  PlayScene.EdChat.Visible := TRUE;
  PlayScene.EdChat.Text := '/'+ UserState1.GuildName+' ';
  PlayScene.EdChat.SetFocus;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
end;

procedure TFrmDlg.DLNewStateUserNameClick(Sender: TObject; X, Y: Integer);
begin
  PlayScene.EdChat.Visible := TRUE;
  PlayScene.EdChat.Text := '/'+ UserState1.UserName+' ';
  PlayScene.EdChat.SetFocus;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
end;

procedure TFrmDlg.DLNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + InternalForceMagicPage * 6, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, False);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLHelpXinfaClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with TAspDLabel(Sender) do begin
    g_LingWuXinFa.btHelpPage := Tag;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, True);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLHeroNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
const
	Lines = '<技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TAspDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+10,
        			Format(Lines, [pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBPetLogCloseClick(Sender: TObject; X, Y: Integer);
begin
	DWPetLog.Visible := False;
  if g_PetDlg.sLogList <> nil then FreeAndNil(g_PetDlg.sLogList);
end;

procedure TFrmDlg.DWPetLogDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
	d: TAsphyreLockableTexture;
  I: Integer;
const
	sHapplyLine = '你的宠物的快乐度为:%d';
begin
	with DWPetLog do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    AspTextureFonts.SetFont('宋体', 14);
    AspTextureFont.TextOut(SurfaceX(GLeft)+160, SurfaceY(GTop)+16, clWhite, '宠物放养');
    AspTextureFonts.SetFont('宋体', 9);
    if g_PetDlg.sLogList <> nil then
    if g_PetDlg.sLogList.Count > 0 then begin
    	for I:=0 to g_PetDlg.sLogList.Count-1 do begin
      	AspTextureFont.TextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+50+I*17, clWhite, g_PetDlg.sLogList[I]);
      end;
    end;
    AspTextureFont.BoldTextOut(SurfaceX(GLeft)+60, SurfaceY(GTop)+266, clRed, clBlack, Format(sHapplyLine, [g_PetDlg.nHapply]));;
  end;
end;

procedure TFrmDlg.DLPetLogMoveClick(Sender: TObject; X, Y: Integer);
begin
	frmMain.SendPetMove;
end;

procedure TFrmDlg.DLPetLogPagePrvClick(Sender: TObject; X, Y: Integer);
begin
	if Sender = DLPetLogPagePrv then
  	frmMain.SendPetLogPage(0)
  else frmMain.SendPetLogPage(1);
end;

procedure TFrmDlg.SetChatDlgHeight(Value: Integer);
var
  nHeight: Integer;
begin
  DWBottomCenter.GHeight := Value;
  DWBottomCenter.GTop := g_D3DConfig.wScreenHeight - DWBottomCenter.GHeight;

  nHeight := (DWBottomCenter.GHeight - 54 - 16 - 32);
  DChatMemo.DrawLineCount := (nHeight div 12);
  if nHeight mod 12 > 0 then
    DChatMemo.DrawLineCount := DChatMemo.DrawLineCount + 1;
  DChatMemo.GHeight := nHeight;
  DChatMemo.DoResize;
  if DWBottomCenter.GHeight - (DChatMemo.GTop + DChatMemo.GHeight) < 20 then begin
    DChatMemo.DrawLineCount := DChatMemo.DrawLineCount - 1;
    DChatMemo.GHeight := nHeight;
    DChatMemo.DoResize;
  end;
end;

{$if M2Version<>2 }
procedure TFrmDlg.FactionMemberListFree();
var
  I: Integer;
  FactionMember: TFactionMember;
begin
  if g_FactionMeberList <> nil then begin
    for I:=0 to g_FactionMeberList.Count-1 do
    begin
      FactionMember :=  TFactionMember(g_FactionMeberList.Values[g_FactionMeberList.Keys[i]]);
      if FactionMember <> nil then FactionMember.Free;
    end;
    FreeAndNil(g_FactionMeberList);
  end;
end;

procedure TFrmDlg.ShowFactionDlg;
begin
  //DLFactionDlgExit.Visible := not g_FactionDlg.boIsAdmin;
  if g_FactionDlg.boPublic then
    DLFactionDlgExit.GLeft := DLFactionDlgKick.GLeft
  else DLFactionDlgExit.GLeft := 153;
  DLFactionDlgHome.Visible := not g_FactionDlg.boPublic;
  DLFactionDlgList.Visible := not g_FactionDlg.boPublic;

  DLFactionDlgEditNotice.Visible := g_FactionDlg.boIsAdmin;
  DLFactionDlgManageApply.Visible := g_FactionDlg.boIsAdmin;
  DLFactionDlgGetTitle.Visible := g_FactionDlg.boIsAdmin;
  DLFactionDlgKick.Visible := g_FactionDlg.boIsAdmin;
  FactionMemberListFree();
  g_FactionDlgHint := '师门公告';
  m_btFactionPage := 0;
  DWFactionDlg.Visible := TRUE;
end;

procedure TFrmDlg.AddFactionMember(DivisionMember: TClientDivisionMember; X, Y: Integer);
var
  FactionMember: TFactionMember;
  I: Integer;
begin
  FactionMember := TFactionMember.Create;
  FactionMember.m_Icon.GLeft := X;
  FactionMember.m_Icon.GTop := Y;
  if DivisionMember.DivisionMember.boStatus then
    FactionMember.m_Icon.SetImgIndex(g_WUI1Images, 0)
  else FactionMember.m_Icon.SetImgIndex(g_WUI1Images, 6);

  FactionMember.m_Name.GLeft := X+FactionMember.m_Icon.GWidth;
  FactionMember.m_Name.GTop := Y-2;
  FactionMember.m_Name.Caption := DivisionMember.sChrName;
  FactionMember.m_DivisionMember := DivisionMember;
  g_FactionMeberList.Add(IntToStr(Integer(FactionMember.m_Name)), FactionMember);
end;

/// <param name="boVisible">是否显示</param>
/// <param name="boIsXinFa">True为心法,False为内功</param>
procedure TFrmDlg.SetNewWinStateTabVisible(boVisible, boIsXinFa: Boolean);
begin
  if boVisible then begin//显示
    DBNewStateTab3.Visible := boIsXinFa or DBNewStateTab3.Visible; //心法
    DBNewStateTab2.Visible := True; //有心法或内功都显示
    DBNewStateTab1.Visible := True;
  end else begin
    if boIsXinFa then begin
      DBNewStateTab3.Visible := False;
      g_boXinFaType := False;
    end else begin
      DBNewStateTab2.Visible := False;
      DBNewStateTab1.Visible := False
    end;
  end;
end;

/// <param name="boVisible">是否显示</param>
procedure TFrmDlg.SetNewHeroStateTabVisible(boVisible: Boolean);
begin
  DBNewStateHeroTab2.Visible := boVisible;
  DBNewStateHeroTab1.Visible := boVisible;
end;

procedure TFrmDlg.DBFactionIconDirectPaint(Sender: TObject;
  dsurface: TAsphyreCanvas);
var
  d: TAsphyreLockableTexture;
begin
	with Sender as TAspDButton do begin
    if WLib <> nil then begin
      if MouseMoveing then d := WLib.Images[FaceIndex+1]
      else if Downed then
        d := WLib.Images[FaceIndex+2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBFactionIconMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  with Sender as TAspDButton do begin
    if FaceIndex = 0 then
      DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, '在线', clYellow, False)
    else DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, '离线', clYellow, False);
  end;
end;

// new copy
procedure TFrmDlg.DLFactionNameClick(Sender: TObject; X, Y: Integer);
var
  ShowText: string;
  FactionMember: TFactionMember;
  I: Integer;
  sSex: string[2];
begin
  with Sender as TAspDLabel do begin
    for I:=0 to g_FactionMeberList.Count-1 do begin
      FactionMember := TFactionMember(g_FactionMeberList.Values[g_FactionMeberList.Keys[i]]);
      if FactionMember <> nil then begin
        FactionMember.m_Name.UpColor := clWhite;
        FactionMember.m_Name.HotColor := clWhite;
      end;
    end;
    FactionMember := TFactionMember(g_FactionMeberList.GetValues(IntToStr(Integer(Sender))));
    if FactionMember <> nil then begin
      with FactionMember.m_DivisionMember.DivisionMember do begin
        if btGender = 0 then
          sSex := '男'
        else sSex := '女';
        if FactionMember.m_DivisionMember.DivisionMember.boStatus then begin
          ShowText := Format('状态        在线\性别        %s\职业        %s\等级        %d\'+
                             '贡献人气值  %d', [sSex, GetJobName(btJob), nLevel, nContribution]);
        end else begin
          ShowText := Format('状态        离线\性别        %s\职业        %s\等级        %d\'+
                             '贡献人气值  %d\上次登陆    %s', [sSex, GetJobName(btJob), nLevel, nContribution, FormatDateTime('yyyy年mm月dd日', dLogonTime)]);
        end;
        DScreen.ShowHint(SurfaceX(GLeft)+20, SurfaceY(GTop), ShowText, clYellow, False);
        g_FactionMember.SelMemberName := FactionMember.m_DivisionMember.sChrName;
        UpColor := clYellow;
        HotColor := clYellow;
        PlayScene.EdChat.Visible := TRUE;
        PlayScene.EdChat.Text := '/'+ FactionMember.m_DivisionMember.sChrName+' ';
        PlayScene.EdChat.SetFocus;
        SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
        PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowFactionDlgEditNotice();
var
  d: TAsphyreLockableTexture;
  i: integer;
  data: string;
begin
  with DWFactionDlgEditNotice do begin
    GLeft := 146;
    GTop := 78;
    HideAllControls;
    DWFactionDlgEditNotice.ShowModal;

    Memo.Left := SurfaceX(GLeft+27);
    Memo.Top  := SurfaceY(GTop+56);
    Memo.Width := 424;
    Memo.Height := 202;
    if g_FactionDlg.NoticeList <> nil then
    Memo.Lines.Assign (g_FactionDlg.NoticeList);
    Memo.Visible := TRUE;

    while TRUE do begin
      if not Visible then break;
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then exit;
    end;

    DWFactionDlgEditNotice.Visible := FALSE;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then begin
      data := '';
      if Memo.Lines.Count > 0 then //20080629
      for i:=0 to Memo.Lines.Count-1 do begin
        if Memo.Lines[i] = '' then
          data := data + Memo.Lines[i] + ' '#13
        else data := data + Memo.Lines[i] + #13;
      end;
      if Length(data) > 964 then begin
        data := Copy (data, 1, 964);
        DMessageDlg ('公告内容超过限制大小，公告内容将被截短！', [mbOk]);
      end;
      FrmMain.SendFactionDlgUpdateNotice (data);
    end;
  end;
end;

{$IFEND}

{$IF M2Version = 1}
procedure TFrmDlg.ChangeNGPointPage();
begin
  //32 12
  DLNewWinPointName1.Caption := GetPulseName(StatePulsePage,0);
  DLNewWinPointName2.Caption := GetPulseName(StatePulsePage,1);
  DLNewWinPointName3.Caption := GetPulseName(StatePulsePage,2);
  DLNewWinPointName4.Caption := GetPulseName(StatePulsePage,3);
  DLNewWinPointName5.Caption := GetPulseName(StatePulsePage,4);
  case StatePulsePage of
    0: DBNewWinPointPractice.Caption := '修炼冲脉';
    1: DBNewWinPointPractice.Caption := '修炼阴跷';
    2: DBNewWinPointPractice.Caption := '修炼阴维';
    3: DBNewWinPointPractice.Caption := '修炼任脉';
    4: DBNewWinPointPractice.Caption := '修炼奇经';
  end;
  DBNewWinPointPractice.Enabled := not (g_HumanPulseArr[StatePulsePage].nPulseLevel >= 5) or ((g_HumanPulseArr[StatePulsePage].nPulsePoint = 0) and (StatePulsePage = 4));
  case StatePulsePage of
    0: begin
      DBNewWinPointIcon1.GLeft := 69;
      DBNewWinPointIcon1.GTop := 42;
      DBNewWinPointIcon2.GLeft := 68;
      DBNewWinPointIcon2.GTop := 71;
      DBNewWinPointIcon3.GLeft := 70;
      DBNewWinPointIcon3.GTop := 96;
      DBNewWinPointIcon4.GLeft := 77;
      DBNewWinPointIcon4.GTop := 118;
      DBNewWinPointIcon5.GLeft := 84;
      DBNewWinPointIcon5.GTop := 100;
      DLNewWinPointName1.GLeft := 113;
      DLNewWinPointName1.GTop := 47;
      DLNewWinPointName2.GLeft := 112;
      DLNewWinPointName2.GTop := 76;
      DLNewWinPointName3.GLeft := 34;
      DLNewWinPointName3.GTop := 101;
      DLNewWinPointName4.GLeft := 38;
      DLNewWinPointName4.GTop := 123;
      DLNewWinPointName5.GLeft := 118;
      DLNewWinPointName5.GTop := 104;
    end;
    1: begin
      DBNewWinPointIcon1.GLeft := 80;
      DBNewWinPointIcon1.GTop := 36;
      DBNewWinPointIcon2.GLeft := 80;
      DBNewWinPointIcon2.GTop := 76;
      DBNewWinPointIcon3.GLeft := 85;
      DBNewWinPointIcon3.GTop := 116;
      DBNewWinPointIcon4.GLeft := 93;
      DBNewWinPointIcon4.GTop := 155;
      DBNewWinPointIcon5.GLeft := 96;
      DBNewWinPointIcon5.GTop := 196;
      DLNewWinPointName1.GLeft := 36;
      DLNewWinPointName1.GTop := 41;
      DLNewWinPointName2.GLeft := 36;
      DLNewWinPointName2.GTop := 80;
      DLNewWinPointName3.GLeft := 123;
      DLNewWinPointName3.GTop := 120;
      DLNewWinPointName4.GLeft := 56;
      DLNewWinPointName4.GTop := 158;
      DLNewWinPointName5.GLeft := 61;
      DLNewWinPointName5.GTop := 201;
    end;
    2: begin
      DBNewWinPointIcon1.GLeft := 80;
      DBNewWinPointIcon1.GTop := 50;
      DBNewWinPointIcon2.GLeft := 74;
      DBNewWinPointIcon2.GTop := 80;
      DBNewWinPointIcon3.GLeft := 73;
      DBNewWinPointIcon3.GTop := 118;
      DBNewWinPointIcon4.GLeft := 69;
      DBNewWinPointIcon4.GTop := 151;
      DBNewWinPointIcon5.GLeft := 66;
      DBNewWinPointIcon5.GTop := 187;
      DLNewWinPointName1.GLeft := 35;
      DLNewWinPointName1.GTop := 53;
      DLNewWinPointName2.GLeft := 115;
      DLNewWinPointName2.GTop := 85;
      DLNewWinPointName3.GLeft := 33;
      DLNewWinPointName3.GTop := 122;
      DLNewWinPointName4.GLeft := 103;
      DLNewWinPointName4.GTop := 156;
      DLNewWinPointName5.GLeft := 99;
      DLNewWinPointName5.GTop := 192;
    end;
    3: begin
      DBNewWinPointIcon1.GLeft := 80;
      DBNewWinPointIcon1.GTop := 32;
      DBNewWinPointIcon2.GLeft := 81;
      DBNewWinPointIcon2.GTop := 52;
      DBNewWinPointIcon3.GLeft := 81;
      DBNewWinPointIcon3.GTop := 73;
      DBNewWinPointIcon4.GLeft := 80;
      DBNewWinPointIcon4.GTop := 97;
      DBNewWinPointIcon5.GLeft := 81;
      DBNewWinPointIcon5.GTop := 121;
      DLNewWinPointName1.GLeft := 34;
      DLNewWinPointName1.GTop := 37;
      DLNewWinPointName2.GLeft := 126;
      DLNewWinPointName2.GTop := 57;
      DLNewWinPointName3.GLeft := 36;
      DLNewWinPointName3.GTop := 79;
      DLNewWinPointName4.GLeft := 125;
      DLNewWinPointName4.GTop := 102;
      DLNewWinPointName5.GLeft := 37;
      DLNewWinPointName5.GTop := 126;
    end;
    4: begin
      DBNewWinPointIcon1.GLeft := 79;
      DBNewWinPointIcon1.GTop := 28;
      DBNewWinPointIcon2.GLeft := 124;
      DBNewWinPointIcon2.GTop := 114;
      DBNewWinPointIcon3.GLeft := 35;
      DBNewWinPointIcon3.GTop := 113;
      DBNewWinPointIcon4.GLeft := 97;
      DBNewWinPointIcon4.GTop := 197;
      DBNewWinPointIcon5.GLeft := 61;
      DBNewWinPointIcon5.GTop := 198;
      DLNewWinPointName1.GLeft := 36;
      DLNewWinPointName1.GTop := 36;
      DLNewWinPointName2.GLeft := 100;
      DLNewWinPointName2.GTop := 106;
      DLNewWinPointName3.GLeft := 58;
      DLNewWinPointName3.GTop := 128;
      DLNewWinPointName4.GLeft := 74;
      DLNewWinPointName4.GTop := 190;
      DLNewWinPointName5.GLeft := 35;
      DLNewWinPointName5.GTop := 202;
    end;
  end;
end;

procedure TFrmDlg.ChangeHeroNGPointPage();
begin
  //32 12
  DLNewHeroPointName1.Caption := GetPulseName(HeroStatePulsePage,0);
  DLNewHeroPointName2.Caption := GetPulseName(HeroStatePulsePage,1);
  DLNewHeroPointName3.Caption := GetPulseName(HeroStatePulsePage,2);
  DLNewHeroPointName4.Caption := GetPulseName(HeroStatePulsePage,3);
  DLNewHeroPointName5.Caption := GetPulseName(HeroStatePulsePage,4);
  case HeroStatePulsePage of
    0: DBNewHeroPointPractice.Caption := '修炼冲脉';
    1: DBNewHeroPointPractice.Caption := '修炼阴跷';
    2: DBNewHeroPointPractice.Caption := '修炼阴维';
    3: DBNewHeroPointPractice.Caption := '修炼任脉';
    4: DBNewHeroPointPractice.Caption := '修炼奇经';
  end;
  DBNewHeroPointPractice.Enabled := not (g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel >= 5) or ((g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0) and (HeroStatePulsePage = 4));
  case HeroStatePulsePage of
    0: begin
      DBNewHeroPointIcon1.GLeft := 69;
      DBNewHeroPointIcon1.GTop := 42;
      DBNewHeroPointIcon2.GLeft := 68;
      DBNewHeroPointIcon2.GTop := 71;
      DBNewHeroPointIcon3.GLeft := 70;
      DBNewHeroPointIcon3.GTop := 96;
      DBNewHeroPointIcon4.GLeft := 77;
      DBNewHeroPointIcon4.GTop := 118;
      DBNewHeroPointIcon5.GLeft := 84;
      DBNewHeroPointIcon5.GTop := 100;
      DLNewHeroPointName1.GLeft := 113;
      DLNewHeroPointName1.GTop := 47;
      DLNewHeroPointName2.GLeft := 112;
      DLNewHeroPointName2.GTop := 76;
      DLNewHeroPointName3.GLeft := 34;
      DLNewHeroPointName3.GTop := 101;
      DLNewHeroPointName4.GLeft := 38;
      DLNewHeroPointName4.GTop := 123;
      DLNewHeroPointName5.GLeft := 118;
      DLNewHeroPointName5.GTop := 104;
    end;
    1: begin
      DBNewHeroPointIcon1.GLeft := 80;
      DBNewHeroPointIcon1.GTop := 36;
      DBNewHeroPointIcon2.GLeft := 80;
      DBNewHeroPointIcon2.GTop := 76;
      DBNewHeroPointIcon3.GLeft := 85;
      DBNewHeroPointIcon3.GTop := 116;
      DBNewHeroPointIcon4.GLeft := 93;
      DBNewHeroPointIcon4.GTop := 155;
      DBNewHeroPointIcon5.GLeft := 96;
      DBNewHeroPointIcon5.GTop := 196;
      DLNewHeroPointName1.GLeft := 36;
      DLNewHeroPointName1.GTop := 41;
      DLNewHeroPointName2.GLeft := 36;
      DLNewHeroPointName2.GTop := 80;
      DLNewHeroPointName3.GLeft := 123;
      DLNewHeroPointName3.GTop := 120;
      DLNewHeroPointName4.GLeft := 56;
      DLNewHeroPointName4.GTop := 158;
      DLNewHeroPointName5.GLeft := 61;
      DLNewHeroPointName5.GTop := 201;
    end;
    2: begin
      DBNewHeroPointIcon1.GLeft := 80;
      DBNewHeroPointIcon1.GTop := 50;
      DBNewHeroPointIcon2.GLeft := 74;
      DBNewHeroPointIcon2.GTop := 80;
      DBNewHeroPointIcon3.GLeft := 73;
      DBNewHeroPointIcon3.GTop := 118;
      DBNewHeroPointIcon4.GLeft := 69;
      DBNewHeroPointIcon4.GTop := 151;
      DBNewHeroPointIcon5.GLeft := 66;
      DBNewHeroPointIcon5.GTop := 187;
      DLNewHeroPointName1.GLeft := 35;
      DLNewHeroPointName1.GTop := 53;
      DLNewHeroPointName2.GLeft := 115;
      DLNewHeroPointName2.GTop := 85;
      DLNewHeroPointName3.GLeft := 33;
      DLNewHeroPointName3.GTop := 122;
      DLNewHeroPointName4.GLeft := 103;
      DLNewHeroPointName4.GTop := 156;
      DLNewHeroPointName5.GLeft := 99;
      DLNewHeroPointName5.GTop := 192;
    end;
    3: begin
      DBNewHeroPointIcon1.GLeft := 80;
      DBNewHeroPointIcon1.GTop := 32;
      DBNewHeroPointIcon2.GLeft := 81;
      DBNewHeroPointIcon2.GTop := 52;
      DBNewHeroPointIcon3.GLeft := 81;
      DBNewHeroPointIcon3.GTop := 73;
      DBNewHeroPointIcon4.GLeft := 80;
      DBNewHeroPointIcon4.GTop := 97;
      DBNewHeroPointIcon5.GLeft := 81;
      DBNewHeroPointIcon5.GTop := 121;
      DLNewHeroPointName1.GLeft := 34;
      DLNewHeroPointName1.GTop := 37;
      DLNewHeroPointName2.GLeft := 126;
      DLNewHeroPointName2.GTop := 57;
      DLNewHeroPointName3.GLeft := 36;
      DLNewHeroPointName3.GTop := 79;
      DLNewHeroPointName4.GLeft := 125;
      DLNewHeroPointName4.GTop := 102;
      DLNewHeroPointName5.GLeft := 37;
      DLNewHeroPointName5.GTop := 126;
    end;
    4: begin
      DBNewHeroPointIcon1.GLeft := 79;
      DBNewHeroPointIcon1.GTop := 28;
      DBNewHeroPointIcon2.GLeft := 124;
      DBNewHeroPointIcon2.GTop := 114;
      DBNewHeroPointIcon3.GLeft := 35;
      DBNewHeroPointIcon3.GTop := 113;
      DBNewHeroPointIcon4.GLeft := 97;
      DBNewHeroPointIcon4.GTop := 197;
      DBNewHeroPointIcon5.GLeft := 61;
      DBNewHeroPointIcon5.GTop := 198;
      DLNewHeroPointName1.GLeft := 36;
      DLNewHeroPointName1.GTop := 36;
      DLNewHeroPointName2.GLeft := 100;
      DLNewHeroPointName2.GTop := 106;
      DLNewHeroPointName3.GLeft := 58;
      DLNewHeroPointName3.GTop := 128;
      DLNewHeroPointName4.GLeft := 74;
      DLNewHeroPointName4.GTop := 190;
      DLNewHeroPointName5.GLeft := 35;
      DLNewHeroPointName5.GTop := 202;
    end;
  end;
end;

{$IFEND}


procedure TFrmDlg.NewMagicBtnNotVisible;
begin
  if DBNewJDSee.Visible then DBNewJDSee.Visible := False;
  if DBNewHBExp.Visible then DBNewHBExp.Visible := False;
  if DBNewJQExp.Visible then DBNewJQExp.Visible := False;
end;

end.

