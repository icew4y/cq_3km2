unit FState;
//本单元提供系统中的所有对话框显示
interface

uses
  Windows, SysUtils, StrUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, DXDraws, Grids, Grobal2, clFunc, hUtil32, cliUtil,EDcode, soundUtil, actor, IniFiles, PathFind,
  DWinCtl, Share, Wil, uDScrollBar, uDListView, uDTreeView{.$IF Version<>0,DataUnit}{.$IFEND}, EDcodeUnit,
  uDScrollBox, uDLabel, uDCheckBox, uDComboBox, uDChatMemo;

const
   BOTTOMBOARD800 = 371;//主操作介面图形号
   BOTTOMBOARD1024 = 2;//主操作介面图形号
   //VIEWCHATLINE = 9;
   MAXSTATEPAGE = 4;
   LISTLINEHEIGHT = 13;
   MAXMENU = 10;

   STRLINS = 50;

   AdjustAbilHints : array[0..8] of string = (
      '攻击点',
      '魔法点',
      '道法点',
      '防御点',
      '魔防点',
      '生命值',
      '能量值',
      '准确点',
      '敏捷点'
   );
type
  {$IF M2Version = 2}
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmPlayDrink);
  {$ELSE}
  TSpotDlgMode = (dmSell, dmRepair, dmStorage, dmPlayDrink, dmArmsTear, dmArmsExchange);//20100708
  TSkillMemoClickPoint = record
    rc: TRect;
    Ident: Word;
  end;
  pTSkillMemoClickPoint = ^TSkillMemoClickPoint;
  {$IFEND}

  TClickPoint = record
     rc: TRect;
     RStr: string;
     TStr: string; //标题
  end;
  pTClickPoint = ^TClickPoint;
  TClickSLPoint = record
     rc: TRect;
     RStr: string;  //里面有唯一标实
     SStr: string;  //真正内容
  end;
  pTClickSLPoint = ^TClickSLPoint;
  TDiceInfo = record
    nDicePoint :Integer;      //0x66C
    nPlayPoint :Integer;//0x670 当前骰子点数
    nX         :Integer;      //0x674
    nY         :Integer;      //0x678
    n67C       :Integer;      //0x67C
    n680       :Integer;      //0x680
    dwPlayTick :LongWord; //0x684
  end;
  pTDiceInfo = ^TDiceInfo;
  
  TMissionLabel = class(TDTreeNode)
  public
    m_sCmd: string;
  end;

  {$IF M2Version <> 2}
  TFactionMember = class
  public
    m_Icon: TDButton;
    m_Name: TDLabel;
    m_DivisionMember: TClientDivisionMember;
    constructor Create();
    destructor Destroy; override;
  end;
  {$IFEND}

  TFrmDlg = class(TForm)
    DStateWin: TDWindow;
    DBackground: TDWindow;
    DItemBag: TDWindow;
    DMyState: TDButton;
    DMyBag: TDButton;
    DMyMagic: TDButton;
    DOption: TDButton;
    DGold: TDButton;
    DPrevState: TDButton;
    DItemsUpBut: TDButton;
    DCloseBag: TDButton;
    DCloseState: TDButton;
    DLogIn: TDWindow;
    DNewAccount: TDWindow;
    DSelectChr: TDWindow;
    DscSelect1: TDButton;
    DscSelect2: TDButton;
    DscStart: TDButton;
    DscNewChr: TDButton;
    DscEraseChr: TDButton;
    DscCredits: TDButton;
    DscExit: TDButton;
    DCreateChr: TDWindow;
    DItemGrid: TDGrid;
    DMsgDlg: TDWindow;
    DMsgDlgOk: TDButton;
    DMsgDlgYes: TDButton;
    DMsgDlgCancel: TDButton;
    DMsgDlgNo: TDButton;
    DNextState: TDButton;
    DSWNecklace: TDButton;
    DSWLight: TDButton;
    DSWArmRingR: TDButton;
    DSWArmRingL: TDButton;
    DSWRingR: TDButton;
    DSWRingL: TDButton;
    DSWWeapon: TDButton;
    DSWDress: TDButton;
    DSWHelmet: TDButton;
    DSWBujuk: TDButton;
    DSWBelt: TDButton;
    DSWBoots: TDButton;
    DSWCharm: TDButton;

    DBelt1: TDButton;
    DBelt2: TDButton;
    DBelt3: TDButton;
    DBelt4: TDButton;
    DBelt5: TDButton;
    DBelt6: TDButton;
    DChgPw: TDWindow;
    DChgpwOk: TDButton;
    DChgpwCancel: TDButton;
    DMerchantDlg: TDWindow;
    DMerchantDlgClose: TDButton;
    DMenuDlg: TDWindow;
    DMenuPrev: TDButton;
    DMenuNext: TDButton;
    DMenuBuy: TDButton;
    DMenuClose: TDButton;
    DSellDlg: TDWindow;
    DSellDlgOk: TDButton;
    DSellDlgClose: TDButton;
    DSellDlgSpot: TDButton;
    DStMag1: TDButton;
    DStMag2: TDButton;
    DStMag3: TDButton;
    DStMag4: TDButton;
    DStMag5: TDButton;
    DKeySelDlg: TDWindow;
    DKsIcon: TDButton;
    DKsF1: TDButton;
    DKsF2: TDButton;
    DKsF3: TDButton;
    DKsF4: TDButton;
    DKsNone: TDButton;
    DKsOk: TDButton;
    DBotGroup: TDButton;
    DBotTrade: TDButton;
    DBotMiniMap: TDButton;
    DBotFriend: TDButton;
    DGroupDlg: TDWindow;
    DGrpAllowGroup: TDButton;
    DGrpDlgClose: TDButton;
    DGrpCreate: TDButton;
    DGrpAddMem: TDButton;
    DGrpDelMem: TDButton;
    DBotLogout: TDButton;
    DBotExit: TDButton;
    DBotGuild: TDButton;
    DStPageUp: TDButton;
    DStPageDown: TDButton;
    DDealRemoteDlg: TDWindow;
    DDealDlg: TDWindow;
    DDRGrid: TDGrid;
    DDGrid: TDGrid;
    DDealOk: TDButton;
    DDealClose: TDButton;
    DDGold: TDButton;
    DDRGold: TDButton;
    DSelServerDlg: TDWindow;
    DUserState1: TDWindow;
    DCloseUS1: TDButton;
    DWeaponUS1: TDButton;
    DHelmetUS1: TDButton;
    DNecklaceUS1: TDButton;
    DDressUS1: TDButton;
    DLightUS1: TDButton;
    DArmringRUS1: TDButton;
    DRingRUS1: TDButton;
    DArmringLUS1: TDButton;
    DRingLUS1: TDButton;

    DBujukUS1: TDButton;
    DBeltUS1: TDButton;
    DBootsUS1: TDButton;
    DCharmUS1: TDButton;
    DGuildDlg: TDWindow;
    DGDHome: TDButton;
    DGDList: TDButton;
    DGDChat: TDButton;
    DGDAddMem: TDButton;
    DGDDelMem: TDButton;
    DGDEditNotice: TDButton;
    DGDEditGrade: TDButton;
    DGDAlly: TDButton;
    DGDBreakAlly: TDButton;
    DGDWar: TDButton;
    DGDCancelWar: TDButton;
    DGDUp: TDButton;
    DGDDown: TDButton;
    DGDClose: TDButton;
    DGuildEditNotice: TDWindow;
    DGEClose: TDButton;
    DGEOk: TDButton;
    DAdjustAbility: TDWindow;
    DPlusDC: TDButton;
    DPlusMC: TDButton;
    DPlusSC: TDButton;
    DPlusAC: TDButton;
    DPlusMAC: TDButton;
    DPlusHP: TDButton;
    DPlusMP: TDButton;
    DPlusHit: TDButton;
    DPlusSpeed: TDButton;
    DMinusDC: TDButton;
    DMinusMC: TDButton;
    DMinusSC: TDButton;
    DMinusAC: TDButton;
    DMinusMAC: TDButton;
    DMinusMP: TDButton;
    DMinusHP: TDButton;
    DMinusHit: TDButton;
    DMinusSpeed: TDButton;
    DAdjustAbilClose: TDButton;
    DAdjustAbilOk: TDButton;
    DBotPlusAbil: TDButton;
    DKsF5: TDButton;
    DKsF6: TDButton;
    DKsF7: TDButton;
    DKsF8: TDButton;
    DKsConF1: TDButton;
    DKsConF2: TDButton;
    DKsConF3: TDButton;
    DKsConF4: TDButton;
    DKsConF5: TDButton;
    DKsConF6: TDButton;
    DKsConF7: TDButton;
    DKsConF8: TDButton;
    DBotMemo: TDButton;
    DFriendDlg: TDWindow;
    DFrdClose: TDButton;
    DButtonHP: TDButton;
    DButtonMP: TDButton;
    DBRefusePublicChat: TDButton;
    DBRefuseCRY: TDButton;
    DBRefuseWHISPER: TDButton;
    DBRefuseguild: TDButton;
    DBAutoCRY: TDButton;
    DBCallHero: TDButton;
    DBHeroState: TDButton;
    DBHeroPackage: TDButton;
    Challenge: TDButton;
    CharacterSranking: TDButton;
    DStateHero: TDWindow;
    DCloseHeroState: TDButton;
    DSHHelmet: TDButton;
    DSHWeapon: TDButton;
    DSHDress: TDButton;
    DPrevStateHero: TDButton;
    DSHArmRingR: TDButton;
    DSHRingR: TDButton;
    DNextStateHero: TDButton;
    DSHNecklace: TDButton;
    DSHLight: TDButton;
    DSHArmRingL: TDButton;
    DSHRingL: TDButton;
    DStMagHero1: TDButton;
    DStMagHero2: TDButton;
    DStMagHero3: TDButton;
    DStMagHero4: TDButton;
    DStMagHero5: TDButton;
    DSHPageUp: TDButton;
    DSHPageDown: TDButton;
    DSHBujuk: TDButton;
    DSHBelt: TDButton;
    DSHBoots: TDButton;
    DSHCharm: TDButton;
    DHeroItemBag: TDWindow;
    DHeroItemGrid: TDGrid;
    DHeroItemGridClose: TDButton;
    DHeroIcon: TDWindow;
    DHeroRoleIcon: TDButton;
    DShop: TDWindow;
    DShopClose: TDButton;
    DShopImgLogo: TDButton;
    DShopDecorate: TDButton;
    DShopSupplies: TDButton;
    DshopStrengthen: TDButton;
    DShopFriend: TDButton;
    DShopCapacity: TDButton;
    DShopPrev: TDButton;
    DShopNext: TDButton;
    DShopBuy: TDButton;
    DShopPresent: TDButton;
    DShopClose1: TDButton;
    DShopImg1: TDButton;
    DShopImg2: TDButton;
    DShopImg3: TDButton;
    DShopImg4: TDButton;
    DShopImg5: TDButton;
    DShopImg6: TDButton;
    DShopImg7: TDButton;
    DShopImg8: TDButton;
    DShopImg9: TDButton;
    DShopImg10: TDButton;
    DShopSpeciallyImg1: TDButton;
    DShopSpeciallyImg2: TDButton;
    DShopSpeciallyImg3: TDButton;
    DShopSpeciallyImg4: TDButton;
    DShopSpeciallyImg5: TDButton;
    DWLevelOrder: TDWindow;
    DLevelOrderClose: TDButton;
    DIndividualOrder: TDButton;
    DHeroOrder: TDButton;
    DMasterOrder: TDButton;
    DColonyHeroOrder: TDButton;
    DWarriorOrder: TDButton;
    DWizerdOrder: TDButton;
    DTaoistOrder: TDButton;
    DHeroAllOrder: TDButton;
    DWarriorHeroOrder: TDButton;
    DWizerdHeroOrder: TDButton;
    DTaoistHeroOrder: TDButton;
    DLevelOrderIndex: TDButton;
    DLevelOrderPrev: TDButton;
    DLevelOrderNext: TDButton;
    DLevelOrderLastPage: TDButton;
    DMyLevelOrder: TDButton;
    DBoxs: TDWindow;
    DBoxsBelt1: TDButton;
    DBoxsBelt2: TDButton;
    DBoxsBelt3: TDButton;
    DBoxsBelt4: TDButton;
    DBoxsBelt5: TDButton;
    DBoxsBelt6: TDButton;
    DBoxsBelt7: TDButton;
    DBoxsBelt8: TDButton;
    DBoxsBelt9: TDButton;
    DBoxsTautology: TDButton;
    DLieDragon: TDWindow;
    DLieDragonClose: TDButton;
    DLieDragonPrevPage: TDButton;
    DLieDragonNextPage: TDButton;
    DGoToLieDragon: TDButton;
    DLieDragonNpc: TDWindow;
    DLieDragonNpcClose: TDButton;
    DItemsUp: TDWindow;
    DItemsUpClose: TDButton;
    DItemsUpBelt1: TDButton;
    DItemsUpBelt2: TDButton;
    DItemsUpBelt3: TDButton;
    DItemsUpOk: TDButton;
    DBInternet: TDButton;
    DGameGirdExchange: TDButton;
    DWSellOff: TDWindow;
    DSellOffClose: TDButton;
    DSellOffOk: TDButton;
    DSellOffCancel: TDButton;
    DSellOffItemGrid: TDGrid;
    DWSellOffList: TDWindow;
    DSellOffListColse: TDButton;
    DEditSellOffName: TDButton;
    DEditSellOffNum: TDButton;
    DSellOffItem1: TDButton;
    DSellOffItem2: TDButton;
    DSellOffItem3: TDButton;
    DSellOffItem4: TDButton;
    DSellOffItem5: TDButton;
    DSellOffItem6: TDButton;
    DSellOffItem7: TDButton;
    DSellOffItem8: TDButton;
    DSellOffItem9: TDButton;
    DSellOffItem0: TDButton;
    DSellOffListCancel: TDButton;
    DSellOffBuyCancel: TDButton;
    DSellOffBuy: TDButton;
    DWGameGold: TDButton;
    DStMag6: TDButton;
    DStMagHero6: TDButton;
    DWiGetHero: TDWindow;
    DGetHeroClose: TDButton;
    DBGlory: TDButton;
    DSelHero1: TDButton;
    DSelHero2: TDButton;
    DPlayDrink: TDWindow;
    DPlayDrinkClose: TDButton;
    DPlayDrinkFist: TDButton;
    DPlayDrinkScissors: TDButton;
    DPlayDrinkCloth: TDButton;
    DPlayFist: TDButton;
    DDrink3: TDButton;
    DDrink1: TDButton;
    DDrink2: TDButton;
    DDrink4: TDButton;
    DDrink5: TDButton;
    DDrink6: TDButton;
    DWPleaseDrink: TDWindow;
    DPDrink1: TDButton;
    DPDrink2: TDButton;
    DPleaseDrinkClose: TDButton;
    DPleaseDrinkDrink: TDButton;
    DPleaseDrinkExit: TDButton;
    DPlayDrinkNpcNum: TDButton;
    DPlayDrinkPlayNum: TDButton;
    DPlayDrinkWhoWin: TDButton;
    DLOGO: TDButton;
    DFriendDlgFrd: TDButton;
    DFriendDlgTanget: TDButton;
    DHeiMingDan: TDButton;
    DPrevFriendDlg: TDButton;
    DNextFriendDlg: TDButton;
    DFriendList: TDButton;
    DAddFriend: TDButton;
    DDelFriend: TDButton;
    DWCheckNum: TDWindow;
    DCheckNumClose: TDButton;
    DCheckNumOK: TDButton;
    DCheckNumChange: TDButton;
    DEditCheckNum: TDEdit;
    DWMakeWineDesk: TDWindow;
    DMakeWineDeskClose: TDButton;
    DDrunkScale: TDButton;
    DLiquorProgress: TDButton;
    DMakeWineHelp: TDButton;
    DMaterialMemo: TDButton;
    DStartMakeWine: TDButton;
    DBMateria: TDButton;
    DBWineSong: TDButton;
    DBWater: TDButton;
    DBWineCrock: TDButton;
    DBAssistMaterial1: TDButton;
    DBAssistMaterial2: TDButton;
    DBAssistMaterial3: TDButton;
    DBDrug: TDButton;
    DBWine: TDButton;
    DBWineBottle: TDButton;
    DHeroLiquorProgress: TDButton;
    DWNewSdoAssistant: TDWindow;
    DNewSdoAssistantClose: TDButton;
    DNewSdoBasic: TDButton;
    DNewSdoProtect: TDButton;
    DNewSdoSkill: TDButton;
    DNewSdoKey: TDButton;
    DNedSdoHelp: TDButton;
    DCheckSdoNameShow: TDCheckBox;
    DCheckSdoDuraWarning: TDCheckBox;
    DCheckSdoAvoidShift: TDCheckBox;
    DCheckSdoLongHit: TDCheckBox;
    DCheckSdoAutoWideHit: TDCheckBox;
    DCheckSdoAutoFireHit: TDCheckBox;
    DCheckSdoZhuri: TDCheckBox;
    DCheckSdoAutoShield: TDCheckBox;
    DCheckSdoHeroShield: TDCheckBox;
    DCheckSdoAutoHide: TDCheckBox;
    DCheckSdoAutoMagic: TDCheckBox;
    DEdtSdoAutoMagicTimer: TDEdit;
    DCheckSdoAutoDrinkWine: TDCheckBox;
    DEdtSdoDrunkWineDegree: TDEdit;
    DCheckSdoHeroAutoDrinkWine: TDCheckBox;
    DEdtSdoHeroDrunkWineDegree: TDEdit;
    DWChallenge: TDWindow;
    DChallengeClose: TDButton;
    DChallengeOK: TDButton;
    DChallengeCancel: TDButton;
    DChallengeGrid: TDGrid;
    DChallengeGold: TDButton;
    DRChallengeGrid: TDGrid;
    dwRecoverChr: TDWindow;
    dgrdRecoverName: TDGrid;
    btnRecover: TDButton;
    btnRecvChrClose: TDButton;
    DCheckSdoExpFiltrate: TDCheckBox;
    DCheckSdoAutoDrinkDrugWine: TDCheckBox;
    DEdtSdoDrunkDrugWineDegree: TDEdit;
    DCheckSdoHeroAutoDrinkDrugWine: TDCheckBox;
    DEdtSdoHeroDrunkDrugWineDegree: TDEdit;
    DStateTab: TDButton;
    DHeroStateTab: TDButton;
    DSighIcon: TDButton;
    DWExpCrystal: TDWindow;
    DExpCrystalTop: TDButton;
    DCrystalExp: TDButton;
    DCrystalNGExp: TDButton;
    DCheckSdoMapDesc: TDCheckBox;
    DNewBoxsHelp: TDButton;
    DBNewHelpBtn: TDButton;
    DNewBoxsHelpClose: TDButton;
    DCheckAutoOpenBoxs: TDCheckBox;
    DBoxsNewBelt1: TDButton;
    DBoxsNewBelt2: TDButton;
    DBoxsNewBelt3: TDButton;
    DBoxsNewClose: TDButton;
    DSdoMemo: TDMemo;
    DSdoMemoScrollBar: TDMemoScrollBar;
    DCheckAutoButch: TDCheckBox;
    DCheckAutoUseHuolongzhu: TDCheckBox;
    DCheckAutoUseJingyuandan: TDCheckBox;
    DEdtSdoExpFiltrate: TDEdit;
    DWNQState: TDWindow;
    DNQExp: TDButton;
    DNQBoxs: TDButton;
    DBMission: TDButton;
    DWKimNeedle: TDWindow;
    DKimNeedleLogo: TDButton;
    DKimNeedleHelp: TDButton;
    DKimNeedleMemo: TDButton;
    DStartKimNeedle: TDButton;
    DKimNeedleBar: TDButton;
    DKimNeedle1: TDButton;
    DKimNeedle2: TDButton;
    DKimNeedle3: TDButton;
    DKimNeedle4: TDButton;
    DKimNeedle5: TDButton;
    DKimNeedle6: TDButton;
    DKimNeedle7: TDButton;
    DKimNeedle8: TDButton;
    DKimNeedleClose: TDButton;
    DStateSsas: TDButton;
    DStateWinPulse: TDButton;
    DStateWinBatter: TDButton;
    DWinBatterTopMag1: TDButton;
    DWinBatterTopMag2: TDButton;
    DWinBatterTopMag3: TDButton;
    DWinBatterMag1: TDButton;
    DWinBatterMag2: TDButton;
    DWinBatterMag3: TDButton;
    DWinBatterMag4: TDButton;
    DWinBatterCom: TDButton;
    DWinBatterRandom: TDButton;
    DWinBatterSetKey: TDButton;
    DHeroStateSsas: TDButton;
    DWWhisper: TDWindow;
    DWhisperClose: TDButton;
    DMemoWhisperList: TDMemo;
    DMemoWhisperListScrollBar: TDMemoScrollBar;
    DCheckWhisper: TDCheckBox;
    DEdtWhisper: TDEdit;
    DBWhisper: TDButton;
    DHeroStateWinPulse: TDButton;
    DHeroStateWinBatter: TDButton;
    DHeroBatterTopMag1: TDButton;
    DHeroBatterTopMag2: TDButton;
    DHeroBatterTopMag3: TDButton;
    DHeroBatterRandom: TDButton;
    DHeroBatterCom: TDButton;
    DHeroBatterMag1: TDButton;
    DHeroBatterMag2: TDButton;
    DHeroBatterMag3: TDButton;
    DHeroBatterMag4: TDButton;
    DCheckMyHp: TDCheckBox;
    DCheckHeroBatterNotMob: TDCheckBox;
    DBHeroSpleenImg: TDButton;
    DBHelp: TDButton;
    DBatterShowImg: TDButton;
    HBExp: TDButton;
    JQExp: TDButton;
    DCheckDeputyHeroWarr: TDCheckBox;
    DCheckDeputyHeroWiz: TDCheckBox;
    DCheckDeputyHeroTaos: TDCheckBox;
    DCheckHeroDeputyHeroWarr: TDCheckBox;
    DCheckHeroDeputyHeroWiz: TDCheckBox;
    DCheckHeroDeputyHeroTaos: TDCheckBox;
    DWHeroAssess: TDWindow;
    DHeroAssessSign: TDButton;
    DHeroAssessClose: TDButton;
    DHeroAssessClose1: TDButton;
    DHeroAssessSign1: TDButton;
    DBCallDeputyHero: TDButton;
    DHeroAssessMenu: TDButton;
    DWHeroAutoPractice: TDWindow;
    DHeroAutoPracticeMemo: TDButton;
    DHeroAutoPraMapPrev: TDButton;
    DHeroAutoPraMapNext: TDButton;
    DHeroAutoPraYDSPrev: TDButton;
    DHeroAutoPraYDSNext: TDButton;
    DHeroAutoPraClose: TDButton;
    DStartHeroAutoPra: TDButton;
    DCheckHeroLevelHint: TDCheckBox;
    DHeroJQExp: TDButton;
    DWJenniferLongBox: TDWindow;
    DJenniferLongBoxClose: TDButton;
    DJLChangeItem: TDButton;
    DJLStartItem: TDButton;
    DJLBoxBelt1: TDButton;
    DJLBoxBelt2: TDButton;
    DJLBoxBelt3: TDButton;
    DJLBoxBelt4: TDButton;
    DJLBoxBelt5: TDButton;
    DJLBoxBelt6: TDButton;
    DJLBoxBelt7: TDButton;
    DJLBoxBelt8: TDButton;
    DJLBoxFlash: TDButton;
    DGJLBoxFreeItem: TDGrid;
    DBCommand: TDButton;
    DBCommandFrame: TDButton;
    DListViewFilterItem: TDListView;
    DScrollBarFilterItem: TDScrollBar;
    DNewSdoFilterItem: TDButton;
    DCBFilterItemStdMode: TDComboBox;
    DEdtFilterItemStdMode: TDEdit;
    DBtnDefaultFilterItem: TDButton;
    DCheckBFilterItemPickUpAll: TDCheckBox;
    DWStall: TDWindow;
    DGStall: TDGrid;
    DBStallClose: TDButton;
    DEdtStallName: TDEdit;
    DBtnStallStart: TDButton;
    DBtnStallStop: TDButton;
    DWWStallPrice: TDWindow;
    DEdtWStallPrice: TDEdit;
    DBWStallPriceOK: TDButton;
    DBWStallPriceCancel: TDButton;
    DBWStallPriceClose: TDButton;
    DBWStallPriceTab1: TDButton;
    DBWStallPriceTab2: TDButton;
    DBotStall: TDButton;
    DWUserStall: TDWindow;
    DGUserStall: TDGrid;
    DBUserStallClose: TDButton;
    DBBuyUserStallItem: TDButton;
    DWinBatterTopMag4: TDButton;
    DHeroBatterTopMag4: TDButton;
    DCheckScreenShake: TDCheckBox;
    DWMission: TDWindow;
    DBMissionClose: TDButton;
    DWMiniMap: TDMapMini;
    DTreeViewMission1: TDTreeView;
    DScrollBarMission1: TDScrollBar;
    DMemoMissionBottom: TDMemo;
    DMemoMissionBottomScrollBar: TDMemoScrollBar;
    DBMission1: TDButton;
    DBMission2: TDButton;
    DBMission3: TDButton;
    DBMissionClose1: TDButton;
    DCheckShowHeroStateNumber: TDCheckBox;
    DCheckShowSpecialDamage: TDCheckBox;
    DWSignedItems: TDWindow;
    DWSkillMemo: TDWindow;
    DWHeroSkillMemo: TDWindow;
    DBSkillMemoClose: TDButton;
    DBHeroSkillMemoClose: TDButton;
    DBSkillMemoIcon: TDButton;
    DBSkillMemoLink: TDButton;
    DBJDSee: TDButton;
    DBHeroSkillMemoIcon: TDButton;
    DBHeroSkillMemoLink: TDButton;
    DBHeroQSSSee: TDButton;
    DBSignedItem: TDButton;
    DBSignedChangeItem: TDButton;
    DBSignedMemo: TDButton;
    DBSignedChangeMemo: TDButton;
    DBSignedItemsClose: TDButton;
    DBSignedBelt1: TDButton;
    DBSignedBelt2: TDButton;
    DBOrdSigned: TDButton;
    DBHighSigned: TDButton;
    DBSignedChange: TDButton;
    DWJudgeItems: TDWindow;
    DBJudgeItem: TDButton;
    DBJudgeItemMemo: TDButton;
    DBJudgeBelt1: TDButton;
    DBJudgeStart: TDButton;
    DBJudgeItemsClose: TDButton;
    DWMakeSigned: TDWindow;
    DBMakeSignedRead: TDButton;
    DBMakeSignedMake: TDButton;
    DBMakeSignedReadMemo: TDButton;
    DBMakeSignedMakeMemo: TDButton;
    DBMakeSignedBelt1: TDButton;
    DBMakeSignedBelt2: TDButton;
    DBMakeSignedBelt3: TDButton;
    DBMakeSignedClose: TDButton;
    DBMakeSignedExp1: TDButton;
    DBMakeSignedExp2: TDButton;
    DBMakeSignedReadStart: TDButton;
    DBMakeSignedLeve1: TDButton;
    DBMakeSignedLeve2: TDButton;
    DBMakeSignedLeve3: TDButton;
    DBMakeSignedLeve4: TDButton;
    DBLingMeiBelt: TDButton;
    DBLevelOrderUseItem: TDButton;
    DBLevelOrderCloud: TDButton;
    DBOrderWeapon: TDButton;
    DBOrderRing: TDButton;
    DBOrderDress: TDButton;
    DBOrderBoots: TDButton;
    DBOrderHelmet: TDButton;
    DBOrderBelt: TDButton;
    DBOrderNecklace: TDButton;
    DBOrderMedal: TDButton;
    DBOrderWristlet: TDButton;
    DBOrderHat: TDButton;
    DBItemLevelBelt1: TDButton;
    DBItemLevelBelt2: TDButton;
    DBItemLevelBelt3: TDButton;
    DBItemLevelBelt4: TDButton;
    DBItemLevelBelt5: TDButton;
    DBItemLevelBelt6: TDButton;
    DBItemLevelBelt7: TDButton;
    DBItemLevelBelt8: TDButton;
    DBItemLevelBelt9: TDButton;
    DBItemLevelBelt10: TDButton;
    DCheckAutoDragInBody: TDCheckBox;
    DCheckHideHumanWing: TDCheckBox;
    DCheckHideWeaponEffect: TDCheckBox;
    DBNewSdoProtect1: TDButton;
    DScrollBoxPro: TDScrollBox;
    DLoginOk: TDButton;
    DLoginNew: TDButton;
    m_EdId: TDEdit;
    m_EdPasswd: TDEdit;
    DLoginClose: TDButton;
    DLoginChgPw: TDButton;
    DNewAccountOk: TDButton;
    DNewAccountCancel: TDButton;
    DNewAccountClose: TDButton;
    DSServer6: TDButton;
    DSServer5: TDButton;
    DSServer4: TDButton;
    DSServer3: TDButton;
    DSServer2: TDButton;
    DSServer1: TDButton;
    DSSrvClose: TDButton;
    DccOk: TDButton;
    DccClose: TDButton;
    DccRightHair: TDButton;
    DccLeftHair: TDButton;
    DccMale: TDButton;
    DccWarrior: TDButton;
    DccWizzard: TDButton;
    DccMonk: TDButton;
    DccReserved: TDButton;
    DccFemale: TDButton;
    DScrollBarPro: TDScrollBar;
    DBProMySelf: TDButton;
    DBProMyHero1: TDButton;
    DBProMyHero2: TDButton;
    DBProMyHero3: TDButton;
    DBProMyHero4: TDButton;
    DLabel1: TDLabel;
    DLabel2: TDLabel;
    DCheckBoxBookHPPro: TDCheckBox;
    DEdtBookHPPro: TDEdit;
    DLabel3: TDLabel;
    DCBBookHPMan: TDCombobox;
    DCheckBoxBookMPPro: TDCheckBox;
    DEdtBookMPPro: TDEdit;
    DLabel4: TDLabel;
    DLabel5: TDLabel;
    DLabel6: TDLabel;
    DCheckBoxRenewHP: TDCheckBox;
    DEdtRenewHP: TDEdit;
    DEdtRenewHPTime: TDEdit;
    DCheckBoxRenewMP: TDCheckBox;
    DEdtRenewMp: TDEdit;
    DEdtRenewMpTime: TDEdit;
    DCheckBoxRenewHPSpecial: TDCheckBox;
    DEdtRenewHPSpecial: TDEdit;
    DEdtRenewHPSpecialTime: TDEdit;
    DCheckBoxRenewMPSpecial: TDCheckBox;
    DEdtRenewMPSpecial: TDEdit;
    DEdtRenewMPSpecialTime: TDEdit;
    DCheckBoxUseSuperMedica: TDCheckBox;
    DLabel7: TDLabel;
    DLabel8: TDLabel;
    DCheckBoxUseSuperMedicaItemName1: TDCheckBox;
    DEditSuperMedicaHP1: TDEdit;
    DEditSuperMedicaHPTime1: TDEdit;
    DEditSuperMedicaMP1: TDEdit;
    DEditSuperMedicaMPTime1: TDEdit;
    DCheckBoxUseSuperMedicaItemName2: TDCheckBox;
    DEditSuperMedicaHP2: TDEdit;
    DEditSuperMedicaHPTime2: TDEdit;
    DEditSuperMedicaMP2: TDEdit;
    DEditSuperMedicaMPTime2: TDEdit;
    DCheckBoxUseSuperMedicaItemName3: TDCheckBox;
    DEditSuperMedicaHP3: TDEdit;
    DEditSuperMedicaHPTime3: TDEdit;
    DEditSuperMedicaMP3: TDEdit;
    DEditSuperMedicaMPTime3: TDEdit;
    DCheckBoxUseSuperMedicaItemName4: TDCheckBox;
    DEditSuperMedicaHP4: TDEdit;
    DEditSuperMedicaHPTime4: TDEdit;
    DEditSuperMedicaMP4: TDEdit;
    DEditSuperMedicaMPTime4: TDEdit;
    DCheckBoxUseSuperMedicaItemName5: TDCheckBox;
    DEditSuperMedicaHP5: TDEdit;
    DEditSuperMedicaHPTime5: TDEdit;
    DEditSuperMedicaMP5: TDEdit;
    DEditSuperMedicaMPTime5: TDEdit;
    DCheckBoxUseSuperMedicaItemName6: TDCheckBox;
    DEditSuperMedicaHP6: TDEdit;
    DEditSuperMedicaHPTime6: TDEdit;
    DEditSuperMedicaMP6: TDEdit;
    DEditSuperMedicaMPTime6: TDEdit;
    DCheckBoxUseSuperMedicaItemName7: TDCheckBox;
    DEditSuperMedicaHP7: TDEdit;
    DEditSuperMedicaHPTime7: TDEdit;
    DEditSuperMedicaMP7: TDEdit;
    DEditSuperMedicaMPTime7: TDEdit;
    DCheckBoxUseSuperMedicaItemName8: TDCheckBox;
    DEditSuperMedicaHP8: TDEdit;
    DEditSuperMedicaHPTime8: TDEdit;
    DEditSuperMedicaMP8: TDEdit;
    DEditSuperMedicaMPTime8: TDEdit;
    DCheckBoxUseSuperMedicaItemName9: TDCheckBox;
    DEditSuperMedicaHP9: TDEdit;
    DEditSuperMedicaHPTime9: TDEdit;
    DEditSuperMedicaMP9: TDEdit;
    DEditSuperMedicaMPTime9: TDEdit;
    DCBBookMPMan: TDCombobox;
    DWQJPractice: TDWindow;
    DBQJPracticeClose: TDButton;
    DBQJPracticePage1: TDButton;
    DBQJPracticeStart: TDButton;
    DLQJPracticeLink1: TDLabel;
    DLQJPracticeLink2: TDLabel;
    DLQJPracticeLink3: TDLabel;
    DLQJPracticeLink4: TDLabel;
    DBQJPracticeItem: TDButton;
    DWQJFurnace: TDWindow;
    DBQJFurnaceClose: TDButton;
    DBQJFurnaceStart: TDButton;
    DCheckBoxUseSuperMedicaItemName10: TDCheckBox;
    DEditSuperMedicaHP10: TDEdit;
    DEditSuperMedicaHPTime10: TDEdit;
    DEditSuperMedicaMP10: TDEdit;
    DEditSuperMedicaMPTime10: TDEdit;
    DCheckBoxUseSuperMedicaItemName11: TDCheckBox;
    DEditSuperMedicaHP11: TDEdit;
    DEditSuperMedicaHPTime11: TDEdit;
    DEditSuperMedicaMP11: TDEdit;
    DEditSuperMedicaMPTime11: TDEdit;
    DCheckBoxUseSuperMedicaItemName12: TDCheckBox;
    DEditSuperMedicaHP12: TDEdit;
    DEditSuperMedicaHPTime12: TDEdit;
    DEditSuperMedicaMP12: TDEdit;
    DEditSuperMedicaMPTime12: TDEdit;
    DCheckBoxUseSuperMedicaItemName13: TDCheckBox;
    DEditSuperMedicaHP13: TDEdit;
    DEditSuperMedicaHPTime13: TDEdit;
    DEditSuperMedicaMP13: TDEdit;
    DEditSuperMedicaMPTime13: TDEdit;
    DCheckBoxUseSuperMedicaItemName14: TDCheckBox;
    DEditSuperMedicaHP14: TDEdit;
    DEditSuperMedicaHPTime14: TDEdit;
    DEditSuperMedicaMP14: TDEdit;
    DEditSuperMedicaMPTime14: TDEdit;
    DLabel9: TDLabel;
    DScrollBoxKey: TDScrollBox;
    DScrollBarKey: TDScrollBar;
    DCheckSdoStartKey: TDCheckBox;
    DLabel10: TDLabel;
    DLabel11: TDLabel;
    DScrollBoxKeySurface: TDButton;
    DBtnSdoCallHeroKey: TDButton;
    DBtnSdoHeroAttackTargetKey: TDButton;
    DBtnSdoHeroGotethKey: TDButton;
    DBtnSdoHeroStateKey: TDButton;
    DBtnSdoHeroGuardKey: TDButton;
    DBtnSdoAttackModeKey: TDButton;
    DBtnSdoMinMapKey: TDButton;
    DBtnSdoSeriesKillKey: TDButton;
    DBtnSdoCallHero1Key: TDButton;
    DBTitleMan: TDButton;
    DBTitle1: TDButton;
    DBTitle2: TDButton;
    DBTitle3: TDButton;
    DBTitle4: TDButton;
    DBPrevTitle: TDButton;
    DBNextTitle: TDButton;
    DBUserTitleMan: TDButton;
    DBUserTitle1: TDButton;
    DBUserTitle2: TDButton;
    DBUserTitle3: TDButton;
    DBUserTitle4: TDButton;
    DBUserPrevTitle: TDButton;
    DBUserNextTitle: TDButton;
    DWPFLingPai: TDWindow;
    DLPFLingPaiPrev: TDLabel;
    DLPFLingPaiDown: TDLabel;
    DBPFLingPaiIcon1: TDButton;
    DBPFLingPaiIcon2: TDButton;
    DBPFLingPaiIcon3: TDButton;
    DBPFLingPaiIcon4: TDButton;
    DBPFLingPaiIcon5: TDButton;
    DBPFLingPaiClose: TDButton;
    DBPFLingPaiName1: TDButton;
    DBPFLingPaiName2: TDButton;
    DBPFLingPaiName3: TDButton;
    DBPFLingPaiName4: TDButton;
    DBPFLingPaiName5: TDButton;
    DBPFLingPaiCall1: TDButton;
    DBPFLingPaiCall2: TDButton;
    DBPFLingPaiCall3: TDButton;
    DBPFLingPaiCall4: TDButton;
    DBPFLingPaiCall5: TDButton;
    DBPFLingPaiMove1: TDButton;
    DBPFLingPaiMove2: TDButton;
    DBPFLingPaiMove3: TDButton;
    DBPFLingPaiMove4: TDButton;
    DBPFLingPaiMove5: TDButton;
    DWZZLingPai: TDWindow;
    DLabel12: TDLabel;
    DBZZLingPaiTab1: TDButton;
    DBZZLingPaiTab3: TDButton;
    DBZZLingPaiTab2: TDButton;
    DMZZLingPai: TDMemo;
    DMZZLingPaiScrollBar: TDMemoScrollBar;
    DBZZLingPaiIcon1: TDButton;
    DBZZLingPaiIcon2: TDButton;
    DBZZLingPaiIcon3: TDButton;
    DBZZLingPaiIcon4: TDButton;
    DBZZLingPaiIcon5: TDButton;
    DLZZLingPaiPrev: TDLabel;
    DLZZLingPaiDown: TDLabel;
    DBZZLingPaiName5: TDButton;
    DBZZLingPaiName4: TDButton;
    DBZZLingPaiName3: TDButton;
    DBZZLingPaiName2: TDButton;
    DBZZLingPaiName1: TDButton;
    DBZZLingPaiCall1: TDButton;
    DBZZLingPaiCall2: TDButton;
    DBZZLingPaiCall3: TDButton;
    DBZZLingPaiCall4: TDButton;
    DBZZLingPaiCall5: TDButton;
    DBZZLingPaiMove5: TDButton;
    DBZZLingPaiMove4: TDButton;
    DBZZLingPaiMove3: TDButton;
    DBZZLingPaiMove2: TDButton;
    DBZZLingPaiMove1: TDButton;
    DLabel15: TDLabel;
    DBZZLingPaiClose: TDButton;
    DBZZLingPaiMapName1: TDButton;
    DBZZLingPaiMapName2: TDButton;
    DBZZLingPaiMapName3: TDButton;
    DBZZLingPaiMapName4: TDButton;
    DBZZLingPaiMapName5: TDButton;
    DBZZLingPaiMapName6: TDButton;
    DBZZLingPaiMapName7: TDButton;
    DBZZLingPaiMapName8: TDButton;
    DBZZLingPaiMapName9: TDButton;
    DBZZLingPaiMapName10: TDButton;
    DBZZLingPaiMapName11: TDButton;
    DBZZLingPaiMapName12: TDButton;
    DBZZLingPaiMapName13: TDButton;
    DBZZLingPaiMapName14: TDButton;
    DBZZLingPaiMapName15: TDButton;
    DBZZLingPaiMapName16: TDButton;
    DBZZLingPaiMapName17: TDButton;
    DBZZLingPaiMapName18: TDButton;
    DCheckBoxHideTitle: TDCheckBox;
    DCheckBoxHideShiti: TDCheckBox;
    DLNGUpLevel1: TDLabel;
    DLNGUpLevel2: TDLabel;
    DLNGUpLevel3: TDLabel;
    DLNGUpLevel4: TDLabel;
    DLNGUpLevel5: TDLabel;
    DLNGUpLevel6: TDLabel;
    DLHeroNGUpLevel1: TDLabel;
    DLHeroNGUpLevel2: TDLabel;
    DLHeroNGUpLevel3: TDLabel;
    DLHeroNGUpLevel4: TDLabel;
    DLHeroNGUpLevel5: TDLabel;
    DLHeroNGUpLevel6: TDLabel;
    DWPetLog: TDWindow;
    DLPetLogPagePrv: TDLabel;
    DLPetLogPageNext: TDLabel;
    DBPetLogClose: TDButton;
    DLPetLogMove: TDLabel;
    DCheckSdoPosLongHit: TDCheckBox;
    DWFactionDlg: TDWindow;
    DBFactionDlgClose: TDButton;
    DLFactionDlgHome: TDLabel;
    DLFactionDlgList: TDLabel;
    DLFactionDlgExit: TDLabel;
    DWFactionAddDlg: TDWindow;
    DBFactionAddDlgClose: TDButton;
    DLFactionAddPrev: TDLabel;
    DLFactionAddNext: TDLabel;
    DLFactionAddQuery: TDLabel;
    DEditFactionAddQuery: TDEdit;
    DLFactionApplyAdd1: TDLabel;
    DLFactionApplyAdd2: TDLabel;
    DLFactionApplyAdd3: TDLabel;
    DLFactionApplyAdd4: TDLabel;
    DLFactionApplyAdd5: TDLabel;
    DBotFaction: TDButton;
    DLFactionDlgEditNotice: TDLabel;
    DLFactionDlgManageApply: TDLabel;
    DLFactionDlgGetTitle: TDLabel;
    DLFactionDlgKick: TDLabel;
    DWFactionDlgEditNotice: TDWindow;
    DBFactionDlgEditNoticeClose: TDButton;
    DLFactionDlgEditNoticeOK: TDLabel;
    DWFactionApplyManage: TDWindow;
    DGridFactionApplySel: TDGrid;
    DLFactionApplyManageAllSel: TDLabel;
    DLFactionApplyManageNotAllSel: TDLabel;
    DLFactionApplyManageAgree: TDLabel;
    DLFactionApplyManageRefuse: TDLabel;
    DWFactionApplyManageClose: TDButton;
    DWLingWUXinFa: TDWindow;
    DBLingWUXinFaClose: TDButton;
    DLLingWUXinFa: TDLabel;
    DLXinFaHelp: TDLabel;
    DBXinFaNamePrev: TDButton;
    DBXinFaNameNext: TDButton;
    DLXinFaMakeName: TDLabel;
    DWLingWuXinFaKey: TDWindow;
    DGridLingWuXinFaKey: TDGrid;
    DBLingWuXinFaKeyClose: TDButton;
    DLLingWuXinFaKeyPrev: TDLabel;
    DLLingWuXinFaKeyNext: TDLabel;
    DLLingWuXinFaKeyChange: TDLabel;
    DLLingWuXinFaKeyOK: TDLabel;
    DBLingWuXinFaName: TDButton;
    DLXinFaChangeSelName: TDLabel;
    DWNewStateWin: TDWindow;
    DPNewStateWinTab: TDPageControl;
    DWNewStateWinTab1: TDWindow;
    DBNewStateWinPage: TDButton;
    DPNewStateWinPage: TDPageControl;
    DWNewStateWinTab2: TDWindow;
    DWNewStateWinPageTab1: TDWindow;
    DWNewStateWinPageTab2: TDWindow;
    DBNewSWHelmet: TDButton;
    DBNewSWDress: TDButton;
    DBNewSWArmRingR: TDButton;
    DBNewSWLight: TDButton;
    DBNewSWRingR: TDButton;
    DBNewSWNecklace: TDButton;
    DBNewSWArmRingL: TDButton;
    DBNewSWRingL: TDButton;
    DBNewSWBujuk: TDButton;
    DBNewSWBelt: TDButton;
    DBNewSWBoots: TDButton;
    DBNewSWCharm: TDButton;
    DBNewSWWeapon: TDButton;
    DBNewStateWinClose: TDButton;
    DWNewStateWinPageTab3: TDWindow;
    DBNewLiquorProgress: TDButton;
    DWNewStateWinPageTab4: TDWindow;
    DBNewTitleMan: TDButton;
    DBNewTitle1: TDButton;
    DBNewTitle2: TDButton;
    DBNewTitle3: TDButton;
    DBNewTitle4: TDButton;
    DBNewPrevTitle: TDButton;
    DBNewNextTitle: TDButton;
    DBNewTitle5: TDButton;
    DWNewStateWinPageTab5: TDWindow;
    DBNewStMag1: TDButton;
    DBNewStMag2: TDButton;
    DBNewStMag3: TDButton;
    DBNewStMag4: TDButton;
    DBNewStMag5: TDButton;
    DBNewStPageUp: TDButton;
    DBNewStPageDown: TDButton;
    DBNewJDSee: TDButton;
    DBNewHBExp: TDButton;
    DBNewJQExp: TDButton;
    DWNewStateWinPageTab6: TDWindow;
    DCheckNewDeputyHeroWarr: TDCheckBox;
    DCheckNewDeputyHeroWiz: TDCheckBox;
    DCheckNewDeputyHeroTaos: TDCheckBox;
    DBNewStateTab1: TDButton;
    DBNewStateWinNGPage: TDButton;
    DPNewStateWinNGPage: TDPageControl;
    DWNewStateWinNGPageTab1: TDWindow;
    DWNewStateWinNGPageTab2: TDWindow;
    DWNewStateWinNGPageTab3: TDWindow;
    DWNewStateWinNGPageTab4: TDWindow;
    DBNewStNGMag1: TDButton;
    DBNewStNGMag2: TDButton;
    DBNewStNGMag3: TDButton;
    DBNewStNGMag4: TDButton;
    DBNewStNGMag5: TDButton;
    DBNewStNGPageUp: TDButton;
    DBNewStNGPageDown: TDButton;
    DLNewNGUpLevel1: TDLabel;
    DLNewNGUpLevel2: TDLabel;
    DLNewNGUpLevel3: TDLabel;
    DLNewNGUpLevel4: TDLabel;
    DLNewNGUpLevel5: TDLabel;
    DBNewWinBatterTopMag1: TDButton;
    DBNewWinBatterTopMag2: TDButton;
    DBNewWinBatterTopMag3: TDButton;
    DBNewWinBatterTopMag4: TDButton;
    DBNewWinBatterRandom: TDButton;
    DBNewWinBatterSetKey: TDButton;
    DBNewWinBatterMag1: TDButton;
    DBNewWinBatterMag2: TDButton;
    DBNewWinBatterMag3: TDButton;
    DBNewWinBatterMag4: TDButton;
    DBNewWinBatterCom: TDButton;
    DBNewWinPointIcon1: TDButton;
    DBNewWinPointIcon2: TDButton;
    DBNewWinPointIcon3: TDButton;
    DBNewWinPointIcon4: TDButton;
    DBNewWinPointIcon5: TDButton;
    DLNewWinPointName1: TDLabel;
    DLNewWinPointName2: TDLabel;
    DLNewWinPointName3: TDLabel;
    DLNewWinPointName4: TDLabel;
    DLNewWinPointName5: TDLabel;
    DBNewWinPointPage1: TDButton;
    DBNewWinPointPage2: TDButton;
    DBNewWinPointPage3: TDButton;
    DBNewWinPointPage4: TDButton;
    DBNewWinPointPage5: TDButton;
    DBNewWinPointPractice: TDButton;
    DWNewStateWinTab3: TDWindow;
    DBNewStateWinXFPage: TDButton;
    DPNewStateWinXFPage: TDPageControl;
    DWNewStateWinXFPageTab1: TDWindow;
    DBXinFaExp: TDButton;
    DBWinXinFaMag1: TDButton;
    DBWinXinFaMag2: TDButton;
    DBWinXinFaMag3: TDButton;
    DBWinXinFaMag4: TDButton;
    DBWinXinFaMag5: TDButton;
    DWNewStateWinXFPageTab2: TDWindow;
    DBWinXinFaMagPageUp: TDButton;
    DBWinXinFaMagPageDown: TDButton;
    DBNewStateTab2: TDButton;
    DBNewStateTab3: TDButton;
    DBXinfaExpAbsorb: TDButton;
    DBXinFaAbdomenMouseHint: TDButton;
    DWNewStateHero: TDWindow;
    DBNewStateHeroTab1: TDButton;
    DBNewStateHeroTab2: TDButton;
    DPNewStateHeroTab: TDPageControl;
    DWNewStateHeroTab1: TDWindow;
    DPNewStateHeroPage: TDPageControl;
    DWNewStateHeroPageTab1: TDWindow;
    DBNewSHHelmet: TDButton;
    DBNewSHDress: TDButton;
    DBNewSHLight: TDButton;
    DBNewSHArmRingR: TDButton;
    DBNewSHRingR: TDButton;
    DBNewSHNecklace: TDButton;
    DBNewSHArmRingL: TDButton;
    DBNewSHRingL: TDButton;
    DBNewSHBujuk: TDButton;
    DBNewSHBelt: TDButton;
    DBNewSHBoots: TDButton;
    DBNewSHCharm: TDButton;
    DBNewSHWeapon: TDButton;
    DWNewStateHeroPageTab2: TDWindow;
    DBNewHeroLiquorProgress: TDButton;
    DWNewStateHeroPageTab3: TDWindow;
    DWNewStateHeroPageTab5: TDWindow;
    DBNewHeroStMag1: TDButton;
    DBNewHeroStMag2: TDButton;
    DBNewHeroStMag3: TDButton;
    DBNewHeroStMag4: TDButton;
    DBNewHeroStMag5: TDButton;
    DBNewHeroStPageUp: TDButton;
    DBNewHeroStPageDown: TDButton;
    DBNewHeroJQExp: TDButton;
    DBNewStateHeroPage: TDButton;
    DWNewStateHeroTab2: TDWindow;
    DBNewStateHeroNGPage: TDButton;
    DPNewStateHeroNGPage: TDPageControl;
    DWNewStateHeroNGPageTab1: TDWindow;
    DWNewStateHeroNGPageTab2: TDWindow;
    DBNewHeroStNGMag1: TDButton;
    DBNewHeroStNGMag2: TDButton;
    DBNewHeroStNGMag3: TDButton;
    DBNewHeroStNGMag4: TDButton;
    DBNewHeroStNGMag5: TDButton;
    DBNewHeroStNGPageUp: TDButton;
    DBNewHeroStNGPageDown: TDButton;
    DLNewHeroNGUpLevel1: TDLabel;
    DLNewHeroNGUpLevel2: TDLabel;
    DLNewHeroNGUpLevel3: TDLabel;
    DLNewHeroNGUpLevel4: TDLabel;
    DLNewHeroNGUpLevel5: TDLabel;
    DWNewStateHeroNGPageTab3: TDWindow;
    DBNewHeroPointIcon1: TDButton;
    DBNewHeroPointIcon2: TDButton;
    DBNewHeroPointIcon3: TDButton;
    DBNewHeroPointIcon4: TDButton;
    DBNewHeroPointIcon5: TDButton;
    DLNewHeroPointName1: TDLabel;
    DLNewHeroPointName2: TDLabel;
    DLNewHeroPointName3: TDLabel;
    DLNewHeroPointName4: TDLabel;
    DLNewHeroPointName5: TDLabel;
    DBNewHeroPointPage1: TDButton;
    DBNewHeroPointPage2: TDButton;
    DBNewHeroPointPage3: TDButton;
    DBNewHeroPointPage4: TDButton;
    DBNewHeroPointPage5: TDButton;
    DBNewHeroPointPractice: TDButton;
    DWNewStateHeroNGPageTab4: TDWindow;
    DBNewHeroBatterTopMag1: TDButton;
    DBNewHeroBatterTopMag2: TDButton;
    DBNewHeroBatterTopMag3: TDButton;
    DBNewHeroBatterTopMag4: TDButton;
    DBNewHeroBatterRandom: TDButton;
    DBNewHeroBatterMag1: TDButton;
    DBNewHeroBatterMag2: TDButton;
    DBNewHeroBatterMag3: TDButton;
    DBNewHeroBatterMag4: TDButton;
    DBNewHeroBatterCom: TDButton;
    DBNewStateHeroClose: TDButton;
    DWNewStateUser: TDWindow;
    DBNewStateUserClose: TDButton;
    DPNewStateUserTab: TDPageControl;
    DWNewStateUserTab1: TDWindow;
    DPNewStateUserPage: TDPageControl;
    DWNewStateUserPageTab1: TDWindow;
    DBNewSUHelmet: TDButton;
    DBNewSUDress: TDButton;
    DBNewSULight: TDButton;
    DBNewSUArmRingR: TDButton;
    DBNewSURingR: TDButton;
    DBNewSUNecklace: TDButton;
    DBNewSUArmRingL: TDButton;
    DBNewSURingL: TDButton;
    DBNewSUBujuk: TDButton;
    DBNewSUBelt: TDButton;
    DBNewSUBoots: TDButton;
    DBNewSUCharm: TDButton;
    DBNewSUWeapon: TDButton;
    DWNewStateUserPageTab2: TDWindow;
    DBNewUserTitleMan: TDButton;
    DBNewUserTitle1: TDButton;
    DBNewUserTitle2: TDButton;
    DBNewUserTitle3: TDButton;
    DBNewUserTitle4: TDButton;
    DBNewUserTitle5: TDButton;
    DBNewUserPrevTitle: TDButton;
    DBNewUserNextTitle: TDButton;
    DBNewStateUserPage: TDButton;
    DLNewStateUserName: TDLabel;
    DLNewStateUserGuildName: TDLabel;
    DMemoXinFaHint: TDMemo;
    DMemoXinFaHintScrollBar: TDMemoScrollBar;
    DWBottomLeft: TDWindow;
    DWBottomCenter: TDWindow;
    DWBottomRight: TDWindow;
    DChatMemo: TDChatMemo;
    DMsgDlgGameGoldBuy: TDButton;
    DMsgDlgGamePointBuy: TDButton;
    DLHelpXinfa: TDLabel;
    DLLingwuZhaoshi: TDLabel;
    DBNewSWDRUM: TDButton;
    DBNewSHDrum: TDButton;
    DBNewSUDrum: TDButton;
    DBigMerchantDlg: TDWindow;
    DBigMerchantDlgClose: TDButton;

    procedure DMyStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DOptionClick();
    procedure DItemBagDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemsUpButDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure FormCreate(Sender: TObject);
    procedure DPrevStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLoginNewDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DscSelect1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DccCloseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemGridGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DItemGridDblClick(Sender: TObject);
    procedure DMsgDlgOkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMsgDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMsgDlgKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DCloseBagDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBackgroundBackgroundClick(Sender: TObject);
    procedure DItemGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure FormDestroy(Sender: TObject);
    procedure DBelt1DblClick(Sender: TObject);
    procedure DLoginCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLoginOkClick(Sender: TObject; X, Y: Integer);
    procedure DLoginNewClick(Sender: TObject; X, Y: Integer);
    procedure DLoginChgPwClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountOkClick(Sender: TObject; X, Y: Integer);
    procedure DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
    procedure DccCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgpwOkClick(Sender: TObject; X, Y: Integer);
    procedure DscSelect1Click(Sender: TObject; X, Y: Integer);
    procedure DCloseStateClick(Sender: TObject; X, Y: Integer);
    procedure DPrevStateClick(Sender: TObject; X, Y: Integer);
    procedure DNextStateClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponClick(Sender: TObject; X, Y: Integer);//移动英雄装备物品
    procedure HeroPageChanged;
    procedure HeroInternalForcePageChanged;
    procedure DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DCloseBagClick(Sender: TObject; X, Y: Integer);
    procedure DBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DMyStateClick(Sender: TObject; X, Y: Integer);
    procedure DStateWinClick(Sender: TObject; X, Y: Integer);
    procedure DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DMerchantDlgShowText(Sender: TObject; dsurface:
      TDirectDrawSurface; Msg, SelectStr: string; X, Y: Word;
      Points: TList; var AddPoints: Boolean);
    procedure DMerchantDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    function DMerchantDlgSelect(const RStr, sTitle: string; var LStr: string): Boolean;
    procedure DMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DMenuCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMenuDlgClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
    procedure DSellDlgSpotDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellDlgSpotMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DSellDlgOkClick(Sender: TObject; X, Y: Integer);
    procedure DMenuBuyClick(Sender: TObject; X, Y: Integer);
    procedure DMenuPrevClick(Sender: TObject; X, Y: Integer);
    procedure DMenuNextClick(Sender: TObject; X, Y: Integer);
    procedure DGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSWLightDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSHLightDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);  //显示英雄装备    $010
    procedure DBackgroundMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLoginNewClickSound(Sender: TObject;
      Clicksound: TClickSound);
    procedure DStMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DKsIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKsF1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKsOkClick(Sender: TObject; X, Y: Integer);
    procedure DKsF1Click(Sender: TObject; X, Y: Integer);
    procedure DKeySelDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotGroupDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGrpAllowGroupDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
    procedure DGrpCreateClick(Sender: TObject; X, Y: Integer);
    procedure DGroupDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGrpAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGrpDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DBotLogoutClick(Sender: TObject; X, Y: Integer);
    procedure DBotExitClick(Sender: TObject; X, Y: Integer);
    procedure DStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DDealOkClick(Sender: TObject; X, Y: Integer);
    procedure DDealCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotTradeClick(Sender: TObject; X, Y: Integer);
    procedure DDealRemoteDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDealDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDGridGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DDGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DDRGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DDGoldClick(Sender: TObject; X, Y: Integer);
    procedure DSServer1Click(Sender: TObject; X, Y: Integer);
    procedure DSSrvCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotMiniMapClick(Sender: TObject; X, Y: Integer);
    procedure DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUserState1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DUserState1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCloseUS1Click(Sender: TObject; X, Y: Integer);
    procedure DNecklaceUS1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotGuildClick(Sender: TObject; X, Y: Integer);
    procedure DGuildDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGDUpClick(Sender: TObject; X, Y: Integer);
    procedure DGDDownClick(Sender: TObject; X, Y: Integer);
    procedure DGDCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGDHomeClick(Sender: TObject; X, Y: Integer);
    procedure DGDListClick(Sender: TObject; X, Y: Integer);
    procedure DGDAddMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDDelMemClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DGDEditGradeClick(Sender: TObject; X, Y: Integer);
    procedure DGECloseClick(Sender: TObject; X, Y: Integer);
    procedure DGEOkClick(Sender: TObject; X, Y: Integer);
    procedure DGuildEditNoticeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGDChatClick(Sender: TObject; X, Y: Integer);
    procedure DGoldDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DNewAccountDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilityDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
    procedure DPlusDCClick(Sender: TObject; X, Y: Integer);
    procedure DMinusDCClick(Sender: TObject; X, Y: Integer);
    procedure DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
    procedure DBotPlusAbilDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DAdjustAbilityMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DUserState1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DGDAllyClick(Sender: TObject; X, Y: Integer);
    procedure DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
    procedure DBotFactionMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DFrdFriendDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBotFriendClick(Sender: TObject; X, Y: Integer);
    procedure DFrdCloseClick(Sender: TObject; X, Y: Integer);
    procedure DChgGamePwdDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBCallHeroClick(Sender: TObject; X, Y: Integer);
    procedure DBRefuseguildClick(Sender: TObject; X, Y: Integer);
    procedure DBRefuseWHISPERClick(Sender: TObject; X, Y: Integer);
    procedure DBHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DCloseHeroStateClick(Sender: TObject; X, Y: Integer);
    procedure DStateHeroDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCloseHeroStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSHWeaponMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
    procedure DBHeroPackageClick(Sender: TObject; X, Y: Integer);
    procedure DNextStateHeroClick(Sender: TObject; X, Y: Integer);
    procedure DBRefusePublicChatClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemBagDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DHeroItemGridCloseClick(Sender: TObject; X, Y: Integer);
    procedure DHeroItemGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DHeroItemGridGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DHeroItemGridDblClick(Sender: TObject);
    function HeroIcon(sex:integer;job:integer):integer;
    procedure DHeroRoleIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBHeroSpleenImgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPrevStateHeroClick(Sender: TObject; X, Y: Integer);
    procedure DSHPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DHeroIconClick(Sender: TObject; X, Y: Integer);
    procedure DStMagHero1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateHeroMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBotMemoClick(Sender: TObject; X, Y: Integer);
    procedure ShopStrWord(s:string;dsurface:TDirectDrawSurface;x,y:integer);//取|符号 左右边的内容
    procedure DShopDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DShopCloseClick(Sender: TObject; X, Y: Integer);
    procedure DShopImg1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DShopNextClick(Sender: TObject; X, Y: Integer);
    procedure DShopDecorateClick(Sender: TObject; X, Y: Integer);
    procedure DShopImg1Click(Sender: TObject; X, Y: Integer);
    procedure Itemstrorlist(str:string; WIDTH,HEIGH:integer);
    procedure DShopBuyClick(Sender: TObject; X, Y: Integer);
    procedure DShopSpeciallyImg1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DShopSpeciallyImg1Click(Sender: TObject; X, Y: Integer);
    //Shop 物品动画演示
    procedure ShopGifInfo(dsurface: TDirectDrawSurface;dx,dy,ShopGifBegin,ShopGifEnd:integer);
    procedure DShopPresentClick(Sender: TObject; X, Y: Integer);
    procedure CharacterSrankingClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderCloseClick(Sender: TObject; X, Y: Integer);
    procedure DIndividualOrderClick(Sender: TObject; X, Y: Integer);
    procedure DHeroOrderClick(Sender: TObject; X, Y: Integer);
    procedure DWLevelOrderDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DColonyHeroOrderClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAllOrderClick(Sender: TObject; X, Y: Integer);
    procedure DMasterOrderClick(Sender: TObject; X, Y: Integer);
    procedure DMyLevelOrderClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderIndexClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderLastPageClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderNextClick(Sender: TObject; X, Y: Integer);
    procedure DBottomMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure typeTimeimg; //英雄怒气变换函数
    procedure DPlayGameNum();
    procedure ItemLightTimeImg();//物品发光变换函数 20080223
    procedure BoxsFlash(Button: TDButton;dsurface: TDirectDrawSurface);
    procedure BoxsFillFlash(Button: TDButton;dsurface: TDirectDrawSurface);//宝箱填充物品动画
    procedure BoxsRandomImg;
    procedure BoxsRunning(dsurface: TDirectDrawSurface);
    procedure JLBoxRunning(dsurface: TDirectDrawSurface);//珍珑宝箱更换奖励
    procedure JLBoxFreeRunning(dsurface: TDirectDrawSurface); //珍珑免费宝箱翻牌
    procedure DBoxsDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBoxsClick(Sender: TObject; X, Y: Integer);
    procedure DBoxsBelt5DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBoxsBelt5MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBoxsTautologyClick(Sender: TObject; X, Y: Integer);
    procedure DBoxsTautologyMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBoxsBelt1DblClick(Sender: TObject);
    procedure DLieDragonDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLieDragonCloseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLieDragonCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLieDragonNextPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLieDragonPrevPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLieDragonNextPageClick(Sender: TObject; X, Y: Integer);
    procedure DGoToLieDragonDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLieDragonNpcDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLieDragonNpcCloseClick(Sender: TObject; X, Y: Integer);
    procedure ShowBoxsGird(Show: Boolean; IsNewBoxs:Byte);
    procedure DGoToLieDragonClick(Sender: TObject; X, Y: Integer);
    procedure DItemsUpButMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DItemsUpButClick(Sender: TObject; X, Y: Integer);
    procedure DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCIDSpleenDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DButton4DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBRefuseCRYClick(Sender: TObject; X, Y: Integer);
    procedure DBAutoCRYClick(Sender: TObject; X, Y: Integer);
    procedure DSHWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DBHelpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGameGirdExchangeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGameGirdExchangeClick(Sender: TObject; X, Y: Integer);
    procedure DWLevelOrderClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffCloseClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffItemGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DSellOffItemGridGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TDGridDrawState;
      dsurface: TDirectDrawSurface);
    procedure DSellOffItemGridGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DWSellOffDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellOffOkClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffCancelClick(Sender: TObject; X, Y: Integer);
    procedure ShowSellOffListDlg;
    procedure DEditSellOffNameClick(Sender: TObject; X, Y: Integer);
    procedure DEditSellOffNumClick(Sender: TObject; X, Y: Integer);
    procedure DEditSellOffNameDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DEditSellOffNumDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellOffListColseClick(Sender: TObject; X, Y: Integer);
    procedure DWSellOffListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellOffItem0DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSellOffItem0Click(Sender: TObject; X, Y: Integer);
    procedure DSellOffListCancelClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffBuyCancelClick(Sender: TObject; X, Y: Integer);
    procedure DSellOffBuyClick(Sender: TObject; X, Y: Integer);
    procedure DWGameGoldMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWMiniMap1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DSelectChrMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCIDSpleenMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DUserState1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroIconMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBoxsTautologyDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemsUpBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DItemsUpBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DItemsUpOkClick(Sender: TObject; X, Y: Integer);
    procedure DItemsUpBelt1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DItemsUpCloseClick(Sender: TObject; X, Y: Integer);
    procedure DGetHeroCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBGloryDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSelHero1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPlayDrinkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure ChallengeClick(Sender: TObject; X, Y: Integer);
    procedure DDrink1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWiGetHeroDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSelHero1Click(Sender: TObject; X, Y: Integer);
    procedure DPlayFistClick(Sender: TObject; X, Y: Integer);
    procedure DPlayDrinkCloseDirctPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPlayDrinkMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DPlayDrinkMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DPlayDrinkClick(Sender: TObject; X, Y: Integer);
    procedure DWPleaseDrinkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPDrink1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPlayDrinkCloseClick(Sender: TObject; X, Y: Integer);
    procedure DPlayDrinkFistClick(Sender: TObject; X, Y: Integer);
    procedure DPlayDrinkNpcNumDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPlayDrinkPlayNumDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DPlayDrinkWhoWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface); //显示寄售列表界面 20080317
    procedure ShowPlayDrinkImg(Show: Boolean);
    procedure DPlayDrinkFistDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DPlayDrinkMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DDrink1Click(Sender: TObject; X, Y: Integer);
    procedure DPDrink1Click(Sender: TObject; X, Y: Integer);
    procedure DPDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWPleaseDrinkMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DPleaseDrinkExitClick(Sender: TObject; X, Y: Integer);
    procedure DPleaseDrinkDrinkClick(Sender: TObject; X, Y: Integer);
    procedure DWPleaseDrinkClick(Sender: TObject; X, Y: Integer);
    procedure DWPleaseDrinkMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWPleaseDrinkMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DLOGODirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLOGOClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgFrdDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DFriendDlgFrdClick(Sender: TObject; X, Y: Integer);
    procedure DFriendDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DFriendListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DFriendListDblClick(Sender: TObject);
    procedure DFriendListMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DPrevFriendDlgClick(Sender: TObject; X, Y: Integer);
    procedure DAddFriendClick(Sender: TObject; X, Y: Integer);
    procedure DDelFriendClick(Sender: TObject; X, Y: Integer);
    procedure DBInternetClick(Sender: TObject; X, Y: Integer);
    procedure DStMagHero1Click(Sender: TObject; X, Y: Integer);
    procedure DWCheckNumDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckNumOKDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckNumOKClick(Sender: TObject; X, Y: Integer);
    procedure DEditCheckNumKeyPress(Sender: TObject; var Key: Char);
    procedure DEditCheckNumKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DCheckNumChangeClick(Sender: TObject; X, Y: Integer);
    procedure DWMakeWineDeskDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMakeWineHelpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMakeWineDeskCloseClick(Sender: TObject; X, Y: Integer);
    procedure DMakeWineHelpClick(Sender: TObject; X, Y: Integer);
    procedure DMaterialMemoClick(Sender: TObject; X, Y: Integer);
    procedure DBMateriaMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWMakeWineDeskMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure ShowMakeWine(bool:Boolean);
    procedure DBMateriaClick(Sender: TObject; X, Y: Integer);
    procedure DBMateriaDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBDrugDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBDrugClick(Sender: TObject; X, Y: Integer);
    procedure DStartMakeWineClick(Sender: TObject; X, Y: Integer);
    procedure DDrunkScaleDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBDrugMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DHeroLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckSdoNameShowDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DNewSdoBasicDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewSdoAssistantDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DNewSdoBasicClick(Sender: TObject; X, Y: Integer);
    procedure DEdtSdoAutoMagicTimerDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DNewSdoAssistantCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBtnSdoCallHeroKeyDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
//    procedure DBtnSdoRandomNameDirectPaint(Sender: TObject;
//      dsurface: TDirectDrawSurface);
    procedure DCheckSdoNameShowClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoCommonHpClick(Sender: TObject; X, Y: Integer);
    procedure DEdtSdoCommonHpChange(Sender: TObject);
    procedure DCheckSdoLongHitClick(Sender: TObject; X, Y: Integer);
    procedure DBtnSdoCallHeroKeyKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DBtnSdoCallHeroKeyMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DEdtSdoCommonHpKeyPress(Sender: TObject; var Key: Char);
    procedure DWChallengeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChallengeGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DChallengeGridGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DChallengeGridGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DChallengeCloseClick(Sender: TObject; X, Y: Integer);
    procedure DRChallengeGridGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DRChallengeGridGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TDGridDrawState;
      dsurface: TDirectDrawSurface);
    procedure DChallengeOKClick(Sender: TObject; X, Y: Integer);
    procedure DChallengeGoldClick(Sender: TObject; X, Y: Integer);
    procedure btnRecvChrCloseClick(Sender: TObject; X, Y: Integer);
    procedure dgrdRecoverNameGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TDGridDrawState;
      dsurface: TDirectDrawSurface);
    procedure dgrdRecoverNameGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure btnRecoverClick(Sender: TObject; X, Y: Integer);
    procedure DWChallengeMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DEdtSdoCommonHpTimerKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DCheckSdoExpFiltrateMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWNewSdoAssistantMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DStateTabClick(Sender: TObject; X, Y: Integer);
    procedure DStateTabDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStateTabDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStateTabClick(Sender: TObject; X, Y: Integer);
    procedure DSighIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSighIconClick(Sender: TObject; X, Y: Integer);
    procedure DCrystalExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DExpCrystalTopMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWExpCrystalMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DCrystalExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DExpCrystalTopDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DExpCrystalTopClick(Sender: TObject; X, Y: Integer);
    procedure DBotGroupMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DNewBoxsHelpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHelpBtnClick(Sender: TObject; X, Y: Integer);
    procedure DNewBoxsHelpCloseClick(Sender: TObject; X, Y: Integer);
    procedure DCheckAutoOpenBoxsDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBoxsNewCloseClick(Sender: TObject; X, Y: Integer);
    procedure DCheckAutoOpenBoxsClick(Sender: TObject; X, Y: Integer);
    procedure DSdoMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DSdoMemoScrollBarDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure m_EdIdKeyPress(Sender: TObject; var Key: Char);
    procedure m_EdPasswdKeyPress(Sender: TObject; var Key: Char);
    procedure m_EdIdKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure m_EdPasswdKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DAdjustAbilOkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGDWarClick(Sender: TObject; X, Y: Integer);
    procedure DWNQStateMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DNQBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DNQExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNQStateDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKimNeedleHelpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWKimNeedleDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKimNeedleLogoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKimNeedle1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DKimNeedle6DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWKimNeedleMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKimNeedle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKimNeedle6MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKimNeedleHelpClick(Sender: TObject; X, Y: Integer);
    procedure DKimNeedleMemoClick(Sender: TObject; X, Y: Integer);
    procedure DStartKimNeedleClick(Sender: TObject; X, Y: Integer);
    procedure DKimNeedleCloseClick(Sender: TObject; X, Y: Integer);
    procedure DKimNeedle1Click(Sender: TObject; X, Y: Integer);
    procedure DKimNeedleBarDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateSsasDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateSsasClick(Sender: TObject; X, Y: Integer);
    procedure DStateWinPulseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateWinPulseMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DStateWinPulseClick(Sender: TObject; X, Y: Integer);
    procedure DWinBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DStateWinBatterDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWinBatterComDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroSpleenDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBatterShowImgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWinBatterComMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWinBatterComMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWinBatterRandomDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWinBatterRandomClick(Sender: TObject; X, Y: Integer);
    procedure DWinBatterSetKeyClick(Sender: TObject; X, Y: Integer);
    procedure DWinBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWinBatterTopMag1MouseUp(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWinBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DStateWinBatterMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroStateSsasClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateSsasDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoWhisperListDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoWhisperListMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DMemoWhisperListClick(Sender: TObject; X, Y: Integer);
    procedure DMemoWhisperListScrollBarChange(Sender: TObject);
    procedure DWhisperCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBWhisperClick(Sender: TObject; X, Y: Integer);
    procedure DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DStMagHero1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DKeySelDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBHelpClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateWinPulseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroStateWinPulseClick(Sender: TObject; X, Y: Integer);
    procedure DHeroStateWinPulseMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroStateWinBatterDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroBatterTopMag1MouseUp(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
    procedure DHeroBatterComDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroBatterComMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroBatterComMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure HBExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure HBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure JQExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure JQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWHeroAssessDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroAssessSign1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBCallDeputyHeroClick(Sender: TObject; X, Y: Integer);
    procedure DCheckDeputyHeroWarrClick(Sender: TObject; X, Y: Integer);
    procedure DCheckHeroDeputyHeroWarrClick(Sender: TObject; X,
      Y: Integer);
    procedure DHeroAssessSignClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAssessMenuDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroAssessMenuMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DHeroAssessMenuMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DHeroAssessCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWHeroAutoPracticeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroAutoPracticeMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroAutoPraMapPrevClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAutoPraYDSPrevClick(Sender: TObject; X, Y: Integer);
    procedure DHeroAutoPraCloseClick(Sender: TObject; X, Y: Integer);
    procedure DStartHeroAutoPraClick(Sender: TObject; X, Y: Integer);
    procedure DCheckHeroLevelHintClick(Sender: TObject; X, Y: Integer);
    procedure DHeroJQExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DHeroJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWJenniferLongBoxDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DJLChangeItemMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DJLBoxBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DJLBoxBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWJenniferLongBoxMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWJenniferLongBoxClick(Sender: TObject; X, Y: Integer);
    procedure DJenniferLongBoxCloseClick(Sender: TObject; X, Y: Integer);
    procedure DJLChangeItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DJLChangeItemClick(Sender: TObject; X, Y: Integer);
    procedure DJLStartItemClick(Sender: TObject; X, Y: Integer);
    procedure DJLBoxBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DJLBoxBelt1DblClick(Sender: TObject);
    procedure DJLBoxFlashDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGJLBoxFreeItemGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TDGridDrawState;
      dsurface: TDirectDrawSurface);
    procedure DGJLBoxFreeItemGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGJLBoxFreeItemGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DGJLBoxFreeItemDblClick(Sender: TObject);
    procedure DBCommandFrameDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBCommandMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBCommandFrameMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBCommandFrameMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DCBFilterItemStdModeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DEdtFilterItemStdModeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBtnDefaultFilterItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DEdtFilterItemStdModeChange(Sender: TObject);
    procedure DCBFilterItemStdModeChange(Sender: TObject);
    procedure DBtnDefaultFilterItemClick(Sender: TObject; X, Y: Integer);
    procedure DListViewFilterItemListItemClick(Sender: TObject; ARow,
      ACol: Integer; ListItem: TDListItem; ViewItem: pTViewItem);
    procedure DBotMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWWStallPriceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBWStallPriceTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBWStallPriceTab1Click(Sender: TObject; X, Y: Integer);
    procedure DBotStallClick(Sender: TObject; X, Y: Integer);
    procedure DGStallGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DGStallGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBStallCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBWStallPriceCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBWStallPriceOKClick(Sender: TObject; X, Y: Integer);
    procedure DBtnStallStartClick(Sender: TObject; X, Y: Integer);
    procedure DBtnStallStopClick(Sender: TObject; X, Y: Integer);
    procedure DGStallGridMouseMove(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DGUserStallGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DGUserStallGridMouseMove(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWUserStallDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWStallMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWUserStallMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DGUserStallGridSelect(Sender: TObject; ACol, ARow: Integer;
      Shift: TShiftState);
    procedure DBBuyUserStallItemClick(Sender: TObject; X, Y: Integer);
    procedure DWMiniMapDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWMiniMapMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWMiniMapMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DTreeViewMission1Select(Sender: TObject; TreeNode: TDTreeNode);
    procedure DMemoMissionBottomDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoMissionBottomMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DMemoMissionBottomClick(Sender: TObject; X, Y: Integer);
    procedure DMemoMissionBottomScrollBarChange(Sender: TObject);
    procedure DBMissionCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBMission1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBMission1Click(Sender: TObject; X, Y: Integer);
    procedure DBMissionClick(Sender: TObject; X, Y: Integer);
    procedure DBMissionDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBMissionClose1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWSkillMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBSkillMemoIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBSkillMemoCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBHeroSkillMemoCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBJDSeeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBJDSeeClick(Sender: TObject; X, Y: Integer);
    procedure DBJDSeeMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBHeroQSSSeeClick(Sender: TObject; X, Y: Integer);
    procedure DWHeroSkillMemoDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBHeroSkillMemoIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBHeroSkillMemoLinkDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBHeroSkillMemoLinkClick(Sender: TObject; X, Y: Integer);
    procedure DBHeroSkillMemoLinkMouseUp(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DBHeroSkillMemoLinkMouseDown(Sender: TObject;
      Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure DWSignedItemsDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBSignedItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBSignedItemClick(Sender: TObject; X, Y: Integer);
    procedure DBOrdSignedDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBSignedBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBSignedBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DBSignedItemsCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWJudgeItemsDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBJudgeItemClick(Sender: TObject; X, Y: Integer);
    procedure DBJudgeItemsCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWMakeSignedDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBMakeSignedExp1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DWMakeSignedMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBMakeSignedReadClick(Sender: TObject; X, Y: Integer);
    procedure DBOrdSignedClick(Sender: TObject; X, Y: Integer);
    procedure DBSignedBelt1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWSignedItemsMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBSignedChangeClick(Sender: TObject; X, Y: Integer);
    procedure DscStartDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBMakeSignedBelt3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBMakeSignedBelt3Click(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedLeve1Click(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBMakeSignedCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedBelt3MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBMakeSignedBelt1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBMakeSignedReadStartClick(Sender: TObject; X, Y: Integer);
    procedure DBMakeSignedExp1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBLingMeiBeltDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBLingMeiBeltClick(Sender: TObject; X, Y: Integer);
    procedure DIndividualOrderDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBLevelOrderUseItemClick(Sender: TObject; X, Y: Integer);
    procedure DBJudgeBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBJudgeBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DBJudgeStartClick(Sender: TObject; X, Y: Integer);
    procedure DLevelOrderClick(Sender: TObject; X, Y: Integer);
    procedure DBItemLevelBelt1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBItemLevelBelt1Click(Sender: TObject; X, Y: Integer);
    procedure DWLevelOrderMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBJudgeBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWJudgeItemsMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBLingMeiBeltMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBLingMeiBeltDblClick(Sender: TObject);
    procedure DLoginNewInitialize(Sender: TObject);
    procedure DLoginOkInitialize(Sender: TObject);
    procedure DLoginCloseInitialize(Sender: TObject);
    procedure DLoginChgPwInitialize(Sender: TObject);
    procedure DLogInInitialize(Sender: TObject);
    procedure DNewAccountOkInitialize(Sender: TObject);
    procedure DNewAccountCancelInitialize(Sender: TObject);
    procedure DNewAccountCloseInitialize(Sender: TObject);
    procedure DNewAccountInitialize(Sender: TObject);
    procedure DSServer1Initialize(Sender: TObject);
    procedure DSServer2Initialize(Sender: TObject);
    procedure DSServer3Initialize(Sender: TObject);
    procedure DSServer4Initialize(Sender: TObject);
    procedure DSServer5Initialize(Sender: TObject);
    procedure DSServer6Initialize(Sender: TObject);
    procedure DSSrvCloseInitialize(Sender: TObject);
    procedure DSelServerDlgInitialize(Sender: TObject);
    procedure DccWarriorInitialize(Sender: TObject);
    procedure DccWizzardInitialize(Sender: TObject);
    procedure DccMonkInitialize(Sender: TObject);
    procedure DccMaleInitialize(Sender: TObject);
    procedure DccFemaleInitialize(Sender: TObject);
    procedure DccLeftHairInitialize(Sender: TObject);
    procedure DccRightHairInitialize(Sender: TObject);
    procedure DccOkInitialize(Sender: TObject);
    procedure DccCloseInitialize(Sender: TObject);
    procedure DCreateChrInitialize(Sender: TObject);
    procedure DChgpwOkInitialize(Sender: TObject);
    procedure DChgpwCancelInitialize(Sender: TObject);
    procedure DChgPwInitialize(Sender: TObject);
    procedure DKsF1Initialize(Sender: TObject);
    procedure DKsF2Initialize(Sender: TObject);
    procedure DKsF3Initialize(Sender: TObject);
    procedure DKsF4Initialize(Sender: TObject);
    procedure DKsF5Initialize(Sender: TObject);
    procedure DKsF6Initialize(Sender: TObject);
    procedure DKsF7Initialize(Sender: TObject);
    procedure DKsF8Initialize(Sender: TObject);
    procedure DKsConF1Initialize(Sender: TObject);
    procedure DKsConF2Initialize(Sender: TObject);
    procedure DKsConF3Initialize(Sender: TObject);
    procedure DKsConF4Initialize(Sender: TObject);
    procedure DKsConF5Initialize(Sender: TObject);
    procedure DKsConF6Initialize(Sender: TObject);
    procedure DKsConF7Initialize(Sender: TObject);
    procedure DKsConF8Initialize(Sender: TObject);
    procedure DKsNoneInitialize(Sender: TObject);
    procedure DKsOkInitialize(Sender: TObject);
    procedure DKeySelDlgInitialize(Sender: TObject);
    procedure DscSelect1Initialize(Sender: TObject);
    procedure DscSelect2Initialize(Sender: TObject);
    procedure DscStartInitialize(Sender: TObject);
    procedure DscNewChrInitialize(Sender: TObject);
    procedure DscEraseChrInitialize(Sender: TObject);
    procedure DscCreditsInitialize(Sender: TObject);
    procedure DscExitInitialize(Sender: TObject);
    procedure DItemGridInitialize(Sender: TObject);
    procedure DGoldInitialize(Sender: TObject);
    procedure DWGameGoldInitialize(Sender: TObject);
    procedure DItemsUpButInitialize(Sender: TObject);
    procedure DCloseBagInitialize(Sender: TObject);
    procedure DItemBagInitialize(Sender: TObject);
    procedure DDRGoldInitialize(Sender: TObject);
    procedure DDealRemoteDlgInitialize(Sender: TObject);
    procedure DDGoldInitialize(Sender: TObject);
    procedure DDealOkInitialize(Sender: TObject);
    procedure DDealCloseInitialize(Sender: TObject);
    procedure DDealDlgInitialize(Sender: TObject);
    procedure DMenuPrevInitialize(Sender: TObject);
    procedure DMenuNextInitialize(Sender: TObject);
    procedure DMenuBuyInitialize(Sender: TObject);
    procedure DMenuCloseInitialize(Sender: TObject);
    procedure DMenuDlgInitialize(Sender: TObject);
    procedure DStateTabInitialize(Sender: TObject);
    procedure DCloseStateInitialize(Sender: TObject);
    procedure DStateSsasInitialize(Sender: TObject);
    procedure DPrevStateInitialize(Sender: TObject);
    procedure DNextStateInitialize(Sender: TObject);
    procedure DBJDSeeInitialize(Sender: TObject);
    procedure HBExpInitialize(Sender: TObject);
    procedure JQExpInitialize(Sender: TObject);
    procedure DStPageUpInitialize(Sender: TObject);
    procedure DStPageDownInitialize(Sender: TObject);
    procedure DLiquorProgressInitialize(Sender: TObject);
    procedure DStateWinInitialize(Sender: TObject);
    procedure DGrpAllowGroupInitialize(Sender: TObject);
    procedure DGrpCreateInitialize(Sender: TObject);
    procedure DGrpAddMemInitialize(Sender: TObject);
    procedure DGrpDelMemInitialize(Sender: TObject);
    procedure DGrpDlgCloseInitialize(Sender: TObject);
    procedure DGroupDlgInitialize(Sender: TObject);
    procedure DGEOkInitialize(Sender: TObject);
    procedure DGECloseInitialize(Sender: TObject);
    procedure DGuildEditNoticeInitialize(Sender: TObject);
    procedure DIndividualOrderInitialize(Sender: TObject);
    procedure DHeroOrderInitialize(Sender: TObject);
    procedure DMasterOrderInitialize(Sender: TObject);
    procedure DBLevelOrderUseItemInitialize(Sender: TObject);
    procedure DBLevelOrderCloudInitialize(Sender: TObject);
    procedure DLevelOrderCloseInitialize(Sender: TObject);
    procedure DColonyHeroOrderInitialize(Sender: TObject);
    procedure DWarriorOrderInitialize(Sender: TObject);
    procedure DWizerdOrderInitialize(Sender: TObject);
    procedure DTaoistOrderInitialize(Sender: TObject);
    procedure DHeroAllOrderInitialize(Sender: TObject);
    procedure DWarriorHeroOrderInitialize(Sender: TObject);
    procedure DWizerdHeroOrderInitialize(Sender: TObject);
    procedure DTaoistHeroOrderInitialize(Sender: TObject);
    procedure DLevelOrderIndexInitialize(Sender: TObject);
    procedure DLevelOrderPrevInitialize(Sender: TObject);
    procedure DLevelOrderNextInitialize(Sender: TObject);
    procedure DLevelOrderLastPageInitialize(Sender: TObject);
    procedure DMyLevelOrderInitialize(Sender: TObject);
    procedure DBOrderWeaponInitialize(Sender: TObject);
    procedure DBOrderRingInitialize(Sender: TObject);
    procedure DBOrderDressInitialize(Sender: TObject);
    procedure DBOrderBootsInitialize(Sender: TObject);
    procedure DBOrderHelmetInitialize(Sender: TObject);
    procedure DBOrderBeltInitialize(Sender: TObject);
    procedure DBOrderNecklaceInitialize(Sender: TObject);
    procedure DBOrderMedalInitialize(Sender: TObject);
    procedure DBOrderWristletInitialize(Sender: TObject);
    procedure DBOrderHatInitialize(Sender: TObject);
    procedure DWLevelOrderInitialize(Sender: TObject);
    procedure m_EdIdInitialize(Sender: TObject);
    procedure m_EdPasswdInitialize(Sender: TObject);
    procedure DBotMiniMapInitialize(Sender: TObject);
    procedure DBotTradeInitialize(Sender: TObject);
    procedure DBotGuildInitialize(Sender: TObject);
    procedure DBotGroupInitialize(Sender: TObject);
    procedure DBotPlusAbilInitialize(Sender: TObject);
    procedure DBotFriendInitialize(Sender: TObject);
    procedure ChallengeInitialize(Sender: TObject);
    procedure CharacterSrankingInitialize(Sender: TObject);
    procedure DBWhisperInitialize(Sender: TObject);
    procedure DBotStallInitialize(Sender: TObject);
    procedure DBotLogoutInitialize(Sender: TObject);
    procedure DBotExitInitialize(Sender: TObject);
    procedure DBHelpInitialize(Sender: TObject);
    procedure DMyStateInitialize(Sender: TObject);
    procedure DMyBagInitialize(Sender: TObject);
    procedure DMyMagicInitialize(Sender: TObject);
    procedure DOptionInitialize(Sender: TObject);
    procedure DDrunkScaleInitialize(Sender: TObject);
    procedure DBRefusePublicChatInitialize(Sender: TObject);
    procedure DBRefuseCRYInitialize(Sender: TObject);
    procedure DBRefuseWHISPERInitialize(Sender: TObject);
    procedure DBRefuseguildInitialize(Sender: TObject);
    procedure DBCommandInitialize(Sender: TObject);
    procedure DBAutoCRYInitialize(Sender: TObject);
    procedure DBInternetInitialize(Sender: TObject);
    procedure DBMissionInitialize(Sender: TObject);
    procedure DBatterShowImgInitialize(Sender: TObject);
    procedure DBCallHeroInitialize(Sender: TObject);
    procedure DBHeroStateInitialize(Sender: TObject);
    procedure DBHeroPackageInitialize(Sender: TObject);
    procedure DBCallDeputyHeroInitialize(Sender: TObject);
    procedure DBotMemoInitialize(Sender: TObject);
    procedure DMsgDlgOkInitialize(Sender: TObject);
    procedure DMsgDlgCancelInitialize(Sender: TObject);
    procedure DMsgDlgYesInitialize(Sender: TObject);
    procedure DMsgDlgNoInitialize(Sender: TObject);
    procedure DMsgDlgInitialize(Sender: TObject);
    procedure DStateWinPulseInitialize(Sender: TObject);
    procedure DWinBatterRandomInitialize(Sender: TObject);
    procedure DWinBatterSetKeyInitialize(Sender: TObject);
    procedure DWinBatterComInitialize(Sender: TObject);
    procedure DHeroItemBagInitialize(Sender: TObject);
    procedure DHeroItemGridCloseInitialize(Sender: TObject);
    procedure DExpCrystalTopInitialize(Sender: TObject);
    procedure DCrystalExpInitialize(Sender: TObject);
    procedure DCrystalNGExpInitialize(Sender: TObject);
    procedure DWExpCrystalInitialize(Sender: TObject);
    procedure DMerchantDlgInitialize(Sender: TObject);
    procedure DMerchantDlgCloseInitialize(Sender: TObject);
    procedure DBtnStallStartInitialize(Sender: TObject);
    procedure DBtnStallStopInitialize(Sender: TObject);
    procedure DBStallCloseInitialize(Sender: TObject);
    procedure DWStallInitialize(Sender: TObject);
    procedure DBWStallPriceTab1Initialize(Sender: TObject);
    procedure DBWStallPriceTab2Initialize(Sender: TObject);
    procedure DBWStallPriceOKInitialize(Sender: TObject);
    procedure DBWStallPriceCancelInitialize(Sender: TObject);
    procedure DBWStallPriceCloseInitialize(Sender: TObject);
    procedure DWWStallPriceInitialize(Sender: TObject);
    procedure DBBuyUserStallItemInitialize(Sender: TObject);
    procedure DBUserStallCloseInitialize(Sender: TObject);
    procedure DWUserStallInitialize(Sender: TObject);
    procedure DGDUpInitialize(Sender: TObject);
    procedure DGDDownInitialize(Sender: TObject);
    procedure DGDCloseInitialize(Sender: TObject);
    procedure DGDHomeInitialize(Sender: TObject);
    procedure DGDAddMemInitialize(Sender: TObject);
    procedure DGDEditNoticeInitialize(Sender: TObject);
    procedure DGDAllyInitialize(Sender: TObject);
    procedure DGDWarInitialize(Sender: TObject);
    procedure DGDListInitialize(Sender: TObject);
    procedure DGDChatInitialize(Sender: TObject);
    procedure DGDDelMemInitialize(Sender: TObject);
    procedure DGDEditGradeInitialize(Sender: TObject);
    procedure DGDBreakAllyInitialize(Sender: TObject);
    procedure DGDCancelWarInitialize(Sender: TObject);
    procedure DGuildDlgInitialize(Sender: TObject);
    procedure DBMission1Initialize(Sender: TObject);
    procedure DBMission2Initialize(Sender: TObject);
    procedure DBMission3Initialize(Sender: TObject);
    procedure DBMissionCloseInitialize(Sender: TObject);
    procedure DBMissionClose1Initialize(Sender: TObject);
    procedure DScrollBarMission1Initialize(Sender: TObject);
    procedure DTreeViewMission1Initialize(Sender: TObject);
    procedure DWMissionInitialize(Sender: TObject);
    procedure DMemoMissionBottomInitialize(Sender: TObject);
    procedure DMemoMissionBottomScrollBarInitialize(Sender: TObject);
    procedure DSellDlgInitialize(Sender: TObject);
    procedure DSellDlgCloseInitialize(Sender: TObject);
    procedure DSellDlgOkInitialize(Sender: TObject);
    procedure DPlusMCInitialize(Sender: TObject);
    procedure DPlusDCInitialize(Sender: TObject);
    procedure DPlusSCInitialize(Sender: TObject);
    procedure DPlusACInitialize(Sender: TObject);
    procedure DPlusMACInitialize(Sender: TObject);
    procedure DPlusHPInitialize(Sender: TObject);
    procedure DPlusMPInitialize(Sender: TObject);
    procedure DPlusHitInitialize(Sender: TObject);
    procedure DPlusSpeedInitialize(Sender: TObject);
    procedure DMinusDCInitialize(Sender: TObject);
    procedure DMinusMCInitialize(Sender: TObject);
    procedure DMinusSCInitialize(Sender: TObject);
    procedure DMinusACInitialize(Sender: TObject);
    procedure DMinusMACInitialize(Sender: TObject);
    procedure DMinusHPInitialize(Sender: TObject);
    procedure DMinusMPInitialize(Sender: TObject);
    procedure DMinusHitInitialize(Sender: TObject);
    procedure DMinusSpeedInitialize(Sender: TObject);
    procedure DAdjustAbilCloseInitialize(Sender: TObject);
    procedure DAdjustAbilOkInitialize(Sender: TObject);
    procedure DAdjustAbilityInitialize(Sender: TObject);
    procedure DHeroIconInitialize(Sender: TObject);
    procedure DCloseUS1Initialize(Sender: TObject);
    procedure DUserState1Initialize(Sender: TObject);
    procedure DSelHero1Initialize(Sender: TObject);
    procedure DSelHero2Initialize(Sender: TObject);
    procedure DGetHeroCloseInitialize(Sender: TObject);
    procedure DWiGetHeroInitialize(Sender: TObject);
    procedure DCheckNumOKInitialize(Sender: TObject);
    procedure DCheckNumChangeInitialize(Sender: TObject);
    procedure DCheckNumCloseInitialize(Sender: TObject);
    procedure DWCheckNumInitialize(Sender: TObject);
    procedure DChallengeOKInitialize(Sender: TObject);
    procedure DChallengeCancelInitialize(Sender: TObject);
    procedure DChallengeCloseInitialize(Sender: TObject);
    procedure DWChallengeInitialize(Sender: TObject);
    procedure DBoxsBelt1Initialize(Sender: TObject);
    procedure DBoxsBelt2Initialize(Sender: TObject);
    procedure DBoxsBelt3Initialize(Sender: TObject);
    procedure DBoxsBelt4Initialize(Sender: TObject);
    procedure DBoxsBelt5Initialize(Sender: TObject);
    procedure DBoxsBelt6Initialize(Sender: TObject);
    procedure DBoxsBelt7Initialize(Sender: TObject);
    procedure DBoxsBelt8Initialize(Sender: TObject);
    procedure DBoxsBelt9Initialize(Sender: TObject);
    procedure DBNewHelpBtnInitialize(Sender: TObject);
    procedure DBoxsNewCloseInitialize(Sender: TObject);
    procedure DNewBoxsHelpCloseInitialize(Sender: TObject);
    procedure DNewBoxsHelpInitialize(Sender: TObject);
    procedure DBoxsInitialize(Sender: TObject);
    procedure DFriendDlgFrdInitialize(Sender: TObject);
    procedure DFriendDlgTangetInitialize(Sender: TObject);
    procedure DHeiMingDanInitialize(Sender: TObject);
    procedure DAddFriendInitialize(Sender: TObject);
    procedure DDelFriendInitialize(Sender: TObject);
    procedure DPrevFriendDlgInitialize(Sender: TObject);
    procedure DNextFriendDlgInitialize(Sender: TObject);
    procedure DFrdCloseInitialize(Sender: TObject);
    procedure DFriendDlgInitialize(Sender: TObject);
    procedure DSighIconInitialize(Sender: TObject);
    procedure DItemsUpOkInitialize(Sender: TObject);
    procedure DItemsUpCloseInitialize(Sender: TObject);
    procedure DItemsUpInitialize(Sender: TObject);
    procedure DSellOffOkInitialize(Sender: TObject);
    procedure DSellOffCancelInitialize(Sender: TObject);
    procedure DSellOffCloseInitialize(Sender: TObject);
    procedure DWSellOffInitialize(Sender: TObject);
    procedure DSellOffListCancelInitialize(Sender: TObject);
    procedure DSellOffBuyCancelInitialize(Sender: TObject);
    procedure DSellOffBuyInitialize(Sender: TObject);
    procedure DSellOffListColseInitialize(Sender: TObject);
    procedure DWSellOffListInitialize(Sender: TObject);
    procedure DMemoWhisperListInitialize(Sender: TObject);
    procedure DMemoWhisperListScrollBarInitialize(Sender: TObject);
    procedure DWhisperCloseInitialize(Sender: TObject);
    procedure DWWhisperInitialize(Sender: TObject);
    procedure DHeroAssessSign1Initialize(Sender: TObject);
    procedure DHeroAssessClose1Initialize(Sender: TObject);
    procedure DHeroAssessSignInitialize(Sender: TObject);
    procedure DHeroAssessCloseInitialize(Sender: TObject);
    procedure DWHeroAssessInitialize(Sender: TObject);
    procedure DHeroAutoPraMapPrevInitialize(Sender: TObject);
    procedure DHeroAutoPraMapNextInitialize(Sender: TObject);
    procedure DHeroAutoPraYDSPrevInitialize(Sender: TObject);
    procedure DHeroAutoPraYDSNextInitialize(Sender: TObject);
    procedure DStartHeroAutoPraInitialize(Sender: TObject);
    procedure DHeroAutoPraCloseInitialize(Sender: TObject);
    procedure DWHeroAutoPracticeInitialize(Sender: TObject);
    procedure DShopPrevInitialize(Sender: TObject);
    procedure DShopNextInitialize(Sender: TObject);
    procedure DShopBuyInitialize(Sender: TObject);
    procedure DShopPresentInitialize(Sender: TObject);
    procedure DShopClose1Initialize(Sender: TObject);
    procedure DShopCloseInitialize(Sender: TObject);
    procedure DShopInitialize(Sender: TObject);
    procedure DStateHeroInitialize(Sender: TObject);
    procedure DHeroStateTabInitialize(Sender: TObject);
    procedure DCloseHeroStateInitialize(Sender: TObject);
    procedure DHeroStateSsasInitialize(Sender: TObject);
    procedure DPrevStateHeroInitialize(Sender: TObject);
    procedure DNextStateHeroInitialize(Sender: TObject);
    procedure DSHPageUpInitialize(Sender: TObject);
    procedure DSHPageDownInitialize(Sender: TObject);
    procedure DHeroJQExpInitialize(Sender: TObject);
    procedure DBHeroQSSSeeInitialize(Sender: TObject);
    procedure DHeroLiquorProgressInitialize(Sender: TObject);
    procedure DHeroStateWinPulseInitialize(Sender: TObject);
    procedure DHeroBatterRandomInitialize(Sender: TObject);
    procedure DHeroBatterComInitialize(Sender: TObject);
    procedure DHeroStateWinBatterInitialize(Sender: TObject);
    procedure DPDrink1Initialize(Sender: TObject);
    procedure DPDrink2Initialize(Sender: TObject);
    procedure DPleaseDrinkDrinkInitialize(Sender: TObject);
    procedure DPleaseDrinkExitInitialize(Sender: TObject);
    procedure DWPleaseDrinkInitialize(Sender: TObject);
    procedure DPleaseDrinkCloseInitialize(Sender: TObject);
    procedure DDrink1Initialize(Sender: TObject);
    procedure DDrink2Initialize(Sender: TObject);
    procedure DDrink3Initialize(Sender: TObject);
    procedure DDrink4Initialize(Sender: TObject);
    procedure DDrink5Initialize(Sender: TObject);
    procedure DDrink6Initialize(Sender: TObject);
    procedure DPlayDrinkCloseInitialize(Sender: TObject);
    procedure DPlayDrinkFistInitialize(Sender: TObject);
    procedure DPlayDrinkScissorsInitialize(Sender: TObject);
    procedure DPlayDrinkClothInitialize(Sender: TObject);
    procedure DPlayFistInitialize(Sender: TObject);
    procedure DPlayDrinkInitialize(Sender: TObject);
    procedure btnRecoverInitialize(Sender: TObject);
    procedure btnRecvChrCloseInitialize(Sender: TObject);
    procedure dwRecoverChrInitialize(Sender: TObject);
    procedure DMakeWineHelpInitialize(Sender: TObject);
    procedure DMaterialMemoInitialize(Sender: TObject);
    procedure DStartMakeWineInitialize(Sender: TObject);
    procedure DMakeWineDeskCloseInitialize(Sender: TObject);
    procedure DWMakeWineDeskInitialize(Sender: TObject);
    procedure DNQExpInitialize(Sender: TObject);
    procedure DWNQStateInitialize(Sender: TObject);
    procedure DKimNeedleHelpInitialize(Sender: TObject);
    procedure DKimNeedleMemoInitialize(Sender: TObject);
    procedure DStartKimNeedleInitialize(Sender: TObject);
    procedure DKimNeedleLogoInitialize(Sender: TObject);
    procedure DKimNeedleBarInitialize(Sender: TObject);
    procedure DKimNeedleCloseInitialize(Sender: TObject);
    procedure DWKimNeedleInitialize(Sender: TObject);
    procedure DJLBoxBelt8Initialize(Sender: TObject);
    procedure DJLBoxBelt1Initialize(Sender: TObject);
    procedure DJLBoxBelt2Initialize(Sender: TObject);
    procedure DJLBoxBelt3Initialize(Sender: TObject);
    procedure DJLBoxBelt4Initialize(Sender: TObject);
    procedure DJLBoxBelt5Initialize(Sender: TObject);
    procedure DJLBoxBelt6Initialize(Sender: TObject);
    procedure DJLBoxBelt7Initialize(Sender: TObject);
    procedure DJLChangeItemInitialize(Sender: TObject);
    procedure DJLStartItemInitialize(Sender: TObject);
    procedure DJenniferLongBoxCloseInitialize(Sender: TObject);
    procedure DWJenniferLongBoxInitialize(Sender: TObject);
    procedure DBSkillMemoCloseInitialize(Sender: TObject);
    procedure DWSkillMemoInitialize(Sender: TObject);
    procedure DBHeroSkillMemoCloseInitialize(Sender: TObject);
    procedure DWHeroSkillMemoInitialize(Sender: TObject);
    procedure DBSignedItemInitialize(Sender: TObject);
    procedure DBSignedChangeItemInitialize(Sender: TObject);
    procedure DBSignedMemoInitialize(Sender: TObject);
    procedure DBSignedChangeMemoInitialize(Sender: TObject);
    procedure DBSignedBelt1Initialize(Sender: TObject);
    procedure DBSignedBelt2Initialize(Sender: TObject);
    procedure DBSignedChangeInitialize(Sender: TObject);
    procedure DBOrdSignedInitialize(Sender: TObject);
    procedure DBHighSignedInitialize(Sender: TObject);
    procedure DBSignedItemsCloseInitialize(Sender: TObject);
    procedure DWSignedItemsInitialize(Sender: TObject);
    procedure DBJudgeItemInitialize(Sender: TObject);
    procedure DBJudgeItemMemoInitialize(Sender: TObject);
    procedure DBJudgeBelt1Initialize(Sender: TObject);
    procedure DBJudgeStartInitialize(Sender: TObject);
    procedure DBJudgeItemsCloseInitialize(Sender: TObject);
    procedure DWJudgeItemsInitialize(Sender: TObject);
    procedure DBMakeSignedReadInitialize(Sender: TObject);
    procedure DBMakeSignedMakeInitialize(Sender: TObject);
    procedure DBMakeSignedReadMemoInitialize(Sender: TObject);
    procedure DBMakeSignedMakeMemoInitialize(Sender: TObject);
    procedure DBMakeSignedExp1Initialize(Sender: TObject);
    procedure DBMakeSignedExp2Initialize(Sender: TObject);
    procedure DBMakeSignedBelt1Initialize(Sender: TObject);
    procedure DBMakeSignedBelt2Initialize(Sender: TObject);
    procedure DBMakeSignedBelt3Initialize(Sender: TObject);
    procedure DBMakeSignedReadStartInitialize(Sender: TObject);
    procedure DBMakeSignedLeve1Initialize(Sender: TObject);
    procedure DBMakeSignedLeve2Initialize(Sender: TObject);
    procedure DBMakeSignedLeve3Initialize(Sender: TObject);
    procedure DBMakeSignedLeve4Initialize(Sender: TObject);
    procedure DBMakeSignedCloseInitialize(Sender: TObject);
    procedure DWMakeSignedInitialize(Sender: TObject);
    procedure DWNewSdoAssistantInitialize(Sender: TObject);
    procedure DNewSdoBasicInitialize(Sender: TObject);
    procedure DNewSdoFilterItemInitialize(Sender: TObject);
    procedure DNewSdoProtectInitialize(Sender: TObject);
    procedure DNewSdoSkillInitialize(Sender: TObject);
    procedure DNewSdoKeyInitialize(Sender: TObject);
    procedure DNedSdoHelpInitialize(Sender: TObject);
    procedure DScrollBarFilterItemInitialize(Sender: TObject);
    procedure DListViewFilterItemInitialize(Sender: TObject);
    procedure DNewSdoAssistantCloseInitialize(Sender: TObject);
    procedure DCBFilterItemStdModeInitialize(Sender: TObject);
    procedure DCheckSdoStartKeyInitialize(Sender: TObject);
    procedure DSdoMemoScrollBarInitialize(Sender: TObject);
    procedure DSdoMemoInitialize(Sender: TObject);
    procedure DSWBujukDblClick(Sender: TObject);
    procedure DBNewSdoProtect1Initialize(Sender: TObject);
    procedure DScrollBarProInitialize(Sender: TObject);
    procedure DScrollBoxProDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBProMySelfDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBProMySelfInitialize(Sender: TObject);
    procedure DBProMySelfClick(Sender: TObject; X, Y: Integer);
    procedure DCheckSdoNameShowInitialize(Sender: TObject);
    procedure DCBBookHPManInitialize(Sender: TObject);
    procedure DCBBookHPManDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckBoxBookHPProClick(Sender: TObject; X, Y: Integer);
    procedure DCBBookHPManChange(Sender: TObject);
    procedure DEdtBookHPProChange(Sender: TObject);
    procedure DScrollBoxProMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWQJPracticeInitialize(Sender: TObject);
    procedure DWQJPracticeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBQJPracticeCloseInitialize(Sender: TObject);
    procedure DBQJPracticePage1Initialize(Sender: TObject);
    procedure DBQJPracticePage1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBQJPracticeStartInitialize(Sender: TObject);
    procedure DBQJPracticeItemDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBQJPracticeItemClick(Sender: TObject; X, Y: Integer);
    procedure DBQJPracticeCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWQJFurnaceInitialize(Sender: TObject);
    procedure DBQJFurnaceCloseInitialize(Sender: TObject);
    procedure DWQJFurnaceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBQJPracticeStartClick(Sender: TObject; X, Y: Integer);
    procedure DLQJPracticeLink1Click(Sender: TObject; X, Y: Integer);
    procedure DLQJPracticeLink3Click(Sender: TObject; X, Y: Integer);
    procedure DLQJPracticeLink4Click(Sender: TObject; X, Y: Integer);
    procedure DBQJFurnaceStartClick(Sender: TObject; X, Y: Integer);
    procedure DBQJFurnaceCloseClick(Sender: TObject; X, Y: Integer);
    procedure DScrollBoxProInitialize(Sender: TObject);
    procedure DScrollBarKeyInitialize(Sender: TObject);
    procedure DScrollBoxKeyInitialize(Sender: TObject);
    procedure DScrollBoxKeySurfaceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBTitleManInitialize(Sender: TObject);
    procedure DBTitle1Initialize(Sender: TObject);
    procedure DBPrevTitleInitialize(Sender: TObject);
    procedure DBNextTitleInitialize(Sender: TObject);
    procedure DBTitle1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBTitleManDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBTitle1Click(Sender: TObject; X, Y: Integer);
    procedure DBTitleManClick(Sender: TObject; X, Y: Integer);
    procedure DBPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBUserTitle1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBUserTitleManDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBUserPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBUserTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWPFLingPaiInitialize(Sender: TObject);
    procedure DWPFLingPaiDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBPFLingPaiIcon1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBPFLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWPFLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBPFLingPaiCloseInitialize(Sender: TObject);
    procedure DBPFLingPaiCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLPFLingPaiPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBPFLingPaiName1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBPFLingPaiCall1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBPFLingPaiMove1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBPFLingPaiCall1Click(Sender: TObject; X, Y: Integer);
    procedure DBPFLingPaiMove1Click(Sender: TObject; X, Y: Integer);
    procedure DWZZLingPaiInitialize(Sender: TObject);
    procedure DWZZLingPaiDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBPFLingPaiName1Click(Sender: TObject; X, Y: Integer);
    procedure DLabel12Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBZZLingPaiTab1Initialize(Sender: TObject);
    procedure DBZZLingPaiTab1Click(Sender: TObject; X, Y: Integer);
    procedure DMZZLingPaiDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMZZLingPaiInitialize(Sender: TObject);
    procedure DMZZLingPaiScrollBarInitialize(Sender: TObject);
    procedure DBZZLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBZZLingPaiIcon1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBZZLingPaiName1Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiName1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBZZLingPaiCall1Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiCall1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBZZLingPaiCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiMove1Click(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiMove1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLabel15Click(Sender: TObject; X, Y: Integer);
    procedure DLZZLingPaiPrevClick(Sender: TObject; X, Y: Integer);
    procedure DBZZLingPaiMapName1Initialize(Sender: TObject);
    procedure DBZZLingPaiMapName1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBZZLingPaiMapName1Click(Sender: TObject; X, Y: Integer);
    procedure DWZZLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNGUpLevel1Initialize(Sender: TObject);
    procedure DLNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DLHeroNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DBPetLogCloseInitialize(Sender: TObject);
    procedure DWPetLogInitialize(Sender: TObject);
    procedure DBPetLogCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWPetLogDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLPetLogPagePrvClick(Sender: TObject; X, Y: Integer);
    procedure DLPetLogMoveClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionDlgInitialize(Sender: TObject);
    procedure DLFactionDlgHomeInitialize(Sender: TObject);
    procedure DWFactionDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWFactionAddDlgInitialize(Sender: TObject);
    procedure DEditFactionAddQueryDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWFactionAddDlgDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLFactionAddPrevClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionAddQueryClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionApplyAdd1Click(Sender: TObject; X, Y: Integer);
    procedure DBFactionAddDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBotFactionInitialize(Sender: TObject);
    procedure DBotFactionClick(Sender: TObject; X, Y: Integer);
    procedure DBFactionDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgHomeClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgListClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWFactionDlgEditNoticeInitialize(Sender: TObject);
    procedure DLFactionDlgEditNoticeClick(Sender: TObject; X, Y: Integer);
    procedure DBFactionDlgEditNoticeCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgEditNoticeOKClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgEditNoticeOKInitialize(Sender: TObject);
    procedure DLFactionDlgExitClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionDlgKickClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionApplyManageInitialize(Sender: TObject);
    procedure DLFactionDlgManageApplyClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionApplyManageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DGridFactionApplySelGridPaint(Sender: TObject; ACol,
      ARow: Integer; Rect: TRect; State: TDGridDrawState;
      dsurface: TDirectDrawSurface);
    procedure DGridFactionApplySelGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DLFactionApplyManageAllSelClick(Sender: TObject; X, Y: Integer);
    procedure DWFactionApplyManageCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionApplyManageAgreeClick(Sender: TObject; X, Y: Integer);
    procedure DLFactionApplyManageRefuseClick(Sender: TObject; X, Y: Integer);
    procedure DWLingWUXinFaInitialize(Sender: TObject);
    procedure DWLingWUXinFaDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBLingWUXinFaCloseInitialize(Sender: TObject);
    procedure DLLingWUXinFaInitialize(Sender: TObject);
    procedure DLFactionDlgGetTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBXinFaNamePrevInitialize(Sender: TObject);
    procedure DBXinFaNameNextInitialize(Sender: TObject);
    procedure DBXinFaNamePrevDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLXinFaMakeNameInitialize(Sender: TObject);
    procedure DWLingWuXinFaKeyInitialize(Sender: TObject);
    procedure DGridLingWuXinFaKeyGridPaint(Sender: TObject; ACol, ARow: Integer;
      Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
    procedure DGridLingWuXinFaKeyGridSelect(Sender: TObject; ACol,
      ARow: Integer; Shift: TShiftState);
    procedure DLLingWuXinFaKeyPrevInitialize(Sender: TObject);
    procedure DBXinFaNamePrevClick(Sender: TObject; X, Y: Integer);
    procedure DBLingWuXinFaNameClick(Sender: TObject; X, Y: Integer);
    procedure DBLingWuXinFaKeyCloseClick(Sender: TObject; X, Y: Integer);
    procedure DLLingWuXinFaKeyPrevClick(Sender: TObject; X, Y: Integer);
    procedure DLLingWuXinFaKeyChangeClick(Sender: TObject; X, Y: Integer);
    procedure DLLingWUXinFaClick(Sender: TObject; X, Y: Integer);
    procedure DLXinFaChangeSelNameInitialize(Sender: TObject);
    procedure DLXinFaMakeNameClick(Sender: TObject; X, Y: Integer);
    procedure DLXinFaChangeSelNameClick(Sender: TObject; X, Y: Integer);
    procedure DBLingWUXinFaCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinInitialize(Sender: TObject);
    procedure DBNewStateWinPageInitialize(Sender: TObject);
    procedure DWNewStateWinPageTab1Initialize(Sender: TObject);
    procedure DWNewStateWinPageTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateWinCloseDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateWinPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateWinPageClick(Sender: TObject; X, Y: Integer);
    procedure DBNewSWNecklaceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWNewStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewSWWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DBNewSWBujukDblClick(Sender: TObject);
    procedure DWNewStateWinPageTab2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateWinPageTab2Initialize(Sender: TObject);
    procedure DWNewStateWinDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateWinPageTab3Initialize(Sender: TObject);
    procedure DWNewStateWinPageTab3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewLiquorProgressInitialize(Sender: TObject);
    procedure DBNewLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateWinPageTab4Initialize(Sender: TObject);
    procedure DBNewTitleManInitialize(Sender: TObject);
    procedure DBNewTitleManDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewTitle1Initialize(Sender: TObject);
    procedure DBNewPrevTitleInitialize(Sender: TObject);
    procedure DBNewNextTitleInitialize(Sender: TObject);
    procedure DBNewTitle1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewTitle1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewTitleManClick(Sender: TObject; X, Y: Integer);
    procedure DBNewPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinPageTab5Initialize(Sender: TObject);
    procedure DBNewStMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHBExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewJQExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewStPageUpInitialize(Sender: TObject);
    procedure DBNewStPageDownInitialize(Sender: TObject);
    procedure DBNewStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinPageTab5DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DCheckNewDeputyHeroWarrClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinNGPageInitialize(Sender: TObject);
    procedure DBNewStateWinNGPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateWinNGPageClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinNGPageTab1Initialize(Sender: TObject);
    procedure DWNewStateWinNGPageTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateWinNGPageTab2Initialize(Sender: TObject);
    procedure DBNewStNGMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStNGMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewStNGMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewStNGPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinNGPageTab2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DLNewNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinNGPageTab4Initialize(Sender: TObject);
    procedure DBNewWinBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewWinBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewWinBatterRandomInitialize(Sender: TObject);
    procedure DBNewWinBatterMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewWinBatterComDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewWinBatterComMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewWinBatterComClick(Sender: TObject; X, Y: Integer);
    procedure DBNewWinBatterTopMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewWinBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DWNewStateWinNGPageTab3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateWinNGPageTab3Initialize(Sender: TObject);
    procedure DBNewWinPointIcon1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewWinPointPage1Initialize(Sender: TObject);
    procedure DBNewWinPointPage1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewWinPointPage1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewWinPointPracticeInitialize(Sender: TObject);
    procedure DBNewWinPointPracticeDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewWinPointIcon1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewWinPointIcon1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewWinPointPracticeClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateWinXFPageInitialize(Sender: TObject);
    procedure DWNewStateWinXFPageTab1Initialize(Sender: TObject);
    procedure DBNewStateWinXFPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBWinXinFaMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateWinXFPageClick(Sender: TObject; X, Y: Integer);
    procedure DBWinXinFaMagPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinXFPageTab2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateTab1Click(Sender: TObject; X, Y: Integer);
    procedure DBXinFaExpDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBWinXinFaMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBXinfaExpAbsorbClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateWinXFPageTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBXinFaExpMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBXinFaAbdomenMouseHintMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewStateWinCloseClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateHeroInitialize(Sender: TObject);
    procedure DWNewStateHeroDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateHeroPageInitialize(Sender: TObject);
    procedure DBNewStateHeroPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateHeroMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWNewStateHeroPageTab1Initialize(Sender: TObject);
    procedure DWNewStateHeroPageTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewSHWeaponClick(Sender: TObject; X, Y: Integer);
    procedure DBNewSHWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewSHNecklaceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateHeroPageClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateHeroPageTab2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroLiquorProgressDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateHeroPageTab3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateHeroPageTab5DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroStMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewHeroStMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroStPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DBNewStateHeroNGPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateHeroNGPageClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateHeroNGPageTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroStNGMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateHeroNGPageTab2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroStNGMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewHeroStNGMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroStNGPageUpClick(Sender: TObject; X, Y: Integer);
    procedure DLNewHeroNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DLNewHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
    procedure DWNewStateHeroNGPageTab3DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroPointPage1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroPointPage1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroPointIcon1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroPointIcon1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewHeroPointIcon1Click(Sender: TObject; X, Y: Integer);
    procedure DMsgDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewHeroBatterTopMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroBatterTopMag1MouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewHeroBatterTopMag1Click(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroBatterMag1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroBatterMag1MouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewHeroBatterComDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewHeroBatterComMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y: Integer);
    procedure DBNewHeroBatterComClick(Sender: TObject; X, Y: Integer);
    procedure DBNewHeroPointPracticeMouseMove(Sender: TObject;
      Shift: TShiftState; X, Y: Integer);
    procedure DBNewHeroPointPracticeClick(Sender: TObject; X, Y: Integer);
    procedure DWNewStateUserDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateUserMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWNewStateUserPageTab1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewSUWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DBNewSUNecklaceDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateUserPageInitialize(Sender: TObject);
    procedure DBNewStateUserPageDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewStateUserPageClick(Sender: TObject; X, Y: Integer);
    procedure DLNewStateUserNameClick(Sender: TObject; X, Y: Integer);
    procedure DLNewStateUserGuildNameClick(Sender: TObject; X, Y: Integer);
    procedure DBNewUserTitleManDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewUserTitle1DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBNewUserPrevTitleClick(Sender: TObject; X, Y: Integer);
    procedure DBNewUserTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWNewStateWinPageTab4DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWNewStateUserPageTab2DirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoXinFaHintDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoXinFaHintScrollBarDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DMemoXinFaHintScrollBarInitialize(Sender: TObject);
    procedure DMemoXinFaHintInitialize(Sender: TObject);
    procedure DWBottomLeftInitialize(Sender: TObject);
    procedure DWBottomCenterDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWBottomRightInitialize(Sender: TObject);
    procedure DWBottomCenterMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWBottomCenterMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DWBottomLeftDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DChatMemoInitialize(Sender: TObject);
    procedure DChatMemoMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DChatMemoInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DChatMemoChange(Sender: TObject);
    procedure DWBottomRightDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DWBottomLeftMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWBottomRightMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DWBottomCenterInRealArea(Sender: TObject; X, Y: Integer;
      var IsRealArea: Boolean);
    procedure DMsgDlgGameGoldBuyInitialize(Sender: TObject);
    procedure DMsgDlgGamePointBuyInitialize(Sender: TObject);
    procedure DLHelpXinfaClick(Sender: TObject; X, Y: Integer);
    procedure DBigMerchantDlgClick(Sender: TObject; X, Y: Integer);
    procedure DBigMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
    procedure DBigMerchantDlgCloseInitialize(Sender: TObject);
    procedure DBigMerchantDlgInitialize(Sender: TObject);
    procedure DBigMerchantDlgMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure DBigMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    {$IF M2Version <> 2}
    procedure DBFactionIconDirectPaint(Sender: TObject;
      dsurface: TDirectDrawSurface);
    procedure DBFactionIconMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure DLFactionNameClick(Sender: TObject; X, Y: Integer);
    {$IFEND}
{.$if Version <> 0}
   // constructor Create(AOwner: TComponent); override;
{.$IFEND}
  private
    DlgTemp: TList;
    magcur, magtop, HeroMagTop: integer;
    EdDlgEdit: TEdit;
    Memo: TMemo;
    MoveChatDlgY: Integer;
    ChatMemoHeight: Integer;
    ViewDlgEdit: Boolean;
    msglx, msgly: integer;
    MenuTop: integer;
    MagKeyIcon, MagKeyCurKey, MagKeyEffect, MagKeyID, MagKeyLevel: integer;
    MagKeyLevelEx: Byte;
    MagKeyMagName: string;
    MagicPage: integer;

    {$IF M2Version <> 2}
    m_btUserTitlePage: Byte;
    m_btTitlePage: Byte;
    m_btXinFaPage: Byte;
    SkillMemoTitle, SkillMemoName: string;
    SkillMemoId, SkillMemoEffect, SKillMemoIcon, SkillMemoLevel: Integer;
    HeroSkillMemoTitle, HeroSkillMemoName, HeroSkillMemoUserName: string;
    HeroSkillMemoId, HeroSkillMemoEffect, HeroSkillMemoIcon: Integer;
    HeroSkillMemoLinkIdx: Byte;
    m_dwAbilTick: LongWord;
    m_btAbilIndex: Byte;
    {$IFEND}
    InternalForceMagicPage: integer;  //内功技能页
    HeroMagicPage: integer;
    HeroInternalForceMagicPage: integer; //英雄内功技能页
    BlinkTime: Longword;
    BlinkCount: integer;  //0..9荤捞甫 馆汗

    imginsex:integer;// 
    typetime: longword;

    SighIconTimeTick: LongWord; //感叹号时间间隔
    SighIconImginsex: Byte;

    ExpCrystalTopTimeTick: LongWord; //天地结晶显示时间间隔
    ExpCrystalTopImginsex: Byte;
    ExpCrystalTopEffectTimeTick: LongWord; //天地结晶动画显示时间间隔
    ExpCrystalTopEffectImginsex: Byte;

    ExpNQTimeTick: LongWord; //牛气显示时间间隔
    ExpNQImginsex: Byte;
    //评定英雄按钮动画
    HeroAssessSignTimeTick: LongWord;
    HeroAssessSignImginsex: Byte;
    //金针logo上的动画
    KimNeedleLogoTimeTick: LongWord;
    KimNeedleLogoImginsex: Byte;
    //金针锻造状态下的火苗
    KimNeedleStartFlameTimeTick: LongWord;
    KimNeedleStartFlameImginsex: Byte;
    //显示开始锻造的滚动条
    KimShowBarTimeTick: LongWord;
    KimShowBarImginsex: Byte;
    boKimShowBarSend: Boolean;
    //学位闪亮动画
    PulseOriginTimeTick: LongWord;
    PulseOriginImginsex: Byte;
    //可以使用连击时的小块动画
    BatterShowTimeTick: LongWord;
    BatterShowImginsex: Byte;
    BatterTopTimeTick: LongWord;
    BatterTopImginsex: Byte;
    BatterTopMagIndex: Byte;
    HeroBatterTopMagIndex: Byte;
    WinBatterComIndex: Integer;
    HeroBatterComIndex: Integer;
    //私聊系统
    WhisperPoints: TList;
    WhisperAddPoints: Boolean;
    WhisperMoveedStr: string;
    WhisperSelectStr: string;
    //内观刀发光动画变量
    WeaponTimeTick: LongWord;
    WeaponImginsex: Byte;

    //任务系统
    MissionBottomPoints: TList;
    MissionBottomAddPoints: Boolean;
    MissionMoveedBottomStr: string;
    m_dwMissionEffTick: LongWord;
    m_btMissionEffImg: Byte;
    {$IF M2Version = 1}
    m_boQJPracticeHero: Boolean;
    m_sQJPracticeObjectName: string;
    m_btQjPracticeSkillLevel: Byte;
    m_dwQjPracticeCurTrain: Longword;
    m_dwQJpracticeMaxTrain: LongWord;
    {$IFEND}
    procedure MissionPageChanged;//任务系统页数改变
    procedure SendMissionSelect (rstr: string);
    procedure HideAllControls;
    procedure RestoreHideControls;
    procedure PageChanged;
    procedure InternalForcePageChanged;
    procedure LevelOrderPageChanged;//等级排行榜页数改变 2007.12.12
//    procedure MouseRightItem(WhoItemBag{谁的包裹},ACol,ARow:Integer);//右键穿装备
    procedure DealItemReturnBag (mitem: TClientItem);
    procedure ChallengeItemReturnBag (mitem: TClientItem);
    procedure SellOffItemReturnBag (mitem: TClientItem);//元宝寄售返回包裹 20080316
    //procedure ItemUpReturnBag (mitem: TMovingItem); //粹练返回包裹 20080506
    procedure DealZeroGold;
    function  GetMiniMapNum(num:Integer): TDirectDrawSurface;  //获得新小地图号  20080324
    procedure NpcAutoSelDrinkRuning(dsurface: TDirectDrawSurface);
    
    {$IF M2Version = 1}
    procedure ShowQJPractice(boIsHero: Boolean);
    procedure ChangeNGPointPage();
    procedure ChangeHeroNGPointPage();
    {$IFEND}

    {$IF M2Version <> 2}
    function GetTitlePageIdx(btMaxPage: Byte): Byte;
    function GetUserTitlePageIdx(): Byte;
    procedure ShowFactionDlgEditNotice();
    {$IFEND}
    procedure SetChatDlgHeight(Value: Integer);
  public
    strorlist    :array[0..STRLINS-1] of String;
    strorlistidx :array[0..STRLINS-1] of Integer;
    strorliscont :Integer;
    HeroStatePage: Integer; //英雄信息页码 $012 2007.10.21
    HeroStatePulsePage: Integer; //冲脉，阴跷，阴维，任脉，奇经
    MsgText: string;
    DialogSize: Integer;

    m_nDiceCount:Integer;
    m_boPlayDice:Boolean;
    m_Dice:array[0..9] of TDiceInfo;

    MerchantName: string;
    MerchantFace: Integer;
    MDlgStr: string;
    MDlgPoints: TList;
    RequireAddPoints: Boolean;
    SelectMenuStr: string;
    LastestClickTime: longword;
    SpotDlgMode: TSpotDlgMode;
    DlgShopTime: LongWord;
    MenuList: TList; //list of PTClientGoods
    MenuIndex: integer;
    WinType:Integer;
    CurDetailItem: string;
    MenuTopLine: integer;
    BoDetailMenu: Boolean;
    BoStorageMenu: Boolean;
    BoNoDisplayMaxDura: Boolean;
    BoMakeDrugMenu: Boolean;
    NAHelps: TStringList;
    NewAccountTitle: string;
    DlgEditText: string;
    UserState1: TUserStateInfo;
    Guild: string;
    GuildFlag: string;
    GuildCommanderMode: Boolean;
    GuildStrs: TStringList;
    GuildStrs2: TStringList;
    GuildNotice: TStringList;
    GuildMembers: TStringList;
    GuildTopLine: integer;
    GuildEditHint: string;
    GuildChats: TStringList;
    BoGuildChat: Boolean;
    //任务
    m_boMissionEff: Boolean;
    m_btMissionPage: Byte;
    //内挂药品
    m_btProPage: Byte;
    //控制面板
    StateTab: Byte; //内功上面的页
    HeroStateTab: Byte; //英雄内功上面的页
    InternalForcePage: Integer; //内功状态页
    HeroInternalForcePage: Integer; //英雄内功状态页

    StatePage: Integer;
    LevelOrderPage: Integer; //大分类页数
    StatePulsePage: Integer; //冲脉，阴跷，阴维，任脉，奇经

    {$IF M2Version <> 2}
    m_btSignedItemsPage: Byte;
    m_btJudjeItemsPage: Byte;
    m_btMakeSignedPage: Byte;
    m_dwSignedLockTick: DWord; //鉴定锁定超时By TasNat at: 2012-11-12 10:14:01
    m_boSignedLock: Boolean; //鉴定 发送消息后锁定
    m_boMakeSignedLock: Boolean; //解读 发送消息后锁定
    m_dwSignedTimeTick: LongWord; //鉴定时间间隔
    m_btSignedImginsex: Byte;
    m_dwMakeSignedTimeTick: LongWord; //解读时间间隔
    m_btMakeSignedImginsex: Byte;
    m_dwLingMeiTimeTick: LongWord; //灵媒时间间隔
    m_btLingMeiImgFrame: Byte;
    m_boLingMeiEffect: Boolean; //是否执行动画
    m_btSignedSuccess: Byte; //鉴定 1-成功 2-失败   更换3-成功 4-失败
    m_btSignedHint: Byte; //鉴定 1-成功的提示 2-失败的提示
    m_btMakeSignedSuccess: Byte; //鉴定 1-成功 2-失败   更换3-成功 4-失败
    m_btMakeSignedHint: byte; //解读 兑换卷轴1-成功的提示 2-失败的提示  解读属性3-成功的提示 4-失败的提示
    HeroSkillMemoAddHp: Integer;
    m_btPJLingPaiPage: Byte;
    m_sSelPJLingPaiName: string; //护花令牌选择人名
    m_btZZLingPaiPage: Byte; //主宰令牌分页
    m_btZZHWLingPaiPage: Byte; //主宰近卫军分页
    m_sSelHWLingPaiName: string; //近卫军选择人名
    m_btFactionPage: Byte;
    {$IFEND}
    procedure Initialize;
    procedure PlayInitialize;
    procedure InitializePlace; //初始化图象位置 20080524
    procedure OpenMyStatus;
    procedure OpenUserState (UserState: TUserStateInfo);
    procedure OpenItemBag;
    procedure ViewBottomBox (visible: Boolean);
    procedure CancelItemMoving;
    procedure OpenAdjustAbility;
    procedure ShowSelectServerDlg;
    function  DMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
    procedure ShowMDlg (face: integer; mname, msgstr: string);
    procedure ShowMBigDlg (face: integer; mname, msgstr: string);
    procedure ShowGuildDlg;
    procedure ShowGuildEditNotice;
    procedure ShowGuildEditGrade;
    procedure ResetMenuDlg;
    procedure ShowShopMenuDlg;
    procedure ShowShopSellDlg;
    procedure ShowShopSellOffDlg;  //元宝寄售显示窗口 20080316
    procedure CloseDSellDlg;
    procedure CloseMDlg;
    procedure CloseMBigDlg;
    procedure ToggleShowGroupDlg;
    procedure OpenDealDlg;
    procedure OpenChallengeDlg; //打开挑战对话框
    procedure CloseChallengeDlg;
    procedure CloseDealDlg;
    procedure OpenFriendDlg;
    procedure SoldOutGoods (itemserverindex: integer);
    procedure DelStorageItem (itemserverindex: integer);

    procedure GetMouseItemInfo (var iname, iname1, line1, line2, line3, line4, line5, sUnKnow1, sUnKnow2: string; var useable: boolean; Who: Integer{1为主人,2为英雄}); // 2007.12.15 支持英雄
    procedure ShowMouseItemInfo(X, Y: Integer; AddLine: string; who:Byte; DrawUp: Boolean);

    procedure SetMagicKeyDlg (icon: integer; Effect, Level, LevelEx: Byte; MagID: Word; magname: string; var curkey: word);

    {$IF M2Version <> 2}
    function  GetTitleInfo(TitleItem: TClientHumTitle; var List: TStringList; boNewState: Boolean): string;
    procedure SetSkillMemoDlg(MagID, MagLevel: Word; Effect: Byte; magname, magTitle: string);
    procedure SetHeroSkillMemoDlg(MagID: Word; Effect: Byte; magname, magTitle: string);
    procedure UseLingMeiItem();
    procedure ChangeZZLingPaiPage(btPage: Byte);
    procedure NGUpLevelState(boIsHero: Boolean);
    procedure NewNGUpLevelState(boIsHero: Boolean);

    procedure ShowFactionDlg;
    procedure AddFactionMember(DivisionMember: TClientDivisionMember; X, Y: Integer);
    procedure FactionMemberListFree();
    procedure SetNewWinStateTabVisible(boVisible, boIsXinFa: Boolean);
    procedure SetNewHeroStateTabVisible(boVisible: Boolean);
    {$IFEND}
    procedure AddGuildChat (str: string);
    procedure ShowPlayDrink (Who1: integer; msgstr: string);
    procedure NewSdoAssistantPageChanged;//新盛大内挂页数改变 20080624
    procedure ShowKimNeedle(Bool: Boolean);
    procedure AddWhisper(str: string);
    procedure AutoWhisper(str: string);
    procedure JLBoxItemBelt(Sender: TObject; dsurface: TDirectDrawSurface);
    procedure ClientGetMissionSay(nParam: Integer; Text: string);
    procedure ChangeProPage(nPage: Byte);
    procedure CancelHeroItemMoving; // 取消英雄物品移动
    procedure DropMovingItem;
    procedure DropHeroMovingItem; //英雄往地上扔东西
    procedure CreateParams(var Params:TCreateParams);override;//设置程序的类名 20080412
    procedure NewMagicBtnNotVisible();
  end;
var
  FrmDlg: TFrmDlg;
implementation

uses
   ClMain, MShare, Browser, Splash, DrawScrn;

{$R *.DFM}

{$IF M2Version <> 2}
{ TFactionMember }

constructor TFactionMember.Create;
begin
  m_Icon := TDButton.Create(FrmDlg.DWFactionDlg.Owner);
  m_Icon.OnDirectPaint := FrmDlg.DBFactionIconDirectPaint;
  m_Icon.OnMouseMove := FrmDlg.DBFactionIconMouseMove;
  m_Icon.DParent := FrmDlg.DWFactionDlg;
  //FrmDlg.DWFactionDlg.AddChild(m_Icon);
  m_Name := TDLabel.Create(FrmDlg.DWFactionDlg.Owner);
  m_Name.OnClick := FrmDlg.DLFactionNameClick;
  m_Name.DParent := FrmDlg.DWFactionDlg;
  //FrmDlg.DWFactionDlg.AddChild(m_Name);
  m_Name.UpColor := clWhite;
  m_Name.HotColor := clWhite;
  m_Name.BoldFont := True;
  FillChar(m_DivisionMember, SizeOf(TClientDivisionMember), #0);
end;

destructor TFactionMember.Destroy;
begin
  m_Name.Free;
  m_Icon.Free;
  inherited;
end;
{$IFEND}

procedure TFrmDlg.FormCreate(Sender: TObject);
begin
   //frmMain.DXDraw.Initialize;
   //ItemLightImgIdx := 0; //初始化物品发光图片ID为0 20080223
   g_boBoxsMiddleItems := False; //初始化宝箱物品为中间
   StatePage := 0;
   m_btMissionPage := 0;
   m_btProPage := 0;
   StatePulsePage := 0;
   LevelOrderPage := 0;
   g_nBoxsImg := 0;
   g_BoxsFlashImg := 0;
   g_BoxsFilleFlashImg := 0;
   g_LieDragonPage := 0; //卧龙
   HeroStatePage := 0;
   HeroMagicPage := 0;
   DlgTemp := TList.Create;
   DialogSize := 1;
   m_nDiceCount:=0;
   m_boPlayDice:=False;
   magcur := 0;
   magtop := 0;
   HeroMagTop := 0;
   MDlgPoints := TList.Create;
   WhisperPoints := TList.create;
   MissionBottomPoints := TList.Create;
   SelectMenuStr := '';
   MenuList := TList.Create;
   MenuIndex := -1;
   MenuTopLine := 0;
   BoDetailMenu := FALSE;
   BoStorageMenu := FALSE;
   BoNoDisplayMaxDura := FALSE;
   BoMakeDrugMenu := FALSE;
   MagicPage := 0;
   InternalForceMagicPage := 0;
   HeroInternalForceMagicPage := 0;
   NAHelps := TStringList.Create;
   BlinkTime := GetTickCount;
   DlgShopTime := GetTickCount;
   BlinkCount := 0;
   g_ShopPage:=0;
   ShopGifFrame:=0;
   imginsex:=0;
   //ShopImgIdx := 0;
   SighIconImginsex := 0;
   WeaponImginsex := 0;
   ExpCrystalTopImginsex := 0;
   ExpCrystalTopEffectImginsex := 0;
   ExpNQImginsex := 0;
   ShowNQExpInc := 0;
   KimNeedleLogoImginsex := 0;
   KimNeedleStartFlameImginsex := 0;
   PulseOriginImginsex := 0;
   BatterShowImginsex := 0;
   BatterTopImginsex := 0;
   BatterTopMagIndex := 0;
   HeroBatterTopMagIndex := 0;
   {$IF M2Version <> 2}
   m_btUserTitlePage := 0;
   m_btTitlePage := 0;
   m_btXinFaPage := 0;
   m_btPJLingPaiPage := 0;
   m_btZZLingPaiPage := 0;
   m_btZZHWLingPaiPage := 0;
   m_boMissionEff := False;
   m_btMissionEffImg := 0;
   HeroSkillMemoLinkIdx := 0;
   m_boSignedLock := False;
   m_boMakeSignedLock := False;
   m_btSignedImginsex := 0;
   m_btLingMeiImgFrame := 0;
   m_btMakeSignedImginsex := 0;
   m_boLingMeiEffect := False;
   m_btSignedSuccess := 0; //1-成功 2-失败
   m_btSignedHint := 0;
   m_btMakeSignedSuccess := 0;
   m_btMakeSignedHint := 0;
   m_btFactionPage := 0;
   m_dwAbilTick := GetTickCount();
   m_btAbilIndex := 0;
   {$IFEND}
   g_SellDlgItem.S.Name := '';
   Guild := '';
   GuildFlag := '';
   GuildCommanderMode := FALSE;
   GuildStrs := TStringList.Create;
   GuildStrs2 := TStringList.Create; //归诀侩
   GuildNotice := TStringList.Create;
   GuildMembers := TStringList.Create;
   GuildChats := TStringList.Create;
   g_PlayDrinkPoints := TList.Create; //20080515
   EdDlgEdit := TEdit.Create (FrmMain.Owner);
   with EdDlgEdit do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Size := 9;
      MaxLength := 30;
      Height := 16;
      Ctl3d := FALSE;
      BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
      Visible := FALSE;
   end;
   Memo := TMemo.Create (FrmMain.Owner);
   with Memo do begin
      Parent := FrmMain;
      Color := clBlack;
      Font.Color := clWhite;
      Font.Size := 9;
      Ctl3d := FALSE;
      BorderStyle := bsSingle;  {OnKeyPress := EdDlgEditKeyPress;}
      Visible := FALSE;
   end;
end;

procedure TFrmDlg.FormDestroy(Sender: TObject);
var
  I: Integer;
begin
   DlgTemp.Free;
   for I:=0 to MDlgPoints.Count - 1  do begin  //20080718释放内存
    if pTClickPoint(MDlgPoints[i]) <> nil then
      Dispose(pTClickPoint(MDlgPoints[i]));
   end;
   FreeAndNil(MDlgPoints);
   for I:=0 to WhisperPoints.Count - 1 do begin
     if pTClickSLPoint(WhisperPoints[I]) <> nil then
      Dispose(pTClickSLPoint(WhisperPoints[i]))
   end;
   FreeAndNil(WhisperPoints);
   for I:=0 to MissionBottomPoints.Count - 1 do begin
     if pTClickPoint(MissionBottomPoints[I]) <> nil then
      Dispose(pTClickPoint(MissionBottomPoints[I]))
   end;
   FreeAndNil(MissionBottomPoints);
   g_PlayDrinkPoints.Free;  
   MenuList.Free;
   NAHelps.Free;
   GuildStrs.Free;
   GuildStrs2.Free;
   GuildNotice.Free;
   GuildMembers.Free;
   GuildChats.Free;
end;

procedure TFrmDlg.HideAllControls;
var
   i: integer;
   c: TControl;
begin
   DlgTemp.Clear;
   with FrmMain do
      if ControlCount > 0 then //20080629
      for i:=0 to ControlCount-1 do begin
         c := Controls[i];
         if c is TEdit then
            if (c.Visible) and (c <> EdDlgEdit) then begin
               DlgTemp.Add (c);
               c.Visible := FALSE;
            end;
      end;
end;

procedure TFrmDlg.RestoreHideControls;
var
   i: integer;
begin
   if DlgTemp.Count > 0 then //20080629
   for i:=0 to DlgTemp.Count-1 do begin
      TControl(DlgTemp[i]).Visible := TRUE;
   end;
end;

procedure TFrmDlg.Initialize;  //初始化窗口   2007.10.20
var
  d: TDirectDrawSurface;
begin
  g_DWinMan.ClearAll;

  DBackground.GLeft := 0;
  DBackground.GTop := 0;
  DBackground.GWidth := SCREENWIDTH;
  DBackground.GHeight := SCREENHEIGHT;
  DBackground.Background := TRUE;
  g_DWinMan.AddDControl (DBackground, TRUE);
  {$IF M2Version <> 2}
  DPNewStateWinTab.ActivePage := 0;
  DPNewStateWinPage.ActivePage := 0;
  DPNewStateWinNGPage.ActivePage := 0;
  DPNewStateWinXFPage.ActivePage := 0;
  //英雄
  DPNewStateHeroTab.ActivePage := 0;
  DPNewStateHeroPage.ActivePage := 0;
  DPNewStateHeroNGPage.ActivePage := 0;
  d := g_WUI1Images.Images[2185];
  g_boNewNewStateWin := d <> nil;
  d := g_WUI1Images.Images[2232];
  g_boNewNewHeroState := d <> nil;
  {$IFEND}
  g_boDoFadeIn := True;
end;

//初始化图象位置 20080524
procedure TFrmDlg.InitializePlace;
begin
  SplashForm.ProgressBar1.Position := SplashForm.ProgressBar1.Position + 2;
  ChatMemoHeight := 211;
  MoveChatDlgY := 0;
//去不掉的
{$IF M2Version = 2} //1.76
  DItemBag.GLeft := 0;
  DItemBag.GTop := 0;
{$ELSE}
  DItemBag.GLeft := -5;
  DItemBag.GTop := 69;//20090304修改
{$IFEND}
  {$IF M2Version = 2}
  DBHelp.Visible := False;
  DBInternet.Visible := False;
  DBCallHero.Visible := False;
  DBHeroState.Visible := False;
  DBHeroPackage.Visible := False;
  DBCallDeputyHero.Visible := False;
  DBGlory.Visible := False;
  DStateSsas.Visible := False;
  DLiquorProgress.Visible := False;
  DBujukUS1.Visible := False;
  DBeltUS1.Visible := False;
  DBootsUS1.Visible := False;
  DCharmUS1.Visible := False;
  DDrunkScale.Visible := False;
  DItemsUpBut.Visible := False;
  DWGameGold.Visible := False;
  DGameGirdExchange.Visible := False;
  DCheckAutoButch.Visible := False;
  DCheckAutoUseHuolongzhu.Visible := False;
  DCheckAutoUseJingyuandan.Visible := False;
  DCheckBoxHideTitle.Visible := False;
  DCheckScreenShake.Visible := False;
  DCheckHeroLevelHint.Visible := False;
  DCheckSdoAutoDrinkWine.Visible := False;
  DEdtSdoDrunkWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkWine.Visible := False;
  DEdtSdoHeroDrunkWineDegree.Visible := False;
  DCheckSdoAutoDrinkDrugWine.Visible := False;
  DEdtSdoDrunkDrugWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkDrugWine.Visible := False;
  DEdtSdoHeroDrunkDrugWineDegree.Visible := False;
  DCheckSdoZhuri.Visible := False;
  DCheckSdoHeroShield.Visible := False;
  DCheckShowHeroStateNumber.Visible := False;
  DCheckShowSpecialDamage.Visible := False;
  DCheckAutoDragInBody.Visible := False;
  DCheckHeroBatterNotMob.Visible := False;
  DCheckHideHumanWing.Visible := False;
  DCheckHideWeaponEffect.Visible := False;
  DBProMyHero1.Visible := False;
  DBProMyHero2.Visible := False;
  DBProMyHero3.Visible := False;
  DBProMyHero4.Visible := False;
  DBotFaction.Visible := False;
  {$IFEND}
end;

procedure TFrmDlg.PlayInitialize;
begin
  {$IF M2Version <> 2}
  DBLevelOrderUseItem.Visible := True;
  DBLevelOrderCloud.Visible := True;
  DBOrderWeapon.Visible := True;
  DBOrderRing.Visible := True;
  DBOrderDress.Visible := True;
  DBOrderBoots.Visible := True;
  DBOrderHelmet.Visible := True;
  DBOrderBelt.Visible := True;
  DBOrderNecklace.Visible := True;
  DBOrderMedal.Visible := True;
  DBOrderWristlet.Visible := True;
  DBOrderHat.Visible := True;
  DBMission.Visible := True;
  {$IFEND}
  g_boOnePlay := True;
end;

{$REGION '控件初始化'}
{$REGION '登录窗体'}
procedure TFrmDlg.DLoginNewInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DLoginNew.SetImgIndex (g_WMainImages, 61);
  DLoginNew.GLeft := 25;
  DLoginNew.GTop  := 207;
{$ELSE}
  DLoginNew.SetImgIndex (g_WMainImages, 61);
  DLoginNew.GLeft := 32;
  DLoginNew.GTop  := 173;
{$IFEND}
end;

procedure TFrmDlg.DLoginOkInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DLoginOk.SetImgIndex (g_WMainImages, 62);
  DLoginOk.GLeft := 169;
  DLoginOk.GTop := 163;
{$ELSE}
  DLoginOk.SetImgIndex (g_WMain3Images, 10);
  DLoginOk.GLeft := 164;
  DLoginOk.GTop := 172;
{$IFEND}
end;

procedure TFrmDlg.DLoginChgPwInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DLoginChgPw.SetImgIndex (g_WMainImages, 53);
  DLoginChgPw.GLeft := 130;
  DLoginChgPw.GTop  := 207;
{$ELSE}
  DLoginChgPw.SetImgIndex (g_WMain3Images, 28);
  DLoginChgPw.GLeft := 164;
  DLoginChgPw.GTop  := 215;
{$IFEND}
end;

procedure TFrmDlg.DLoginCloseInitialize(Sender: TObject);
begin
  DLoginClose.SetImgIndex (g_WMainImages, 64);
{$IF M2Version = 2} //1.76
  DLoginClose.GLeft := 252;
  DLoginClose.GTop := 28;
{$ELSE}
  DLoginClose.GLeft := 258;
  DLoginClose.GTop := 24;
{$IFEND}
end;

procedure TFrmDlg.DLogInInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
{$IF M2Version = 2} //1.76
  d := g_WMainImages.Images[60];
  if d <> nil then begin
    DLogIn.SetImgIndex (g_WMainImages, 60);
    DLogIn.GLeft := (SCREENWIDTH - d.Width) div 2;
    DLogIn.GTop := (SCREENHEIGHT - d.Height) div 2;
  end;
{$ELSE}
  d := g_WMain3Images.Images[18];
  if d <> nil then begin
    DLogIn.SetImgIndex (g_WMain3Images, 18);
    DLogIn.GLeft := (SCREENWIDTH - d.Width) div 2;
    DLogIn.GTop := (SCREENHEIGHT - d.Height) div 2;
  end;
{$IFEND}
end;
procedure TFrmDlg.m_EdIdInitialize(Sender: TObject);
begin
  with m_Edid do begin
    {$IF M2Version = 2} //1.76
    GLeft := 98;
    GTop := 83;
    {$ELSE}
    GLeft := 123;
    GTop := 70;
    {$IFEND}
  end;
end;
procedure TFrmDlg.m_EdPasswdInitialize(Sender: TObject);
begin
  with m_EdPasswd do begin
    {$IF M2Version = 2} //1.76
    GLeft := 98;
    GTop := 115;
   {$ELSE}
    GLeft := 123;
    GTop := 102;
   {$IFEND}
  end;
end;
{$ENDREGION}
{$REGION '注册窗体'}
procedure TFrmDlg.DNewAccountOkInitialize(Sender: TObject);
begin
  DNewAccountOk.SetImgIndex (g_WMainImages, 62);
end;

procedure TFrmDlg.DNewAccountCancelInitialize(Sender: TObject);
begin
  DNewAccountCancel.SetImgIndex (g_WMainImages, 52);
end;

procedure TFrmDlg.DNewAccountCloseInitialize(Sender: TObject);
begin
  DNewAccountClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DNewAccountInitialize(Sender: TObject);
begin
  DNewAccount.SetImgIndex (g_WMainImages, 63);
end;
{$ENDREGION}
{$REGION '选择服务器'}
procedure TFrmDlg.DSServer1Initialize(Sender: TObject);
begin
  DSServer1.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer2Initialize(Sender: TObject);
begin
  DSServer2.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer3Initialize(Sender: TObject);
begin
  DSServer3.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer4Initialize(Sender: TObject);
begin
  DSServer4.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer5Initialize(Sender: TObject);
begin
  DSServer5.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSServer6Initialize(Sender: TObject);
begin
  DSServer6.SetImgIndex (g_WMain3Images, 2);
end;

procedure TFrmDlg.DSSrvCloseInitialize(Sender: TObject);
begin
  DSSrvClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DSelServerDlgInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[256]; //81];
  if d <> nil then begin
    DSelServerDlg.SetImgIndex (g_WMainImages, 256);
    DSelServerDlg.GLeft := (SCREENWIDTH - d.Width) div 2;
    DSelServerDlg.GTop := (SCREENHEIGHT - d.Height) div 2;
  end;
end;
{$ENDREGION}
{$REGION '创建人物'}
procedure TFrmDlg.DccWarriorInitialize(Sender: TObject);
begin
  DccWarrior.SetImgIndex (g_WMainImages, 74);
end;

procedure TFrmDlg.DccWizzardInitialize(Sender: TObject);
begin
  DccWizzard.SetImgIndex (g_WMainImages, 75);
end;

procedure TFrmDlg.DccMaleInitialize(Sender: TObject);
begin
  DccMale.SetImgIndex (g_WMainImages, 77);
end;

procedure TFrmDlg.DccMonkInitialize(Sender: TObject);
begin
  DccMonk.SetImgIndex (g_WMainImages, 76);
end;

procedure TFrmDlg.DccOkInitialize(Sender: TObject);
begin
  DccOk.SetImgIndex (g_WMainImages, 62);
end;

procedure TFrmDlg.DccFemaleInitialize(Sender: TObject);
begin
  DccFemale.SetImgIndex (g_WMainImages, 78);
end;

procedure TFrmDlg.DccLeftHairInitialize(Sender: TObject);
begin
  DccLeftHair.SetImgIndex (g_WMainImages, 79);
end;

procedure TFrmDlg.DccRightHairInitialize(Sender: TObject);
begin
  DccRightHair.SetImgIndex (g_WMainImages, 80);
end;

procedure TFrmDlg.DccCloseInitialize(Sender: TObject);
begin
  DccClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DCreateChrInitialize(Sender: TObject);
begin
  DCreateChr.SetImgIndex (g_WMainImages, 73);
end;
{$ENDREGION}
{$REGION '修改密码窗体'}
procedure TFrmDlg.DChgpwOkInitialize(Sender: TObject);
begin
  DChgpwOk.SetImgIndex (g_WMainImages, 62);
end;

procedure TFrmDlg.DChgpwCancelInitialize(Sender: TObject);
begin
  DChgpwCancel.SetImgIndex (g_WMainImages, 52);
end;

procedure TFrmDlg.DChgPwInitialize(Sender: TObject);
begin
  DChgPw.SetImgIndex (g_WMainImages, 50);
end;
{$ENDREGION}
{$REGION '设置魔法快捷键'}
procedure TFrmDlg.DKsF1Initialize(Sender: TObject);
begin
  DKsF1.SetImgIndex (g_WMainImages, 232);
end;

procedure TFrmDlg.DKsF2Initialize(Sender: TObject);
begin
  DKsF2.SetImgIndex (g_WMainImages, 234);
end;

procedure TFrmDlg.DKsF3Initialize(Sender: TObject);
begin
  DKsF3.SetImgIndex (g_WMainImages, 236);
end;

procedure TFrmDlg.DKsF4Initialize(Sender: TObject);
begin
  DKsF4.SetImgIndex (g_WMainImages, 238);
end;

procedure TFrmDlg.DKsF5Initialize(Sender: TObject);
begin
  DKsF5.SetImgIndex (g_WMainImages, 240);
end;

procedure TFrmDlg.DKsF6Initialize(Sender: TObject);
begin
  DKsF6.SetImgIndex (g_WMainImages, 242);
end;

procedure TFrmDlg.DKsF7Initialize(Sender: TObject);
begin
  DKsF7.SetImgIndex (g_WMainImages, 244);
end;

procedure TFrmDlg.DKsF8Initialize(Sender: TObject);
begin
  DKsF8.SetImgIndex (g_WMainImages, 246);
end;

procedure TFrmDlg.DKsConF1Initialize(Sender: TObject);
begin
  DKsConF1.SetImgIndex (g_WMain3Images, 132);
end;

procedure TFrmDlg.DKsConF2Initialize(Sender: TObject);
begin
  DKsConF2.SetImgIndex (g_WMain3Images, 134);
end;

procedure TFrmDlg.DKsConF3Initialize(Sender: TObject);
begin
  DKsConF3.SetImgIndex (g_WMain3Images, 136);
end;

procedure TFrmDlg.DKsConF4Initialize(Sender: TObject);
begin
  DKsConF4.SetImgIndex (g_WMain3Images, 138);
end;

procedure TFrmDlg.DKsConF5Initialize(Sender: TObject);
begin
  DKsConF5.SetImgIndex (g_WMain3Images, 140);
end;

procedure TFrmDlg.DKsConF6Initialize(Sender: TObject);
begin
  DKsConF6.SetImgIndex (g_WMain3Images, 142);
end;

procedure TFrmDlg.DKsConF7Initialize(Sender: TObject);
begin
  DKsConF7.SetImgIndex (g_WMain3Images, 144);
end;

procedure TFrmDlg.DKsConF8Initialize(Sender: TObject);
begin
  DKsConF8.SetImgIndex (g_WMain3Images, 146);
end;

procedure TFrmDlg.DKsNoneInitialize(Sender: TObject);
begin
  DKsNone.SetImgIndex (g_WMain3Images, 129);
end;

procedure TFrmDlg.DKsOkInitialize(Sender: TObject);
begin
  DKsOk.SetImgIndex (g_WMain3Images, 127);
end;

procedure TFrmDlg.DKeySelDlgInitialize(Sender: TObject);
begin
  DKeySelDlg.SetImgIndex (g_WMain3Images, 126);
end;
{$ENDREGION}
{$REGION '选择人物'}
procedure TFrmDlg.DscSelect1Initialize(Sender: TObject);
begin
  DscSelect1.SetImgIndex (g_WMainImages, 66);
end;

procedure TFrmDlg.DscSelect2Initialize(Sender: TObject);
begin
  DscSelect2.SetImgIndex (g_WMainImages, 67);
end;

procedure TFrmDlg.DscStartInitialize(Sender: TObject);
begin
  DscStart.SetImgIndex (g_qingqingImages, 21);
end;

procedure TFrmDlg.DscNewChrInitialize(Sender: TObject);
begin
  DscNewChr.SetImgIndex (g_WMainImages, 69);
end;

procedure TFrmDlg.DscEraseChrInitialize(Sender: TObject);
begin
  DscEraseChr.SetImgIndex (g_WMainImages, 70);
end;

procedure TFrmDlg.DscCreditsInitialize(Sender: TObject);
begin
  DscCredits.SetImgIndex (g_WMain3Images, 405);
end;

procedure TFrmDlg.DscExitInitialize(Sender: TObject);
begin
  DscExit.SetImgIndex (g_WMainImages, 72);
end;
{$ENDREGION}
{$REGION '人物包裹'}
procedure TFrmDlg.DItemGridInitialize(Sender: TObject);
begin
  with DItemGrid do begin
  {$IF M2Version = 2} //1.76
    GLeft := 20;
    GTop  := 13;
    GWidth := 286;
    GHeight := 162;
  {$ELSE}
    GLeft := 28;
    GTop  := 41;
    GWidth := 286;
    GHeight := 162;
  {$IFEND}
  end;
end;

procedure TFrmDlg.DGoldInitialize(Sender: TObject);
begin
  with DGold do begin
    SetImgIndex (g_WMainImages, 29);
    {$IF M2Version = 2} //1.76
      GLeft := 10;
      GTop  := 190;
    {$ELSE}
      GLeft := 18;
      GTop  := 217;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DWGameGoldInitialize(Sender: TObject);
begin
  DWGameGold.SetImgIndex(g_qingqingImages, 2);
end;

procedure TFrmDlg.DItemsUpButInitialize(Sender: TObject);
begin
  DItemsUpBut.SetImgIndex (g_qingqingImages, 3);
end;

procedure TFrmDlg.DCloseBagInitialize(Sender: TObject);
begin
  with DClosebag do begin
    SetImgIndex (g_WMainImages, 371);
    {$IF M2Version = 2} //1.76
      GLeft := 309;
      GTop := 203;
    {$ELSE}
      GLeft := 336;
      GTop := 59;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DItemBagInitialize(Sender: TObject);
begin
{$IF M2Version = 2} //1.76
  DItemBag.SetImgIndex (g_WMainImages, 3);
{$ELSE}
  DItemBag.SetImgIndex (g_qingqingImages, 1);
{$IFEND}
end;
{$ENDREGION}
{$REGION '交易2个窗体'}
procedure TFrmDlg.DDRGoldInitialize(Sender: TObject);
begin
  DDRGold.SetImgIndex (g_WMainImages, 28);
end;

procedure TFrmDlg.DDealRemoteDlgInitialize(Sender: TObject);
begin
  DDealRemoteDlg.SetImgIndex (g_WMainImages, 390);
end;

procedure TFrmDlg.DDGoldInitialize(Sender: TObject);
begin
  DDGold.SetImgIndex (g_WMainImages, 28);
end;

procedure TFrmDlg.DDealOkInitialize(Sender: TObject);
begin
  DDealOk.SetImgIndex (g_WMainImages, 391);
end;

procedure TFrmDlg.DDealCloseInitialize(Sender: TObject);
begin
  DDealClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DDealDlgInitialize(Sender: TObject);
begin
  DDealDlg.SetImgIndex (g_WMainImages, 389);
end;
{$ENDREGION}
{$REGION '商店窗体'}
procedure TFrmDlg.DMenuPrevInitialize(Sender: TObject);
begin
  DMenuPrev.SetImgIndex (g_WMainImages, 388);
end;

procedure TFrmDlg.DMenuNextInitialize(Sender: TObject);
begin
  DMenuNext.SetImgIndex (g_WMainImages, 387);
end;

procedure TFrmDlg.DMenuBuyInitialize(Sender: TObject);
begin
  DMenuBuy.SetImgIndex (g_WMainImages, 386);
end;

procedure TFrmDlg.DMenuCloseInitialize(Sender: TObject);
begin
  DMenuClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DMenuDlgInitialize(Sender: TObject);
begin
  DMenuDlg.SetImgIndex (g_WMainImages, 385);
end;
{$ENDREGION}
{$REGION '人物状态窗体'}
procedure TFrmDlg.DStateTabInitialize(Sender: TObject);
begin
  DStateTab.SetImgIndex(g_WMain2Images, 744);
end;

procedure TFrmDlg.DCloseStateInitialize(Sender: TObject);
begin
  DCloseState.SetImgIndex (g_WMainImages, 371);
end;

procedure TFrmDlg.DStateSsasInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
{$IF M2Version <> 2} //1.76
  with DStateSsas do begin
    d := g_WMainImages.Images[792];
    if d <> nil then begin
      SetImgIndex(g_WMainImages, 792);
    end else begin
      Visible := False;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DPrevStateInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  with DPrevState do begin
{$IF M2Version = 2} //1.76
    d := g_WMainImages.Images[370];
    if d <> nil then begin
      SetImgIndex (g_WMainImages, 373);
//      Visible := True;
    end;
{$ELSE}
    d := g_WMainImages.Images[806];
    if d <> nil then begin
      Visible := False;
    end else begin
      d := g_WMain3Images.Images[207];
      if d <> nil then begin
        SetImgIndex (g_WMainImages, 373);
      end;
    end;
{$IFEND}
  end;
end;

procedure TFrmDlg.DNextStateInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  with DNextState do begin
{$IF M2Version = 2} //1.76
    d := g_WMainImages.Images[370];
    if d <> nil then begin
      SetImgIndex (g_WMainImages, 372);
      //Visible := True;
    end;
{$ELSE}
    d := g_WMainImages.Images[806];
    if d <> nil then begin
      Visible := False;
    end else begin
      d := g_WMain3Images.Images[207];
      if d <> nil then begin
        SetImgIndex (g_WMainImages, 372);
      end;
    end;
{$IFEND}
  end;
end;
procedure TFrmDlg.DBJDSeeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 482);
{$IFEND}
end;
procedure TFrmDlg.HBExpInitialize(Sender: TObject);
begin
  TDButton(Sender).SetImgIndex(g_WMain2Images, 577);
end;
procedure TFrmDlg.JQExpInitialize(Sender: TObject);
begin
  TDButton(Sender).SetImgIndex(g_WMain2Images, 577);
end;
procedure TFrmDlg.DStPageUpInitialize(Sender: TObject);
begin
  DStPageUp.SetImgIndex (g_WMainImages, 398);
end;
procedure TFrmDlg.DStPageDownInitialize(Sender: TObject);
begin
  DStPageDown.SetImgIndex (g_WMainImages, 396);
end;
procedure TFrmDlg.DLiquorProgressInitialize(Sender: TObject);
begin
  DLiquorProgress.SetImgIndex(g_WMain2Images, 575);
end;
procedure TFrmDlg.DStateWinPulseInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[806];
  if d <> nil then begin
    DStateWinPulse.SetImgIndex(g_WMainImages, 820);
  end else begin
    DStateWinPulse.Visible := False;
  end;
end;
procedure TFrmDlg.DWinBatterRandomInitialize(Sender: TObject);
begin
  DWinBatterRandom.SetImgIndex(g_WMainImages, 901);
end;
procedure TFrmDlg.DWinBatterSetKeyInitialize(Sender: TObject);
begin
  DWinBatterSetKey.SetImgIndex(g_WMainImages, 901);
end;
procedure TFrmDlg.DWinBatterComInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TDButton(Sender).SetImgIndex(g_WMainImages, 911);
{$IFEND}
end;
procedure TFrmDlg.DStateWinInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  with DStateWin do begin
    {$IF M2Version = 2} //1.76
    if not g_boShowNewItem then     
      SetImgIndex (g_WMainImages, 370) //人物状态
    else begin
      SetImgIndex (g_WMain2Images, 740) //人物状态
    end;
    {$ELSE}
    d := g_WMainImages.Images[806];
    if d <> nil then begin
      SetImgIndex (g_WMainImages, 806); //人物状态  4格图
      DStateWinBatter.SetImgIndex(g_WMainImages, 900);
      g_boNewStateWin := True;
    end else begin
     DStateWinBatter.Visible := False;
     g_boNewStateWin := False;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DLNGUpLevel1Initialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
	with Sender as TDLabel do begin
    d := g_WUI1Images.Images[482];
    if d <> nil then
    	SetImgIndex(g_WUI1Images, 482);
  end;
end;

{$ENDREGION}
{$REGION '组队窗体'}
procedure TFrmDlg.DGrpAllowGroupInitialize(Sender: TObject);
begin
  DGrpAllowGroup.SetImgIndex (g_WMainImages, 122);
end;
procedure TFrmDlg.DGrpCreateInitialize(Sender: TObject);
begin
  DGrpCreate.SetImgIndex (g_WMainImages, 123);
end;
procedure TFrmDlg.DGrpAddMemInitialize(Sender: TObject);
begin
  DGrpAddMem.SetImgIndex (g_WMainImages, 124);
end;
procedure TFrmDlg.DGrpDelMemInitialize(Sender: TObject);
begin
  DGrpDelMem.SetImgIndex (g_WMainImages, 125);
end;
procedure TFrmDlg.DGrpDlgCloseInitialize(Sender: TObject);
begin
  DGrpDlgClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DGroupDlgInitialize(Sender: TObject);
begin
  DGroupDlg.SetImgIndex (g_WMainImages, 120);
end;
{$ENDREGION}
{$REGION '行会公告编辑框'}
procedure TFrmDlg.DGEOkInitialize(Sender: TObject);
begin
  DGEOK.SetImgIndex (g_WMainImages, 361);
end;
procedure TFrmDlg.DGECloseInitialize(Sender: TObject);
begin
  DGEClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DGuildEditNoticeInitialize(Sender: TObject);
begin
  DGuildEditNotice.SetImgIndex (g_WMainImages, 204);
end;
{$ENDREGION}
{$REGION '排行榜'}
procedure TFrmDlg.DIndividualOrderInitialize(Sender: TObject);
begin
  with DIndividualOrder do begin
  {$IF M2Version <> 2}
    SetImgIndex(g_Wmain2Images, 161);
    GTop := 61;
  {$ELSE}
    SetImgIndex(g_Wmain3Images,443);
    GTop := 60;
  {$IFEND}
  end;
end;
procedure TFrmDlg.DHeroOrderInitialize(Sender: TObject);
begin
  with DHeroOrder do begin
  {$IF M2Version <> 2}
    SetImgIndex(g_Wmain2Images, 162);
    GLeft := 86;
    GTop := 61;
  {$ELSE}
    SetImgIndex(g_Wmain3Images,444);
    GLeft := 123;
    GTop := 60;
  {$IFEND}
  end;
end;
procedure TFrmDlg.DMasterOrderInitialize(Sender: TObject);
begin
  with DMasterOrder do begin
  {$IF M2Version <> 2}
    SetImgIndex(g_Wmain2Images, 163);
    GLeft := 143;
    GTop := 61;
  {$ELSE}
    SetImgIndex(g_Wmain3Images,445);
    GLeft := 220;
    GTop := 60;
  {$IFEND}
  end;
end;
procedure TFrmDlg.DBLevelOrderUseItemInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
    DBLevelOrderUseItem.SetImgIndex(g_WUI1Images, 1343);
  {$IFEND}
end;
procedure TFrmDlg.DBLevelOrderCloudInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
    DBLevelOrderCloud.SetImgIndex(g_WMain2Images, 165);
  {$IFEND}
end;
procedure TFrmDlg.DLevelOrderCloseInitialize(Sender: TObject);
begin
  DLevelOrderClose.SetImgIndex(g_WmainImages,371);
end;
procedure TFrmDlg.DColonyHeroOrderInitialize(Sender: TObject);
begin
  DColonyHeroOrder.SetImgIndex(g_Wmain3Images,427);
end;
procedure TFrmDlg.DWarriorOrderInitialize(Sender: TObject);
begin
  DWarriorOrder.SetImgIndex(g_Wmain3Images,431);
end;

procedure TFrmDlg.DWizerdOrderInitialize(Sender: TObject);
begin
  DWizerdOrder.SetImgIndex(g_Wmain3Images,433);
end;

procedure TFrmDlg.DTaoistOrderInitialize(Sender: TObject);
begin
  DTaoistOrder.SetImgIndex(g_Wmain3Images,435);
end;
procedure TFrmDlg.DHeroAllOrderInitialize(Sender: TObject);
begin
  DHeroAllOrder.SetImgIndex(g_Wmain3Images,429);
end;
procedure TFrmDlg.DWarriorHeroOrderInitialize(Sender: TObject);
begin
  DWarriorHeroOrder.SetImgIndex(g_Wmain3Images,437);
end;
procedure TFrmDlg.DWizerdHeroOrderInitialize(Sender: TObject);
begin
  DWizerdHeroOrder.SetImgIndex(g_Wmain3Images,439);
end;
procedure TFrmDlg.DTaoistHeroOrderInitialize(Sender: TObject);
begin
  DTaoistHeroOrder.SetImgIndex(g_Wmain3Images,441);
end;
procedure TFrmDlg.DLevelOrderIndexInitialize(Sender: TObject);
begin
  DLevelOrderIndex.SetImgIndex(g_Wmain3Images,450);
end;
procedure TFrmDlg.DLevelOrderPrevInitialize(Sender: TObject);
begin
  DLevelOrderPrev.SetImgIndex(g_Wmain3Images,452);
end;
procedure TFrmDlg.DLFactionDlgHomeInitialize(Sender: TObject);
begin
	with Sender as TDLabel do
  	SetImgIndex(g_WMainImages, 1738);
end;
procedure TFrmDlg.DLevelOrderNextInitialize(Sender: TObject);
begin
  DLevelOrderNext.SetImgIndex(g_Wmain3Images,454);
end;
procedure TFrmDlg.DLevelOrderLastPageInitialize(Sender: TObject);
begin
  DLevelOrderLastPage.SetImgIndex(g_Wmain3Images,456);
end;
procedure TFrmDlg.DMyLevelOrderInitialize(Sender: TObject);
begin
  DMyLevelOrder.SetImgIndex(g_Wmain3Images,458);
end;
procedure TFrmDlg.DBOrderWeaponInitialize(Sender: TObject);
begin
  DBOrderWeapon.SetImgIndex(g_WUI1Images, 1368);
end;
procedure TFrmDlg.DBOrderWristletInitialize(Sender: TObject);
begin
  DBOrderWristlet.SetImgIndex(g_WUI1Images, 1362);
end;
procedure TFrmDlg.DBOrderRingInitialize(Sender: TObject);
begin
  DBOrderRing.SetImgIndex(g_WUI1Images, 1364);
end;

procedure TFrmDlg.DBOrderBeltInitialize(Sender: TObject);
begin
  DBOrderBelt.SetImgIndex(g_WUI1Images, 1376);
end;

procedure TFrmDlg.DBOrderBootsInitialize(Sender: TObject);
begin
  DBOrderBoots.SetImgIndex(g_WUI1Images, 1372);
end;

procedure TFrmDlg.DBOrderDressInitialize(Sender: TObject);
begin
  DBOrderDress.SetImgIndex(g_WUI1Images, 1378);
end;
procedure TFrmDlg.DBOrderHatInitialize(Sender: TObject);
begin
  DBOrderHat.SetImgIndex(g_WUI1Images, 1360);
end;

procedure TFrmDlg.DBOrderHelmetInitialize(Sender: TObject);
begin
  DBOrderHelmet.SetImgIndex(g_WUI1Images, 1366);
end;

procedure TFrmDlg.DBOrderMedalInitialize(Sender: TObject);
begin
  DBOrderMedal.SetImgIndex(g_WUI1Images, 1374);
end;

procedure TFrmDlg.DBOrderNecklaceInitialize(Sender: TObject);
begin
  DBOrderNecklace.SetImgIndex(g_WUI1Images, 1370);
end;

procedure TFrmDlg.DWLevelOrderInitialize(Sender: TObject);
begin
  with DWLevelOrder do begin
    {$IF M2Version <> 2}
      SetImgIndex (g_WUI1Images, 1340);
    {$ELSE}
      SetImgIndex (g_WMain3Images, 420);
    {$IFEND}
  end;
end;
{$ENDREGION}

{$REGION '底部窗体'}
procedure TFrmDlg.DBotMiniMapInitialize(Sender: TObject);
begin
  DBotMiniMap.SetImgIndex (g_WMainImages, 130);
end;
procedure TFrmDlg.DBotTradeInitialize(Sender: TObject);
begin
  DBotTrade.SetImgIndex (g_WMainImages, 132);
end;
procedure TFrmDlg.DBotGuildInitialize(Sender: TObject);
begin
  DBotGuild.SetImgIndex (g_WMainImages, 134);
end;
procedure TFrmDlg.DBotGroupInitialize(Sender: TObject);
begin
  DBotGroup.SetImgIndex (g_WMainImages, 128);
end;
procedure TFrmDlg.DBotPlusAbilInitialize(Sender: TObject);
begin
  DBotPlusAbil.SetImgIndex (g_WMainImages, 140);
end;
procedure TFrmDlg.ChallengeInitialize(Sender: TObject);
begin
  Challenge.SetImgIndex (g_WMain3Images,36);  //挑战
end;
procedure TFrmDlg.DBWhisperInitialize(Sender: TObject);
begin
  DBWhisper.SetImgIndex(g_WMainImages, 1151); //私聊信息
end;
procedure TFrmDlg.DBotStallInitialize(Sender: TObject);
begin
  DBotStall.SetImgIndex(g_qingqingImages, 13); //摆摊
end;
procedure TFrmDlg.DBotFactionInitialize(Sender: TObject);
begin
  DBotFaction.SetImgIndex(g_WUI1Images, 2500);
end;
procedure TFrmDlg.DBotLogoutInitialize(Sender: TObject);
begin
  DBotLogout.SetImgIndex (g_WMainImages, 136);
end;
procedure TFrmDlg.DBotExitInitialize(Sender: TObject);
begin
  DBotExit.SetImgIndex (g_WMainImages, 138);
end;
procedure TFrmDlg.DBHelpInitialize(Sender: TObject);
begin
  DBHelp.SetImgIndex(g_WMain2Images,495);
end;
procedure TFrmDlg.DMyStateInitialize(Sender: TObject);
begin
  DMyState.SetImgIndex (g_WMainImages, 8);
end;

procedure TFrmDlg.DMyBagInitialize(Sender: TObject);
begin
  DMyBag.SetImgIndex (g_WMainImages, 9);
end;
procedure TFrmDlg.DMyMagicInitialize(Sender: TObject);
begin
  DMyMagic.SetImgIndex (g_WMainImages, 10);
end;
procedure TFrmDlg.DOptionInitialize(Sender: TObject);
begin
  DOption.SetImgIndex (g_WMainImages, 11);
end;
procedure TFrmDlg.DDrunkScaleInitialize(Sender: TObject);
begin
  DDrunkScale.SetImgIndex(g_WMain2Images, 511);
end;
procedure TFrmDlg.DBRefusePublicChatInitialize(Sender: TObject);
begin
  DBRefusePublicChat.SetImgIndex(g_WMain3Images,280); //拒绝所有公聊信息
end;
procedure TFrmDlg.DBRefuseCRYInitialize(Sender: TObject);
begin
  DBRefuseCRY.SetImgIndex(g_WMain3Images,282);    //拒绝所有喊话信息
end;
procedure TFrmDlg.DBRefuseWHISPERInitialize(Sender: TObject);
begin
  DBRefuseWHISPER.SetImgIndex(g_WMain3Images,284);   //拒绝所有私聊信息
end;
procedure TFrmDlg.DBRefuseguildInitialize(Sender: TObject);
begin
  DBRefuseguild.SetImgIndex(g_WMain3Images,286);  //拒绝行会聊天信息
end;
procedure TFrmDlg.DBAutoCRYInitialize(Sender: TObject);
begin
  DBAutoCRY.SetImgIndex(g_WMain3Images,288);   //自动喊话开关
end;
procedure TFrmDlg.DBCommandInitialize(Sender: TObject);
begin
  DBCommand.SetImgIndex(g_WchantkkImages, 36); //游戏命令
end;
procedure TFrmDlg.DBInternetInitialize(Sender: TObject);
begin
  DBInternet.SetImgIndex(g_WMain2Images,498);
end;
procedure TFrmDlg.DBMissionInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
  DBMission.SetImgIndex(g_WMainImages, 283);
  {$IFEND}
end;
procedure TFrmDlg.DBatterShowImgInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DBatterShowImg.SetImgIndex(g_WMainImages, 1120);
  {$IFEND}
end;
procedure TFrmDlg.DBCallHeroInitialize(Sender: TObject);
begin
  DBCallHero.SetImgIndex(g_WMain3Images,372);    //召唤英雄
end;
procedure TFrmDlg.DBHeroStateInitialize(Sender: TObject);
begin
  DBHeroState.SetImgIndex(g_WMain3Images,373); //英雄状态信息
end;
procedure TFrmDlg.DBHeroPackageInitialize(Sender: TObject);
begin
  DBHeroPackage.SetImgIndex(g_WMain3Images,374);   //英雄包裹
end;
procedure TFrmDlg.DBCallDeputyHeroInitialize(Sender: TObject);
begin
  DBCallDeputyHero.SetImgIndex(g_WMain3Images,314);    //召唤副将英雄
end;
procedure TFrmDlg.DBotMemoInitialize(Sender: TObject);
begin
  DBotMemo.SetImgIndex (g_WMain3Images,297);
end;
{$ENDREGION}
{$REGION '提示对话框'}
procedure TFrmDlg.DMsgDlgOkInitialize(Sender: TObject);
begin
  DMsgDlgOk.SetImgIndex (g_WMainImages, 361);
end;
procedure TFrmDlg.DMsgDlgYesInitialize(Sender: TObject);
begin
  DMsgDlgYes.SetImgIndex (g_WMainImages, 363);
end;
procedure TFrmDlg.DMsgDlgCancelInitialize(Sender: TObject);
begin
  DMsgDlgCancel.SetImgIndex (g_WMainImages, 365);
end;
procedure TFrmDlg.DMsgDlgNoInitialize(Sender: TObject);
begin
  DMsgDlgNo.SetImgIndex (g_WMainImages, 367);
end;
procedure TFrmDlg.DMsgDlgGameGoldBuyInitialize(Sender: TObject);
begin
  DMsgDlgGameGoldBuy.SetImgIndex (g_qingqingImages, 26);
end;
procedure TFrmDlg.DMsgDlgGamePointBuyInitialize(Sender: TObject);
begin
  DMsgDlgGamePointBuy.SetImgIndex (g_qingqingImages, 28);
end;

procedure TFrmDlg.DMsgDlgInitialize(Sender: TObject);
begin

end;
{$ENDREGION}
{$REGION '英雄包裹'}
procedure TFrmDlg.DHeroItemBagInitialize(Sender: TObject);
begin
  DHeroItemBag.SetImgIndex (g_WMain3Images, 376);
end;
procedure TFrmDlg.DHeroItemGridCloseInitialize(Sender: TObject);
begin
  DHeroItemGridClose.SetImgIndex (g_WMainImages, 371);
end;

{$ENDREGION}
{$REGION '天地结晶'}
procedure TFrmDlg.DExpCrystalTopInitialize(Sender: TObject);
begin
  DExpCrystalTop.SetImgIndex(g_WMainImages, 468);
end;
procedure TFrmDlg.DCrystalExpInitialize(Sender: TObject);
begin
  DCrystalExp.SetImgIndex(g_WMainImages, 484);
end;
procedure TFrmDlg.DCrystalNGExpInitialize(Sender: TObject);
begin
  DCrystalNGExp.SetImgIndex(g_WMainImages, 485);
end;
procedure TFrmDlg.DWExpCrystalInitialize(Sender: TObject);
begin
  DWExpCrystal.SetImgIndex(g_WMainImages, 464);
end;
{$ENDREGION}
{$REGION 'NPC对话框'}
procedure TFrmDlg.DMerchantDlgInitialize(Sender: TObject);
begin
  DMerchantDlg.SetImgIndex (g_WMainImages, 384);
end;
procedure TFrmDlg.DMerchantDlgCloseInitialize(Sender: TObject);
begin
  DMerchantDlgClose.SetImgIndex (g_WMainImages, 64);
end;
{$ENDREGION}
{$REGION '摆摊'}
procedure TFrmDlg.DBtnStallStartInitialize(Sender: TObject);
begin
  DBtnStallStart.SetImgIndex(g_WMain2Images, 275);
end;
procedure TFrmDlg.DBtnStallStopInitialize(Sender: TObject);
begin
  DBtnStallStop.SetImgIndex(g_WMain2Images, 275);
end;
procedure TFrmDlg.DBStallCloseInitialize(Sender: TObject);
begin
  DBStallClose.SetImgIndex(g_WMainImages, 64);
end;

procedure TFrmDlg.DBTitle1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do 
    SetImgIndex(g_WUI1Images, 675);
{$IFEND}
end;

procedure TFrmDlg.DBTitleManInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do
  SetImgIndex(g_WUI1Images, 670);
{$IFEND}
end;

procedure TFrmDlg.DWStallInitialize(Sender: TObject);
begin
  DWStall.SetImgIndex(g_qingqingImages, 9);
end;
procedure TFrmDlg.DBWStallPriceTab1Initialize(Sender: TObject);
begin
  DBWStallPriceTab1.SetImgIndex(g_qingqingImages, 11);
end;
procedure TFrmDlg.DBWStallPriceTab2Initialize(Sender: TObject);
begin
  DBWStallPriceTab2.SetImgIndex(g_qingqingImages, 11);
end;
procedure TFrmDlg.DBWStallPriceOKInitialize(Sender: TObject);
begin
  DBWStallPriceOK.SetImgIndex(g_WMain2Images, 277);
end;
procedure TFrmDlg.DBWStallPriceCancelInitialize(Sender: TObject);
begin
  DBWStallPriceCancel.SetImgIndex(g_WMain2Images, 277);
end;
procedure TFrmDlg.DBWStallPriceCloseInitialize(Sender: TObject);
begin
  with Sender as TDButton do begin
    SetImgIndex(g_WMain2Images, 279);
  end;
end;
procedure TFrmDlg.DWWStallPriceInitialize(Sender: TObject);
begin
  DWWStallPrice.SetImgIndex(g_qingqingImages, 10);
end;

procedure TFrmDlg.DWZZLingPaiInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWZZLingPai.SetImgIndex(g_WUI1Images, 550);
{$IFEND}
end;

procedure TFrmDlg.DWZZLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBBuyUserStallItemInitialize(Sender: TObject);
begin
  DBBuyUserStallItem.SetImgIndex(g_WMain2Images, 275);
end;
procedure TFrmDlg.DBUserStallCloseInitialize(Sender: TObject);
begin
  DBUserStallClose.SetImgIndex(g_WMainImages, 64);
end;

procedure TFrmDlg.DWUserStallInitialize(Sender: TObject);
begin
  DWUserStall.SetImgIndex(g_qingqingImages, 9);
end;
{$ENDREGION}
{$REGION '行会'}
procedure TFrmDlg.DGDUpInitialize(Sender: TObject);
begin
  DGDUp.SetImgIndex (g_WMainImages, 373);
end;
procedure TFrmDlg.DGDDownInitialize(Sender: TObject);
begin
  DGDDown.SetImgIndex (g_WMainImages, 372);
end;
procedure TFrmDlg.DGDCloseInitialize(Sender: TObject);
begin
  DGDClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DGDHomeInitialize(Sender: TObject);
begin
  DGDHome.SetImgIndex (g_WMainImages, 198);
end;
procedure TFrmDlg.DGDAddMemInitialize(Sender: TObject);
begin
  DGDAddMem.SetImgIndex (g_WMainImages, 182);
end;
procedure TFrmDlg.DGDEditNoticeInitialize(Sender: TObject);
begin
  DGDEditNotice.SetImgIndex (g_WMainImages, 196);
end;
procedure TFrmDlg.DGDAllyInitialize(Sender: TObject);
begin
  DGDAlly.SetImgIndex (g_WMainImages, 184);
end;
procedure TFrmDlg.DGDWarInitialize(Sender: TObject);
begin
  DGDWar.SetImgIndex (g_WMainImages, 202);
end;
procedure TFrmDlg.DGDListInitialize(Sender: TObject);
begin
  DGDList.SetImgIndex (g_WMainImages, 200);
end;
procedure TFrmDlg.DGDChatInitialize(Sender: TObject);
begin
  DGDChat.SetImgIndex (g_WMainImages, 190);
end;
procedure TFrmDlg.DGDDelMemInitialize(Sender: TObject);
begin
  DGDDelMem.SetImgIndex (g_WMainImages, 192);
end;
procedure TFrmDlg.DGDEditGradeInitialize(Sender: TObject);
begin
  DGDEditGrade.SetImgIndex (g_WMainImages, 194);
end;
procedure TFrmDlg.DGDBreakAllyInitialize(Sender: TObject);
begin
  DGDBreakAlly.SetImgIndex (g_WMainImages, 186);
end;
procedure TFrmDlg.DGDCancelWarInitialize(Sender: TObject);
begin
  DGDCancelWar.SetImgIndex (g_WMainImages, 188);
end;
procedure TFrmDlg.DGuildDlgInitialize(Sender: TObject);
begin
  DGuildDlg.SetImgIndex (g_WMainImages, 180);
end;
{$ENDREGION}
{$REGION '任务'}
procedure TFrmDlg.DBMission1Initialize(Sender: TObject);
begin
  DBMission1.SetImgIndex(g_WMainImages, 286);
end;
procedure TFrmDlg.DBMission2Initialize(Sender: TObject);
begin
  DBMission2.SetImgIndex(g_WMainImages, 286);
end;
procedure TFrmDlg.DBMission3Initialize(Sender: TObject);
begin
  DBMission3.SetImgIndex(g_WMainImages, 286);
end;
procedure TFrmDlg.DBMissionCloseInitialize(Sender: TObject);
begin
  DBMissionClose.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DBMissionClose1Initialize(Sender: TObject);
begin
  DBMissionClose1.SetImgIndex(g_WMainImages, 286);
end;

procedure TFrmDlg.DScrollBarMission1Initialize(Sender: TObject);
begin
  DScrollBarMission1.ItemHeight := 15;
  DScrollBarMission1.SetImgIndex(g_WMain2Images, 574);
  DScrollBarMission1.GHeight := 134;
  DScrollBarMission1.ScrollSize := 15;
  DScrollBarMission1.PrevImageIndex.Up := 292;
  DScrollBarMission1.PrevImageIndex.Down := 293;
  DScrollBarMission1.NextImageIndex.Up := 294;
  DScrollBarMission1.NextImageIndex.Down := 295;
  DScrollBarMission1.BarImageIndex.Up := 581;
  DScrollBarMission1.RemoveSize :=  135;
  DScrollBarMission1.MaxValue := 0;
  DScrollBarMission1.Position := 0;
end;

procedure TFrmDlg.DScrollBoxKeyInitialize(Sender: TObject);
var
  ItemList: TStringList;
begin
  {$IF M2Version = 2}
    DBtnSdoHeroAttackTargetKey.Visible := False;
    DBtnSdoHeroGuardKey.Visible := False;
    DBtnSdoHeroStateKey.Visible := False;
    DBtnSdoHeroGotethKey.Visible := False;
    DBtnSdoCallHeroKey.Visible := False;
    DBtnSdoCallHero1Key.Visible := False;
    DBtnSdoSeriesKillKey.Visible := False;
    DBtnSdoAttackModeKey.GLeft := DBtnSdoSeriesKillKey.GLeft;
    DBtnSdoAttackModeKey.GTop := DBtnSdoSeriesKillKey.GTop;
    DBtnSdoMinMapKey.GLeft := DBtnSdoCallHeroKey.GLeft;
    DBtnSdoMinMapKey.GTop := DBtnSdoCallHeroKey.GTop;
  {$ELSE}
    {$IF M2Version = 0}
    DBtnSdoSeriesKillKey.Visible := False;
    DBtnSdoMinMapKey.GLeft := DBtnSdoAttackModeKey.GLeft;
    DBtnSdoMinMapKey.GTop := DBtnSdoAttackModeKey.GTop;
    DBtnSdoAttackModeKey.GLeft := DBtnSdoHeroGuardKey.GLeft;
    DBtnSdoAttackModeKey.GTop := DBtnSdoHeroGuardKey.GTop;
    DBtnSdoHeroGuardKey.GLeft := DBtnSdoHeroStateKey.GLeft;
    DBtnSdoHeroGuardKey.GTop := DBtnSdoHeroStateKey.GTop;
    DBtnSdoHeroStateKey.GLeft := DBtnSdoHeroGotethKey.GLeft;
    DBtnSdoHeroStateKey.GTop := DBtnSdoHeroGotethKey.GTop;
    DBtnSdoHeroGotethKey.GLeft := DBtnSdoHeroAttackTargetKey.GLeft;
    DBtnSdoHeroGotethKey.GTop := DBtnSdoHeroAttackTargetKey.GTop;
    DBtnSdoHeroAttackTargetKey.GLeft := DBtnSdoCallHero1Key.GLeft;
    DBtnSdoHeroAttackTargetKey.GTop := DBtnSdoCallHero1Key.GTop;
    DBtnSdoCallHero1Key.GLeft := DBtnSdoCallHeroKey.GLeft;
    DBtnSdoCallHero1Key.GTop := DBtnSdoCallHeroKey.GTop;
    DBtnSdoCallHeroKey.GLeft := DBtnSdoSeriesKillKey.GLeft;
    DBtnSdoCallHeroKey.GTop := DBtnSdoSeriesKillKey.GTop;
    DScrollBoxKey.SpareSize := 10;
    ItemList := DScrollBoxKey.Add;
    DScrollBoxKey.AddSuItem(ItemList, DCheckSdoStartKey);
    DScrollBoxKey.AddSuItem(ItemList, DLabel10);
    DScrollBoxKey.AddSuItem(ItemList, DLabel11);
    DScrollBoxKey.AddSuItem(ItemList, DScrollBoxKeySurface);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroAttackTargetKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoMinMapKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoAttackModeKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGuardKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroStateKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGotethKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHeroKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHero1Key);
    DScrollBarKey.MaxValue := 240;
    {$ELSE}
    DScrollBoxKey.SpareSize := 10;
    ItemList := DScrollBoxKey.Add;
    DScrollBoxKey.AddSuItem(ItemList, DCheckSdoStartKey);
    DScrollBoxKey.AddSuItem(ItemList, DLabel10);
    DScrollBoxKey.AddSuItem(ItemList, DLabel11);
    DScrollBoxKey.AddSuItem(ItemList, DScrollBoxKeySurface);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroAttackTargetKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoMinMapKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoAttackModeKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGuardKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroStateKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoHeroGotethKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHeroKey);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoCallHero1Key);
    DScrollBoxKey.AddSuItem(ItemList, DBtnSdoSeriesKillKey);
    DScrollBarKey.MaxValue := 260;
    {$IFEND}
  {$IFEND}
end;

procedure TFrmDlg.DScrollBoxKeySurfaceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Rc: TRect;
begin
  with DScrollBoxKeySurface do begin
    {$IF M2Version = 2}
    dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 2, clSilver, clBlack, '切换攻击模式');
    dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22+2, clSilver, clBlack, '切换小地图');
    Rc.Left := SurfaceX(GLeft)+90;
    Rc.Top := SurfaceY(GTop);
    Rc.Right := Rc.Left + 110;
    Rc.Bottom := Rc.Top + 19;
    dsurface.FastFillRect(Rc, $00040404);
    dsurface.FastFrameRect(Rc, $00848284);
    Rc.Left := SurfaceX(GLeft)+90;
    Rc.Top := SurfaceY(GTop)+22;
    Rc.Right := Rc.Left + 110;
    Rc.Bottom := Rc.Top + 19;
    dsurface.FastFillRect(Rc, $00040404);
    dsurface.FastFrameRect(Rc, $00848284);
    dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 3, clSilver, clBlack, 'Ctrl+H');
    dsurface.BoldTextOut (SurfaceX(GLeft) + 127+9, SurfaceY(GTop) + 22+3, clSilver, clBlack, 'Tab');
    {$ELSE}
      {$IF M2Version = 0}
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 2, clSilver, clBlack, '召唤英雄');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22+2, clSilver, clBlack, '召唤副将英雄');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*2+2, clSilver, clBlack, '英雄攻击目标');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*3+2, clSilver, clBlack, '使用合击技');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*4+2, clSilver, clBlack, '切换英雄状态');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*5+2, clSilver, clBlack, '英雄守护');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*6+2, clSilver, clBlack, '切换攻击模式');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*7+2, clSilver, clBlack, '切换小地图');
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop);
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*2;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*3;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*4;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*5;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*6;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*7;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22+3, clSilver, clBlack, 'Ctrl+F');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*2+3, clSilver, clBlack, 'Ctrl+W');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*3+3, clSilver, clBlack, 'Ctrl+S');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*4+3, clSilver, clBlack, 'Ctrl+E');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*5+3, clSilver, clBlack, 'Ctrl+Q');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*6+3, clSilver, clBlack, 'Ctrl+H');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127+9, SurfaceY(GTop) + 22*7+3, clSilver, clBlack, 'Tab');
      {$ELSE}
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 2, clRed, clBlack, '连击技');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22+2, clSilver, clBlack, '召唤英雄');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*2+2, clSilver, clBlack, '召唤副将英雄');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*3+2, clSilver, clBlack, '英雄攻击目标');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*4+2, clSilver, clBlack, '使用合击技');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*5+2, clSilver, clBlack, '切换英雄状态');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*6+2, clSilver, clBlack, '英雄守护');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*7+2, clSilver, clBlack, '切换攻击模式');
      dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + 22*8+2, clSilver, clBlack, '切换小地图');
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop);
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*2;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*3;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*4;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*5;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*6;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*7;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);
      Rc.Left := SurfaceX(GLeft)+90;
      Rc.Top := SurfaceY(GTop)+22*8;
      Rc.Right := Rc.Left + 110;
      Rc.Bottom := Rc.Top + 19;
      dsurface.FastFillRect(Rc, $00040404);
      dsurface.FastFrameRect(Rc, $00848284);

      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 3, clSilver, clBlack, 'Ctrl+D');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*2+3, clSilver, clBlack, 'Ctrl+F');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*3+3, clSilver, clBlack, 'Ctrl+W');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*4+3, clSilver, clBlack, 'Ctrl+S');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*5+3, clSilver, clBlack, 'Ctrl+E');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*6+3, clSilver, clBlack, 'Ctrl+Q');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 22*7+3, clSilver, clBlack, 'Ctrl+H');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 127+9, SurfaceY(GTop) + 22*8+3, clSilver, clBlack, 'Tab');
      {$IFEND}
    {$IFEND}
  end;
end;

procedure TFrmDlg.DScrollBoxProDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Rc: TRect;
begin
  with DScrollBoxPro do begin
    Rc.Top := SurfaceY(GTop);
    Rc.Bottom := SurfaceY(GTop+GHeight);
    Rc.Left := SurfaceX(GLeft+63);
    Rc.Right := SurfaceX(GLeft+64);
    dsurface.FillRect(Rc,$00848284);
  end;

end;

procedure TFrmDlg.DScrollBoxProInitialize(Sender: TObject);
var
  ItemList: TStringList;
begin
  DScrollBoxPro.SpareSize := 10;
  ItemList := DScrollBoxPro.Add;
  DScrollBoxPro.AddSuItem(ItemList, DLabel1);
  DScrollBoxPro.AddSuItem(ItemList, DLabel9);
  DScrollBoxPro.AddSuItem(ItemList, DLabel2);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxBookHPPro);
  DScrollBoxPro.AddSuItem(ItemList, DEdtBookHPPro);
  DScrollBoxPro.AddSuItem(ItemList, DLabel3);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxBookMPPro);
  DScrollBoxPro.AddSuItem(ItemList, DEdtBookMPPro);
  DScrollBoxPro.AddSuItem(ItemList, DLabel4);
  DScrollBoxPro.AddSuItem(ItemList, DLabel5);
  DScrollBoxPro.AddSuItem(ItemList, DLabel6);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewHP);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHP);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHPTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewMP);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMp);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMpTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewHPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewHPSpecialTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxRenewMPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMPSpecial);
  DScrollBoxPro.AddSuItem(ItemList, DEdtRenewMPSpecialTime);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedica);
  DScrollBoxPro.AddSuItem(ItemList, DLabel7);
  DScrollBoxPro.AddSuItem(ItemList, DLabel8);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP1);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime1);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP2);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime2);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP3);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime3);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP4);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime4);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP5);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime5);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP6);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime6);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP7);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime7);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP8);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime8);
  DScrollBoxPro.AddSuItem(ItemList, DCheckBoxUseSuperMedicaItemName9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHP9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaHPTime9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMP9);
  DScrollBoxPro.AddSuItem(ItemList, DEditSuperMedicaMPTime9);
  //DScrollBarPro.MaxValue := 500+25*5;
end;

procedure TFrmDlg.DScrollBoxProMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DTreeViewMission1Initialize(Sender: TObject);
begin
  DTreeViewMission1.WWLib := g_WMainImages;
  DTreeViewMission1.unfoldImg := 291;
  DTreeViewMission1.shrinkImg := 292;
end;
procedure TFrmDlg.DWMissionInitialize(Sender: TObject);
begin
  DWMission.SetImgIndex(g_WMainImages, 290);
end;
procedure TFrmDlg.DMemoMissionBottomInitialize(Sender: TObject);
begin
  DMemoMissionBottom.DScroll := DMemoMissionBottomScrollBar;
  DMemoMissionBottom.DScroll.GTop := -3;
  DMemoMissionBottom.DScroll.GLeft := DMemoMissionBottom.GWidth+3;
  DMemoMissionBottom.DScroll.GHeight := DMemoMissionBottom.GHeight;
  DMemoMissionBottom.DScroll.GWidth := 16;
  DMemoMissionBottom.DScroll.Bar.GTop := 17;
  DMemoMissionBottom.DScroll.BDown.GTop := DMemoMissionBottom.DScroll.GHeight-17;
  DMemoMissionBottom.DScroll.BUp.GTop := 2;
end;
procedure TFrmDlg.DMemoMissionBottomScrollBarInitialize(Sender: TObject);
begin
  DMemoMissionBottomScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DMemoMissionBottomScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DMemoMissionBottomScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;
{$ENDREGION}
{$REGION '卖东西'}
procedure TFrmDlg.DSellDlgInitialize(Sender: TObject);
begin
  DSellDlg.SetImgIndex (g_WMainImages, 392);
end;
procedure TFrmDlg.DSellDlgCloseInitialize(Sender: TObject);
begin
  DSellDlgClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DSellDlgOkInitialize(Sender: TObject);
begin
  DSellDlgOk.SetImgIndex (g_WMainImages, 393);
end;
{$ENDREGION}
{$REGION '属性点'}
procedure TFrmDlg.DAdjustAbilityInitialize(Sender: TObject);
begin
  DAdjustAbility.SetImgIndex (g_WMainImages, 226);
end;
procedure TFrmDlg.DAdjustAbilOkInitialize(Sender: TObject);
begin
  DAdjustAbilOk.SetImgIndex (g_WMainImages, 62);
end;
procedure TFrmDlg.DAdjustAbilCloseInitialize(Sender: TObject);
begin
  DAdjustAbilClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DMinusDCInitialize(Sender: TObject);
begin
  DMinusDC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusHitInitialize(Sender: TObject);
begin
  DMinusHit.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusHPInitialize(Sender: TObject);
begin
  DMinusHP.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusMACInitialize(Sender: TObject);
begin
  DMinusMAC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusMCInitialize(Sender: TObject);
begin
  DMinusMC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusMPInitialize(Sender: TObject);
begin
  DMinusMP.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusSCInitialize(Sender: TObject);
begin
  DMinusSC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DMinusSpeedInitialize(Sender: TObject);
begin
  DMinusSpeed.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DPlusMACInitialize(Sender: TObject);
begin
  DPlusMAC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusMCInitialize(Sender: TObject);
begin
  DPlusMC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DMinusACInitialize(Sender: TObject);
begin
  DMinusAC.SetImgIndex (g_WMainImages, 228);
end;
procedure TFrmDlg.DPlusMPInitialize(Sender: TObject);
begin
  DPlusMP.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusACInitialize(Sender: TObject);
begin
  DPlusAC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusSCInitialize(Sender: TObject);
begin
  DPlusSC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusSpeedInitialize(Sender: TObject);
begin
  DPlusSpeed.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusDCInitialize(Sender: TObject);
begin
  DPlusDC.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusHitInitialize(Sender: TObject);
begin
  DPlusHit.SetImgIndex (g_WMainImages, 227);
end;
procedure TFrmDlg.DPlusHPInitialize(Sender: TObject);
begin
  DPlusHP.SetImgIndex (g_WMainImages, 227);
end;

{$ENDREGION}
{$REGION '英雄图标'}
procedure TFrmDlg.DHeroIconInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
   d := g_WUI1Images.Images[1290];
   if d <> nil then DHeroIcon.SetImgIndex (g_WUI1Images, 1290)
   else begin
    d := g_WMainImages.Images[1214];
    if d <> nil then DHeroIcon.SetImgIndex (g_WMainImages, 1214); 
   end;
end;
{$ENDREGION}
{$REGION '其他人状态栏'}
procedure TFrmDlg.DCloseUS1Initialize(Sender: TObject);
begin
  DCloseUS1.SetImgIndex (g_WMainImages, 371);
end;
procedure TFrmDlg.DUserState1Initialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
   {$IF M2Version = 2}//1.76
   d := g_WMainImages.Images[370];
   if d <> nil then
      DUserState1.SetImgIndex (g_WMainImages, 370);
   {$ELSE}
   d := g_WMain3Images.Images[207];
   if d <> nil then
      DUserState1.SetImgIndex (g_WMain3Images, 207);   //4格
   {$IFEND}
end;
{$ENDREGION}
{$REGION '取回英雄'}
procedure TFrmDlg.DSelHero1Initialize(Sender: TObject);
begin
  DSelHero1.SetImgIndex(g_Wmain2Images,508);
end;
procedure TFrmDlg.DSelHero2Initialize(Sender: TObject);
begin
  DSelHero2.SetImgIndex(g_Wmain2Images,508);
end;
procedure TFrmDlg.DGetHeroCloseInitialize(Sender: TObject);
begin
  DGetHeroClose.SetImgIndex(g_WmainImages,371);
end;
procedure TFrmDlg.DWiGetHeroInitialize(Sender: TObject);
begin
  DWiGetHero.SetImgIndex (g_WMain2Images, 501);
end;
{$ENDREGION}
{$REGION '验证码'}
procedure TFrmDlg.DCheckNumOKInitialize(Sender: TObject);
begin
  DCheckNumOK.SetImgIndex(g_WMain2Images, 146);
end;
procedure TFrmDlg.DCheckNumChangeInitialize(Sender: TObject);
begin
  DCheckNumChange.SetImgIndex(g_WMain2Images, 146);
end;
procedure TFrmDlg.DCheckNumCloseInitialize(Sender: TObject);
begin
  DCheckNumClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DWCheckNumInitialize(Sender: TObject);
begin
  DWCheckNum.SetImgIndex(g_WMain3Images, 43);
end;
{$ENDREGION}
{$REGION '挑战'}
procedure TFrmDlg.DChallengeOKInitialize(Sender: TObject);
begin
  DChallengeOK.SetImgIndex(g_WMain3Images, 463);
end;

procedure TFrmDlg.DChatMemoInitialize(Sender: TObject);
begin
  DChatMemo.WLib := g_WchantkkImages;
  DChatMemo.ScrollImageIndex.Up := 20;
  DChatMemo.PrevImageIndex.Up := 21;
  DChatMemo.PrevImageIndex.Hot := 22;
  DChatMemo.PrevImageIndex.Down := 23;
  DChatMemo.BarImageIndex.Up := 27;
  DChatMemo.BarImageIndex.Hot := 28;
  DChatMemo.BarImageIndex.Down := 29;
  DChatMemo.NextImageIndex.Up := 24;
  DChatMemo.NextImageIndex.Hot := 25;
  DChatMemo.NextImageIndex.Down := 26;
  DChatMemo.Clear;
  {
  DChatMemo.WLib := g_qingqingImages; //DChatMemo的资源为 g_WNewopUIImages
  DChatMemo.ScrollImageIndex.Up := 50; //DChatMemo的滚动条的背景正常图片序列号为20
  DChatMemo.PrevImageIndex.Up := 51; //DChatMemo的滚动条的向上按钮的正常图片序列号为21
  DChatMemo.PrevImageIndex.Hot := 52; //DChatMemo的滚动条的向上按钮的鼠标经过时片序列号为22
  DChatMemo.PrevImageIndex.Down := 53; //DChatMemo的滚动条的向上按钮的鼠标按下时片序列号为23
  DChatMemo.BarImageIndex.Up := 57; //DChatMemo的滚动条的中间圆圆滚动按钮
  DChatMemo.BarImageIndex.Hot := 58; //DChatMemo的滚动条的中间圆圆滚动按钮
  DChatMemo.BarImageIndex.Down := 59; //DChatMemo的滚动条的中间圆圆滚动按钮
  DChatMemo.NextImageIndex.Up := 54;  //DChatMemo的滚动条的向下按钮
  DChatMemo.NextImageIndex.Hot := 55; //DChatMemo的滚动条的向下按钮
  DChatMemo.NextImageIndex.Down := 56; //DChatMemo的滚动条的向下按钮
  DChatMemo.Clear;
  }
end;

procedure TFrmDlg.DChallengeCancelInitialize(Sender: TObject);
begin
  DChallengeCancel.SetImgIndex(g_WMain3Images, 466);
end;
procedure TFrmDlg.DChallengeCloseInitialize(Sender: TObject);
begin
  DChallengeClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DWChallengeInitialize(Sender: TObject);
begin
  DWChallenge.SetImgIndex(g_WMain3Images, 465);
end;
{$ENDREGION}
{$REGION '宝箱'}
procedure TFrmDlg.DBoxsBelt1Initialize(Sender: TObject);
begin
  DBoxsBelt1.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt2Initialize(Sender: TObject);
begin
  DBoxsBelt2.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt3Initialize(Sender: TObject);
begin
  DBoxsBelt3.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt4Initialize(Sender: TObject);
begin
  DBoxsBelt4.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt5Initialize(Sender: TObject);
begin
  DBoxsBelt5.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt6Initialize(Sender: TObject);
begin
  DBoxsBelt6.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt7Initialize(Sender: TObject);
begin
  DBoxsBelt7.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt8Initialize(Sender: TObject);
begin
  DBoxsBelt8.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBoxsBelt9Initialize(Sender: TObject);
begin
  DBoxsBelt9.SetImgIndex(g_WMain3Images, 514);
end;
procedure TFrmDlg.DBNewHelpBtnInitialize(Sender: TObject);
begin
  DBNewHelpBtn.SetImgIndex(g_WMain2Images, 219);
end;
procedure TFrmDlg.DBoxsNewCloseInitialize(Sender: TObject);
begin
  DBoxsNewClose.SetImgIndex(g_WMain2Images, 212);
end;
procedure TFrmDlg.DNewBoxsHelpCloseInitialize(Sender: TObject);
begin
  DNewBoxsHelpClose.SetImgIndex(g_WMain2Images, 212);
end;
procedure TFrmDlg.DNewBoxsHelpInitialize(Sender: TObject);
begin
  DNewBoxsHelp.SetImgIndex(g_WMain2Images, 211);
end;
procedure TFrmDlg.DBoxsInitialize(Sender: TObject);
begin
//  DBoxs.SetImgIndex(g_WMain3Images,520);
end;
{$ENDREGION}
{$REGION '关系系统'}
procedure TFrmDlg.DFriendDlgFrdInitialize(Sender: TObject);
begin
  DFriendDlgFrd.SetImgIndex (g_WMain3Images, 481);
end;
procedure TFrmDlg.DFriendDlgTangetInitialize(Sender: TObject);
begin
  DFriendDlgTanget.SetImgIndex (g_WMainImages, 301);
end;
procedure TFrmDlg.DHeiMingDanInitialize(Sender: TObject);
begin
  DHeiMingDan.SetImgIndex (g_WMain3Images, 483);
end;
procedure TFrmDlg.DAddFriendInitialize(Sender: TObject);
begin
  DAddFriend.SetImgIndex (g_WMain3Images, 485);
end;
procedure TFrmDlg.DDelFriendInitialize(Sender: TObject);
begin
  DDelFriend.SetImgIndex (g_WMain3Images, 484);
end;
procedure TFrmDlg.DPrevFriendDlgInitialize(Sender: TObject);
begin
  DPrevFriendDlg.SetImgIndex (g_WMainImages, 398);
end;
procedure TFrmDlg.DNextFriendDlgInitialize(Sender: TObject);
begin
  DNextFriendDlg.SetImgIndex (g_WMainImages, 396);
end;
procedure TFrmDlg.DFrdCloseInitialize(Sender: TObject);
begin
  DFrdClose.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DFriendDlgInitialize(Sender: TObject);
begin
  DFriendDlg.SetImgIndex (g_WMainImages, 300);
end;
{$ENDREGION}
{$REGION '感叹号'}
procedure TFrmDlg.DSighIconInitialize(Sender: TObject);
begin
  DSighIcon.SetImgIndex(g_WMainImages, 460);
end;
{$ENDREGION}
{$REGION '淬炼'}
procedure TFrmDlg.DItemsUpOkInitialize(Sender: TObject);
begin
  DItemsUpOk.SetImgIndex(g_WMain3Images, 463);
end;
procedure TFrmDlg.DItemsUpCloseInitialize(Sender: TObject);
begin
  DItemsUpClose.SetImgIndex (g_WMainImages, 64);
end;
procedure TFrmDlg.DItemsUpInitialize(Sender: TObject);
begin
  DItemsUp.SetImgIndex (g_WMain3Images, 462);
end;

{$ENDREGION}
{$REGION '寄售'}
procedure TFrmDlg.DSellOffOkInitialize(Sender: TObject);
begin
  DSellOffOk.SetImgIndex(g_WMain3Images, 210);
end;
procedure TFrmDlg.DSellOffCancelInitialize(Sender: TObject);
begin
  DSellOffCancel.SetImgIndex(g_WMain3Images, 212);
end;
procedure TFrmDlg.DSellOffCloseInitialize(Sender: TObject);
begin
  DSellOffClose.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DWSellOffInitialize(Sender: TObject);
begin
  DWSellOff.SetImgIndex(g_WMain3Images, 209);
end;
procedure TFrmDlg.DSellOffListCancelInitialize(Sender: TObject);
begin
  DSellOffListCancel.SetImgIndex(g_WMain3Images, 251);
end;
procedure TFrmDlg.DSellOffBuyCancelInitialize(Sender: TObject);
begin
  DSellOffBuyCancel.SetImgIndex(g_WMain3Images, 249);
end;
procedure TFrmDlg.DSellOffBuyInitialize(Sender: TObject);
begin
  DSellOffBuy.SetImgIndex(g_WMain3Images, 247);
end;
procedure TFrmDlg.DSellOffListColseInitialize(Sender: TObject);
begin
  DSellOffListColse.SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DWSellOffListInitialize(Sender: TObject);
begin
  DWSellOffList.SetImgIndex(g_WMain3Images, 277);
end;
{$ENDREGION}
{$REGION '私聊记录'}
procedure TFrmDlg.DMemoWhisperListInitialize(Sender: TObject);
begin
  DMemoWhisperList.DScroll := DMemoWhisperListScrollBar;
  DMemoWhisperList.DScroll.GTop := 0;
  DMemoWhisperList.DScroll.GLeft := 346;
  DMemoWhisperList.DScroll.GHeight := 180;
  DMemoWhisperList.DScroll.GWidth := 16;
  DMemoWhisperList.DScroll.Bar.GTop := 17;
  DMemoWhisperList.DScroll.BDown.GTop := 163;
  DMemoWhisperList.DScroll.BUp.GTop := 2;
end;
procedure TFrmDlg.DMemoWhisperListScrollBarInitialize(Sender: TObject);
begin
  DMemoWhisperListScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DMemoWhisperListScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DMemoWhisperListScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;

procedure TFrmDlg.DWhisperCloseInitialize(Sender: TObject);
begin
	with Sender as TDButton do
  SetImgIndex(g_WMain3Images,233);
end;
procedure TFrmDlg.DWWhisperInitialize(Sender: TObject);
begin
  DWWhisper.SetImgIndex(g_WMainImages, 1150);
end;
{$ENDREGION}
{$REGION '英雄评定'}
procedure TFrmDlg.DHeroAssessSign1Initialize(Sender: TObject);
begin
  DHeroAssessSign1.SetImgIndex(g_WMainImages, 1546);
end;
procedure TFrmDlg.DHeroAssessClose1Initialize(Sender: TObject);
begin
  DHeroAssessClose1.SetImgIndex(g_WMainImages, 1546);
end;
procedure TFrmDlg.DHeroAssessSignInitialize(Sender: TObject);
begin
  DHeroAssessSign.SetImgIndex(g_WMainImages, 1542);
end;
procedure TFrmDlg.DHeroAssessCloseInitialize(Sender: TObject);
begin
  DHeroAssessClose.SetImgIndex(g_Wmain3Images,233);
end;
procedure TFrmDlg.DWHeroAssessInitialize(Sender: TObject);
begin
  DWHeroAssess.SetImgIndex(g_WMainImages, 1540);
end;
procedure TFrmDlg.DHeroAutoPraMapPrevInitialize(Sender: TObject);
begin
  DHeroAutoPraMapPrev.SetImgIndex(g_WMainImages, 1564);
end;
procedure TFrmDlg.DHeroAutoPraMapNextInitialize(Sender: TObject);
begin
  DHeroAutoPraMapNext.SetImgIndex(g_WMainImages, 1561);
end;
procedure TFrmDlg.DHeroAutoPraYDSPrevInitialize(Sender: TObject);
begin
  DHeroAutoPraYDSPrev.SetImgIndex(g_WMainImages, 1564);
end;
procedure TFrmDlg.DHeroAutoPraYDSNextInitialize(Sender: TObject);
begin
  DHeroAutoPraYDSNext.SetImgIndex(g_WMainImages, 1561);
end;
procedure TFrmDlg.DStartHeroAutoPraInitialize(Sender: TObject);
begin
  DStartHeroAutoPra.SetImgIndex(g_WmainImages,1548);
end;
procedure TFrmDlg.DHeroAutoPraCloseInitialize(Sender: TObject);
begin
  DHeroAutoPraClose.SetImgIndex(g_Wmain3Images,233);
end;
procedure TFrmDlg.DWHeroAutoPracticeInitialize(Sender: TObject);
begin
  DWHeroAutoPractice.SetImgIndex(g_WMainImages, 1570);
end;
{$ENDREGION}
{$REGION '商铺'}
procedure TFrmDlg.DShopPrevInitialize(Sender: TObject);
begin
  DShopPrev.SetImgIndex(g_WmainImages,388);
end;
procedure TFrmDlg.DShopNextInitialize(Sender: TObject);
begin
  DShopNext.SetImgIndex(g_WmainImages,387);
end;
procedure TFrmDlg.DShopBuyInitialize(Sender: TObject);
begin
  DShopBuy.SetImgIndex(g_Wmain3Images,304);
end;
procedure TFrmDlg.DShopPresentInitialize(Sender: TObject);
begin
  DShopPresent.SetImgIndex(g_Wmain3Images,305);
end;
procedure TFrmDlg.DShopClose1Initialize(Sender: TObject);
begin
  DShopClose1.SetImgIndex(g_Wmain3Images,306);
end;
procedure TFrmDlg.DShopCloseInitialize(Sender: TObject);
begin
  DShopClose.SetImgIndex(g_WmainImages,371);
end;
procedure TFrmDlg.DShopInitialize(Sender: TObject);
begin
  DShop.SetImgIndex (g_Wmain3Images,298);
end;
{$ENDREGION}
{$REGION '英雄状态栏'}
procedure TFrmDlg.DStateHeroInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DStateHero.SetImgIndex (g_WMainImages, 808);
    g_boNewHeroState := True;
  end else begin
    d := g_WMain3Images.Images[384];
    if d <> nil then begin
      DStateHero.SetImgIndex (g_WMain3Images, 384); //人物状态  4格图
    end;
    g_boNewHeroState := False;
  end;
end;
procedure TFrmDlg.DHeroStateWinPulseInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DHeroStateWinPulse.SetImgIndex(g_WMainImages, 820);
  end else DHeroStateWinPulse.Visible := False;
end;
procedure TFrmDlg.DHeroStateTabInitialize(Sender: TObject);
begin
  DHeroStateTab.SetImgIndex(g_WMain2Images, 746);
end;
procedure TFrmDlg.DCloseHeroStateInitialize(Sender: TObject);
begin
  DCloseHeroState.SetImgIndex (g_WMainImages, 371);
end;
procedure TFrmDlg.DHeroStateSsasInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DHeroStateSsas.SetImgIndex(g_WMainImages, 792);
  end else begin
    DHeroStateSsas.Visible := False;
  end;
end;
procedure TFrmDlg.DPrevStateHeroInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DPrevStateHero.Visible := False;
  end else begin
    d := g_WMain3Images.Images[384];
    if d <> nil then begin
      DPrevStateHero.SetImgIndex (g_WMainImages, 373);
    end;
  end;
end;
procedure TFrmDlg.DNextStateHeroInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DNextStateHero.Visible := False;
  end else begin
    d := g_WMain3Images.Images[384];
    if d <> nil then begin
      DNextStateHero.SetImgIndex (g_WMainImages, 372);
    end;
  end;
end;
procedure TFrmDlg.DSHPageUpInitialize(Sender: TObject);
begin
  DSHPageUp.SetImgIndex (g_WMainImages, 398);
end;
procedure TFrmDlg.DSHPageDownInitialize(Sender: TObject);
begin
  DSHPageDown.SetImgIndex (g_WMainImages, 396);
end;
procedure TFrmDlg.DHeroJQExpInitialize(Sender: TObject);
begin
  DHeroJQExp.SetImgIndex(g_WMain2Images, 577);
end;
procedure TFrmDlg.DBHeroQSSSeeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
DBHeroQSSSee.SetImgIndex(g_WUI1Images, 482);
{$IFEND}
end;
procedure TFrmDlg.DHeroLiquorProgressInitialize(Sender: TObject);
begin
  DHeroLiquorProgress.SetImgIndex(g_WMain2Images, 575);
end;
procedure TFrmDlg.DHeroBatterRandomInitialize(Sender: TObject);
begin
  DHeroBatterRandom.SetImgIndex(g_WMainImages, 901);
end;
procedure TFrmDlg.DHeroBatterComInitialize(Sender: TObject);
begin
  DHeroBatterCom.SetImgIndex(g_WMainImages, 911);
end;
procedure TFrmDlg.DHeroStateWinBatterInitialize(Sender: TObject);
var
  d: TDirectDrawSurface;
begin
  d := g_WMainImages.Images[808];
  if d <> nil then begin
    DHeroStateWinBatter.SetImgIndex(g_WMainImages, 900);
  end else DHeroStateWinBatter.Visible := False;
end;
{$ENDREGION}
{$REGION '请酒'}
procedure TFrmDlg.DPDrink1Initialize(Sender: TObject);
begin
  DPDrink1.SetImgIndex(g_WMain2Images, 365);
end;
procedure TFrmDlg.DPDrink2Initialize(Sender: TObject);
begin
  DPDrink2.SetImgIndex(g_WMain2Images, 365);
end;
procedure TFrmDlg.DPleaseDrinkDrinkInitialize(Sender: TObject);
begin
  DPleaseDrinkDrink.SetImgIndex(g_WMain2Images, 354);
end;
procedure TFrmDlg.DPleaseDrinkExitInitialize(Sender: TObject);
begin
  DPleaseDrinkExit.SetImgIndex(g_WMain2Images, 356);
end;
procedure TFrmDlg.DWPleaseDrinkInitialize(Sender: TObject);
begin
  DWPleaseDrink.SetImgIndex (g_WMain2Images, 340);
end;
procedure TFrmDlg.DPleaseDrinkCloseInitialize(Sender: TObject);
begin
  DPleaseDrinkClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DDrink1Initialize(Sender: TObject);
begin
  DDrink1.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink2Initialize(Sender: TObject);
begin
  DDrink2.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink3Initialize(Sender: TObject);
begin
  DDrink3.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink4Initialize(Sender: TObject);
begin
  DDrink4.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink5Initialize(Sender: TObject);
begin
  DDrink5.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DDrink6Initialize(Sender: TObject);
begin
  DDrink6.SetImgIndex(g_WMain2Images, 363);
end;
procedure TFrmDlg.DPlayDrinkCloseInitialize(Sender: TObject);
begin
  DPlayDrinkClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DPlayDrinkFistInitialize(Sender: TObject);
begin
  DPlayDrinkFist.SetImgIndex(g_WMain2Images, 348);
end;
procedure TFrmDlg.DPlayDrinkScissorsInitialize(Sender: TObject);
begin
  DPlayDrinkScissors.SetImgIndex(g_WMain2Images, 350);
end;
procedure TFrmDlg.DPlayDrinkClothInitialize(Sender: TObject);
begin
  DPlayDrinkCloth.SetImgIndex(g_WMain2Images, 352);
end;
procedure TFrmDlg.DPlayFistInitialize(Sender: TObject);
begin
  DPlayFist.SetImgIndex(g_WMain2Images, 358);
end;
procedure TFrmDlg.DPlayDrinkInitialize(Sender: TObject);
begin
  DPlayDrink.SetImgIndex (g_WMain2Images, 341);
end;
{$ENDREGION}
{$REGION '酿酒'}
procedure TFrmDlg.DMakeWineHelpInitialize(Sender: TObject);
begin
  DMakeWineHelp.SetImgIndex(g_WMain2Images, 590);
end;
procedure TFrmDlg.DMaterialMemoInitialize(Sender: TObject);
begin
  DMaterialMemo.SetImgIndex(g_WMain2Images, 590);
end;
procedure TFrmDlg.DStartMakeWineInitialize(Sender: TObject);
begin
  DStartMakeWine.SetImgIndex(g_WMain2Images, 590);
end;
procedure TFrmDlg.DMakeWineDeskCloseInitialize(Sender: TObject);
begin
  DMakeWineDeskClose.SetImgIndex (g_WMainImages, 371);
end;
procedure TFrmDlg.DWMakeWineDeskInitialize(Sender: TObject);
begin
  DWMakeWineDesk.SetImgIndex(g_WMain2Images, 584);
end;
{$ENDREGION}
{$REGION '恢复删除人物'}
procedure TFrmDlg.btnRecoverInitialize(Sender: TObject);
begin
  btnRecover.SetImgIndex(g_WMain3Images, 407);
end;
procedure TFrmDlg.btnRecvChrCloseInitialize(Sender: TObject);
begin
  btnRecvChrClose.SetImgIndex(g_WMainImages, 64);
end;
procedure TFrmDlg.dwRecoverChrInitialize(Sender: TObject);
begin
  dwRecoverChr.SetImgIndex(g_WMain3Images, 406);
end;
{$ENDREGION}
{$REGION '牛气'}
procedure TFrmDlg.DNQExpInitialize(Sender: TObject);
begin
  DNQExp.SetImgIndex(g_WMainImages,564);
end;
procedure TFrmDlg.DWNQStateInitialize(Sender: TObject);
begin
  DWNQState.SetImgIndex(g_WMainImages, 560);
end;
{$ENDREGION}
{$REGION '锻造金针'}
procedure TFrmDlg.DKimNeedleHelpInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleHelp.SetImgIndex(g_WMainImages, 776);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleMemoInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleMemo.SetImgIndex(g_WMainImages, 774);
{$IFEND}
end;
procedure TFrmDlg.DStartKimNeedleInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DStartKimNeedle.SetImgIndex(g_WMainImages, 770);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleLogoInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleLogo.SetImgIndex(g_WMainImages, 752);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleBarInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleBar.SetImgIndex(g_WMainImages, 756);
{$IFEND}
end;
procedure TFrmDlg.DKimNeedleCloseInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DKimNeedleClose.SetImgIndex(g_WMainImages, 371);
{$IFEND}
end;
procedure TFrmDlg.DWKimNeedleInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  DWKimNeedle.SetImgIndex(g_WMainImages, 751);
{$IFEND}
end;
{$ENDREGION}
{$REGION '珍珑宝箱'}
procedure TFrmDlg.DJLBoxBelt1Initialize(Sender: TObject);
begin
  DJLBoxBelt1.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt2Initialize(Sender: TObject);
begin
  DJLBoxBelt2.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt3Initialize(Sender: TObject);
begin
  DJLBoxBelt3.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt4Initialize(Sender: TObject);
begin
  DJLBoxBelt4.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt5Initialize(Sender: TObject);
begin
  DJLBoxBelt5.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt6Initialize(Sender: TObject);
begin
  DJLBoxBelt6.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt7Initialize(Sender: TObject);
begin
  DJLBoxBelt7.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLBoxBelt8Initialize(Sender: TObject);
begin
  DJLBoxBelt8.SetImgIndex(g_WMainImages, 661);
end;
procedure TFrmDlg.DJLChangeItemInitialize(Sender: TObject);
begin
  DJLChangeItem.SetImgIndex(g_WMainImages, 663);
end;
procedure TFrmDlg.DJLStartItemInitialize(Sender: TObject);
begin
  DJLStartItem.SetImgIndex(g_WMainImages, 663);
end;
procedure TFrmDlg.DJenniferLongBoxCloseInitialize(Sender: TObject);
begin
  DJenniferLongBoxClose.SetImgIndex(g_WMain2Images, 212);
end;
procedure TFrmDlg.DWJenniferLongBoxInitialize(Sender: TObject);
begin
end;
{$ENDREGION}
{$REGION '鉴定'}
procedure TFrmDlg.DBSignedItemInitialize(Sender: TObject);
begin
	with Sender as TDButton do
  SetImgIndex(g_WMainImages, 1614);
end;
procedure TFrmDlg.DBSignedChangeItemInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedChangeItem.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedMemo.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedChangeMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedChangeMemo.SetImgIndex(g_WMainImages, 1614);
{$IFEND}
end;
procedure TFrmDlg.DBSignedBelt1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedBelt1.SetImgIndex(g_WUI1Images, 922);
{$IFEND}
end;
procedure TFrmDlg.DBSignedBelt2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedBelt2.SetImgIndex(g_WUI1Images, 924);
{$IFEND}
end;
procedure TFrmDlg.DBSignedChangeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedChange.SetImgIndex(g_WUI1Images, 885);
{$IFEND}
end;
procedure TFrmDlg.DBOrdSignedInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBOrdSigned.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBHighSignedInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBHighSigned.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBSignedItemsCloseInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBSignedItemsClose.SetImgIndex(g_WMain2Images, 148);
{$IFEND}
end;
procedure TFrmDlg.DWSignedItemsInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWSignedItems.SetImgIndex(g_WUI1Images, 880);
{$IFEND}
end;

procedure TFrmDlg.DWFactionDlgInitialize(Sender: TObject);
begin
	DWFactionDlg.SetImgIndex(g_WUI1Images, 2230);
end;

procedure TFrmDlg.DWFactionDlgEditNoticeInitialize(Sender: TObject);
begin
	DWFactionDlgEditNotice.SetImgIndex(g_WMainImages, 1740);
end;

procedure TFrmDlg.DLFactionDlgEditNoticeOKInitialize(Sender: TObject);
begin
  with Sender as TDLabel do 
	SetImgIndex(g_WMainImages, 1614);
end;

procedure TFrmDlg.DWFactionAddDlgInitialize(Sender: TObject);
begin
	DWFactionAddDlg.SetImgIndex(g_WUI1Images, 2491);
end;

procedure TFrmDlg.DWFactionApplyManageInitialize(Sender: TObject);
begin
  DWFactionApplyManage.SetImgIndex(g_WUI1Images, 2490);
end;

procedure TFrmDlg.DWLingWUXinFaInitialize(Sender: TObject);
begin
  DWLingWUXinFa.SetImgIndex(g_WUI1Images, 2134);
end;
{$ENDREGION}
{$REGION '鉴定品评'}
procedure TFrmDlg.DBJudgeItemInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeItem.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeItemMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeItemMemo.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeBelt1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeBelt1.SetImgIndex(g_WUI1Images, 1344);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeStartInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeStart.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBJudgeItemsCloseInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBJudgeItemsClose.SetImgIndex(g_WMain2Images, 148);
{$IFEND}
end;
procedure TFrmDlg.DWJudgeItemsInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWJudgeItems.SetImgIndex(g_WUI1Images, 880);
{$IFEND}
end;
{$ENDREGION}
{$REGION '鉴定解读'}
procedure TFrmDlg.DBMakeSignedReadInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedRead.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedMakeInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedMake.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedReadMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedReadMemo.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedMakeMemoInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedMakeMemo.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedExp1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedExp1.SetImgIndex(g_WUI1Images, 894);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedExp2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedExp2.SetImgIndex(g_WUI1Images, 895);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedBelt1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedBelt1.SetImgIndex(g_WUI1Images, 923);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedBelt2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
   DBMakeSignedBelt2.SetImgIndex(g_WUI1Images, 925);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedBelt3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedBelt3.SetImgIndex(g_WUI1Images, 926);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedReadStartInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedReadStart.SetImgIndex(g_WUI1Images, 885);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve1.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve2.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve3.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedLeve4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedLeve4.SetImgIndex(g_WMainImages, 663);
{$IFEND}
end;
procedure TFrmDlg.DBMakeSignedCloseInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBMakeSignedClose.SetImgIndex(g_WMain2Images, 148);
{$IFEND}
end;
procedure TFrmDlg.DWMakeSignedInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWMakeSigned.SetImgIndex(g_WUI1Images, 880);
{$IFEND}
end;
{$ENDREGION}
{$REGION '内挂'}
procedure TFrmDlg.DWNewSdoAssistantInitialize(Sender: TObject);
begin
  DWNewSdoAssistant.SetImgIndex(g_qingqingImages, 4);
end;
procedure TFrmDlg.DNewSdoAssistantCloseInitialize(Sender: TObject);
begin
  DNewSdoAssistantClose.SetImgIndex(g_WMain2Images, 279);
end;
procedure TFrmDlg.DNewSdoBasicInitialize(Sender: TObject);
begin
  DNewSdoBasic.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNewSdoFilterItemInitialize(Sender: TObject);
begin
  DNewSdoFilterItem.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNewSdoProtectInitialize(Sender: TObject);
begin
  DNewSdoProtect.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DBNewSdoProtect1Initialize(Sender: TObject);
begin
  DBNewSdoProtect1.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DBNextTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do
    SetImgIndex(g_WUI1Images, 686);
{$IFEND}
end;

procedure TFrmDlg.DNewSdoSkillInitialize(Sender: TObject);
begin
  DNewSdoSkill.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNewSdoKeyInitialize(Sender: TObject);
begin
  DNewSdoKey.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DNedSdoHelpInitialize(Sender: TObject);
begin
  DNedSdoHelp.SetImgIndex(g_qingqingImages, 5);
end;
procedure TFrmDlg.DScrollBarProInitialize(Sender: TObject);
begin
  with DScrollBarPro do begin
    SetImgIndex(g_WMain2Images, 574);
    GHeight := 207;  //
    PrevImageIndex.Up := 292;
    PrevImageIndex.Down := 293;
    NextImageIndex.Up := 294;
    NextImageIndex.Down := 295;
    BarImageIndex.Up := 581;
    RemoveSize :=  DScrollBoxPro.GHeight;
    //MaxValue := 400;
  end;
end;

procedure TFrmDlg.DScrollBarFilterItemInitialize(Sender: TObject);
begin
  DScrollBarFilterItem.SetImgIndex(g_WMain2Images, 574);
  DScrollBarFilterItem.GHeight := 207;  //
  DScrollBarFilterItem.PrevImageIndex.Up := 292;
  DScrollBarFilterItem.PrevImageIndex.Down := 293;
  DScrollBarFilterItem.NextImageIndex.Up := 294;
  DScrollBarFilterItem.NextImageIndex.Down := 295;
  DScrollBarFilterItem.BarImageIndex.Up := 581;
  DScrollBarFilterItem.RemoveSize :=  DScrollBarFilterItem.ItemHeight * 8;
  DScrollBarFilterItem.MaxValue := DListViewFilterItem.Count * DScrollBarFilterItem.ItemHeight;
end;
procedure TFrmDlg.DScrollBarKeyInitialize(Sender: TObject);
begin
  with DScrollBarKey do begin
    SetImgIndex(g_WMain2Images, 574);
    GHeight := 207;  //
    PrevImageIndex.Up := 292;
    PrevImageIndex.Down := 293;
    NextImageIndex.Up := 294;
    NextImageIndex.Down := 295;
    BarImageIndex.Up := 581;
    RemoveSize :=  DScrollBoxKey.GHeight;
  end;
end;

procedure TFrmDlg.DListViewFilterItemInitialize(Sender: TObject);
var
  I: Integer;
  ShowItem: pTShowItem1;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
begin
  DListViewFilterItem.Clear;
  DListViewFilterItem.ColCount := 4;
  for I := 0 to g_ShowItemList.m_ShowItemList.Count - 1 do begin
    if g_ShowItemList.m_ShowItemList.Objects[I] = nil then Continue;
    ShowItem := pTShowItem1(g_ShowItemList.m_ShowItemList.Objects[I]);
    ListItem := DListViewFilterItem.Add;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Caption := ShowItem.sItemName;
    ViewItem.Data := ShowItem;
    ViewItem.Style := bsButton; //bsRadio;
    ViewItem.Color.Up.Color := clWhite;
    ViewItem.Color.Hot.Color := clRed; //clWhite;
    ViewItem.Color.Down.Color := clRed;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Style := bsCheckBox;
    ViewItem.ImageIndex.Up := 228;
    ViewItem.ImageIndex.Down := 229;
    ViewItem.Checked := ShowItem.boHintMsg;
    ViewItem.WLib := g_WMain2Images;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Style := bsCheckBox;
    ViewItem.ImageIndex.Up := 228;
    ViewItem.ImageIndex.Down := 229;
    ViewItem.Checked := ShowItem.boPickup;
    ViewItem.WLib := g_WMain2Images;

    ViewItem := ListItem.AddItem('', nil);
    ViewItem.Style := bsCheckBox;
    ViewItem.ImageIndex.Up := 228;
    ViewItem.ImageIndex.Down := 229;
    ViewItem.Checked := ShowItem.boShowName;
    ViewItem.WLib := g_WMain2Images;
  end;
end;
procedure TFrmDlg.DCBFilterItemStdModeInitialize(Sender: TObject);
begin
 {  with DCBFilterItemStdMode.Items do begin
     Add('(全部分类)');
     Add('其他类');
     Add('药品类');
     Add('服装类');
     Add('武器类');
     Add('首饰类');
     Add('饰品类');
     Add('服饰类');
   end;     }
   DCBFilterItemStdMode.ItemIndex := 0;    
end;
procedure TFrmDlg.DCheckSdoStartKeyInitialize(Sender: TObject);
begin
  DCheckSdoStartKey.SetImgIndex(g_qingqingImages, 7);
end;
procedure TFrmDlg.DSdoMemoScrollBarInitialize(Sender: TObject);
begin
  DSdoMemoScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DSdoMemoScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DSdoMemoScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;
procedure TFrmDlg.DSdoMemoInitialize(Sender: TObject);
begin
  DSdoMemo.DScroll := DSdoMemoScrollBar;
  DSdoMemo.DScroll.GTop := -6;
  DSdoMemo.DScroll.GLeft := 361;
  DSdoMemo.DScroll.GHeight := 206;
  DSdoMemo.DScroll.GWidth := 16;
  DSdoMemo.DScroll.Bar.GTop := 17;
  DSdoMemo.DScroll.BDown.GTop := 189;
  DSdoMemo.DScroll.BUp.GTop := 2;
  if FileExists(g_ParamDir+'\Data\explain2.dat') then begin
    try
      DSdoMemo.Lines.LoadFromFile(g_ParamDir+'\Data\explain2.dat');
    except
    end;
  end;
end;
{$ENDREGION}
{$REGION '其他'}
procedure TFrmDlg.DBSkillMemoCloseInitialize(Sender: TObject);
begin
  DBSkillMemoClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DWSkillMemoInitialize(Sender: TObject);
begin
  DWSkillMemo.SetImgIndex(g_WUI1Images, 760);
end;
procedure TFrmDlg.DBHeroSkillMemoCloseInitialize(Sender: TObject);
begin
  DBHeroSkillMemoClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DWHeroSkillMemoInitialize(Sender: TObject);
begin
  DWHeroSkillMemo.SetImgIndex(g_WUI1Images, 760);
end;
procedure TFrmDlg.DWPetLogInitialize(Sender: TObject);
begin
	if g_WUI1Images.Images[1300] <> nil then
		DWPetLog.SetImgIndex(g_WUI1Images, 1300);
end;
procedure TFrmDlg.DBPetLogCloseInitialize(Sender: TObject);
begin
  DBPetLogClose.SetImgIndex(g_WMain2Images, 148);
end;
procedure TFrmDlg.DBLingWUXinFaCloseInitialize(Sender: TObject);
begin
  with Sender as TDButton do
    SetImgIndex(g_WMainImages, 371);
end;
procedure TFrmDlg.DLLingWUXinFaInitialize(Sender: TObject);
begin
  with Sender as TDLabel do
    SetImgIndex(g_WUI1Images, 2144);
end;
procedure TFrmDlg.DLLingWuXinFaKeyPrevInitialize(Sender: TObject);
begin
  with Sender as TDLabel do
    SetImgIndex(g_WUI1Images, 2324);
end;
procedure TFrmDlg.DBXinFaNameNextInitialize(Sender: TObject);
begin
  DBXinFaNameNext.SetImgIndex(g_WUI1Images, 685);
end;
procedure TFrmDlg.DBXinFaNamePrevInitialize(Sender: TObject);
begin
  DBXinFaNamePrev.SetImgIndex(g_WUI1Images, 680);
end;
procedure TFrmDlg.DLXinFaChangeSelNameInitialize(Sender: TObject);
begin
  DLXinFaChangeSelName.SetImgIndex(g_WUI1Images, 2140);
end;
procedure TFrmDlg.DLXinFaMakeNameInitialize(Sender: TObject);
begin
  DLXinFaMakeName.SetImgIndex(g_WUI1Images, 2142);
end;
procedure TFrmDlg.DWLingWuXinFaKeyInitialize(Sender: TObject);
begin
  DWLingWuXinFaKey.SetImgIndex(g_WUI1Images, 2321);
end;
{$ENDREGION}
{$REGION '新人物状态栏'}
procedure TFrmDlg.DWNewStateWinInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2185);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2180);
{$IFEND}
end;
procedure TFrmDlg.DBNewStateWinPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
   DBNewStateWinPage.SetImgIndex(g_WUI1Images, 2190);
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBNewStateHeroPage.SetImgIndex(g_WUI1Images, 2240);
{$IFEND}
end;
procedure TFrmDlg.DBNewStateWinXFPageInitialize(Sender: TObject);
begin
  DBNewStateWinXFPage.SetImgIndex(g_WUI1Images, 2312);
end;
procedure TFrmDlg.DWNewStateWinPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2182);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinPageTab3Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2183);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinPageTab4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2186);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinPageTab5Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;
procedure TFrmDlg.DBNewLiquorProgressInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WMain2Images, 575);
{$IFEND}
end;
procedure TFrmDlg.DBNewNextTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 2209);
{$IFEND}
end;
procedure TFrmDlg.DBNewPrevTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 2206);
{$IFEND}
end;
procedure TFrmDlg.DBNewTitleManInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 670);
{$IFEND}
end;
procedure TFrmDlg.DBNewTitle1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do
    SetImgIndex(g_WUI1Images, 675);
{$IFEND}
end;
procedure TFrmDlg.DBNewStPageDownInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 2203);
{$IFEND}
end;
procedure TFrmDlg.DBNewStPageUpInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 2200);
{$IFEND}
end;
procedure TFrmDlg.DBNewStateWinNGPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  {$IF M2Version = 1}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 2240);
  {$ELSE}
  TDButton(Sender).SetImgIndex(g_WUI1Images, 2312);
  {$IFEND}
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinNGPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2234);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinNGPageTab2Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2184);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinNGPageTab4Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2239);
{$IFEND}
end;
procedure TFrmDlg.DBNewWinBatterRandomInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  TDButton(Sender).SetImgIndex(g_WMainImages, 901);
{$IFEND}
end;
procedure TFrmDlg.DBNewStateUserPageInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DBNewStateUserPage.SetImgIndex(g_WUI1Images, 2312);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinNGPageTab3Initialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TDWindow(Sender).SetImgIndex(g_WUI1Images, 2231);
{$IFEND}
end;
procedure TFrmDlg.DBNewWinPointPage1Initialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TDButton(Sender).SetImgIndex(g_WMainImages, 812);
{$IFEND}
end;
procedure TFrmDlg.DBNewWinPointPracticeInitialize(Sender: TObject);
begin
{$IF M2Version = 1}
  TDButton(Sender).SetImgIndex(g_WMainImages, 814);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinXFPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWNewStateWinXFPageTab1.SetImgIndex(g_WUI1Images, 2310);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateHeroInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWNewStateHero.SetImgIndex(g_WUI1Images, 2232);
{$IFEND}
end;
procedure TFrmDlg.DWNewStateHeroPageTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWNewStateHeroPageTab1.SetImgIndex(g_WUI1Images, 2247);
{$IFEND}
end;

procedure TFrmDlg.DMemoXinFaHintScrollBarInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with DMemoXinFaHintScrollBar do begin
    Bar.SetImgIndex(g_WUI1Images, 1610);
    BUp.SetImgIndex(g_WUI1Images, 1613);
    BDown.SetImgIndex(g_WUI1Images, 1616);
  end;
{$IFEND}
end;

procedure TFrmDlg.DMemoXinFaHintInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with DMemoXinFaHint do begin
    DScroll := DMemoXinFaHintScrollBar;
    DScroll.Bar.GTop := 13;
    DScroll.BDown.GTop := DScroll.GHeight-13;
    DScroll.BUp.GTop := 2;
  end;
{$IFEND}
end;
{$ENDREGION}
{$REGION '新底拦'}
procedure TFrmDlg.DWBottomLeftInitialize(Sender: TObject);
begin
  DWBottomLeft.SetImgIndex(g_WchantkkImages, 0);
end;

procedure TFrmDlg.DWBottomRightInitialize(Sender: TObject);
begin
  {$IF M2Version = 2} //1.76
  DWBottomRight.SetImgIndex(g_qingqingImages, 25);
  {$ELSE}
  DWBottomRight.SetImgIndex(g_WchantkkImages, 1);
  {$IFEND}
end;

{$ENDREGION}
{$ENDREGION}

{------------------------------------------------------------------------}
//打开人物信息状态
procedure TFrmDlg.OpenMyStatus;
begin
  with DStateWin do begin
    {$IF M2Version = 2} //1.76
    if not g_boShowNewItem then     
      SetImgIndex (g_WMainImages, 370) //人物状态
    else begin
      SetImgIndex (g_WMain2Images, 740) //人物状态
    end;
    {$IFEND}
  end;
  {$IF M2Version = 2}
  DSWBujuk.Visible := g_boShowNewItem;
  DSWBelt.Visible := g_boShowNewItem;
  DSWBoots.Visible := g_boShowNewItem;
  DSWCharm.Visible := g_boShowNewItem;
  DStateWin.Visible := not DStateWin.Visible;
  {$ELSE}
  {$IF M2Version = 0} //合击
  if g_ClientConf.boUses176StateWin then
    DStateWin.Visible := not DStateWin.Visible
  else
  {$ifend}
  if g_boNewNewStateWin then begin
    DWNewStateWin.Visible := not DWNewStateWin.Visible;
    if DWNewStateWin.Visible then begin
      if (DPNewStateWinTab.ActivePage = 0) and (DPNewStateWinPage.ActivePage = 4) then begin
        NewMagicBtnNotVisible;
      end;
    end;
    //Exit;
  end else begin
    DStateWin.Visible := not DStateWin.Visible;
    DScreen.AddChatBoardString ('由于你的客户端资源过旧，强化技能、心法将无法使用，请更新最新资源！',clLime, clBlack);
  end;
  {$IFEND}

  {$IF M2Version <> 2}
  if StateTab = 0 then
   PageChanged
  else InternalForcePageChanged;
  {$ELSE}
  PageChanged;
  {$IFEND}
end;

//显示玩加信息对话框
procedure TFrmDlg.OpenUserState (UserState: TUserStateInfo);
begin
  UserState1 := UserState;
  {$IF M2Version <> 2}
  {$IF M2Version = 0} //合击
  if g_ClientConf.boUses176StateWin then
    DUserState1.Visible := True
  else
  {$ifend}
  if g_boNewNewStateWin then begin
    m_btUserTitlePage := 0;
    DLNewStateUserName.UpColor := UserState1.NameColor;
    DLNewStateUserName.Caption := UserState1.UserName;
    DLNewStateUserGuildName.UpColor := clSilver;
    case g_boUserIsWho of
      1: DLNewStateUserGuildName.Caption := UserState1.GuildName+' 的英雄';
      2: DLNewStateUserGuildName.Caption := UserState1.GuildName+' 的分身';
    else DLNewStateUserGuildName.Caption := UserState1.GuildName + ' ' + UserState1.GuildRankName;
    end;
    DBNewStateUserPage.Visible := g_boUserIsWho = 0;
    DPNewStateUserPage.ActivePage := 0;
    DWNewStateUser.Visible := True;
  end else begin
  {$IFEND}
    DUserState1.Visible := True;
  {$IF M2Version <> 2}
    DScreen.AddChatBoardString ('由于你的客户端资源过旧，强化技能、心法将无法使用，请更新最新资源！',clLime, clBlack);
  end;
  {$IFEND}
end;

//显示/关闭物品对话框
procedure TFrmDlg.OpenItemBag;
begin
  DItemBag.Visible := not DItemBag.Visible;
  if DItemBag.Visible then ArrangeItemBag;
end;

//底部状态框
procedure TFrmDlg.ViewBottomBox (visible: Boolean);
begin
   //DBottom.Visible := visible;
  DWBottomLeft.Visible := Visible;
  DWBottomRight.Visible := Visible;
  DWBottomCenter.Visible := Visible;
  DChatMemo.Clear;
end;

// 取消英雄物品移动
procedure TFrmDlg.CancelHeroItemMoving;
var
   idx, n: integer;
begin
   if g_boHeroItemMoving then begin
      g_boHeroItemMoving := FALSE;
      idx := g_MovingHeroItem.Index;
      if idx < 0 then begin
        n := -(idx+1);
        if n in [0..14] then
          g_HeroItems[n] := g_MovingHeroItem.Item;
      end else
         if idx in [0..MAXBAGITEM-1] then begin
            if g_HeroItemArr[idx].S.Name = '' then begin
               g_HeroItemArr[idx] := g_MovingHeroItem.Item;
            end else begin
               AddHeroItemBag (g_MovingHeroItem.Item);
            end;
         end;
      g_MovingHeroItem.Item.S.Name := '';
   end;
   ArrangeHeroItemBag;
end;

// 取消物品移动
procedure TFrmDlg.CancelItemMoving;
var
   idx, n: integer;
begin
   if g_boItemMoving then begin
      g_boItemMoving := FALSE;
      idx := g_MovingItem.Index;
      if idx < 0 then begin
         if (idx <= -20) and (idx > -30) then begin
            AddDealItem (g_MovingItem.Item);
         end else begin
            n := -(idx+1);
            //showmessage(inttostr(n));
            if n in [0..14] then begin
               g_UseItems[n] := g_MovingItem.Item;
            end;
            if n in [40..42]then begin //淬炼物品返回 20080507
               g_ItemsUpItem[n-40] := g_MovingItem.Item;
            end;
            if n in [44..45] then begin  //请酒物品
               g_PDrinkItem[n-44] := g_MovingItem.Item;
            end;
            if n in [46..52] then begin  //普通酒物品
               g_WineItem[n-46] := g_MovingItem.Item;
            end;
            if n in [53..55] then begin  //药酒物品
               g_DrugWineItem[n-53] := g_MovingItem.Item;
            end;
            if n in [71..80] then begin  //摆摊物品
              g_ShopItems[n-71].Item := g_MovingItem.Item;
            end;

            if n in [81..90] then begin  //合成军鼓By TasNat at: 2012-11-08 12:23:56
              g_RefineDrumItem[n-81] := g_MovingItem.Item;
            end;

            {$IF M2Version <> 2}
            if n = 254 then begin //灵媒
              g_LingMeiBelt := g_MovingItem.Item;
            end;
            {$IFEND}
         end;
      end else
         if idx in [0..MAXBAGITEM-1] then begin
            if g_ItemArr[idx].Item.S.Name = '' then begin
               g_ItemArr[idx].Item := g_MovingItem.Item;
            end else begin
               AddItemBag (g_MovingItem.Item);
            end;
         end;
      g_MovingItem.Item.S.Name := '';
   end;
   ArrangeItemBag;
end;

//把移动的物品放下
procedure TFrmDlg.DropMovingItem;
begin
   if g_boItemMoving then begin
      g_boItemMoving := FALSE;
      if g_MovingItem.Item.S.Name <> '' then begin
         FrmMain.SendDropItem (g_MovingItem.Item.S.Name, g_MovingItem.Item.MakeIndex);
         AddDropItem (g_MovingItem.Item);
         g_MovingItem.Item.S.Name := '';
      end;
   end;
end;

procedure TFrmDlg.DropHeroMovingItem;//英雄往地上扔物品  2007.11.8
begin
   if g_boHeroItemMoving then begin
      g_boHeroItemMoving := FALSE;
      if g_MovingHeroItem.Item.S.Name <> '' then begin
         FrmMain.SendHeroDropItem (g_MovingHeroItem.Item.S.Name, g_MovingHeroItem.Item.MakeIndex);
         AddDropItem (g_MovingHeroItem.Item);
         g_MovingHeroItem.Item.S.Name := '';
      end;
   end;
end;

//打开属性调整对话框
procedure TFrmDlg.OpenAdjustAbility;
begin
   DAdjustAbility.GLeft := 0;
   DAdjustAbility.GTop := 0;
   g_nSaveBonusPoint := g_nBonusPoint;
   FillChar (g_BonusAbilChg, sizeof(TNakedAbility), #0);
   DAdjustAbility.Visible := TRUE;
end;

procedure TFrmDlg.DBackgroundBackgroundClick(Sender: TObject);
var
   dropgold: integer;
   valstr: string;
begin
   if g_boItemMoving then begin
      DBackground.WantReturn := TRUE;
      if g_MovingItem.Item.S.Name = g_sGoldName{'金币'} then begin
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name := '';
         //倔付甫 滚副 扒瘤 拱绢夯促.
         DialogSize := 1;
         DMessageDlg ('请输入 ' +g_sGoldName+ ' 数量?', [mbOk, mbAbort]);
         GetValidStrVal (DlgEditText, valstr, [' ']);
         dropgold := Str_ToInt (valstr, 0);
         //
         FrmMain.SendDropGold (dropgold);
      end;
      if g_MovingItem.Index >= 0 then //酒捞袍 啊规俊辑 滚赴巴父..
         DropMovingItem;
   end;
   if g_boHeroItemMoving then begin
      DBackground.WantReturn := TRUE;
      if g_MovingHeroItem.Index >= 0 then //酒捞袍 啊规俊辑 滚赴巴父..
      DropHeroMovingItem;
   end;
end;

procedure TFrmDlg.DBackgroundMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   if g_boItemMoving then begin
     DBackground.WantReturn := TRUE;
   end;
end;

{------------------------------------------------------------------------}
////显示通用对话框
//mbRetry: 元宝购买
//mbIgnore: 荣耀点购买
function  TFrmDlg.DMessageDlg (msgstr: string; DlgButtons: TMsgDlgButtons): TModalResult;
const
   XBase = 324;
var
  I: Integer;
   lx, ly: integer;
   d: TDirectDrawSurface;
  procedure ShowDice();
  var
    I: Integer;
    bo05:Boolean;
  begin
    if m_nDiceCount = 1 then begin
      if m_Dice[0].n67C < 20 then begin
        if GetTickCount - m_Dice[0].dwPlayTick > 100 then begin
          if m_Dice[0].n67C div 5 = 4 then begin
            m_Dice[0].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[0].nPlayPoint:=m_Dice[0].n67C div 5 + 8;
          end;
          m_Dice[0].dwPlayTick:=GetTickCount();
          Inc(m_Dice[0].n67C);
        end;
        exit;
      end;//00491461
      m_Dice[0].nPlayPoint:= m_Dice[0].nDicePoint;
      if GetTickCount - m_Dice[0].dwPlayTick > 1500 then begin
        DMsgDlg.Visible:=False;
      end;
      exit;
    end;//004914AD

    bo05:=True;
    if m_nDiceCount > 0 then //20080629
    for I := 0 to m_nDiceCount - 1 do begin
      if m_Dice[I].n67C < m_Dice[I].n680 then begin
        if GetTickCount - m_Dice[I].dwPlayTick > 100 then begin
          if m_Dice[I].n67C div 5 = 4 then begin
            m_Dice[I].nPlayPoint:=Random(6) + 1;
          end else begin
            m_Dice[I].nPlayPoint:=m_Dice[I].n67C div 5 + 8;
          end;
          m_Dice[I].dwPlayTick:=GetTickCount();
          Inc(m_Dice[I].n67C);
        end;
        bo05:=False;
      end else begin  //004915E4
        m_Dice[I].nPlayPoint:= m_Dice[I].nDicePoint;
        if GetTickCount - m_Dice[I].dwPlayTick < 2000 then begin
          bo05:=False;
        end;
      end;
    end; //for
    if bo05 then begin
      DMsgDlg.Visible:=False;
    end;

  end;
begin

   lx := XBase;
   ly := 126;
   case DialogSize of
      0:  //小对话框(转骰子)
         begin
            d := g_WMainImages.Images[381];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 381);
               DMsgDlg.GLeft := (SCREENWIDTH - d.Width) div 2;
               DMsgDlg.GTop := (SCREENHEIGHT - d.Height) div 2;
               msglx := 39;
               msgly := 38;
               lx := 90;
               ly := 36;
            end;
         end;
      1:  //大对话框（横）
         begin
            d := g_WMainImages.Images[360];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 360);
               DMsgDlg.GLeft := (SCREENWIDTH - d.Width) div 2;
               DMsgDlg.GTop := (SCREENHEIGHT - d.Height) div 2;
               msglx := 39;
               msgly := 38;
               lx := XBase;
               ly := 126;
            end;
         end;
      2:  //大对话框（竖）
         begin
            d := g_WMainImages.Images[380];
            if d <> nil then begin
               DMsgDlg.SetImgIndex (g_WMainImages, 380);
               DMsgDlg.GLeft := (SCREENWIDTH - d.Width) div 2;
               DMsgDlg.GTop := (SCREENHEIGHT - d.Height) div 2;
               msglx := 23;
               msgly := 20;
               lx := 90;
               ly := 305;
            end;
         end;
   end;
   MsgText := msgstr;
   ViewDlgEdit := FALSE;  //编辑框不可见
   DMsgDlg.Floating := TRUE; //允许鼠标移动
   DMsgDlgOk.Visible := FALSE;
   DMsgDlgYes.Visible := FALSE;
   DMsgDlgCancel.Visible := FALSE;
   DMsgDlgNo.Visible := FALSE;
   DMsgDlgGamePointBuy.Visible := False;
   DMsgDlgGameGoldBuy.Visible := False;
   DMsgDlg.GLeft := (SCREENWIDTH - DMsgDlg.GWidth) div 2;
   DMsgDlg.GTop := (SCREENHEIGHT - DMsgDlg.GHeight) div 2;
   //调整按钮
   if m_nDiceCount > 0 then //20080629   //色子
   for I := 0 to m_nDiceCount - 1 do begin
     m_Dice[I].n67C:=0;
     m_Dice[I].n680:=Random(m_nDiceCount + 2) * 5 + 10;
     m_Dice[I].nPlayPoint:=1;
     m_Dice[I].dwPlayTick:=GetTickCount();
   end;

   if mbCancel in DlgButtons then begin
      DMsgDlgCancel.GLeft := lx;
      DMsgDlgCancel.GTop := ly;
      DMsgDlgCancel.Visible := TRUE;
      lx := lx - 110;
   end;
   if mbNo in DlgButtons then begin
      DMsgDlgNo.GLeft := lx;
      DMsgDlgNo.GTop := ly;
      DMsgDlgNo.Visible := TRUE;
      lx := lx - 110;
   end;
   if mbYes in DlgButtons then begin
      DMsgDlgYes.GLeft := lx;
      DMsgDlgYes.GTop := ly;
      DMsgDlgYes.Visible := TRUE;
      lx := lx - 110;
   end;
   if (mbOk in DlgButtons) or (lx = XBase) then begin    //只有确定
      DMsgDlgOk.GLeft := lx;
      DMsgDlgOk.GTop := ly;
      DMsgDlgOk.Visible := TRUE;
      lx := lx - 110;
   end;
   if (mbIgnore in DlgButtons) then begin //荣耀点购买
      DMsgDlgGamePointBuy.GLeft := lx;
      DMsgDlgGamePointBuy.GTop := ly;
      DMsgDlgGamePointBuy.Visible := TRUE;
      lx := lx - 110;
   end;
   if (mbRetry in DlgButtons) then begin //元宝购买
      DMsgDlgGameGoldBuy.GLeft := lx;
      DMsgDlgGameGoldBuy.GTop := ly;
      DMsgDlgGameGoldBuy.Visible := TRUE;
      lx := lx - 110;
   end;
   HideAllControls;
   DMsgDlg.ShowModal;
   if mbAbort in DlgButtons then begin
      ViewDlgEdit := TRUE; //显示编辑框.
      DMsgDlg.Floating := FALSE;
      with EdDlgEdit do begin
         Text := '';
         Width := DMsgDlg.GWidth - 70;
         Left := (SCREENWIDTH - EdDlgEdit.Width) div 2;
         Top  := (SCREENHEIGHT - EdDlgEdit.Height) div 2 - 10;
      end;
   end;
   Result := mrOk;

   while TRUE do begin
      if not DMsgDlg.Visible then break;
      //FrmMain.DXTimerTimer (self, 0);
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;

      if m_nDiceCount > 0 then begin
        m_boPlayDice:=True;
        if m_nDiceCount > 0 then //20080629
        for I := 0 to m_nDiceCount - 1 do begin
          m_Dice[I].nX:=((DMsgDlg.GWidth div 2 + 6) - ((m_nDiceCount * 32 + m_nDiceCount) div 2)) + (I * 32 + I);
          m_Dice[I].nY:=DMsgDlg.GHeight div 2 - 14;
        end;

        ShowDice();

      end;

      if Application.Terminated then exit;
   end;

   EdDlgEdit.Visible := FALSE;
   RestoreHideControls;
   DlgEditText := EdDlgEdit.Text;
   if PlayScene.EdChat.Visible then PlayScene.EdChat.SetFocus;
   ViewDlgEdit := FALSE;
   Result := DMsgDlg.DialogResult;
   DialogSize := 1; //扁夯惑怕
   m_nDiceCount:=0;
   m_boPlayDice:=False;
end;

procedure TFrmDlg.DMsgDlgOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMsgDlgOk then DMsgDlg.DialogResult := mrOk;
   if Sender = DMsgDlgYes then DMsgDlg.DialogResult := mrYes;
   if Sender = DMsgDlgCancel then DMsgDlg.DialogResult := mrCancel;
   if Sender = DMsgDlgNo then DMsgDlg.DialogResult := mrNo;
   if Sender = DMsgDlgGameGoldBuy then DMsgDlg.DialogResult := mrRetry;
   if Sender = DMsgDlgGamePointBuy then DMsgDlg.DialogResult := mrIgnore;
   DMsgDlg.Visible := FALSE;
end;

procedure TFrmDlg.DMsgDlgKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = 13 then begin
      if DMsgDlgOk.Visible and not (DMsgDlgYes.Visible {or DMsgDlgCancel.Visible 20080713} or DMsgDlgNo.Visible) then begin
         DMsgDlg.DialogResult := mrOk;
         DMsgDlg.Visible := FALSE;
      end;
      if DMsgDlgYes.Visible and not (DMsgDlgOk.Visible or DMsgDlgCancel.Visible{ or DMsgDlgNo.Visible 20091118}) then begin
         DMsgDlg.DialogResult := mrYes;
         DMsgDlg.Visible := FALSE;
      end;
   end;
   if Key = 27 then begin
      if DMsgDlgCancel.Visible then begin
         DMsgDlg.DialogResult := mrCancel;
         DMsgDlg.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.DMsgDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DMsgDlgOkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  tStr:String;
  //{$if Version <> 1}
  nTextWidth, nTextHeight: Integer;
  //{$IFEND}
  //nStatus:Integer;
begin
//try
  d:=nil; //
   //nStatus:=-1;
   with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if not Downed then
          d := WLib.Images[FaceIndex]
        else d := WLib.Images[FaceIndex+1];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

      if (Name = 'DSServer1') and (g_ServerList.Count >= 1) then begin
        tStr:=g_ServerList.Strings[0];
        //nStatus:=Integer(g_ServerList.Objects[0]);
      end;
      if (Name = 'DSServer2') and (g_ServerList.Count >= 2) then begin
        tStr:=g_ServerList.Strings[1];
        //nStatus:=Integer(g_ServerList.Objects[1]);
      end;
      if (Name = 'DSServer3') and (g_ServerList.Count >= 3) then begin
        tStr:=g_ServerList.Strings[2];
        //nStatus:=Integer(g_ServerList.Objects[2]);
      end;
      if (Name = 'DSServer4') and (g_ServerList.Count >= 4) then begin
        tStr:=g_ServerList.Strings[3];
        //nStatus:=Integer(g_ServerList.Objects[3]);
      end;
      if (Name = 'DSServer5') and (g_ServerList.Count >= 5) then begin
        tStr:=g_ServerList.Strings[4];
        //nStatus:=Integer(g_ServerList.Objects[4]);
      end;
      if (Name = 'DSServer6') and (g_ServerList.Count >= 6) then begin
        tStr:=g_ServerList.Strings[5];
        //nStatus:=Integer(g_ServerList.Objects[5]);
      end;
      if d <> nil then begin
        Color:=$0093F4F2;
        frmMain.Canvas.Font.Size := 12;
        frmMain.Canvas.Font.Style:=[fsBold];
        nTextWidth := frmMain.Canvas.TextExtent(tStr).cx;
        nTextHeight := frmMain.Canvas.TextExtent(tStr).cy;
        if TDButton(Sender).Downed then begin
          dsurface.BoldTextOut (SurfaceX(GLeft + (d.Width - nTextWidth) div 2) + 2, SurfaceY(GTop + (d.Height -nTextHeight) div 2) + 2, Color, clBlack, tStr);
        end else begin
          dsurface.BoldTextOut (SurfaceX(GLeft + (d.Width - nTextWidth) div 2), SurfaceY(GTop + (d.Height -nTextHeight) div 2), Color, clBlack, tStr);
        end;
        frmMain.Canvas.Font.Style:=[];
        frmMain.Canvas.Font.Size :=9;
      end;
   end;
{except
  on e: Exception do begin
    ShowMessage(E.Message);
  end;
end; }
end;

procedure TFrmDlg.DMsgDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I: Integer;
  d: TDirectDrawSurface;
  ly: integer;
  str, data: string;
  nX,nY:Integer;
begin
   with Sender as TDWindow do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

      if m_boPlayDice then begin
        if m_nDiceCount > 0 then //20080629
        for I := 0 to m_nDiceCount - 1 do begin
          d:=frmMain.GetBagItemImg(m_Dice[I].nPlayPoint + 376 - 1,nX,nY);
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft) + m_Dice[I].nX + nX - 14, SurfaceY(GTop) + m_Dice[I].nY + nY + 38, d.ClientRect, d, TRUE);
          end;
        end;
      end;
      ly := msgly;
      str := MsgText;
      while TRUE do begin
         if str = '' then break;
         str := GetValidStr3 (str, data, ['\']);
         if data <> '' then
            dsurface.BoldTextOut (SurfaceX(GLeft+msglx), SurfaceY(GTop+ly), clWhite, clBlack, data);
         ly := ly + 14;
      end;
   end;
   if ViewDlgEdit then begin
      if not EdDlgEdit.Visible then begin
         EdDlgEdit.Visible := TRUE;
         EdDlgEdit.SetFocus;
      end;
   end;
end;

{------------------------------------------------------------------------}
//肺弊牢 芒
procedure TFrmDlg.DLoginNewDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if TDButton(Sender).Downed then begin
         if WLib <> nil then begin //20080701
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         end;
      end;
   end;
end;

procedure TFrmDlg.DLoginNewClick(Sender: TObject; X, Y: Integer);
begin
  LoginScene.NewClick;
end;

procedure TFrmDlg.DLoginOkClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.OkClick;
end;

procedure TFrmDlg.DLoginCloseClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.Close;
end;

procedure TFrmDlg.DLoginChgPwClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.ChgPwClick;
end;



procedure TFrmDlg.DLoginNewClickSound(Sender: TObject;
  Clicksound: TClickSound);
begin
   case Clicksound of
      csNorm:  PlaySound (s_norm_button_click);
      csStone: PlaySound (s_rock_button_click);
      csGlass: PlaySound (s_glass_button_click);
   end;
end;

{------------------------------------------------------------------------}
//显示选择服务器对话框
procedure TFrmDlg.ShowSelectServerDlg;
begin
   case g_ServerList.Count of
     1:begin
         DSServer1.Visible:=True;
         DSServer1.GTop:=204;
         DSServer2.Visible:=False;
         DSServer3.Visible:=False;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     2:begin
         DSServer1.Visible:=True;
         DSServer1.GTop:=190;
         DSServer2.Visible:=True;
         DSServer2.GTop:=235;
         DSServer3.Visible:=False;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     3:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=False;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     4:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=False;
         DSServer6.Visible:=False;
       end;
     5:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=False;
       end;
     6:begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=True;
       end;
     else begin
         DSServer1.Visible:=True;
         DSServer2.Visible:=True;
         DSServer3.Visible:=True;
         DSServer4.Visible:=True;
         DSServer5.Visible:=True;
         DSServer6.Visible:=True;
       end;
   end;
   DSelServerDlg.Visible:=TRUE;
end;
procedure TFrmDlg.DSServer1Click(Sender: TObject; X, Y: Integer);
var
  svname: string;
begin
   svname := '';
   if Sender = DSServer1 then begin
     svname:=g_ServerList.Strings[0];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer2 then begin
     svname:=g_ServerList.Strings[1];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer3 then begin
     svname:=g_ServerList.Strings[2];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer4 then begin
     svname:=g_ServerList.Strings[3];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer5 then begin
     svname:=g_ServerList.Strings[4];
     g_sServerMiniName:=svname;
   end;
   if Sender = DSServer6 then begin 
     svname:=g_ServerList.Strings[5];
     g_sServerMiniName:=svname;
   end;
   if svname <> '' then begin
      FrmMain.SendSelectServer (svname);
      DSelServerDlg.Visible := FALSE;
      g_sServerName := svname;
   end;
end;




procedure TFrmDlg.DSSrvCloseClick(Sender: TObject; X, Y: Integer);
begin
   DSelServerDlg.Visible := FALSE;
   FrmMain.Close;
end;
{------------------------------------------------------------------------}
//新帐号
procedure TFrmDlg.DNewAccountOkClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewAccountOk;
end;

procedure TFrmDlg.DNewAccountCloseClick(Sender: TObject; X, Y: Integer);
begin
   LoginScene.NewAccountClose;
end;

procedure TFrmDlg.DNewAccountDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   i: integer;
begin
   with dsurface.Canvas do begin
      with DNewAccount do begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
      if NAHelps.Count > 0 then //20080629
      for i:=0 to NAHelps.Count-1 do dsurface.TextOut(476, 186 + i*14, clSilver, NAHelps[I]);
      dsurface.BoldTextOut (362, 121, clWhite, clBlack, NewAccountTitle);
   end;
end;


{------------------------------------------------------------------------}
////Chg pw 冠胶

procedure TFrmDlg.DChgpwOkClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DChgpwOk then LoginScene.ChgpwOk;
   if Sender = DChgpwCancel then LoginScene.ChgpwCancel;
end;



{------------------------------------------------------------------------}
//某腐磐 急琶

procedure TFrmDlg.DscSelect1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed and (WLib <> nil) then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (GLeft, GTop, d.ClientRect, d, TRUE);
      end;
   end;
end;



procedure TFrmDlg.DscSelect1Click(Sender: TObject; X, Y: Integer);
begin
   if Sender = DscSelect1 then SelectChrScene.SelChrSelect1Click;
   if Sender = DscSelect2 then SelectChrScene.SelChrSelect2Click;
   if Sender = DscStart then if DscStart.Enabled then SelectChrScene.SelChrStartClick;
   if Sender = DscNewChr then SelectChrScene.SelChrNewChrClick;
   if Sender = DscEraseChr then SelectChrScene.SelChrEraseChrClick;
   if (Sender = DscCredits) and not (dwRecoverChr.Visible) then SelectChrScene.SelChrCreditsClick;
   if Sender = DscExit then SelectChrScene.SelChrExitClick;
end;
{------------------------------------------------------------------------}
//货 某腐磐 父甸扁 芒

procedure TFrmDlg.DccCloseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
         if WLib <> nil then begin //20080701
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
         end;
      end else begin
         d := nil;
         if Sender = DccWarrior then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Job = 0 then d := WLib.Images[55];
         end;
         if Sender = DccWizzard then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Job = 1 then d := WLib.Images[56];
         end;
         if Sender = DccMonk then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Job = 2 then d := WLib.Images[57];
         end;
         if Sender = DccMale then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Sex = 0 then d := WLib.Images[58];
         end;
         if Sender = DccFemale then begin
            with SelectChrScene do
               if ChrArr[NewIndex].UserChr.Sex = 1 then d := WLib.Images[59];
         end;
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DccCloseClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DccClose then SelectChrScene.SelChrNewClose;
   if Sender = DccWarrior then SelectChrScene.SelChrNewJob (0);
   if Sender = DccWizzard then SelectChrScene.SelChrNewJob (1);
   if Sender = DccMonk then SelectChrScene.SelChrNewJob (2);
   if Sender = DccReserved then SelectChrScene.SelChrNewJob (3);
   if Sender = DccMale then SelectChrScene.SelChrNewm_btSex (0);
   if Sender = DccFemale then SelectChrScene.SelChrNewm_btSex (1);
   if Sender = DccLeftHair then SelectChrScene.SelChrNewPrevHair;
   if Sender = DccRightHair then SelectChrScene.SelChrNewNextHair;
   if Sender = DccOk then SelectChrScene.SelChrNewOk;
end;

//人物信息栏绘画 2007.10.20...
procedure TFrmDlg.DStateWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, l, m, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv: integer;
  pm: PTClientMagic;
  d: TDirectDrawSurface;
  old, keyimg: integer;
  rc: TRect;
  {$IF M2Version = 2}
  iname, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: Integer;
  {$IFEND}
  MagColor: TColor;
  wm: TWMImages;
begin
  if g_MySelf = nil then exit;
  {$IF M2Version <> 2}
  DLiquorProgress.Visible := False;
  DBJDSee.Visible := False;
  {$IFEND}
  HBExp.Visible := False;
  JQExp.Visible := False;
  with DStateWin do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    {$IF M2Version <> 2}
    if not g_boIsInternalForce then begin
      if not g_boNewStateWin then begin
        d:=g_WUiMainImages.Images[29];
        if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end else begin
      if StateTab = 0 then begin
        d := g_WMain2Images.Images[744];
      end else begin
        d := g_WMain2Images.Images[745];
      end;
      if d <> nil then dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+31, d.ClientRect, d, TRUE);
    end;
    //侧边导航
    if DStateSsas.Visible then begin
      with DStateSsas do begin
        if WLib <> nil then begin //20080701
          if StateTab = 0 then begin
            d := WLib.Images[FaceIndex + StatePage];
          end else begin
            d := WLib.Images[FaceIndex + 10 + InternalForcePage];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if StateTab = 0 then begin
          frmMain.Canvas.Font.Style:=[fsBold];
          if StatePage = 0 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $00A8D4E8, clBlack, '装');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+21, $00A8D4E8, clBlack, '备');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $00708CA0, clBlack, '装');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+21, $00708CA0, clBlack, '备');
          end;
          if StatePage = 1 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+56, $00A8D4E8, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+69, $00A8D4E8, clBlack, '态');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+56, $00708CA0, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+69, $00708CA0, clBlack, '态');
          end;
          if StatePage = 2 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+102, $00A8D4E8, clBlack, '属');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+115, $00A8D4E8, clBlack, '性');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+102, $00708CA0, clBlack, '属');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+115, $00708CA0, clBlack, '性');
          end;
          if StatePage = 3 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+146, $00A8D4E8, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+159, $00A8D4E8, clBlack, '能');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+146, $00708CA0, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+159, $00708CA0, clBlack, '能');
          end;
          if StatePage = 4 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+190, $00A8D4E8, clBlack, '出');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+203, $00A8D4E8, clBlack, '战');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+190, $00708CA0, clBlack, '出');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+203, $00708CA0, clBlack, '战');
          end;
          frmMain.Canvas.Font.Style:=[];
        end else begin
          frmMain.Canvas.Font.Style:=[fsBold];
          if InternalForcePage = 0 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $0048A4E8, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+22, $0048A4E8, clBlack, '态');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $006098B8, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+22, $006098B8, clBlack, '态');
          end;
          if InternalForcePage = 1 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+58, $0048A4E8, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+72, $0048A4E8, clBlack, '能');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+58, $006098B8, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+72, $006098B8, clBlack, '能');
          end;
          {$IF M2Version = 1}
          if InternalForcePage = 2 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+105, $0048A4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+119, $0048A4E8, clBlack, '络');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+105, $006098B8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+119, $006098B8, clBlack, '络');
          end;
          if InternalForcePage = 3 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+151, $0048A4E8, clBlack, '连');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+165, $0048A4E8, clBlack, '击');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+151, $006098B8, clBlack, '连');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+165, $006098B8, clBlack, '击');
          end;
          {$IFEND}
          frmMain.Canvas.Font.Style:=[];
        end;
      end;
    end;
    {$IFEND}
    case StateTab of
      0: begin
        case StatePage of
          0: begin //自己装备  2007.10.16 
            {$IF M2Version = 2} //1.76
            if not g_boShowNewItem then begin
              pgidx := 376;              //无4格
              if g_MySelf <> nil then
                 if g_MySelf.m_btSex = 1 then pgidx := 377;  //女4格  2007.10.16 
              bbx := GLeft + 38;
              bby := GTop + 52;
              d := g_WMainImages.Images[pgidx];
            end else
            {$IFEND}
            begin
              pgidx := 29;              //男4格  2007.10.16 
              if g_MySelf <> nil then
                 if g_MySelf.m_btSex = 1 then pgidx := 30;  //女4格  2007.10.16
              bbx := GLeft + 38;
              bby := GTop + 52;
              d := g_WMain3Images.Images[pgidx];
            end;

            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx - 7;
            bby := bby + 44;
            if g_UseItems[U_DRESS].S.Name <> '' then begin //衣服
              idx := g_UseItems[U_DRESS].S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                //Modified By TasNat at: 2012-11-22 10:47:29
                with GetEffecItemList(g_UseItems[U_DRESS].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawUseItems[U_DRESS].dwDrawTick >= 150 then begin
                      g_DrawUseItems[U_DRESS].dwDrawTick := GetTickCount;
                      Inc(g_DrawUseItems[U_DRESS].nIndex);
                      if g_DrawUseItems[U_DRESS].nIndex > btShapeCount-1 then g_DrawUseItems[U_DRESS].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_DRESS].nIndex, ax, ay);
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end;
           //自己人物发型  2007.10.16 
            idx := 1799; 
            if g_MySelf.m_btSex = 1 then  idx := 2399;
            if g_MySelf.m_btSex = 0 then begin  //男
              if g_MySelf.m_btHair <> 0 then begin
                if idx > 0 then begin
                  d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                  if d <> nil then
                    dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end;
            end else if g_MySelf.m_btHair <> 1 then begin
              if idx > 0 then begin
                d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
              end;
            end else begin
              d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
            if g_UseItems[U_WEAPON].S.Name <> '' then begin
              idx := g_UseItems[U_WEAPON].S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);

                with GetEffecItemList(g_UseItems[U_WEAPON].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawUseItems[U_WEAPON].dwDrawTick >= 150 then begin
                      g_DrawUseItems[U_WEAPON].dwDrawTick := GetTickCount;
                      Inc(g_DrawUseItems[U_WEAPON].nIndex);
                      if g_DrawUseItems[U_WEAPON].nIndex > btShapeCount-1 then g_DrawUseItems[U_WEAPON].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_WEAPON].nIndex, ax, ay);
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end;
            //斗笠 20080417
            if g_UseItems[U_ZHULI].S.Name <> '' then begin
              if g_UseItems[U_ZHULI].S.Shape <> 2  then begin
                idx := g_UseItems[U_ZHULI].S.Looks;
                if idx >= 0 then begin
                  d := FrmMain.GetWStateImg(idx,ax,ay);
                  if d <> nil then
                     dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end else begin     //黑巾
                if (g_UseItems[U_HELMET].S.Looks = 103) or (g_UseItems[U_HELMET].S.Looks = 106) or (g_UseItems[U_HELMET].S.Looks = 344) or (g_UseItems[U_HELMET].S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
                  if g_UseItems[U_HELMET].S.Name <> '' then begin //头盔
                    idx := g_UseItems[U_HELMET].S.Looks;
                    if idx >= 0 then begin
                      d := FrmMain.GetWStateImg(idx,ax,ay);
                      if d <> nil then
                        dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                  idx := g_UseItems[U_ZHULI].S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                end else begin
                  idx := g_UseItems[U_ZHULI].S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                    dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                  if g_UseItems[U_HELMET].S.Name <> '' then begin //头盔
                    idx := g_UseItems[U_HELMET].S.Looks;
                    if idx >= 0 then begin
                      d := FrmMain.GetWStateImg(idx,ax,ay);
                      if d <> nil then
                         dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                end;

              end;
              if g_UseItems[U_HELMET].S.Name <> '' then begin //金牛头盔
                //Modified By TasNat at: 2012-11-22 10:47:29
                with GetEffecItemList(g_UseItems[U_HELMET].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawUseItems[U_HELMET].dwDrawTick >= 150 then begin
                      g_DrawUseItems[U_HELMET].dwDrawTick := GetTickCount;
                      Inc(g_DrawUseItems[U_HELMET].nIndex);
                      if g_DrawUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems[U_HELMET].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_HELMET].nIndex, ax, ay);
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end else
            if g_UseItems[U_HELMET].S.Name <> '' then begin //头盔
              idx := g_UseItems[U_HELMET].S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                //Modified By TasNat at: 2012-11-22 10:47:29
                with GetEffecItemList(g_UseItems[U_HELMET].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawUseItems[U_HELMET].dwDrawTick >= 150 then begin
                      g_DrawUseItems[U_HELMET].dwDrawTick := GetTickCount;
                      Inc(g_DrawUseItems[U_HELMET].nIndex);
                      if g_DrawUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems[U_HELMET].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_HELMET].nIndex, ax, ay);
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end;
          end;
          1: begin //状态值
            l := GLeft + 110; //66;
            m := GTop + 97;
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+0), clWhite, clBlack, IntToStr(LoWord(g_MySelf.m_Abil.AC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.AC)));
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+20), clWhite, clBlack, IntToStr(LoWord(g_MySelf.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MAC)));
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+40), clWhite, clBlack, IntToStr(LoWord(g_MySelf.m_Abil.DC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.DC)));
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+60), clWhite, clBlack, IntToStr(LoWord(g_MySelf.m_Abil.MC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MC)));
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+80), clWhite, clBlack, IntToStr(LoWord(g_MySelf.m_Abil.SC)) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.SC)));
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+100), clWhite, clBlack, IntToStr(g_MySelf.m_Abil.HP) + '/' + IntToStr(g_MySelf.m_Abil.MaxHP));
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+120), clWhite, clBlack, IntToStr(g_MySelf.m_Abil.MP) + '/' + IntToStr(g_MySelf.m_Abil.MaxMP));
            {$IF M2Version <> 2}
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+140), clWhite, clBlack, IntToStr(g_MySelf.m_Abil.MedicineValue) + '/' + IntToStr(g_MySelf.m_Abil.MaxMedicineValue));//20080624
            dsurface.BoldTextOut(SurfaceX(l), SurfaceY(m+160), clWhite, clBlack, IntToStr(g_MySelf.m_Abil.MaxAlcohol));
            DLiquorProgress.Visible := True;
            {$IFEND}
          end;
          2: begin //人物属性数值
            bbx := GLeft + 38;
            bby := GTop + 52;
            {$IF M2Version = 2} //1.76
            if not g_boShowNewItem then
              d := g_WMainImages.Images[382]
            else
              d := g_WMain3Images.Images[32];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);

            bbx := bbx + 19;
            bby := bby + 2;
            mmx := bbx + 84;
            dsurface.BoldTextOut (bbx, bby, clSilver, clBlack, '当前经验');
            dsurface.BoldTextOut (mmx, bby, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.nExp));
            dsurface.BoldTextOut (bbx, bby+13*1, clSilver, clBlack, '升级经验');
            dsurface.BoldTextOut (mmx, bby+13*1, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.nMaxExp));
            dsurface.BoldTextOut (bbx, bby+13*2, clSilver, clBlack, '背包重量');
            if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
              dsurface.BoldTextOut (mmx, bby+13*2, clRed, clBlack, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight))
            else
            dsurface.BoldTextOut (mmx, bby+13*2, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight));
            dsurface.BoldTextOut (bbx, bby+13*3, clSilver, clBlack, '穿戴重量');
            if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
              dsurface.BoldTextOut (mmx, bby+13*3, clRed, clBlack, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight))
            else
            dsurface.BoldTextOut (mmx, bby+13*3, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight));
            dsurface.BoldTextOut (bbx, bby+13*4, clSilver, clBlack, '腕力');
            if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
              dsurface.BoldTextOut (mmx, bby+13*4, clRed, clBlack, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight))
            else
            dsurface.BoldTextOut (mmx, bby+13*4, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight));
            dsurface.BoldTextOut (bbx, bby+13*5, clSilver, clBlack, '精确度');
            dsurface.BoldTextOut (mmx, bby+13*5, clSilver, clBlack, IntToStr(g_nMyHitPoint));
            dsurface.BoldTextOut (bbx, bby+13*6, clSilver, clBlack, '敏捷度');
            dsurface.BoldTextOut (mmx, bby+13*6, clSilver, clBlack, IntToStr(g_nMySpeedPoint));
            dsurface.BoldTextOut (bbx, bby+13*7, clSilver, clBlack, '魔法防御');
            dsurface.BoldTextOut (mmx, bby+13*7, clSilver, clBlack, '+' + IntToStr(g_nMyAntiMagic * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+13*8, clSilver, clBlack, '中毒防御');
            dsurface.BoldTextOut (mmx, bby+13*8, clSilver, clBlack, '+' + IntToStr(g_nMyAntiPoison * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+13*9, clSilver, clBlack, '中毒恢复');
            dsurface.BoldTextOut (mmx, bby+13*9, clSilver, clBlack, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');
            dsurface.BoldTextOut (mmx, bby+13*9, clSilver, clBlack, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+13*10, clSilver, clBlack, '体力恢复');
            dsurface.BoldTextOut (mmx, bby+13*10, clSilver, clBlack, '+' + IntToStr(g_nMyHealthRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+13*11, clSilver, clBlack, '魔法恢复');
            dsurface.BoldTextOut (mmx, bby+13*11, clSilver, clBlack, '+' + IntToStr(g_nMySpellRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+13*12, clSilver, clBlack, g_sGameDiaMond+'数'); //金刚石
            dsurface.BoldTextOut (mmx, bby+13*12, clSilver, clBlack, IntToStr(g_MySelf.m_nGameDiaMond));
            dsurface.BoldTextOut (bbx, bby+13*13, clSilver, clBlack, g_sGameGird+'数量'); //灵符
            dsurface.BoldTextOut (mmx, bby+13*13, clSilver, clBlack, IntToStr(g_MySelf.m_nGameGird));
            dsurface.BoldTextOut (bbx, bby+13*14, clYellow, clBlack, g_sGameGoldName+'数量'); //元宝
            dsurface.BoldTextOut (mmx, bby+13*14, clYellow, clBlack, IntToStr(g_MySelf.m_nGameGold));
            dsurface.BoldTextOut (bbx, bby+13*15, clSilver, clBlack, g_sGamePointName+'数量'); //荣耀点
            dsurface.BoldTextOut (mmx, bby+13*15, clSilver, clBlack, IntToStr(g_MySelf.m_nGamePoint));
            if g_dGamePointDate <> 32590 then
            dsurface.BoldTextOut(bbx, bby+13*16, clYellow, clBlack, g_sGamePointName+'截止时间'+ FormatDateTime('mm月dd日24时', g_dGamePointDate));
            {$ELSE}
            d := g_WMain3Images.Images[32];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx + 19;
            bby := bby + 9;
            mmx := bbx + 84;
            dsurface.BoldTextOut (bbx, bby, clSilver, clBlack, '当前经验');
            dsurface.BoldTextOut (mmx, bby, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.nExp));
            dsurface.BoldTextOut (bbx, bby+14*1, clSilver, clBlack, '升级经验');
            dsurface.BoldTextOut (mmx, bby+14*1, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.nMaxExp));
            dsurface.BoldTextOut (bbx, bby+14*2, clSilver, clBlack, '背包重量');
            if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
              dsurface.BoldTextOut (mmx, bby+14*2, clRed, clBlack, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight))
            else
            dsurface.BoldTextOut (mmx, bby+14*2, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.Weight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWeight));
            dsurface.BoldTextOut (bbx, bby+14*3, clSilver, clBlack, '穿戴重量');
            if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
              dsurface.BoldTextOut (mmx, bby+14*3, clRed, clBlack, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight))
            else
            dsurface.BoldTextOut (mmx, bby+14*3, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.WearWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxWearWeight));
            dsurface.BoldTextOut (bbx, bby+14*4, clSilver, clBlack, '腕力');
            if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
              dsurface.BoldTextOut (mmx, bby+14*4, clRed, clBlack, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight))
            else
            dsurface.BoldTextOut (mmx, bby+14*4, clSilver, clBlack, IntToStr(g_MySelf.m_Abil.HandWeight) + '/' + IntToStr(g_MySelf.m_Abil.MaxHandWeight));
            dsurface.BoldTextOut (bbx, bby+14*5, clSilver, clBlack, '精确度');
            dsurface.BoldTextOut (mmx, bby+14*5, clSilver, clBlack, IntToStr(g_nMyHitPoint));
            dsurface.BoldTextOut (bbx, bby+14*6, clSilver, clBlack, '敏捷度');
            dsurface.BoldTextOut (mmx, bby+14*6, clSilver, clBlack, IntToStr(g_nMySpeedPoint));
            dsurface.BoldTextOut (bbx, bby+14*7, clSilver, clBlack, '魔法防御');
            dsurface.BoldTextOut (mmx, bby+14*7, clSilver, clBlack, '+' + IntToStr(g_nMyAntiMagic * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*8, clSilver, clBlack, '中毒防御');
            dsurface.BoldTextOut (mmx, bby+14*8, clSilver, clBlack, '+' + IntToStr(g_nMyAntiPoison * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*9, clSilver, clBlack, '中毒恢复');
            dsurface.BoldTextOut (mmx, bby+14*9, clSilver, clBlack, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');
            dsurface.BoldTextOut (mmx, bby+14*9, clSilver, clBlack, '+' + IntToStr(g_nMyPoisonRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*10, clSilver, clBlack, '体力恢复');
            dsurface.BoldTextOut (mmx, bby+14*10, clSilver, clBlack, '+' + IntToStr(g_nMyHealthRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*11, clSilver, clBlack, '魔法恢复');
            dsurface.BoldTextOut (mmx, bby+14*11, clSilver, clBlack, '+' + IntToStr(g_nMySpellRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*12, clSilver, clBlack, g_sGameDiaMond+'数'); //金刚石
            dsurface.BoldTextOut (mmx, bby+14*12, clSilver, clBlack, IntToStr(g_MySelf.m_nGameDiaMond));
            dsurface.BoldTextOut (bbx, bby+14*13, clSilver, clBlack, g_sGameGird+'数量'); //灵符
            dsurface.BoldTextOut (mmx, bby+14*13, clSilver, clBlack, IntToStr(g_MySelf.m_nGameGird));
            dsurface.BoldTextOut (bbx, bby+14*14, clYellow, clBlack, g_sGameGoldName+'数量'); //元宝
            dsurface.BoldTextOut (mmx, bby+14*14, clYellow, clBlack, IntToStr(g_MySelf.m_nGameGold));
            dsurface.BoldTextOut (bbx, bby+14*15, clSilver, clBlack, g_sGamePointName+'数量'); //荣耀点
            dsurface.BoldTextOut (mmx, bby+14*15, clSilver, clBlack, IntToStr(g_MySelf.m_nGamePoint));
            if g_dGamePointDate <> 32590 then
            dsurface.BoldTextOut(mmx, bby+13*16, clYellow, clBlack, g_sGamePointName+'截止时间'+ FormatDateTime('mm月dd日24时', g_dGamePointDate));
            {$IFEND}
          end;
          3: begin //魔法背景
            bbx := GLeft + 38;
            bby := GTop + 52;
            //虐 钎矫, lv, exp
            {$IF M2Version = 2}
            if not g_boShowNewItem then begin               
            d := g_WMainImages.Images[383];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            magtop := MagicPage * 5;
            magline := _MIN(MagicPage*5+5, g_MagicList.Count);
            end else
            {$ifend}
            begin
            d:=FrmMain.UiDXImageList.Items.Find('HManAbility').PatternSurfaces[0];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            magtop := MagicPage * 6;
            magline := _MIN(MagicPage*6+6, g_MagicList.Count);
            end;
            for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_MagicList[i]);
              m := i - magtop;
              keyimg := 0;
              case byte(pm.Key) of
                byte('1'): keyimg := 156;
                byte('2'): keyimg := 157;
                byte('3'): keyimg := 158;
                byte('4'): keyimg := 159;
                byte('5'): keyimg := 160;
                byte('6'): keyimg := 161;
                byte('7'): keyimg := 162;
                byte('8'): keyimg := 163;
                byte('E'): keyimg := 148;
                byte('F'): keyimg := 149;
                byte('G'): keyimg := 150;
                byte('H'): keyimg := 151;
                byte('I'): keyimg := 152;
                byte('J'): keyimg := 153;
                byte('K'): keyimg := 154;
                byte('L'): keyimg := 155;
              end;
              if keyimg > 0 then begin
                d := g_WMain3Images.Images[keyimg];
                if d <> nil then
                   dsurface.Draw (bbx + 145, bby+8+m*37, d.ClientRect, d, TRUE);
              end;
              d := g_WMainImages.Images[112]; //lv
              if d <> nil then begin
                if (pm.Def.wMagicId = 68) or (pm.Def.wMagicId = 71) then   //酒气护体,召唤圣兽
                  dsurface.Draw (bbx + 110, bby+15+m*37-7, d.ClientRect, d, TRUE)
                else dsurface.Draw (bbx + 48, bby+23+m*37, d.ClientRect, d, TRUE);
              end;
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then begin
                if (pm.Def.wMagicId <> 68) and (pm.Def.wMagicId <> 71)  then
                dsurface.Draw (bbx + 74, bby+23+m*37, d.ClientRect, d, TRUE);
              end;
              case pm.Def.wMagicId of
                68: begin
                  if (pm.Level < 100) then begin
                    JQExp.GLeft := 86;
                    JQExp.GTop := 79+m*37;
                    if not JQExp.Visible then JQExp.Visible := True;
                  end;
                end;
                71: begin
                  if (pm.Level < 100) then begin
                    HBExp.GLeft := 86;
                    HBExp.GTop := 79+m*37;
                    if not HBExp.Visible then HBExp.Visible := True;
                  end;
                end;
                {$IF M2Version <> 2}
                100: begin //神秘解读
                  DBJDSee.GLeft := 160;
                  DBJDSee.GTop := 60+m*37;
                  if not DBJDSee.Visible then DBJDSee.Visible := True;
                end;
                {$IFEND}
              end;
            end;

            for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_MagicList[i]);
              m := i - magtop;
              if not (pm.Def.wMagicId in [68,71,95,100,104])then
              if not (pm.Level in [0..4]) then pm.Level := 0;
              dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName);
              if pm.Def.wMagicId = 95 then begin //斗转星移
                dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
                Continue;//继续
              end else if pm.Def.wMagicId = 100 then begin //强身术
                trainlv := pm.Level;
                dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                if pm.Level = 15 then
                  dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-')
                else dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else if pm.Def.wMagicId = 103 then begin //召唤巨魔
                trainlv := pm.Level;
                dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
                Continue;//继续
              end else if pm.Def.wMagicId = 104 then begin
                dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                if pm.Level = 100 then
                  dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-')
                else dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else if (pm.Def.wMagicId = 68) or (pm.Def.wMagicId = 71) then begin
                trainlv := pm.Level;
                dsurface.BoldTextOut (bbx + 125, bby + 15 + m*37-8, clSilver, clBlack, IntToStr(pm.Level));
              end else begin
                if pm.Level in [0..4] then trainlv := pm.Level
                else trainlv := 0;
                dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
              end;
              if trainlv = 4 then begin
                if (pm.Def.wMagicId <> 68) and (pm.Def.wMagicId <> 71) then
                dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
              end else
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if (pm.Def.wMagicId <> 68) and (pm.Def.wMagicId <> 71) then begin
                  if trainlv < 3 then
                    dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
                end;
              end;
            end;
          end;
          4: begin  //出战
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMain3Images.Images[32];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
          end;
        end;
      end;
      1: begin
        case InternalForcePage of
          0: begin
            d := g_WMain2Images.Images[741];
            if d<>nil then begin
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (SurfaceX(GLeft) + 38, SurfaceY(GTop) + 52, rc, d, False);
            end;
            d:=g_WMain2Images.Images[752];
            if d<>nil then
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 110, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 135, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 160, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 185, d.ClientRect, d, TRUE);

            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 210, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 235, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 124, SurfaceY(GTop) + 260, d.ClientRect, d, TRUE);
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 112, clSilver, clBlack, '当前内功等级');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 137, clSilver, clBlack, '当前内功经验');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 162, clSilver, clBlack, '升级内功经验');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 187, clSilver, clBlack, '内 力 值');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 212, clSilver, clBlack, '内功恢复速度');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 237, clSilver, clBlack, '内功伤害增加');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 262, clSilver, clBlack, '内功伤害减免');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 112, clSilver, clBlack, IntToStr(g_dwInternalForceLevel));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 137, clSilver, clBlack, IntToStr(g_dwExp69));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 162, clSilver, clBlack, IntToStr(g_dwMaxExp69));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 187, clSilver, clBlack, IntToStr(g_MySelf.m_Skill69NH)+'/'+IntToStr(g_MySelf.m_Skill69MaxNH));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 212, clSilver, clBlack, IntToStr(g_nInternalRecovery));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 237, clSilver, clBlack, IntToStr(g_nInternalHurtAdd));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 262, clSilver, clBlack, IntToStr(g_nInternalHurtRelief));
          end;
          1: begin
            d := g_WMain2Images.Images[743];
            if d<>nil then begin
              bbx := GLeft + 38;
              bby := GTop + 52;
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (bbx, bby, rc, d, False);

              //虐 钎矫, lv, exp
              magtop := InternalForceMagicPage * 6;
              magline := _MIN(InternalForceMagicPage*6+6, g_InternalForceMagicList.Count);
              for i:=magtop to magline-1 do begin
                pm := PTClientMagic (g_InternalForceMagicList[i]);
                m := i - magtop;
                {d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
                if d <> nil then
                  dsurface.Draw (bbx + 8, bby+7+m*37, d.ClientRect, d, TRUE);    }
                d := g_WMainImages.Images[112]; //lv
                if d <> nil then
                  dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);
                d := g_WMainImages.Images[111]; //exp
                if d <> nil then begin
                  if pm.Def.wMagicId <> 68 then
                  dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
                end;
              end;
              for i:=magtop to magline-1 do begin
                pm := PTClientMagic (g_InternalForceMagicList[i]);
                if word(pm.Key) = 0 then MagColor := clSilver else MagColor := clGray;
                m := i - magtop;
                if not (pm.Level in [0..30]) then pm.Level := 0;
                if word(pm.Key) = 0 then
                	dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName)
              	else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName+'[关]');
                if pm.Level in [0..30] then trainlv := pm.Level
                else trainlv := 0;
                dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < 3 then
                    dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, MagColor, clBlack, '-');
                end;
              end;
            end;
          end;
        end;
      end;
    end;
    {$IF M2Version <> 2} //not 1.76
    //本代码为显示人物身上所带物品信息，显示位置为人物下方
    if g_BatterDesc.sName <> '' then begin
      old := frmMain.Canvas.Font.Size;
      frmMain.Canvas.Font.Size := 9;
      dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309), clYellow, clBlack, g_BatterDesc.sName);
      dsurface.BoldTextOut (SurfaceX(GLeft+36+ frmMain.Canvas.TextWidth(g_BatterDesc.sName)), SurfaceY(GTop+309), clWhite, clBlack, g_BatterDesc.sLine1);
      dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+frmMain.Canvas.TextHeight('A')+2), clWhite, clBlack, g_BatterDesc.sLine2);
      dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+(frmMain.Canvas.TextHeight('A')+2)*2), clWhite, clBlack, g_BatterDesc.sLine3);
      frmMain.Canvas.Font.Size := old;
    end;
    (*{$ELSE}
    if g_MouseStateItem.S.Name <> '' then begin
      g_MouseItem := g_MouseStateItem;
      GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
      if iname <> '' then begin
        if g_MouseItem.Dura = 0 then hcolor := clRed
        else hcolor := clWhite;
        old := frmMain.Canvas.Font.Size;
        frmMain.Canvas.Font.Size := 9;
        dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272), clYellow, clBlack,iname);
        dsurface.BoldTextOut (SurfaceX(GLeft+36+ frmMain.Canvas.TextWidth(iname)), SurfaceY(GTop+272), hcolor, clBlack,d1);
        dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272+frmMain.Canvas.TextHeight('A')+2), hcolor, clBlack,d2);
        dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+272+(frmMain.Canvas.TextHeight('A')+2)*2), hcolor, clBlack,d3);
        frmMain.Canvas.Font.Size := old;
      end;
      g_MouseItem.S.Name := '';
    end;  *)
    {$IFEND}
    if g_boIsInternalForce then begin
      dsurface.TextOut(SurfaceX(GLeft + 122 - frmMain.Canvas.TextWidth(FrmMain.CharName) div 2),
                       SurfaceY(GTop + 16), g_MySelf.m_nNameColor, g_MySelf.m_sUserName)
    end else begin
      dsurface.TextOut(SurfaceX(GLeft + 122 - frmMain.Canvas.TextWidth(FrmMain.CharName) div 2),
                       SurfaceY(GTop + 23), g_MySelf.m_nNameColor, g_MySelf.m_sUserName);
    end;
    if (StatePage = 0) and (StateTab = 0{基本页}) then begin
      dsurface.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
               clSilver, g_sGuildName + ' ' + g_sGuildRankName);
    end;
  end;
end;

procedure TFrmDlg.DSWBujukDblClick(Sender: TObject);
var
  msg: TDefaultMessage;
begin
  //存放罐物品的扩展   20080315
  if (g_UseItems[U_BUJUK].S.StdMode = 2) and (g_UseItems[U_BUJUK].S.AniCount = 21) then begin
    if Sender = DSWBujuk then begin
      if g_UseItems[U_BUJUK].Dura < g_UseItems[U_BUJUK].DuraMax then begin
         msg := MakeDefaultMsg (aa(CM_DBLREPAIRDRAGON, frmMain.TempCertification),0, 0, 0, 0, frmMain.m_nSendMsgCount);//20071231
         FrmMain.SendSocket (EncodeMessage (msg));//20071231
       end;
    end;
  end;
end;

procedure TFrmDlg.DSWLightDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  idx, nWhere, ax, ay: integer;
  d: TDirectDrawSurface;
  wm: TWMImages;
begin
  nWhere := -1;
  if (StateTab = 0{基本页}) and (StatePage = 0) then begin
    if Sender = DSWNecklace then nWhere := U_NECKLACE;
    if Sender = DSWLight then nWhere := U_RIGHTHAND;
    if Sender = DSWArmRingR then nWhere := U_ARMRINGR;
    if Sender = DSWArmRingL then nWhere := U_ARMRINGL;
    if Sender = DSWRingR then nWhere := U_RINGR;
    if Sender = DSWRingL then nWhere := U_RINGL;
    if Sender = DSWBujuk then nWhere := U_BUJUK;
    if Sender = DSWBelt then nWhere := U_BELT;
    if Sender = DSWBoots then nWhere := U_BOOTS;
    if Sender = DSWCharm then nWhere := U_CHARM;

    if nWhere >= 0 then begin
      if g_UseItems[nWhere].S.Name <> '' then begin
        idx := g_UseItems[nWhere].S.looks;
        if idx >= 0 then begin
          d := frmMain.GetWStateImg(idx);
          if d <> nil then begin
            with TDButton(Sender) do begin
              dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                            SurfaceY(GTop + (GHeight - d.Height) div 2),
                            d.ClientRect, d, TRUE);
              //Modified By TasNat at: 2012-11-22 10:47:29
              if GetEffecItemList(g_UseItems[nWhere].S.Name).btShapeCount > 0 then begin
                with GetEffecItemList(g_UseItems[nWhere].S.Name) do begin
                  if GetTickCount - g_DrawUseItems[nWhere].dwDrawTick >= 150 then begin
                    g_DrawUseItems[nWhere].dwDrawTick := GetTickCount;
                    Inc(g_DrawUseItems[nWhere].nIndex);
                    if g_DrawUseItems[nWhere].nIndex > btShapeCount-1 then g_DrawUseItems[nWhere].nIndex := 0;
                  end;
                  wm := GetItemEffectWil(btShapeWilIndex);
                  if wm <> nil then begin
                    d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[nWhere].nIndex, ax, ay);
                    if d <> nil then begin
                      DrawBlend(dsurface,SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d, 255);
                    end;
                  end;
                end;
              end else begin
                if g_UseItems[nWhere].S.Reserved1 = 1 then begin
                  ItemLightTimeImg(); //物品发光变换函数 20080223
                  d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                  if d <> nil then
                    DrawBlend(dsurface,SurfaceX(GLeft-21), SurfaceY(GTop-23), d, 255);
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateWinClick(Sender: TObject; X, Y: Integer);
begin
   if StatePage = 3 then begin
      X := DStateWin.LocalX (X) - DStateWin.GLeft;
      Y := DStateWin.LocalY (Y) - DStateWin.GTop;
      if (X >= 33) and (X <= 33+166) and (Y >= 55) and (Y <= 55+37*5) then begin
         magcur := (Y-55) div 37;
         if (magcur+magtop) >= g_MagicList.Count then
            magcur := (g_MagicList.Count-1) - magtop;
      end;
   end;
end;

procedure TFrmDlg.DCloseStateClick(Sender: TObject; X, Y: Integer);
begin
   DStateWin.Visible := FALSE;
end;

procedure TFrmDlg.DPrevStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.PageChanged;
{$IF M2Version <> 2}
var
  TitleVisible: Boolean;
{$IFEND}
begin
   DScreen.ClearHint;
   {$IF M2Version <> 2}
   TitleVisible := (StatePage = 0) and (StateTab = 0);
   DBTitleMan.Visible := TitleVisible;
   DBTitle1.Visible := TitleVisible;
   DBTitle2.Visible := TitleVisible;
   DBTitle3.Visible := TitleVisible;
   DBTitle4.Visible := TitleVisible;
   DBPrevTitle.Visible := TitleVisible;
   DBNextTitle.Visible := TitleVisible;
   DLNGUpLevel1.Visible := False;
   DLNGUpLevel2.Visible := False;
   DLNGUpLevel3.Visible := False;
   DLNGUpLevel4.Visible := False;
   DLNGUpLevel5.Visible := False;
   DLNGUpLevel6.Visible := False;
   {$IFEND}
   case StatePage of
      3: begin //魔法 惑怕芒
         DStMag1.Visible := TRUE;  DStMag2.Visible := TRUE;
         DStMag3.Visible := TRUE;  DStMag4.Visible := TRUE;
         DStMag5.Visible := TRUE;
         {$IF M2Version <> 2}DStMag6.Visible := True; //Modified By TasNat at: 2012-10-20 10:51:56
         {$else}
          DStMag6.Visible := g_boShowNewItem;
         {$IFEND}

         DStPageUp.Visible := TRUE;
         DStPageDown.Visible := TRUE;
         MagicPage := 0;
          DCheckDeputyHeroWarr.Visible := FALSE;
          DCheckDeputyHeroWiz.Visible := FALSE;
          DCheckDeputyHeroTaos.Visible := FALSE;
      end;
      4: begin
         DStMag1.Visible := FALSE;  DStMag2.Visible := FALSE;
         DStMag3.Visible := FALSE;  DStMag4.Visible := FALSE;
         DStMag5.Visible := FALSE;  DStMag6.Visible := False;
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
        DCheckDeputyHeroWarr.Visible := True;
        DCheckDeputyHeroWiz.Visible := True;
        DCheckDeputyHeroTaos.Visible := True;

        DCheckDeputyHeroWarr.Checked := False;
        DCheckDeputyHeroWiz.Checked := False;
        DCheckDeputyHeroTaos.Checked := False;
        case m_btDeputyHeroJob of
          0: DCheckDeputyHeroWarr.Checked := True;
          1: DCheckDeputyHeroWiz.Checked := True;
          2: DCheckDeputyHeroTaos.Checked := True;
          else DCheckDeputyHeroWarr.Checked := True;
        end;
      end;
      else begin
         DStMag1.Visible := FALSE;  DStMag2.Visible := FALSE;
         DStMag3.Visible := FALSE;  DStMag4.Visible := FALSE;
         DStMag5.Visible := FALSE;  DStMag6.Visible := False;
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
          DCheckDeputyHeroWarr.Visible := FALSE;
          DCheckDeputyHeroWiz.Visible := FALSE;
          DCheckDeputyHeroTaos.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.InternalForcePageChanged;
begin
   DScreen.ClearHint;
   DStMag1.Visible := False;  DStMag2.Visible := False;
   DStMag3.Visible := False;  DStMag4.Visible := False;
   DStMag5.Visible := False;  {$IF M2Version <> 2}DStMag6.Visible := False;{$IFEND}
   DLNGUpLevel1.Visible := False;
   DLNGUpLevel2.Visible := False;
   DLNGUpLevel3.Visible := False;
   DLNGUpLevel4.Visible := False;
   DLNGUpLevel5.Visible := False;
   DLNGUpLevel6.Visible := False;
   DCheckDeputyHeroWarr.Visible := FALSE;
   DCheckDeputyHeroWiz.Visible := FALSE;
   DCheckDeputyHeroTaos.Visible := FALSE;
   case InternalForcePage of
      1: begin //魔法 惑怕芒
         DStPageUp.Visible := TRUE;
         DStPageDown.Visible := TRUE;
         InternalForceMagicPage := 0;
         DStateWinPulse.Visible := False;
         DStateWinBatter.Visible := False;
         DStMag1.Visible := TRUE;  DStMag2.Visible := TRUE;
         DStMag3.Visible := TRUE;  DStMag4.Visible := TRUE;
         DStMag5.Visible := TRUE;  {$IF M2Version <> 2}DStMag6.Visible := True;
         NGUpLevelState(False); {$IFEND}
      end;
      2: begin
        DStateWinPulse.Visible := True;
        DStPageUp.Visible := FALSE;
        DStPageDown.Visible := FALSE;
        DStateWinBatter.Visible := False;
      end;
      3: begin
        DStateWinPulse.Visible := False;
        DStPageUp.Visible := FALSE;
        DStPageDown.Visible := FALSE;
        DStateWinBatter.Visible := True;
      end;
      else begin
         DStateWinBatter.Visible := False;
         DStateWinPulse.Visible := False;
         DStPageUp.Visible := FALSE;
         DStPageDown.Visible := FALSE;
      end;
   end;
end;

procedure TFrmDlg.HeroInternalForcePageChanged;
begin
   DScreen.ClearHint;
   DCheckHeroDeputyHeroWarr.Visible := FALSE;
   DCheckHeroDeputyHeroWiz.Visible := FALSE;
   DCheckHeroDeputyHeroTaos.Visible := FALSE;
   DStMagHero1.Visible := FALSE;  DStMagHero2.Visible := FALSE;
   DStMagHero3.Visible := FALSE;  DStMagHero4.Visible := FALSE;
   DStMagHero5.Visible := FALSE;  DStMagHero6.Visible := FALSE;
   DLHeroNGUpLevel1.Visible := False;
   DLHeroNGUpLevel2.Visible := False;
   DLHeroNGUpLevel3.Visible := False;
   DLHeroNGUpLevel4.Visible := False;
   DLHeroNGUpLevel5.Visible := False;
   DLHeroNGUpLevel6.Visible := False;
   case HeroInternalForcePage of
      1: begin //魔法 惑怕芒
         DSHPageUp.Visible := TRUE;
         DSHPageDown.Visible := TRUE;
         HeroInternalForceMagicPage := 0;
         DHeroStateWinPulse.Visible := False;
         DHeroStateWinBatter.Visible := False;
         DStMagHero1.Visible := TRUE;  DStMagHero2.Visible := TRUE;
         DStMagHero3.Visible := TRUE;  DStMagHero4.Visible := TRUE;
         DStMagHero5.Visible := TRUE;  DStMagHero6.Visible := TRUE;
         {$IF M2Version <> 2}
         NGUpLevelState(True);
         {$IFEND}
      end;
      2: begin
        DHeroStateWinPulse.Visible := True;
        DSHPageUp.Visible := FALSE;
        DSHPageDown.Visible := FALSE;
        DHeroStateWinBatter.Visible := False;
         //DStPageUp.Visible := FALSE;
         //DStPageDown.Visible := FALSE;
      end;
      3: begin
        DHeroStateWinPulse.Visible := False;
        DSHPageUp.Visible := FALSE;
        DSHPageDown.Visible := FALSE;
        DHeroStateWinBatter.Visible := True;
         //DStPageUp.Visible := FALSE;
         //DStPageDown.Visible := FALSE;
      end;    
      else begin
         DHeroStateWinPulse.Visible := False;
         DSHPageUp.Visible := FALSE;
         DSHPageDown.Visible := FALSE;
         DHeroStateWinBatter.Visible := False;
      end;
   end;
end;

procedure TFrmDlg.DPrevStateClick(Sender: TObject; X, Y: Integer);
begin
  if StateTab = 0 then begin
    Dec (StatePage);
    if StatePage < 0 then
      StatePage := MAXSTATEPAGE-1;
    PageChanged;
  end else begin   //内功
    Dec (InternalForcePage);
    if InternalForcePage < 0 then
      InternalForcePage := 1;
    InternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DNextStateClick(Sender: TObject; X, Y: Integer);
begin
  if StateTab = 0 then begin
    Inc (StatePage);
    if StatePage > MAXSTATEPAGE-1 then
      StatePage := 0;
    PageChanged;
  end else begin //内功
    Inc (InternalForcePage);
    if InternalForcePage > 1 then
      InternalForcePage := 0;
    InternalForcePageChanged;
  end;
end;
//点击武器、衣服等装备
procedure TFrmDlg.DSWWeaponClick(Sender: TObject; X, Y: Integer);
var
   where, n, sel: integer;
   flag: Boolean;
   msg: TDefaultMessage;
begin
   if g_MySelf = nil then exit;
   (*if not g_boRightItem {如果不是右键穿戴物品} then*)  if (StateTab <> 0) or (StatePage <> 0) then exit;
   if g_boItemMoving (*or g_boRightItem{右键点物品}*) then begin
      flag := FALSE;
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      where := GetTakeOnPosition (g_MovingItem.Item.S.StdMode);
      if g_MovingItem.Index >= 0 then begin

      //存放罐物品的扩展   20080315
      if ((g_UseItems[U_BUJUK].S.StdMode = 2) and (g_UseItems[U_BUJUK].S.AniCount = 21) and (Byte(g_UseItems[U_BUJUK].S.Source) = g_MovingItem.Item.S.Shape) and (g_UseItems[U_BUJUK].S.Shape = g_MovingItem.Item.S.StdMode)) and (not (g_MovingItem.Item.S.StdMode in [5,6,10,11])) then begin
         if Sender = DSWBujuk then begin
           g_WaitingUseItem := g_MovingItem;
           g_MovingItem.Item.S.Name := '';
           g_boItemMoving := False;
           msg := MakeDefaultMsg (aa(CM_REPAIRDRAGON, frmMain.TempCertification),g_WaitingUseItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
           FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.S.Name));//20071231
           //Exit;
         end;
      end;
      //火云石修复
      if (g_UseItems[U_BUJUK].S.StdMode = 25) and (g_UseItems[U_BUJUK].S.Shape = 10) and (g_MovingItem.Item.S.StdMode = 43) and (g_MovingItem.Item.S.Shape = 1) then begin
         if Sender = DSWBujuk then begin
            g_WaitingUseItem := g_MovingItem;
            g_MovingItem.Item.S.Name := '';
            g_boItemMoving := False;
            msg := MakeDefaultMsg (aa(CM_REPAIRFINEITEM, frmMain.TempCertification),g_WaitingUseItem.Item.MakeIndex, 0, 0, 0, frmMain.m_nSendMsgCount);//20080507
            FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.S.Name));//20080507
         end;
      end;
         case where of
            //衣服
            U_DRESS: begin
               if Sender = DSWDress then begin
                  if g_MySelf.m_btSex = 0 then //男的
                     if g_MovingItem.Item.S.StdMode <> 10 then //10男式衣服
                        exit;
                  if g_MySelf.m_btSex = 1 then //女的
                     if g_MovingItem.Item.S.StdMode <> 11 then //11男式衣服
                        exit;
                  flag := TRUE;
               end;
            end;
            //武器
            U_WEAPON: begin
               if Sender = DSWWEAPON then begin
                  flag := TRUE;
               end;
            end;
            //项链
            U_NECKLACE: begin
               if Sender = DSWNecklace then
                  flag := TRUE;
            end;
             //蜡烛、火把、圣牌、勋章之类的
            U_RIGHTHAND: begin
               if Sender = DSWLight then
                  flag := TRUE;
            end;
            U_HELMET: begin
            //头盔
               if Sender = DSWHelmet then  //原来代码
                  flag := TRUE;
            end;
            U_ZHULI: begin
            //斗笠
              if Sender = DSWHelmet then
                 flag := True;
            end;
            //戒指（左右都可以）
            U_RINGR, U_RINGL: begin
               if Sender = DSWRingL then begin
                  where := U_RINGL;
                  flag := TRUE;
               end;
               if Sender = DSWRingR then begin
                  where := U_RINGR;
                  flag := TRUE;
               end;
            end;
            //手镯、手套(左右都可以)
            U_ARMRINGR: begin  
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
               if Sender = DSWArmRingR then begin
                  where := U_ARMRINGR;
                  flag := TRUE;
               end;
            end;
            //护身符、药粉之类的
            U_ARMRINGL: begin  
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            //护身符、药粉之类的
            U_BUJUK: begin
               if Sender = DSWBujuk then begin
                 case g_MovingItem.Item.S.StdMode of
                   2: begin //祝福罐，魔令包
                     if (g_MovingItem.Item.S.StdMode = 2) and (g_MovingItem.Item.S.AniCount = 21) then
                     begin
                      where := U_BUJUK;
                      flag := TRUE;
                     end;
                   end;
                    25: begin //符
                      where := U_BUJUK;
                      flag := TRUE;
                    end;
                 end;
               end;
               if Sender = DSWArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            //腰带
            U_BELT: begin
               if Sender = DSWBelt then begin
                  where := U_BELT;
                  flag := TRUE;
               end;
            end;
            //鞋子
            U_BOOTS: begin
               if Sender = DSWBoots then begin
                  where := U_BOOTS;
                  flag := TRUE;
               end;
            end;
            //宝石
            U_CHARM: begin
               if Sender = DSWCharm then begin
                  where := U_CHARM;
                  flag := TRUE;
               end;
            end;
         end;
         if Sender = DSWCharm then begin
           if (g_UseItems[U_CHARM].S.Shape = 5) and (g_UseItems[U_CHARM].S.StdMode = 7) and (g_UseItems[U_CHARM].S.Name <> '') then begin//20090205
             case g_MovingItem.Item.S.StdMode of
               7: begin
                 if g_MovingItem.Item.S.Shape = 3 then begin
                   msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingItem.Item.MakeIndex, 1, 0, 0, frmMain.m_nSendMsgCount);//20071231
                   FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingItem.Item.S.Name));//20071231
                   Exit;
                 end;
               end;
             end;
           end;
         end;
      end else begin
         n := -(g_MovingItem.Index+1);
         if n in [0..13] then begin
            ItemClickSound (g_MovingItem.Item.S);
            g_UseItems[n] := g_MovingItem.Item;
            g_MovingItem.Item.S.Name := '';
            g_boItemMoving := FALSE;
         end;
      end;
      if flag then begin
         ItemClickSound (g_MovingItem.Item.S);
         g_WaitingUseItem := g_MovingItem;
         g_WaitingUseItem.Index := where;
         FrmMain.SendTakeOnItem (where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
         g_MovingItem.Item.S.Name := '';
         g_boItemMoving := FALSE;
      end;
   end else begin
      if g_boHeroItemMoving then Exit;
      if (g_MovingItem.Item.S.Name <> '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
      sel := -1;
      if Sender = DSWDress then sel := U_DRESS;
      if Sender = DSWWeapon then sel := U_WEAPON;

      //斗笠
      if Sender = DSWHelmet then begin
        if g_UseItems[U_ZHULI].S.Name <> '' then
         sel := U_ZHULI
        else sel := U_HELMET;
      end;

      if Sender = DSWNecklace then sel := U_NECKLACE;
      if Sender = DSWLight then sel := U_RIGHTHAND;
      if Sender = DSWRingL then sel := U_RINGL;
      if Sender = DSWRingR then sel := U_RINGR;
      if Sender = DSWArmRingL then sel := U_ARMRINGL;
      if Sender = DSWArmRingR then sel := U_ARMRINGR;

      if Sender = DSWBujuk then sel := U_BUJUK;
      if Sender = DSWBelt then sel := U_BELT;  //
      if Sender = DSWBoots then sel := U_BOOTS;
      if Sender = DSWCharm then sel := U_CHARM;

      if sel >= 0 then begin
         if g_UseItems[sel].S.Name <> '' then begin
            ItemClickSound (g_UseItems[sel].S);
            g_MovingItem.Index := -(sel+1);
            g_MovingItem.Item := g_UseItems[sel];
            g_UseItems[sel].S.Name := '';
            g_boItemMoving := TRUE;
         end;
      end;
   end;
end;

procedure TFrmDlg.DSWWeaponMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  (*{$IF M2Version = 2}
  hcolor: Integer;
  {$ELSE}*)
  hcolor: string;
  //{$IFEND}
  Butt:TDButton;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
begin
   if (StateTab <> 0{不是基本页}) or (StatePage <> 0) then Exit;
   sel := -1;
   Lines := '';
   Butt:=TDButton(Sender);
   if Sender = DSWDress then sel := U_DRESS;
   if Sender = DSWWeapon then sel := U_WEAPON;
   if Sender = DSWHelmet then sel := U_HELMET;
   if Sender = DSWNecklace then sel := U_NECKLACE;
   if Sender = DSWLight then sel := U_RIGHTHAND;
   if Sender = DSWRingL then sel := U_RINGL;
   if Sender = DSWRingR then sel := U_RINGR;
   if Sender = DSWArmRingL then sel := U_ARMRINGL;
   if Sender = DSWArmRingR then sel := U_ARMRINGR;

   if Sender = DSWBujuk then sel := U_BUJUK;
   if Sender = DSWBelt then sel := U_BELT;
   if Sender = DSWBoots then sel := U_BOOTS;
   if Sender = DSWCharm then sel := U_CHARM;
   (*{$IF M2Version = 2}//1.76
   if sel >= 0 then begin
      g_MouseStateItem := g_UseItems[sel];
      g_BatterDesc.sName := '';
      if g_UseItems[sel].S.Name <> '' then begin
         TzHintInfo := GetTzInfo(g_UseItems[sel].S.Name, 1);
         if TzHintInfo <> nil then begin
           if DStateWin.GLeft >= 350 then
             nHintX:=DStateWin.SurfaceX(DStateWin.GLeft)-10 - _Min(DScreen.HintWidth, 400)
           else
             nHintX:=DStateWin.SurfaceX(DStateWin.GLeft)+DStateWin.GWidth +10;

           nHintY:=Butt.SurfaceY(Butt.GTop) -50;
           if (sel = U_HELMET) and (g_UseItems[U_ZHULI].S.Name <> '') then begin //指向头盔and斗笠不为空
             g_MouseItem := g_UseItems[U_ZHULI];
             GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
             g_MouseItem.S.Name := '';
             with Butt as TDButton do     //显示有斗笠的
                DScreen.ShowTzHint (nHintX,
                                  nHintY,
                                  iname  + '\'+ d1 + '\' + d2 + '\' + d3 +'\ \'+
                                  TzHintInfo.sTzCaption+'~c\ \'+GetTzStateInfo(TzHintInfo,1), FALSE, True, 40);
           end else begin
             with Butt as TDButton do
                DScreen.ShowTzHint (nHintX,
                                  nHintY,
                                  TzHintInfo.sTzCaption+'~c\ \'+GetTzStateInfo(TzHintInfo,1), FALSE, True, 40);
           end;
         end else begin
            if (sel = U_HELMET) and (g_UseItems[U_ZHULI].S.Name <> '') then begin
              g_MouseItem := g_UseItems[U_ZHULI];
              GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
              if iname <> '' then begin
                if g_UseItems[U_ZHULI].Dura = 0 then hcolor := clRed
                else hcolor := clYellow;

                nHintX:=DSWHelmet.SurfaceX(DSWHelmet.GLeft) + DSWHelmet.GWidth * 2;
                nHintY:=DSWHelmet.SurfaceY(DSWHelmet.GTop);
                with Butt as TDButton do
                  DScreen.ShowHint(nHintX,nHintY,
                                 iname  + '\'+ d1 + '\' + d2 + '\' + d3, hcolor, FALSE);
              end;
              g_MouseItem.S.Name := '';
            end;
         end;
      end else begin//当鼠标放在头盔位置，没带头盔时，有黑巾或斗笠时，提示 20090610
        if (sel = U_HELMET) and (g_UseItems[U_ZHULI].S.Name <> '') then begin
          g_MouseItem := g_UseItems[U_ZHULI];
          GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
          if iname <> '' then begin
            if g_UseItems[U_ZHULI].Dura = 0 then hcolor := clRed
            else hcolor := clYellow;

            nHintX:=DSWHelmet.SurfaceX(DSWHelmet.GLeft) + DSWHelmet.GWidth * 2;
            nHintY:=DSWHelmet.SurfaceY(DSWHelmet.GTop);
            with Butt as TDButton do
              DScreen.ShowHint(nHintX,nHintY,
                             iname  + '\'+ d1 + '\' + d2 + '\' + d3, hcolor, FALSE);
          end;
          g_MouseItem.S.Name := '';
        end;
      end;
   end;
   {$ELSE}  *)
   if sel >= 0 then begin
      g_MouseStateItem := g_UseItems[sel];
      g_BatterDesc.sName := '';
      if (g_UseItems[sel].S.Name <> '') or (g_UseItems[U_ZHULI].S.Name <> '') then begin
        if (sel = U_HELMET) and (g_UseItems[U_ZHULI].S.Name <> '') then begin
          g_MouseItem := g_UseItems[U_ZHULI];
          GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
          if iname <> '' then begin
            if g_UseItems[U_ZHULI].Dura = 0 then hcolor := 'Red'
            else hcolor := '';
            Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
          end;
        end;
        TzHintInfo := GetTzInfo(g_UseItems[sel].S.Name, 1);
        if DStateWin.GLeft >= 350 then
          nHintX:=DStateWin.SurfaceX(DStateWin.GLeft) - _Min(DScreen.HintWidth, 400)
        else nHintX:=DStateWin.SurfaceX(DStateWin.GLeft)+DStateWin.GWidth;
        nHintY:=DStateWin.SurfaceY(DStateWin.GTop) +50;
        g_MouseItem := g_UseItems[sel];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
        if (iname <> '') or (Lines <> '') then begin
          if g_UseItems[sel].Dura = 0 then hcolor := 'Red'
          else hcolor := '';
          with Butt as TDButton do begin
            if TzHintInfo =nil then begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False//'<'+iname+'/c=Yellow>\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + '<'+d4+'/c=Yellow>\'+ d5 + '\' + d6 + '\' + d7, FALSE
                                      ); 

            end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,1)]), False
                                      );  
            end;
          end;
        end;
        g_MouseItem.S.Name := '';
      end;
   end;
   //{$IFEND}
end;

procedure TFrmDlg.DStateWinMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
  g_MouseStateItem.S.Name := '';
end;
//惑怕芒 : 魔法 其捞瘤

procedure TFrmDlg.DStMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   idx, icon: integer;
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   wm: TWMImages;
begin
  with Sender as TDButton do begin
    pm := nil;
    {$IF M2Version = 2} //1.76
    if not g_boShowNewItem then         
      idx := _Max(Tag + MagicPage * 5, 0)
    else
      idx := _Max(Tag + MagicPage * 6, 0);
    if idx < g_MagicList.Count then begin
      pm := PTClientMagic (g_MagicList[idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[icon];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[icon+1];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end;
    {$ELSE}
    if StateTab = 0 then begin
      idx := _Max(Tag + MagicPage * 6, 0);
      if idx < g_MagicList.Count then begin
        pm := PTClientMagic (g_MagicList[idx]);
        if pm <> nil then begin
          wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
          if wm <> nil then begin
            if icon >= 0 then begin
              if not Downed then begin
                d := wm.Images[icon];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := wm.Images[icon+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end else begin
      idx := _Max(Tag + InternalForceMagicPage * 6, 0);
      if idx < g_InternalForceMagicList.Count then begin
        pm := PTClientMagic (g_InternalForceMagicList[idx]);
        if pm <> nil then begin
          if not Downed then begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end else begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2+1];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          if word(pm.Key) <> 0 then begin
            g_ImgMixSurface.SetSize(d.Width, d.Height);
            g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
            DrawEffect(0, 0, g_ImgMixSurface, d, {ceGrayScale}ceBlack);
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
          end;
        end;
      end;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DStMag1Click(Sender: TObject; X, Y: Integer);
var
  i, idx: integer;
  selkey: word;
  keych: char;
  pm: PTClientMagic;
  icon :Integer;
  {$IF M2Version <> 2}
  boChange: Boolean;
  {$IFEND}
begin
	{$IF M2Version <> 2}
  if (StatePage = 3) or (InternalForcePage = 1) then begin
    if StateTab = 0 then begin
      idx := TDButton(Sender).Tag + magtop;
      if (idx >= 0) and (idx < g_MagicList.Count) then begin
        pm := PTClientMagic (g_MagicList[idx]);
        selkey := word(pm.Key);
        GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
        if pm.Def.wMagicId <> 100 then begin //神秘解读
          SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey); //护体神盾魔法拦的图标  20080229
          keych := char(selkey);
          boChange := False;
          if g_MagicList.Count > 0 then //20080629
          for i:=0 to g_MagicList.Count-1 do begin
            pm := PTClientMagic (g_MagicList[i]);
            if pm.Key = keych then begin
               pm.Key := #0;
               FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
               boChange := True;
            end;
          end;
          if not boChange then begin
            for i:=0 to g_XinFaMagic.Count-1 do begin
              pm := PTClientMagic (g_XinFaMagic[i]);
              if pm.Key = keych then begin
                 pm.Key := #0;
                 FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
                 boChange := True;
              end;
            end;
          end;
          pm := PTClientMagic (g_MagicList[idx]);
          pm.Key := keych;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
        {$IF M2Version <> 2}
        end else begin
          SetSkillMemoDlg(pm.Def.wMagicId, pm.Level, pm.Def.btEffect, pm.Def.sMagicName, '神秘解读');
        {$IFEND}
        end;
      end;
    end else begin
      idx := TDButton(Sender).Tag + magtop;
      if (idx >= 0) and (idx < g_InternalForceMagicList.Count) then begin
        pm := PTClientMagic (g_InternalForceMagicList[idx]);
        if word(pm.Key) = 0 then
          keych := char(word(1))
        else keych := char(word(0));
        pm.Key := keych;
        FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
      end;
    end;
  end;
  {$ELSE}
  if StateTab = 0 then begin
    idx := TDButton(Sender).Tag + magtop;
    if (idx >= 0) and (idx < g_MagicList.Count) then begin
      pm := PTClientMagic (g_MagicList[idx]);
      selkey := word(pm.Key);
      GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
      SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey); //护体神盾魔法拦的图标  20080229
      keych := char(selkey);

      if g_MagicList.Count > 0 then //20080629
      for i:=0 to g_MagicList.Count-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if pm.Key = keych then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_MagicList[idx]);
      pm.Key := keych;
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStPageUpClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  if StateTab = 0 then begin
     if Sender = DStPageUp then begin
        if MagicPage > 0 then
           Dec (MagicPage);
     end else begin
        if MagicPage < (g_MagicList.Count+5) div 6 - 1 then
           Inc (MagicPage);
     end;
  end else begin
     if Sender = DStPageUp then begin
        if InternalForceMagicPage > 0 then begin
           Dec (InternalForceMagicPage);
           NGUpLevelState(False);
        end;
     end else begin
        if InternalForceMagicPage < (g_InternalForceMagicList.Count+5) div 6 - 1 then begin
           Inc (InternalForceMagicPage);
           NGUpLevelState(False);
        end;
     end;
  end;
  {$ELSE}
  if Sender = DStPageUp then begin
    if MagicPage > 0 then Dec (MagicPage);
  end else begin
    if MagicPage < (g_MagicList.Count+4) div 5 - 1 then Inc (MagicPage);
  end;
  {$IFEND}
end;
{$REGION '老底部状态画图过程 - 无用'}

(*procedure TFrmDlg.DBottomDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d:TDirectDrawSurface;
  rc:TRect;
  btop, sx, sy, i, fcolor, bcolor: integer;
  r: Real;
begin

{$IF SWH = SWH800}
  {$IF M2Version = 2} //1.76
    d:=g_WMainImages.Images[1];
  {$ELSE}
  if g_boOpenHero then begin
    d:=g_WMain3Images.Images[BOTTOMBOARD800];
  end else begin
    d:=g_WMain3Images.Images[291];
  end;
  {$IFEND}
{$ELSEIF SWH = SWH1024}
  d:=g_WMainImages.Images[BOTTOMBOARD1024];
{$IFEND}
  if d <> nil then
    dsurface.Draw (DBottom.GLeft, DBottom.GTop, d.ClientRect, d, TRUE);
  btop := 0;
  if d <> nil then begin
    with d.ClientRect do
       rc := Rect (Left, Top, Right, Top+120);
    btop := SCREENHEIGHT - d.height;
    //上半部透明
    dsurface.Draw (0, btop, rc, d, TRUE);
    //下半部不透明
    with d.ClientRect do
      rc := Rect (Left, Top+120, Right, Bottom);
    dsurface.Draw (0, btop + 120, rc, d, FALSE);
  end;

   d := nil;
   case g_nDayBright of
      0: d := g_WMainImages.Images[15];  //早上
      1: d := g_WMainImages.Images[12];  //白天
      2: d := g_WMainImages.Images[13];  //傍晚
      3: d := g_WMainImages.Images[14];  //晚上
   end;
   if d <> nil then
     dsurface.Draw (748, 79+DBottom.GTop, d.ClientRect, d, FALSE);

   if g_MySelf <> nil then begin
      //显示HP及MP 图形
      if (g_MySelf.m_Abil.MaxHP > 0) and (g_MySelf.m_Abil.MaxMP > 0) then begin
         if (g_MySelf.m_btJob = 0) and (g_MySelf.m_Abil.Level < 28) then begin //武士
            d := g_WMainImages.Images[5];
            if d <> nil then begin
               rc := d.ClientRect;
               rc.Right := d.ClientRect.Right - 2;
               dsurface.Draw (38, btop+90, rc, d, FALSE);
            end;
            d := g_WMainImages.Images[6];
            if d <> nil then begin
               rc := d.ClientRect;
               rc.Right := d.ClientRect.Right - 2;
               rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
               dsurface.Draw (38, btop+90+rc.Top, rc, d, FALSE);
            end;
         end else begin
            d := g_WMainImages.Images[4];
            if d <> nil then begin
               //HP 图形
               rc := d.ClientRect;
               rc.Right := d.ClientRect.Right div 2 - 1;
               rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
               dsurface.Draw (40, btop+91+rc.Top, rc, d, FALSE);
               //MP 图形
               rc := d.ClientRect;
               rc.Left := d.ClientRect.Right div 2 + 1;
               rc.Right := d.ClientRect.Right - 1;
               rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxMP * (g_MySelf.m_Abil.MaxMP - g_MySelf.m_Abil.MP));
               dsurface.Draw (40 + rc.Left, btop+91+rc.Top, rc, d, FALSE);
            end;
         end;
      end;

      //等级
      if DBNewStateTab3.Visible then
        dsurface.BoldTextOut(666, 494, clYellow, clBlack, IntToStr(g_MySelf.m_Abil.Level))
      else PomiTextOut (dsurface, 660, 496, IntToStr(g_MySelf.m_Abil.Level));

        {-----------------在屏幕右下角显示攻击模式  2008.02.28--------------------------------------}
        {$IF M2Version = 2}
        dsurface.BoldTextOut (635, 464, clWhite, clBlack, g_sAttackMode);
        {$ELSE}
        if g_boOpenHero then begin
          dsurface.BoldTextOut (635, 474, clWhite, clBlack, g_sAttackMode);
        end else begin
          dsurface.BoldTextOut (641, 461, clWhite, clBlack, g_sAttackMode);
        end;
        {$IFEND}
        {-----------------在屏幕右下角显示时间  2007.11.5--------------------------------------}
        dsurface.BoldTextOut (672, 578, clWhite, clBlack, FormatDateTime('hh:mm:ss',Now));
        {-----------------在屏幕左下角显示人物血和蓝  2007.11.5--------------------------------------}
        dsurface.BoldTextOut (27, 562, clWhite, clBlack, (format('%d/%d',[g_MySelf.m_Abil.HP,g_MySelf.m_Abil.MaxHP])));
        dsurface.BoldTextOut (94, 562, clWhite, clBlack, (format('%d/%d',[g_MySelf.m_Abil.MP,g_MySelf.m_Abil.MaxMP])));
        dsurface.BoldTextOut (7, SCREENHEIGHT-15, clWhite, clBlack, Format('%s %d:%d',[g_sMapTitle, g_MySelf.m_nCurrX, g_MySelf.m_nCurrY]));//g_sMapTitle + ' ' + IntToStr(g_MySelf.m_nCurrX) + ':' + IntToStr(g_MySelf.m_nCurrY));
      if (g_MySelf.m_Abil.MaxExp > 0) and (g_MySelf.m_Abil.MaxWeight > 0) then begin
         d := g_WMainImages.Images[7];
         if d <> nil then begin
            //经验条
            rc := d.ClientRect;
            if g_MySelf.m_Abil.Exp > 0 then r := g_MySelf.m_Abil.MaxExp / g_MySelf.m_Abil.Exp
            else r := 0;
            if r > 0 then rc.Right := Round (rc.Right / r)
            else rc.Right := 0;
            dsurface.Draw (666, 527, rc, d, FALSE);
            //背包重量条
            rc := d.ClientRect;
            if g_MySelf.m_Abil.Weight > 0 then r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
            else r := 0;
            if r > 0 then rc.Right := Round (rc.Right / r)
            else rc.Right := 0;
            dsurface.Draw (666, 560, rc, d, FALSE);
         end;
      end;
      //饥饿程度
      if g_nMyHungryState in [1..4] then begin
        d := g_WMainImages.Images[16 + g_nMyHungryState-1];
        if d <> nil then begin
          dsurface.Draw (754, 553, d.ClientRect, d, TRUE);
        end;
      end;
    end;
    {$IF M2Version = 1}
    if g_MySelf <> nil then begin
      if g_MySelf.m_Abil.MaxTransferValue > 0 then begin
        d := g_WMainImages.Images[1200];
        if d <> nil then begin
          dsurface.Draw (12, 414, d.ClientRect, d, TRUE);
        end;

        d:= g_WMainImages.Images[1201];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxTransferValue * (g_MySelf.m_Abil.MaxTransferValue - g_MySelf.m_Abil.TransferValue));
          dsurface.Draw (20, 423+rc.Top, rc, d, TRUE);
        end;
      end;
    end;
    {$IFEND}
  {$IF M2Version <> 2} //1.76
  if g_boOpenHero then begin
    d := g_WMain3Images.Images[313];
    if d <> nil then
      dsurface.Draw (DBottom.SurfaceX(DBottom.GLeft)+633, DBottom.SurfaceY(DBottom.GTop)+103, d.ClientRect, d, TRUE);
  end;
  if g_boOpenLeiMei then begin
    d := g_WUI1Images.Images[896];
    if d <> nil then
        dsurface.Draw (0, DBottom.SurfaceY(DBottom.GTop)+20, d.ClientRect, d, TRUE);
  end;
  if g_MySelf <> nil then begin
    if g_MySelf.m_nState and $00020000 <> 0 then begin //心法激活
      if GetTickCount - m_dwAbilTick > 100 then begin
        m_dwAbilTick := GetTickCount;
        Inc(m_btAbilIndex);
        if m_btAbilIndex >= 12 then m_btAbilIndex := 0;
      end;
      d := g_WMagic10Images.Images[240 + m_btAbilIndex];
      if d <> nil then
        DrawBlend(dsurface,38, btop+90, d, 1,255);
      d := g_WMagic10Images.Images[260 + m_btAbilIndex];
      if d <> nil then
        DrawBlend(dsurface,38, btop+90, d, 1,255);
      d := g_WMagic10Images.Images[280 + m_btAbilIndex];
      if d <> nil then
        DrawBlend(dsurface,-62, btop-10, d, 1,255);
    end;
    if g_boXinFaType then begin //105魔法
      d := g_WUI1Images.Images[2330];
      if d <> nil then
        dsurface.Draw(638, btop+140, d.ClientRect, d, True);
      d := g_WUI1Images.Images[2331];
      if d <> nil then
        dsurface.Draw(638, btop+172, d.ClientRect, d, True);
      if g_boShowXinFaAbsorb then begin
        if GetTickCount - g_dwXinFaAbsorbTimeKick > 200 then begin
          g_dwXinFaAbsorbTimeKick := GetTickCount;
          Inc(g_btXinFaAbsorbImgIndex);
          if g_btXinFaAbsorbImgIndex > 1 then g_btXinFaAbsorbImgIndex := 0;
        end;
        d := g_WMainImages.Images[918+g_btXinFaAbsorbImgIndex];
        if d <> nil then
          dsurface.Draw (642, btop+192, d.ClientRect, d, TRUE);
      end;
    end;
  end;
  {$IFEND}
   //显示聊天框文字
   sx := 208;
   sy := SCREENHEIGHT - 130;
   with DScreen do begin
      if TopChatStrs.Count > 0 then begin
         DelChatTopString();
         for I:=0 to TopChatStrs.Count-1 do begin
           fcolor := pTopChat(TopChatStrs.Objects[I]).FColor;
           bcolor := pTopChat(TopChatStrs.Objects[I]).BColor;
           dsurface.FillRect(Rect(sx, sy+i*12, sx+386, sy+i*12+12),bcolor);
           //ClFunc.ChatTextOut (dsurface, sx, sy+i*12, fcolor, bcolor, TopChatStrs.Strings[i]);
           dsurface.TextOut(sx, sy+i*12, fcolor, TopChatStrs.Strings[i]);
         end;
         sy := sy + TopChatStrs.Count * 12;
      end;
      for i := ChatBoardTop to ChatBoardTop + {VIEWCHATLINE}(9-TopChatStrs.Count)-1 do begin
         if i > ChatStrs.Count-1 then break;
         fcolor := integer(ChatStrs.Objects[i]);
         bcolor := integer(ChatBks[i]);
         ClFunc.ChatTextOut (dsurface, sx, sy+(i-ChatBoardTop)*12, fcolor, bcolor, ChatStrs.Strings[i]);
      end;
   end;
end;   *)
{$ENDREGION}
{$REGION '老底部状态栏判断点像素是否透明 - 无用'}
(*procedure TFrmDlg.DBottomInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var
   d: TDirectDrawSurface;
begin
{$IF SWH = SWH800}
  {$IF M2Version = 2} //1.76
    d:=g_WMainImages.Images[1];
  {$ELSE}
  if g_boOpenHero then begin
    d:=g_WMain3Images.Images[BOTTOMBOARD800];
  end else begin
    d:=g_WMain3Images.Images[291];
  end;
  {$IFEND}
{$ELSEIF SWH = SWH1024}
  d:=g_WMainImages.Images[BOTTOMBOARD1024];
{$IFEND}
   if d <> nil then begin
      if d.Pixels[X, Y] > 0 then IsRealArea := TRUE
      else IsRealArea := FALSE;
   end;
end;   *)
{$ENDREGION}

procedure TFrmDlg.DMyStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.WLib <> nil then begin //20080701
        if d.Downed then begin
           dd := d.WLib.Images[d.FaceIndex];
           if dd <> nil then
              dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DBotGroupDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
  if Sender = DBotGroup then begin
    if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.WLib <> nil then begin //20080701
        if g_boAllowGroup then begin
          dd := d.WLib.Images[d.FaceIndex];
          if dd <> nil then begin
            dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
            DrawBlendEx(dsurface, d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd, 0, 0, d.Width, d.Height, 255);
          end;
        end else begin
          if d.WLib <> nil then begin //20080701
            if not d.Downed then begin
               dd := d.WLib.Images[d.FaceIndex];
               if dd <> nil then
                  dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
            end else begin
               dd := d.WLib.Images[d.FaceIndex+1];
               if dd <> nil then
                  dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
            end;
          end;
        end;
      end;
    end;
  end else begin
    if Sender is TDButton then begin
      d := TDButton(Sender);
      if d.WLib <> nil then begin //20080701
        if not d.Downed then begin
           dd := d.WLib.Images[d.FaceIndex];
           if dd <> nil then
              dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
        end else begin
           dd := d.WLib.Images[d.FaceIndex+1];
           if dd <> nil then
              dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBotPlusAbilDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDButton;
   dd: TDirectDrawSurface;
begin
   if Sender is TDButton then begin
      d := TDButton(Sender);
      if not d.Downed then begin
         if (BlinkCount mod 2 = 0) and (not DAdjustAbility.Visible) then dd := d.WLib.Images[d.FaceIndex]
         else dd := d.WLib.Images[d.FaceIndex + 2];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
      end else begin
         dd := d.WLib.Images[d.FaceIndex+1];
         if dd <> nil then
            dsurface.Draw (d.SurfaceX(d.GLeft), d.SurfaceY(d.GTop), dd.ClientRect, dd, TRUE);
      end;

      if GetTickCount - BlinkTime >= 500 then begin
         BlinkTime := GetTickCount;
         Inc (BlinkCount);
         if BlinkCount >= 10 then BlinkCount := 0;
      end;
   end;
end;

procedure TFrmDlg.DMyStateClick(Sender: TObject; X, Y: Integer);
begin
   if Sender = DMyState then begin
      StatePage := 0;
      {$IF M2Version <> 2}
      DPNewStateWinTab.ActivePage := 0;
      DPNewStateWinPage.ActivePage := 0;
      {$IFEND}
      OpenMyStatus;
   end;
   if Sender = DMyBag then OpenItemBag;
   if Sender = DMyMagic then begin
      StateTab := 0;
      StatePage := 3;
      {$IF M2Version <> 2}
      DPNewStateWinTab.ActivePage := 0;
      DPNewStateWinPage.ActivePage := 4;
      FrmDlg.DStateWinPulse.Visible := False;
      FrmDlg.DStateWinBatter.Visible := False;
      {$IFEND}
      OpenMyStatus;
   end;
   if Sender = DOption then DOptionClick;
end;

procedure TFrmDlg.DOptionClick();
var
  Ini: TIniFile;
  sFileName: String;
begin
  g_boSound := not g_boSound;
  if g_boSound then begin
    DScreen.AddChatBoardString ('[音效 开]',clWhite, clBlack);
  end else begin
    DScreen.AddChatBoardString ('[音效 关]',clWhite, clBlack);
  end;
  if frmMain.CharName <> '' then sFileName := g_ParamDir+format(SDOCONFIGFILE,[g_sServerName,frmMain.CharName,'SdoAssistant'])
    else sFileName:=g_ParamDir+format(CONFIGFILE,['Assistant']);

  if not DirectoryExists(g_ParamDir+'config') then  CreateDir(g_ParamDir+'config');

  if not DirectoryExists(g_ParamDir+format('config\Ly%s_%s',[g_sServerName,frmMain.CharName])) then
    CreateDir(g_ParamDir+format('config\Ly%s_%s',[g_sServerName,frmMain.CharName]));

  Ini:=TIniFile.Create(sFileName);
  Ini.WriteBool('Misc', 'PlaySound', g_boSound);
  Ini.Free;
end;
{------------------------------------------------------------------------}

// 骇飘

{------------------------------------------------------------------------}

procedure TFrmDlg.DBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  idx, n: Integer;
  d: TDirectDrawSurface;
  sText:string;
begin
  with Sender as TDButton do begin
    idx := Tag;
    if idx in [0..5] then begin
      if g_ItemArr[idx].Item.S.Name <> '' then begin
        d := frmMain.GetBagItemImg(g_ItemArr[idx].Item.S.Looks);
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft+(GWidth-d.Width) div 2), SurfaceY(GTop+(GHeight-d.Height) div 2), d.ClientRect, d, TRUE);
        if (g_ItemArr[idx].Item.S.StdMode = 17) and (g_ItemArr[idx].Item.S.Shape = 237) then begin
          sText := IntToStr(g_ItemArr[idx].Item.Dura);
          n := frmMain.Canvas.TextWidth(sText);
          dsurface.BoldTextOut(SurfaceX(GLeft+34)-n, SurfaceY(GTop), clLime, clBlack, sText);
        end;
      end;
    end;
    PomiTextOut (dsurface, SurfaceX(GLeft+13), SurfaceY(GTop+19), IntToStr(idx+1));
  end;
end;

procedure TFrmDlg.DBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx: integer;
begin
  //{$IF M2Version <> 2}
  DScreen.ClearHint;
  //{$IFEND}
  idx := TDButton(Sender).Tag;
  if idx in [0..5] then begin
    if g_ItemArr[idx].Item.S.Name <> '' then begin
      g_MouseItem := g_ItemArr[idx].Item;
      //{$IF M2Version <> 2}
      with Sender as TDButton do
        ShowMouseItemInfo(SurfaceX(GLeft),
                          SurfaceY(GTop), '', 1, True);
      //{$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DBelt1Click(Sender: TObject; X, Y: Integer);
var
   idx: integer;
   temp: TClientItem;
begin
   idx := TDButton(Sender).Tag;
   if idx in [0..5] then begin
      if not g_boItemMoving then begin
         if g_boHeroItemMoving then Exit;
         if g_ItemArr[idx].Item.S.Name <> '' then begin
            ItemClickSound (g_ItemArr[idx].Item.S);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := idx;
            g_MovingItem.Item := g_ItemArr[idx].Item;
            g_ItemArr[idx].Item.S.Name := '';
         end;
      end else begin
         if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
       	 if (g_MovingItem.Item.S.StdMode <= 3) or ((g_MovingItem.Item.S.StdMode = 60) and (g_MovingItem.Item.S.Shape <> 0)) or ((g_MovingItem.Item.S.StdMode = 17) and (g_MovingItem.Item.S.Shape = 237)) then begin
            if (g_MovingItem.Item.S.StdMode = 2) and (g_MovingItem.Item.S.Need = 1) then Exit;  //不允许放入的物品 20080331
            if g_ItemArr[idx].Item.S.Name <> '' then begin
               temp := g_ItemArr[idx].Item;
               g_ItemArr[idx].Item := g_MovingItem.Item;
               g_MovingItem.Index := idx;
               g_MovingItem.Item := temp;
            end else begin
              if (g_MovingItem.Index < 0) and (g_MovingItem.Index >= -14 {-9}) then begin  //装备物品
                //惑怕芒俊辑 啊规栏肺
                g_WaitingUseItem := g_MovingItem;
                FrmMain.SendTakeOffItem (-(g_MovingItem.Index+1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
                g_MovingItem.Item.S.name := '';
                g_boItemMoving := FALSE;
              end else begin
                g_ItemArr[idx].Item := g_MovingItem.Item;
                g_MovingItem.Item.S.name := '';
                g_boItemMoving := FALSE;
              end;
            end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DBelt1DblClick(Sender: TObject);
var
   idx: integer;
begin
   idx := TDButton(Sender).Tag;
   if idx in [0..5] then begin
      if g_ItemArr[idx].Item.S.Name <> '' then begin
         if (g_ItemArr[idx].Item.S.StdMode <= 4) or (g_ItemArr[idx].Item.S.StdMode = 31) or
         ((g_ItemArr[idx].Item.S.StdMode = 60) and (g_ItemArr[idx].Item.S.Shape <> 0)) or
         ((g_ItemArr[idx].Item.S.StdMode = 17) and (g_ItemArr[idx].Item.S.Shape = 237)) then begin //荤侩且 荐 乐绰 酒捞袍
             FrmMain.EatItem (idx);
         end;
      end else begin
         if g_boItemMoving and (g_MovingItem.Index = idx) and
           (g_MovingItem.Item.S.StdMode <= 4) or (g_MovingItem.Item.S.StdMode = 31) or
           ((g_ItemArr[idx].Item.S.StdMode = 60) and (g_ItemArr[idx].Item.S.Shape <> 0)) or
           ((g_ItemArr[idx].Item.S.StdMode = 17) and (g_ItemArr[idx].Item.S.Shape = 237))
         then begin
            if (g_ItemArr[idx].Item.S.StdMode = 2) and (g_ItemArr[idx].Item.S.Shape in [10..12]) then Exit;
            g_BeltIdx := idx; //双击 自动防药IDX 20080229
            FrmMain.EatItem (-1);
         end;
      end;
   end;
end;


{----------------------------------------------------------}
//物品信息   2007.10.17    
{----------------------------------------------------------}
procedure TFrmDlg.GetMouseItemInfo (var iname, iname1, line1, line2, line3, line4, line5, sUnKnow1, sUnKnow2: string; var useable: boolean; Who: Integer{1为主人,2为英雄}); // 2007.12.15 支持英雄

   function GetDuraStr (dura, maxdura: integer): string;
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura/1000)) + '/' + IntToStr(Round(maxdura/1000))
      else
         Result := IntToStr(Round(dura/1000));
   end;

   function GetDuraX10Str (dura, maxdura: integer): string;   //20080306 作用： 直接把两个整数返回STRING
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura*10)) + '/' + IntToStr(Round(maxdura*10))
      else
         Result := IntToStr(Round(dura*10));
   end;

   function GetDura100Str (dura, maxdura: integer): string;
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura/100)) + '/' + IntToStr(Round(maxdura/100))
      else
         Result := IntToStr(Round(dura/100));
   end;

   function GetDuraShowStr (dura, maxdura: integer): string;   //20080306 作用： 直接把两个整数返回STRING
   begin
      if not BoNoDisplayMaxDura then
         Result := IntToStr(Round(dura)) + '/' + IntToStr(Round(maxdura))
      else
         Result := IntToStr(Round(dura));
   end;
var
  sWgt, str:String;
  MouseItem : TClientItem; //20080222
begin
{$I GetMouseItemInfo.inc}
end;
//绘画人物背包
procedure TFrmDlg.DItemBagDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   //d0, d1, d2, d3, d4, d5, d6, d7: string;
   n: integer;
   //useable: Boolean;
   d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DItemBag do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;


         {$IF M2Version = 2} //1.76
         //GetMouseItemInfo (d0, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
         dsurface.BoldTextOut (SurfaceX(GLeft+64), SurfaceY(GTop+184), clWhite, clBlack,GetGoldStr(g_MySelf.m_nGold));
         if g_MouseItem.S.Name = '' then begin
            dsurface.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215), clWhite, clBlack,'ALT  + R 键刷新包裹');
         end;
         {$ELSE}
         dsurface.BoldTextOut (SurfaceX(GLeft+69), SurfaceY(GTop+210), clWhite, clBlack,GetGoldStr(g_MySelf.m_nGold));
         if (g_MouseItem.S.Name <> '元宝信息') and (g_MouseItem.MakeIndex <> 3000)
            and (g_MouseItem.Dura <> 3000) and (g_MouseItem.DuraMax <> 3000) then begin
            dsurface.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+240), clWhite, clBlack,'ALT  + R 键刷新包裹');
            dsurface.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+254), clWhite, clBlack,'Ctrl + 点击物品 放入英雄包裹');
         end;
         {$IFEND}
         {$IF M2Version <> 2} //not 1.76
         if (g_MouseItem.S.Name = '元宝信息') and (g_MouseItem.MakeIndex = 3000)
            and (g_MouseItem.Dura = 3000) and (g_MouseItem.DuraMax = 3000) then begin
            dsurface.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+242), clWhite, clBlack,g_sGameGoldName+'数量 ' + IntToStr(g_MySelf.m_nGameGold));
            dsurface.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+242+14), clWhite, clBlack,g_sGameGird+'数量 ' + IntToStr(g_MySelf.m_nGameGird));
            dsurface.BoldTextOut (SurfaceX(GLeft+74), SurfaceY(GTop+242+14*2), clWhite, clBlack,g_sGameDiaMond+'数量 ' + IntToStr(g_MySelf.m_nGameDiaMond));
            //d0 := '';
         end;
         {$IFEND}

         (*{$IF M2Version = 2}
         if d0 <> '' then begin
            n := FrmMain.Canvas.TextWidth (d0);

            dsurface.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215), clYellow, clBlack,d0);
            dsurface.BoldTextOut (SurfaceX(GLeft+70) + n, SurfaceY(GTop+215), clWhite, clBlack,d1);
            dsurface.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215+14), clWhite, clBlack,d2);
            if not useable then
            dsurface.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215+14*2), clRed, clBlack,d3)
            else dsurface.BoldTextOut (SurfaceX(GLeft+70), SurfaceY(GTop+215+14*2), clWhite, clBlack,d3);
         end;
         {$IFEND} *)
   end;
end;

procedure TFrmDlg.DItemsUpButDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DItemsUpBut do begin
      if WLib <> nil then begin //20080701
        if DItemsUpBut.Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DCloseBagDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DCloseBag do begin
      if WLib <> nil then begin //20080701
        if DCloseBag.Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DCloseBagClick(Sender: TObject; X, Y: Integer);
begin
   DItemBag.Visible := FALSE;
end;

procedure TFrmDlg.DItemGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  iname, d1, d2, d3, d4, d5 , d6, d7, hcolor: string;
  useable: Boolean;
  int: Byte;
begin
  DScreen.ClearHint;
   if ssRight in Shift then begin
      if g_boItemMoving then
         DItemGridGridSelect (self, ACol, ARow, Shift);
   end else begin
      idx := ACol + ARow * DItemGrid.ColCount + 6;
      if idx in [6..MAXBAGITEM-1] then begin
         if (g_ItemArr[idx].Item.S.StdMode = 17) and (ssShift in Shift) and (ssLeft in Shift) then begin//拆分物品 20090615
           if g_ItemArr[idx].Item.Dura > 1 then begin
             int := 0;
             DMessageDlg ('要拆分多少?', [mbOk, mbAbort]);
             if DlgEditText = '' then int := 1;
             if length(DlgEditText) > 5 then begin
               int := 3;
             end else begin
                if not IsStringNumber(DlgEditText) then int := 2;
             end;
             if int = 0 then begin
               if StrToInt(DlgEditText) >= g_ItemArr[idx].Item.Dura then int := 4;//输入大于等于数量时，不做处理
             end;
             case int of
               0: frmMain.SendItemNumUpdateValue(g_ItemArr[idx].Item.MakeIndex, StrToInt(DlgEditText), 0);
               1: DMessageDlg ('内容不能为空！', [mbOk]);
               2: DMessageDlg ('输入错误', [mbOk]);
               3: DMessageDlg ('数量不能超过5位', [mbOk]);
             end;
           end;
         end else begin
           g_MouseItem := g_ItemArr[idx].Item;
           //{$IF M2Version <> 2}
           with DItemGrid do
             ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                               SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
           //{$IFEND}
         end;
      end;
   end;
end;

procedure TFrmDlg.DItemGridGridSelect(Sender: TObject; ACol, ARow: Integer; Shift: TShiftState);
var
   idx, mi: integer;
   temp: TClientItem;
   TempIdx: Integer;
begin
  //20080803修正 英雄装备拿下点主人包里 物品重叠
  if (g_boHeroItemMoving) and (-g_MovingHeroItem.Index in [1..15]) then Exit;
{-------------------------------------------------------}
//从英雄包裹到主人包裹  2007.10.24
   if g_boHeroItemMoving then begin
     if g_MovingHeroItem.Item.S.Name <> '' then begin
      TempIdx := -(g_MovingHeroItem.Index);
       if not (TempIdx in [1..15]) then begin
         g_WaitingHeroUseItem := g_MovingHeroItem;
         FrmMain.SendItemToMasterBag(-(g_MovingHeroItem.Index+1), g_MovingHeroItem.Item.MakeIndex, g_MovingHeroItem.Item.S.Name);
         g_boHeroItemMoving := FALSE;
         g_MovingHeroItem.Item.S.Name:='';
         Exit; //20080331
       end;
     end;
   end;   
{-------------------------------------------------------------}
  idx := ACol + ARow * DItemGrid.ColCount + 6{骇飘傍埃};
  if idx in [6..MAXBAGITEM-1] then begin
    if ssCtrl in Shift then begin
      if (g_ItemArr[idx].Item.S.Name <> '') and not g_boItemMoving and (g_HeroSelf <> nil) then begin
        if g_ItemArr[idx].boLockItem then Exit;
        g_WaitingUseItem.Item := g_ItemArr[idx].Item;
        FrmMain.SendItemToHeroBag(idx, g_ItemArr[idx].Item.MakeIndex, g_ItemArr[idx].Item.S.Name);
        g_ItemArr[idx].Item.S.Name := '';
      end;
    end else begin
      if not g_boItemMoving then begin
        if g_ItemArr[idx].Item.S.Name <> '' then begin
          if g_ItemArr[idx].boLockItem then Exit;
          g_boItemMoving := TRUE;
          g_MovingItem.Index := idx;
          g_MovingItem.Item := g_ItemArr[idx].Item;
          g_ItemArr[idx].Item.S.Name := '';
          ItemClickSound (g_ItemArr[idx].Item.S);
        end;
      end else begin
         mi := g_MovingItem.Index;
         if mi > 0 then begin
           if g_ItemArr[idx].boLockItem then Exit;
         end;
         if (mi = -97) or (mi = -98) then Exit; //金币...
         if (mi < 0) and (mi >= -15 ) then begin  //装备物品
            g_WaitingUseItem := g_MovingItem;
            FrmMain.SendTakeOffItem (-(g_MovingItem.Index+1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
         end else begin
            if (mi <= -20) and (mi > -30) then //交易
               DealItemReturnBag (g_MovingItem.Item);
            if (mi <= -57) and (mi > -63) then //挑战物品
               ChallengeItemReturnBag (g_MovingItem.Item);
            if (mi <= -30) and (mi > -40) then //元宝寄售 20080316
               SellOffItemReturnBag (g_MovingItem.Item);
            if (mi <= -41) and (mi > -44) then begin//粹练返回包裹 20080506
               g_ItemsUpItem[(-mi-41)].S.Name := '';
            end;
            if (g_MovingItem.Index <= -72) and (g_MovingItem.Index > -82) then begin  //摆摊
              DelItemBagLock(g_MovingItem.Item);
              g_MovingItem.Item.S.name := '';
              g_boItemMoving := FALSE;
              Exit;
            end;
            {$IF M2Version <> 2}
            if g_MovingItem.Index = -255 then begin //灵媒
              g_WaitingUseItem := g_MovingItem;
              FrmMain.SendTakeOffLingMei (g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
              g_MovingItem.Item.S.name := '';
              g_boItemMoving := FALSE;
              Exit;
            end;
            {$IFEND}
            if g_ItemArr[idx].Item.S.Name <> '' then begin
               temp := g_ItemArr[idx].Item;
               g_ItemArr[idx].Item := g_MovingItem.Item;
               g_MovingItem.Index := idx;
               g_MovingItem.Item := temp;
            end else begin
               g_ItemArr[idx].Item := g_MovingItem.Item;
               g_MovingItem.Item.S.name := '';
               g_boItemMoving := FALSE;
            end;
         end;
         if (g_MovingItem.Item.S.StdMode = 17) and (g_ItemArr[idx].Item.S.StdMode = 17) and (g_MovingItem.Item.MakeIndex <> g_ItemArr[idx].Item.MakeIndex) then begin
           if (g_MergerItem.S.Name <> '') and (GetTickCount - g_dwMergerTime > 5000) then g_MergerItem.S.Name := '';
           if g_MergerItem.S.Name = '' then begin
             g_MergerItem := g_MovingItem.Item;
             g_MovingItem.Item.S.Name := '';
             g_dwMergerTime := GetTickCount;
             g_boItemMoving := False;
             frmMain.SendItemMakeOne(g_MergerItem.MakeIndex, g_ItemArr[idx].Item.MakeIndex, 0);
           end;
         end;
      end;
    end;
  end;
  ArrangeItemBag;
end;

procedure TFrmDlg.DItemGridDblClick(Sender: TObject);
var
   idx, where, I: integer;
   keyvalue: TKeyBoardState;
   cu: TClientItem;
begin
    g_BeltIdx := 50;  //20080305
   idx := DItemGrid.Col + DItemGrid.Row * DItemGrid.ColCount + 6;
   if idx in [6..MAXBAGITEM-1] then begin
      if g_ItemArr[idx].Item.S.Name <> '' then begin
         FillChar(keyvalue, sizeof(TKeyboardState), #0);
         GetKeyboardState (keyvalue);
         if keyvalue[VK_CONTROL] = $80 then begin
            cu := g_ItemArr[idx].Item;
            g_ItemArr[idx].Item.S.Name := '';
            AddItemBag (cu);
         end else
            if (g_ItemArr[idx].Item.S.StdMode <= 4) or (g_ItemArr[idx].Item.S.StdMode = 31) then begin
               if g_ItemArr[idx].boLockItem then Exit;
               FrmMain.EatItem (idx);
            end;
      end else begin
         if g_boItemMoving and (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index <> -98{20080320 防止复制装备}) then begin
            FillChar(keyvalue, sizeof(TKeyboardState), #0);
            GetKeyboardState (keyvalue);
            if keyvalue[VK_CONTROL] = $80 then begin
               cu := g_MovingItem.Item;
               g_MovingItem.Item.S.Name := '';
               g_boItemMoving := FALSE;
               AddItemBag (cu);
            end else
            {$IF M2Version = 1}
            if (g_MovingItem.Index = idx) and (g_MovingItem.Item.S.StdMode = 17) and (g_MovingItem.Item.S.Shape in [253..255]) then begin
              DScreen.AddChatBoardString('请放到英雄包裹使用！', GetRGB(219), ClWhite);
            end else
            {$IFEND}
            if (g_MovingItem.Index = idx) and
               (g_MovingItem.Item.S.StdMode <= 4) or (g_ItemArr[idx].Item.S.StdMode = 31)  or (g_MovingItem.Item.S.StdMode = 48{宝箱 2008.01.16}) or (g_MovingItem.Item.S.StdMode = 51{聚灵珠 2008.02.21}) or ((g_MovingItem.Item.S.StdMode = 60) and (g_MovingItem.Item.S.Shape <> 0))
            then begin
              if (g_ItemArr[idx].Item.S.StdMode = 2) and (g_ItemArr[idx].Item.S.Shape in [10..12]) then
              else  FrmMain.EatItem (-1);
            end else if (g_MovingItem.Index = idx) and (g_MovingItem.Item.S.StdMode in [17..18]) then begin
               if (g_ItemArr[idx].Item.Dura > 1) or //20110526 修改
                 ((g_ItemArr[idx].Item.Dura = 1) and (g_MovingItem.Item.S.StdMode = 17) and (g_MovingItem.Item.S.Shape = 237)) then begin
                 if g_MovingItem.Item.S.StdMode = 17 then FrmMain.EatItem (-1);
               end else if (g_ItemArr[idx].Item.Dura = 1) and (DWKimNeedle.Visible) and (not DStartKimNeedle.ShowHint) and (not DKimNeedleHelp.ShowHint) then begin
                 if g_MovingItem.Item.S.StdMode = 17 then begin
                   for I:=0 to 4 do begin
                     if (g_KimNeedleItem[I].S.Name = '') or (g_MovingItem.Item.S.Shape <> g_btKimItemOneLevel) then begin
                       case I of
                        0: DKimNeedle1Click(DKimNeedle1, 0, 0);
                        1: DKimNeedle1Click(DKimNeedle2, 0, 0);
                        2: DKimNeedle1Click(DKimNeedle3, 0, 0);
                        3: DKimNeedle1Click(DKimNeedle4, 0, 0);
                        4: DKimNeedle1Click(DKimNeedle5, 0, 0);
                       end;
                       Break;
                     end;
                   end;
                 end else begin
                   for I:=5 to 7 do begin
                     if (g_KimNeedleItem[I].S.Name = '') or (g_MovingItem.Item.S.Shape <> g_btKimItemOneLevel) then begin
                       case I of
                        5: DKimNeedle1Click(DKimNeedle6, 0, 0);
                        6: DKimNeedle1Click(DKimNeedle7, 0, 0);
                        7: DKimNeedle1Click(DKimNeedle8, 0, 0);
                       end;
                       Break;
                     end;
                   end;
                 end;
               end;
            end else begin
              //双击穿装备
              where := GetTakeOnPosition(g_MovingItem.Item.S.StdMode);
              if (where <> -1) then begin
                if where = U_RINGR then begin
                  if g_UseItems[U_RINGR].S.Name = '' then begin
                    where := U_RINGR;
                  end else
                  if g_UseItems[U_RINGL].S.Name = '' then begin
                    where := U_RINGL;
                  end else
                  if not g_boRightItemRingEmpty then begin
                    where := U_RINGR;
                    g_boRightItemRingEmpty := True;
                  end else begin
                    where := U_RINGL;
                    g_boRightItemRingEmpty := False;
                  end;
                end;
                if where = U_ARMRINGR then begin
                  if g_UseItems[U_ARMRINGR].S.Name = '' then begin
                    where := U_ARMRINGR;
                  end else
                  if g_UseItems[U_ARMRINGL].S.Name = '' then begin
                    where := U_ARMRINGL;
                  end else
                  if not g_boRightItemArmRingEmpty then begin
                    where := U_ARMRINGR;
                    g_boRightItemArmRingEmpty := True;
                  end else begin
                    where := U_ARMRINGL;
                    g_boRightItemArmRingEmpty := False;
                  end;
                end;
                g_WaitingUseItem.Item := g_MovingItem.Item;
                g_WaitingUseItem.Index := where;
                FrmMain.SendTakeOnItem(where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
                DelItemBag(g_MovingItem.Item.S.Name, g_MovingItem.Item.MakeIndex);
                g_MovingItem.Item.S.Name := '';
              end;
            end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DItemGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
var
  idx, ax, ay: integer;
  d: TDirectDrawSurface;
  wm: TWMImages;
begin
  idx := ACol + ARow * DItemGrid.ColCount + 6;
  if idx in [6..MAXBAGITEM-1] then begin
    if g_ItemArr[idx].Item.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_ItemArr[idx].Item.S.Looks);
      if d <> nil then begin
        with DItemGrid do  begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                         SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                         d.ClientRect, d, TRUE);
          if g_ItemArr[idx].Item.S.Name = '铁剑' then
          asm
            nop;
          end;

          //Modified By TasNat at: 2012-11-22 10:47:29
          if GetEffecItemList(g_ItemArr[idx].Item.S.Name).btBagCount > 0 then begin
            with GetEffecItemList(g_ItemArr[idx].Item.S.Name) do begin
              if GetTickCount - g_DrawBagItemsArr[idx].dwDrawTick >= 150 then begin
                g_DrawBagItemsArr[idx].dwDrawTick := GetTickCount;
                Inc(g_DrawBagItemsArr[idx].nIndex);
                if g_DrawBagItemsArr[idx].nIndex > btBagCount-1 then g_DrawBagItemsArr[idx].nIndex := 0;
              end;
              wm := GetItemEffectWil(btBagWilIndex);
              if wm <> nil then begin
                d := wm.GetCachedImage(wBagIndex+g_DrawBagItemsArr[idx].nIndex, ax, ay);
                if d <> nil then begin
                  DrawBlend(dsurface, SurfaceX(Rect.Left)+ax+nBagX, SurfaceY(Rect.Top)+ay+nBagY, d, 255);
                end;
              end;
            end;
          end else begin
            if g_ItemArr[idx].Item.S.Reserved1 = 1 then begin //发光 20080223
              ItemLightTimeImg();
              d := g_WMain2Images.Images[ItemLightImgIdx + 260];
              if d <> nil then
                DrawBlend(dsurface,SurfaceX(Rect.Left-21), SurfaceY(Rect.Top-23), d, 255);
            end;
          end;
          if g_ItemArr[idx].Item.S.StdMode = 17 then
               dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_ItemArr[idx].Item.Dura))), SurfaceY(Rect.Top+20), clWhite, InttoStr(g_ItemArr[idx].Item.Dura));
          if g_ItemArr[idx].boLockItem then begin
            d := g_WMainImages.Images[758];
            if d <> nil then begin
              dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                             SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                             d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGoldClick(Sender: TObject; X, Y: Integer);
begin
   if g_MySelf = nil then exit;
   if not g_boItemMoving then begin
      if g_MySelf.m_nGold > 0 then begin
         PlaySound (s_money);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -98; //捣
         g_MovingItem.Item.S.Name := g_sGoldName{'金币'};
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin //捣父..
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name := '';
         if g_MovingItem.Index = -97 then begin //背券芒俊辑 颗
            DealZeroGold;
         end;
      end;
   end;
end;

{------------------------------------------------------------------------}

//惑牢 措拳 芒

{------------------------------------------------------------------------}
procedure TFrmDlg.ShowMDlg (face: integer; mname, msgstr: string);
var
   i: integer;
begin
   DMerchantDlg.GLeft := 0;  //扁夯 困摹
   DMerchantDlg.GTop := 0;
   MerchantFace := face;
   MerchantName := mname;
   MDlgStr := msgstr;
   DMerchantDlg.Visible := TRUE;
   DHeroIcon.Visible:=false;//如果NPC对话框显示 那么英雄图标隐藏
   {$IF M2Version = 2} //1.76
   DItemBag.GLeft := 475;  //啊规困摹 函版
   DItemBag.GTop := 0;//20090304修改
   {$ELSE}
   DItemBag.GLeft := 440;  //啊规困摹 函版
   DItemBag.GTop := {-25}3;//20090304修改
   {$IFEND}
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (pTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   RequireAddPoints := TRUE;
   LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowMBigDlg (face: integer; mname, msgstr: string);
var
   i: integer;
begin
   DBigMerchantDlg.GLeft := 0;  //扁夯 困摹
   DBigMerchantDlg.GTop := 0;
   MerchantFace := face;
   MerchantName := mname;
   MDlgStr := msgstr;
   DMerchantDlg.Visible := False;
   DBigMerchantDlg.Visible := TRUE;
   DHeroIcon.Visible:=false;//如果NPC对话框显示 那么英雄图标隐藏
   {$IF M2Version = 2} //1.76
   DItemBag.GLeft := 475;  //啊规困摹 函版
   DItemBag.GTop := 0;//20090304修改
   {$ELSE}
   DItemBag.GLeft := 440;  //啊规困摹 函版
   DItemBag.GTop := {-25}3;//20090304修改
   {$IFEND}
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (pTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   RequireAddPoints := TRUE;
   LastestClickTime := GetTickCount;
end;


procedure TFrmDlg.ShowMouseItemInfo(X, Y: Integer; AddLine: string; who: Byte;
  DrawUp: Boolean);
var
  hcolor, iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  sItemInfo: string;
const
  sItemInfoFormat = '<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s';
begin
  GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, who);
  case who of
    1: g_MouseItem.S.Name := '';
    2: g_HeroMouseItem.S.Name := '';
  end;
  if iname <> '' then begin
    if not useable then hcolor := 'red' else hcolor := '';
    sItemInfo := Format(sItemInfoFormat, [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]);
    if AddLine <> '' then sItemInfo := sItemInfo + AddLine;
    DScreen.ShowSpecialHint(X, Y, sItemInfo, DrawUp);
  end;
end;

procedure TFrmDlg.ResetMenuDlg;
var
   i: integer;
begin
   CloseDSellDlg;
   if g_MenuItemList.Count > 0 then //20080629
   for i:=0 to g_MenuItemList.Count-1 do  //技何 皋春档 努府绢 窃.
      Dispose(pTClientItem(g_MenuItemList[i]));
   g_MenuItemList.Clear;

   if MenuList.Count > 0 then //20080629
   for i:=0 to MenuList.Count-1 do
      Dispose (PTClientGoods(MenuList[i]));
   MenuList.Clear;
   MenuIndex := -1;
   MenuTopLine := 0;
   BoDetailMenu := False;
   BoStorageMenu := False;
   BoMakeDrugMenu := False;

   DSellDlg.Visible := False;
   DMenuDlg.Visible := False;
   DWSellOffList.Visible := False; //元宝寄售列表不可见 20080318
   g_SellOffItemIndex := 200;
end;

procedure TFrmDlg.ShowShopMenuDlg;
begin
   MenuIndex := -1;
   if WinType=1 then//增加大窗口支持By TasNat at: 2012-11-08 09:44:27
   begin
     DMerchantDlg.GLeft := 0;
     DMerchantDlg.GTop := 0;
     DMerchantDlg.Visible := TRUE;
     DSellDlg.Visible := FALSE;
     DMenuDlg.GLeft := 0;
     DMenuDlg.GTop  := 176;
   end else
   begin
     DBigMerchantDlg.GLeft := 0;
     DBigMerchantDlg.GTop := 0;
     DBigMerchantDlg.Visible := TRUE;
     DSellDlg.Visible := FALSE;
     DMenuDlg.GLeft := 0;
     DMenuDlg.GTop  := DBigMerchantDlg.GHeight+1;
   end;
   {DMerchantDlg.GLeft := 0;
   DMerchantDlg.GTop := 0;
   DMerchantDlg.Visible := TRUE;
   DSellDlg.Visible := FALSE;
   DMenuDlg.GLeft := 0;
   DMenuDlg.GTop  := 176;  }
   DMenuDlg.Visible := TRUE;
   MenuTop := 0;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 475;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := 440;
   DItemBag.GTop := -25;
   {$IFEND}
   DItemBag.Visible := TRUE;
   LastestClickTime := GetTickCount;
end;

procedure TFrmDlg.ShowShopSellDlg;
begin
   if WinType=1 then
   begin
     DSellDlg.GLeft := 260;
     DSellDlg.GTop := 176;
   end else
   begin
     DSellDlg.GLeft := 260;
     DSellDlg.GTop := DBigMerchantDlg.GHeight+1;
   end;
   DSellDlg.Visible := TRUE;
   DMenuDlg.Visible := FALSE;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 475;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := 440;
   DItemBag.GTop := -25;
   {$IFEND}
   DItemBag.Visible := TRUE;
   LastestClickTime := GetTickCount;
   g_sSellPriceStr := '';
end;

procedure TFrmDlg.CloseMDlg;
var
   i: integer;
begin
   MDlgStr := '';
   DMerchantDlg.Visible := FALSE;
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (PTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 0;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := -5;
   DItemBag.GTop := {-25}69;//20090304修改
   {$IFEND}
   DMenuDlg.Visible := FALSE;
   CloseDSellDlg;
   DWSellOffList.Visible := False; //元宝寄售列表不可见 20080318
   DWSellOff.Visible := False;
   if g_HeroSelf <> nil then DHeroIcon.Visible := TRUE;//如果NPC对话框关闭 那么英雄图标显示
{******************************************************************************}
//酒馆
   DWiGetHero.Visible := False;
   DPlayDrink.Visible := False;

   DWPleaseDrink.Visible := False;
   if g_PDrinkItem[0].S.Name <> '' then begin
     AddItemBag(g_PDrinkItem[0]);
     g_PDrinkItem[0].S.Name := '';
   end;
   if g_PDrinkItem[1].S.Name <> '' then begin
     AddItemBag(g_PDrinkItem[1]);
     g_PDrinkItem[1].S.Name := '';
   end;
end;

procedure TFrmDlg.CloseMBigDlg;
var
   i: integer;
begin
   if not DBigMerchantDlg.Visible then Exit;
   MDlgStr := '';
   DBigMerchantDlg.Visible := FALSE;
   if MDlgPoints.Count > 0 then //20080629
   for i:=0 to MDlgPoints.Count-1 do
      Dispose (PTClickPoint (MDlgPoints[i]));
   MDlgPoints.Clear;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 0;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := -5;
   DItemBag.GTop := {-25}69;//20090304修改
   {$IFEND}
   DMenuDlg.Visible := FALSE;
   CloseDSellDlg;
   DWSellOffList.Visible := False; //元宝寄售列表不可见 20080318
   DWSellOff.Visible := False;
   if g_HeroSelf <> nil then DHeroIcon.Visible := TRUE;//如果NPC对话框关闭 那么英雄图标显示
{******************************************************************************}
//酒馆
   DWiGetHero.Visible := False;
   DPlayDrink.Visible := False;

   DWPleaseDrink.Visible := False;
   if g_PDrinkItem[0].s.Name <> '' then begin
     AddItemBag(g_PDrinkItem[0]);
     g_PDrinkItem[0].s.Name := '';
   end;
   if g_PDrinkItem[1].s.Name <> '' then begin
     AddItemBag(g_PDrinkItem[1]);
     g_PDrinkItem[1].s.Name := '';
   end;
end;

procedure TFrmDlg.CreateParams(var Params: TCreateParams);
  function RandomGetPass():string;
  var
    s,s1:string;
    I,i0:Byte;
  begin
    s:='123456789ABCDEFGHIJKLMNPQRSTUVWXYZ';
    s1:='';
    Randomize(); //随机种子
    for i:=0 to 5 do begin
      i0:=random(35);
      s1:=s1+copy(s,i0,1);
    end;
    Result := s1;
  end;
begin
  inherited CreateParams(Params);
  strpcopy(pChar(@Params.WinClassName),RandomGetPass);
end;

procedure TFrmDlg.CloseDSellDlg;
begin
  DSellDlg.Visible := FALSE;
  if g_SellDlgItem.S.Name <> '' then
    AddItemBag (g_SellDlgItem);
  g_SellDlgItem.S.Name := '';
end;

procedure TFrmDlg.DMerchantDlgShowText(Sender: TObject;
  dsurface: TDirectDrawSurface; Msg, SelectStr: string; X, Y: Word;
  Points: TList; var AddPoints: Boolean);
var
  str, data, fdata, cmdstr, cmdparam: string;
  lx, ly, sx: integer;
  pcp: PTClickPoint;
  Color: TColor;
  sColor, cmdtitle, sTemp: string;
begin
  lx := X;
  ly := Y;
  str := Msg;
  with Sender as TDWindow do begin
    while TRUE do begin
      if str = '' then break;
      str := GetValidStr3 (str, data, ['\']);
      if data <> '' then begin
        sx := 0;
        while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin
          fdata := '';
          if data[1] <> '<' then begin
            data := '<' + GetValidStr3 (data, fdata, ['<']);
          end;
          data := ArrestStringEx (data, '<', '>', cmdstr);//得到"<"和">" 号之间的字   赋予给 cmdstr
          if cmdstr <> '' then begin
            if Uppercase(cmdstr) = 'C' then begin
              continue;
            end;
            if UpperCase(cmdstr) = '/C' then begin
              continue;
            end;
            cmdparam := GetValidStr3 (cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
          end else begin
            DMenuDlg.Visible := FALSE;
            DSellDlg.Visible := FALSE;
          end;
          if fdata <> '' then begin
            dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clWhite, clBlack, fdata);
            sx := sx + FrmMain.Canvas.TextWidth(fdata);
          end;
          if (cmdstr <> '') then begin
            if (cmdparam <> '') then begin
              if CompareLStr(cmdparam, 'FCOLOR=', length('FCOLOR=')) then begin
                sColor := GetValidStr3(cmdparam, sTemp, ['=']);
                Color := GetRGB(Lobyte(Str_ToInt(sColor, 255)));
                dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), Color, clBlack, cmdstr)  //显示颜色文字
              end else begin
              	cmdtitle := '';
                if Pos('|', cmdparam) > 0 then begin
                  sTemp := GetValidStr3(cmdparam, cmdparam, ['|']);
                  if CompareLStr(sTemp, 'TITLE=', length('TITLE=')) then begin
                    cmdtitle := GetValidStr3(sTemp, sTemp, ['=']);
                  end;          
                end;
                if AddPoints then begin
                  new (pcp);
                  pcp.rc := Rect (lx+sx, ly, lx+sx + frmMain.Canvas.TextWidth(cmdstr), ly + 14);
                  pcp.RStr := cmdparam;
                  pcp.TStr := cmdtitle;
                  Points.Add (pcp);
                end;
                frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
                if SelectStr = cmdparam then begin
                  dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clRed, clBlack, cmdstr);
                end else dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clYellow, clBlack, cmdstr);
                frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];
              end;
          	end else begin
              frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
              if SelectStr = cmdparam then begin
                dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clRed, clBlack, cmdstr);
              end else dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clYellow, clBlack, cmdstr);
              frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];
            end;
          	sx := sx + FrmMain.Canvas.TextWidth(cmdstr);
          end;
        end;
        if data <> '' then
          dsurface.BoldTextOut (SurfaceX(GLeft+lx+sx), SurfaceY(GTop+ly), clWhite, clBlack, data);
       end;
       ly := ly + 16;
    end;
  end;
  AddPoints := FALSE;
end;

(*******************************************************************************
作用 :NPC脚本文字{功能}显示位置
过程 :
参数 :
*******************************************************************************)
procedure TFrmDlg.DMerchantDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDWindow do begin
     if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
     end;
    DMerchantDlgShowText(Sender, dsurface, MDlgStr, SelectMenuStr, 30, 20,
      MDlgPoints, RequireAddPoints);
   end;
end;

procedure TFrmDlg.DMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseMDlg;
   CloseMBigDlg;
end;

procedure TFrmDlg.DMenuDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  function SX(x: integer): integer;
  begin
      Result := DMenuDlg.SurfaceX (DMenuDlg.GLeft + x);
  end;
  function SY(y: integer): integer;
  begin
      Result := DMenuDlg.SurfaceY (DMenuDlg.GTop + y);
  end;
var
   i, lh,  m, menuline: integer;
   d: TDirectDrawSurface;
   pg: PTClientGoods;
   str: string;
begin
   with dsurface.Canvas do begin
      with DMenuDlg do begin
        if DMenuDlg.WLib <> nil then begin //20080701
         d := DMenuDlg.WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
      //title
      Font.Color := clWhite;
      if not BoStorageMenu then begin
         dsurface.TextOut (19,  SY(11), Font.Color, '物品列表');
         dsurface.TextOut (SX(156), SY(11), Font.Color, '价格');
         dsurface.TextOut (SX(245), SY(11), Font.Color, '持久');
         lh := LISTLINEHEIGHT;
         menuline := _MIN(MAXMENU, MenuList.Count-MenuTop);
         //惑前 府胶飘
         for i:=MenuTop to MenuTop+menuline-1 do begin
            m := i-MenuTop;
            if i = MenuIndex then begin
              Font.Color := clRed;
               dsurface.TextOut (SX(12),  SY(32 + m*lh), Font.Color, char(7));
            end else Font.Color := clWhite;
            pg := PTClientGoods (MenuList[i]);
            dsurface.TextOut (SX(19),  SY(32 + m*lh), Font.Color, pg.Name);
            //if pg.SubMenu >= 1 then
            //   ClFunc.TextOut (SX(137), SY(32 + m*lh), Font.Color, #31);
            dsurface.TextOut (SX(156), SY(32 + m*lh), Font.Color, IntToStr(pg.Price) + ' ' + g_sGoldName{金币'});
            str := '';
            if pg.Grade = -1 then str := '-'
            else dsurface.TextOut (SX(245), SY(32 + m*lh), Font.Color,IntToStr(pg.Grade));
         end;
      end else begin
         dsurface.TextOut (SX(19),  SY(11), Font.Color, '托管物品列表('+IntToStr(MenuList.Count)+'/44件)');
         dsurface.TextOut (SX(156), SY(11), Font.Color, '持久');
         //ClFunc.TextOut (SX(245), SY(11), Font.Color, '');
         lh := LISTLINEHEIGHT;
         menuline := _MIN(MAXMENU, MenuList.Count-MenuTop);
         //惑前 府胶飘
         for i:=MenuTop to MenuTop+menuline-1 do begin
            m := i-MenuTop;
            if i = MenuIndex then begin
               Font.Color := clRed;
               dsurface.TextOut (SX(12),  SY(32 + m*lh), Font.Color, char(7));
            end else Font.Color := clWhite;
            pg := PTClientGoods (MenuList[i]);
            dsurface.TextOut (SX(19),  SY(32 + m*lh), Font.Color, pg.Name);
            dsurface.TextOut (SX(156), SY(32 + m*lh), Font.Color, IntToStr(pg.Stock) + '/' + IntToStr(pg.Grade));
         end;
      end;
   end;
end;

procedure TFrmDlg.DMenuDlgClick(Sender: TObject; X, Y: Integer);
var
   lx, ly, idx: integer;
   iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
   useable: Boolean;
begin
   DScreen.ClearHint;
   lx := DMenuDlg.LocalX (X) - DMenuDlg.GLeft;
   ly := DMenuDlg.LocalY (Y) - DMenuDlg.GTop;
   if (lx >= 14) and (lx <= 279) and (ly >= 32) and (ly <= 160){ 2008.02.13} then begin
      idx := (ly-32) div LISTLINEHEIGHT + MenuTop;
      if idx < MenuList.Count then begin
         PlaySound (s_glass_button_click);
         MenuIndex := idx;
      end;
   end;

   if BoStorageMenu then begin
      if (MenuIndex >= 0) and (MenuIndex < g_SaveItemList.Count) then begin
         g_MouseItem := pTClientItem(g_SaveItemList[MenuIndex])^;
         lx := 240;
         ly := 32+(MenuIndex-MenuTop) * LISTLINEHEIGHT;
         with Sender as TDButton do
         	ShowMouseItemInfo(SurfaceX(GLeft)+lx, SurfaceY(GTop)+ly, '', 1, False);
      end;
   end else begin
      if (MenuIndex >= 0) and (MenuIndex < g_MenuItemList.Count) and (PTClientGoods (MenuList[MenuIndex]).SubMenu = 0) then begin
         g_MouseItem := pTClientItem(g_MenuItemList[MenuIndex])^;
         BoNoDisplayMaxDura := TRUE;
         GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
         BoNoDisplayMaxDura := FALSE;
         if iname <> '' then begin
            lx := 240;
            ly := 32+(MenuIndex-MenuTop) * LISTLINEHEIGHT;
            with Sender as TDButton do
               DScreen.ShowSpecialHint(SurfaceX(GLeft + lx),
                                 SurfaceY(GTop + ly),
                                 Format('<%s/c=Yellow>%s\%s\%s',[iname,d1,d2,d3]), FALSE);
         end;
         g_MouseItem.S.Name := '';
      end;
   end;
end;

procedure TFrmDlg.DMenuDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
   with DMenuDlg do
      if (X < SurfaceX(GLeft+10)) or (X > SurfaceX(GLeft+GWidth-20)) or (Y < SurfaceY(GTop+30)) or (Y > SurfaceY(GTop+GHeight-50)) then begin
         DScreen.ClearHint;
      end;
end;

procedure TFrmDlg.DMenuBuyClick(Sender: TObject; X, Y: Integer);
var
   pg: PTClientGoods;
begin
   if GetTickCount < LastestClickTime then exit; 
   if (MenuIndex >= 0) and (MenuIndex < MenuList.Count) then begin
      pg := PTClientGoods (MenuList[MenuIndex]);
      LastestClickTime := GetTickCount + 5000;
      if pg.SubMenu > 0 then begin
         FrmMain.SendGetDetailItem (g_nCurMerchant, 0, pg.Name);
         MenuTopLine := 0;
         CurDetailItem := pg.Name;
      end else begin
         if BoStorageMenu then begin
            FrmMain.SendTakeBackStorageItem (g_nCurMerchant, pg.Price{MakeIndex}, pg.Name);
            exit;
         end;
         if BoMakeDrugMenu then begin
            FrmMain.SendMakeDrugItem (g_nCurMerchant, pg.Name);
            exit;
         end;
         FrmMain.SendBuyItem (g_nCurMerchant, pg.Stock, pg.Name)
      end;
   end;
end;

procedure TFrmDlg.DMenuPrevClick(Sender: TObject; X, Y: Integer);
begin
   if not BoDetailMenu then begin
      if MenuTop > 0 then Dec (MenuTop, MAXMENU-1);
      if MenuTop < 0 then MenuTop := 0;
   end else begin
      if MenuTopLine > 0 then begin
         MenuTopLine := _MAX(0, MenuTopLine-10);
         FrmMain.SendGetDetailItem (g_nCurMerchant, MenuTopLine, CurDetailItem);
      end;
   end;
end;

procedure TFrmDlg.DMenuNextClick(Sender: TObject; X, Y: Integer);
begin
   if not BoDetailMenu then begin
      if MenuTop + MAXMENU < MenuList.Count then Inc (MenuTop, MAXMENU-1);
   end else begin
      MenuTopLine := MenuTopLine + 10;
      FrmMain.SendGetDetailItem (g_nCurMerchant, MenuTopLine, CurDetailItem);
   end;      
end;

procedure TFrmDlg.SoldOutGoods (itemserverindex: integer);
var
   i: integer;
   pg: PTClientGoods;
begin
   if MenuList.Count > 0 then //20080629
   for i:=0 to MenuList.Count-1 do begin
      pg := PTClientGoods (MenuList[i]);
      if (pg.Grade >= 0) and (pg.Stock = itemserverindex) then begin
         Dispose (pg);
         MenuList.Delete (i);
         if i < g_MenuItemList.Count then g_MenuItemList.Delete (i);
         if MenuIndex > MenuList.Count-1 then MenuIndex := MenuList.Count-1;
         break;
      end;
   end;
end;

procedure TFrmDlg.DelStorageItem (itemserverindex: integer);
var
   i: integer;
   pg: PTClientGoods;
begin
   if MenuList.Count > 0 then //20080629
   for i:=0 to MenuList.Count-1 do begin
      pg := PTClientGoods (MenuList[i]);
      if (pg.Price = itemserverindex) then begin //焊包格废牢版款 Price = ItemServerIndex烙.
         Dispose (pg);
         MenuList.Delete (i);
         if i < g_SaveItemList.Count then g_SaveItemList.Delete (i);
         if MenuIndex > MenuList.Count-1 then MenuIndex := MenuList.Count-1;
         break;
      end;
   end;
end;

procedure TFrmDlg.DMenuCloseClick(Sender: TObject; X, Y: Integer);
begin
   DMenuDlg.Visible := FALSE;
end;

function TFrmDlg.DMerchantDlgSelect(const RStr, sTitle: string;
  var LStr: string): Boolean;
var
  msg: TDefaultMessage;
  param: string;
  I: Integer;
  ssTitle: string;
begin
  Result := False;
  LStr := RStr;
  {$IF M2Version <> 2}
  if CompareText(LStr, '@^SHOWKAMPODLG') = 0 then begin
    if g_boOpenLeiMei then begin
      m_btSignedItemsPage := 0;
      DBSignedBelt1.Visible := True;
      DBSignedBelt2.Visible := True;
      DBOrdSigned.Visible := True;
      DBHighSigned.Visible := True;
      DBSignedChange.Visible := False;
      DWSignedItems.Visible := True;
    end;
  end else if CompareText(LStr, '@^OPENMAKEANDSCROLLDLG') = 0 then begin
    if g_boOpenLeiMei then begin
      if not DWMakeSigned.Visible then begin
        msg := MakeDefaultMsg (aa(CM_OPENSCROLLFRM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket(EncodeMessage (msg));
        DWMakeSigned.Visible := True;
      end;
    end;
  end else begin{$IFEND}
    param := '';
    if sTitle = '' then ssTitle := '输入信息' else ssTitle := sTitle;
    if Length(LStr) >= 2 then begin  //颇扼皋鸥啊 鞘夸茄 版快啊 乐澜.
      if (LStr[1] = '@') and (LStr[2] = '@') then begin
        if LStr = '@@buildguildnow' then begin
          FrmDlg.DMessageDlg ('请输入建立这个行会名称.', [mbOk, mbAbort]);
        end else
        if LStr = '@@buildDivisionnow' then begin
          FrmDlg.DMessageDlg ('请输入自创师门的门派名称（一旦确定无法更改）：', [mbOk, mbAbort]);
        end else
        if Pos('@@InPutString',LStr) > 0 then begin
        	EdDlgEdit.MaxLength := 80;
          if mrOk = FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort, mbCancel]) then begin
            EdDlgEdit.MaxLength := 30;
            if (Trim (FrmDlg.DlgEditText) = '') then begin
              FrmDlg.DMessageDlg ('信息不能为空！', [mbOk]);
              Exit;
            end;
            for I:=1 to length(FrmDlg.DlgEditText) do begin
              if FrmDlg.DlgEditText[i] in ['/','\'] then begin
                FrmDlg.DMessageDlg ('输入数据中包含了非法符号，请重新输入！', [mbOk]);
                Exit;
              end;
            end;
          end else begin
            EdDlgEdit.MaxLength := 30;
            Exit;
          end;
        end else
        if Pos('@@InPutInteger',LStr) > 0 then begin
          if mrCancel = FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort, mbCancel]) then Exit;
          if (Trim (FrmDlg.DlgEditText) = '') then begin
            FrmDlg.DMessageDlg ('信息不能为空！', [mbOk]);
            Exit;
          end;
          for I:=1 to length(FrmDlg.DlgEditText) do begin
            if not (FrmDlg.DlgEditText[i] in ['0'..'9']) then begin
              FrmDlg.DMessageDlg ('输入数据中包含了非法符号，请重新输入！', [mbOk]);
              Exit;
            end;
          end;
          if (StrToInt(FrmDlg.DlgEditText) > 2147483646) then begin
            FrmDlg.DMessageDlg ('输入数字范围必须在0到21亿之间，请重新输入！', [mbOk]);
            Exit;
          end;
        end else
        if Pos('@@SendMsg',LStr) > 0 then begin
        	EdDlgEdit.MaxLength := 80;
          if mrOk = FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort, mbCancel]) then begin
          	EdDlgEdit.MaxLength := 30;
            if (Trim (FrmDlg.DlgEditText) = '') then begin
              FrmDlg.DMessageDlg ('信息不能为空！', [mbOk]);
              Exit;
            end;
            for I:=1 to length(FrmDlg.DlgEditText) do begin
              if FrmDlg.DlgEditText[i] in ['/','\'] then begin
                FrmDlg.DMessageDlg ('输入数据中包含了非法符号，请重新输入！', [mbOk]);
                Exit;
              end;
            end;
          end else begin
          	EdDlgEdit.MaxLength := 30;
            Exit;
          end;
        end else FrmDlg.DMessageDlg (ssTitle, [mbOk, mbAbort]);
        param := Trim (FrmDlg.DlgEditText);
        LStr := LStr + #13 + param;
      end;
    end;
    Result := True;
  {$IF M2Version <> 2}
  end;
  {$IFEND}
end;

procedure TFrmDlg.DMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  msg: TDefaultMessage;
  sData: string;
begin
   if GetTickCount < LastestClickTime then exit;
   L := DMerchantDlg.GLeft;
   T := DMerchantDlg.GTop;
   with DMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            PlaySound (s_glass_button_click);
            if DMerchantDlgSelect(p.RStr, p.TStr, sData) then FrmMain.SendMerchantDlgSelect(g_nCurMerchant, sData);
            LastestClickTime := GetTickCount + 2000; //20080803修改 以前为5000
            break;
         end;
      end;
end;

procedure TFrmDlg.DMerchantDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   if GetTickCount < LastestClickTime then exit; 
   SelectMenuStr := '';
   L := DMerchantDlg.GLeft;
   T := DMerchantDlg.GTop;
   with DMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
   if DHeroIcon.Visible then DHeroIcon.Visible := False;  //20080521
end;

procedure TFrmDlg.DMerchantDlgMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
   SelectMenuStr := '';
end;

procedure TFrmDlg.DSellDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   actionname: string;
begin
   with DSellDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         actionname := '';
         case SpotDlgMode of
            dmSell:   actionname := '出售: ';
            dmRepair: actionname := '修理: ';
            dmStorage: actionname := ' 保管物品';
            dmPlayDrink: actionname := '请酒';  //20080515
            {$IF M2Version <> 2}
            dmArmsTear: actionname := '拆分: ';//20100708
            {$IFEND}
         end;
         dsurface.TextOut (SurfaceX(GLeft+8), SurfaceY(GTop+6), clWhite, actionname + g_sSellPriceStr);
   end;
end;

procedure TFrmDlg.DSellDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   CloseDSellDlg;
end;

procedure TFrmDlg.DSellDlgSpotClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
begin
   g_sSellPriceStr := '';
   if not g_boItemMoving then begin
      if g_SellDlgItem.S.Name <> '' then begin
         ItemClickSound (g_SellDlgItem.S);
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -99; //sell 芒俊辑 唱咳..
         g_MovingItem.Item := g_SellDlgItem;
         g_SellDlgItem.S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -99) then begin //啊规,骇飘俊辑 柯巴父
         ItemClickSound (g_MovingItem.Item.S);
         if g_SellDlgItem.S.Name <> '' then begin //磊府俊 乐栏搁
            temp := g_SellDlgItem;
            g_SellDlgItem := g_MovingItem.Item;
            g_MovingItem.Index := -99; //sell 芒俊辑 唱咳..
            g_MovingItem.Item := temp
         end else begin
            g_SellDlgItem := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
         end;
         g_boQueryPrice := TRUE;
         g_dwQueryPriceTime := GetTickCount;
      end;
   end;
end;

procedure TFrmDlg.DSellDlgSpotDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   if g_SellDlgItem.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_SellDlgItem.S.Looks);
      if d <> nil then
         with DSellDlgSpot do
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect,
                           d, TRUE);
   end;
end;

//卖物品时放物品的那个框框
procedure TFrmDlg.DSellDlgSpotMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   g_MouseItem := g_SellDlgItem;
end;

//卖物品的确定按钮
procedure TFrmDlg.DSellDlgOkClick(Sender: TObject; X, Y: Integer);
begin
   if (g_SellDlgItem.S.Name = '') and (g_SellDlgItemSellWait.S.Name = '') then exit;
   if GetTickCount < LastestClickTime then exit; 
   case SpotDlgMode of
      dmSell: FrmMain.SendSellItem (g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);
      dmRepair: FrmMain.SendRepairItem (g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);
      dmStorage: FrmMain.SendStorageItem (g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);
      dmPlayDrink: FrmMain.SendPlayDrinkItem(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);
      {$IF M2Version <> 2}
      dmArmsTear: FrmMain.SendArmsTear(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);//20100708
      dmArmsExchange: begin
        if mrOk = FrmDlg.DMessageDlg ('你确定要把这件装备兑换成卷轴碎片吗？兑换成功后，你的这件装备将消\失 ，不可赎回！', [mbOk, mbCancel]) then begin
          frmMain.SendArmsExchange(g_nCurMerchant, g_SellDlgItem.MakeIndex, g_SellDlgItem.S.Name);
        end else Exit;
      end;
      {$IFEND}
   end;
   g_SellDlgItemSellWait := g_SellDlgItem;
   g_SellDlgItem.S.Name := '';
   LastestClickTime := GetTickCount + 5000;
   g_sSellPriceStr := '';
end;

procedure TFrmDlg.SetChatDlgHeight(Value: Integer);
var
  nHeight: Integer;
begin
  DWBottomCenter.GHeight := Value;
  DWBottomCenter.GTop := SCREENHEIGHT - DWBottomCenter.GHeight;

  nHeight := (DWBottomCenter.GHeight - 54 - 16 - 32);
  DChatMemo.DrawLineCount := (nHeight div 12);
  if nHeight mod 12 > 0 then
    DChatMemo.DrawLineCount := DChatMemo.DrawLineCount + 1;
  DChatMemo.GHeight := nHeight;
  DChatMemo.DoResize;
  if DWBottomCenter.GHeight - (DChatMemo.GTop + DChatMemo.GHeight) < 20 then begin
    DChatMemo.DrawLineCount := DChatMemo.DrawLineCount - 1;
    DChatMemo.GHeight := nHeight;
    DChatMemo.DoResize;
  end;
end;

procedure TFrmDlg.SetMagicKeyDlg (icon: integer; Effect, Level, LevelEx: Byte; MagID: Word; magname: string; var curkey: word);
var
  d: TDirectDrawSurface;
begin
   MagKeyIcon := icon;
   MagKeyMagName := magname;
   MagKeyCurKey := curkey;
   MagKeyEffect := Effect;
   MagKeyID := MagID;
   MagKeyLevel := Level;
   MagKeyLevelEx := LevelEx;

   d := g_WMain3Images.Images[126];
   DKeySelDlg.GLeft := (SCREENWIDTH - d.Width) div 2;
   DKeySelDlg.GTop  := (SCREENHEIGHT - d.Height) div 2;
   HideAllControls;
   DKeySelDlg.ShowModal;

   while TRUE do begin
      if not DKeySelDlg.Visible then break;
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then exit;
   end;

   RestoreHideControls;
   curkey := MagKeyCurKey;
end;

procedure TFrmDlg.DKeySelDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DKeySelDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      dsurface.TextOut (SurfaceX(GLeft + 95), SurfaceY(GTop + 38), clSilver ,MagKeyMagName + '  快捷键盘被设置为.');
   end;
end;



procedure TFrmDlg.DKsIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   wm: TWMImages;
begin
   with DksIcon do begin
      wm := GetMagicIcon(MagKeyEffect, MagKeyLevel, MagKeyID, MagKeyLevelEx, MagKeyIcon);
      if wm <> nil then begin
        d := wm.Images[MagKeyIcon];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;



procedure TFrmDlg.DKsF1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   b: TDButton;
   d: TDirectDrawSurface;
begin
   case MagKeyCurKey of
      word('1'): b := DKsF1;
      word('2'): b := DKsF2;
      word('3'): b := DKsF3;
      word('4'): b := DKsF4;
      word('5'): b := DKsF5;
      word('6'): b := DKsF6;
      word('7'): b := DKsF7;
      word('8'): b := DKsF8;
      word('E'): b := DKsConF1;
      word('F'): b := DKsConF2;
      word('G'): b := DKsConF3;
      word('H'): b := DKsConF4;
      word('I'): b := DKsConF5;
      word('J'): b := DKsConF6;
      word('K'): b := DKsConF7;
      word('L'): b := DKsConF8;
      else b := DKsNone;
   end;
   if b = Sender then begin
      with b do begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex+1];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
   with Sender as TDButton do begin
      if Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;



procedure TFrmDlg.DKsOkClick(Sender: TObject; X, Y: Integer);
begin
   DKeySelDlg.Visible := FALSE;
end;





procedure TFrmDlg.DKsF1Click(Sender: TObject; X, Y: Integer);
begin
   if Sender = DKsF1 then MagKeyCurKey := integer('1');
   if Sender = DKsF2 then MagKeyCurKey := integer('2');
   if Sender = DKsF3 then MagKeyCurKey := integer('3');
   if Sender = DKsF4 then MagKeyCurKey := integer('4');
   if Sender = DKsF5 then MagKeyCurKey := integer('5');
   if Sender = DKsF6 then MagKeyCurKey := integer('6');
   if Sender = DKsF7 then MagKeyCurKey := integer('7');
   if Sender = DKsF8 then MagKeyCurKey := integer('8');
   if Sender = DKsConF1 then MagKeyCurKey := integer('E');
   if Sender = DKsConF2 then MagKeyCurKey := integer('F');
   if Sender = DKsConF3 then MagKeyCurKey := integer('G');
   if Sender = DKsConF4 then MagKeyCurKey := integer('H');
   if Sender = DKsConF5 then MagKeyCurKey := integer('I');
   if Sender = DKsConF6 then MagKeyCurKey := integer('J');
   if Sender = DKsConF7 then MagKeyCurKey := integer('K');
   if Sender = DKsConF8 then MagKeyCurKey := integer('L');
   if Sender = DKsNone then MagKeyCurKey := 0;
end;

procedure TFrmDlg.DBotMiniMapClick(Sender: TObject; X, Y: Integer);
begin
  if not g_boViewMiniMap then begin
    if GetTickCount > g_dwQueryMsgTick then begin
       g_dwQueryMsgTick := GetTickCount + 3000;
       FrmMain.SendWantMiniMap;
       g_nViewMinMapLv:=1;
       DWMiniMap.GLeft := SCREENWIDTH - 120; //20080323
       DWMiniMap.GWidth := 120; //20080323
       DWMiniMap.GHeight:= 120; //20080323
    end;
  end else begin
   if g_nViewMinMapLv >= 2 then begin
     g_nViewMinMapLv:=0;
     g_boViewMiniMap := FALSE;
     DWMiniMap.Visible := False; //20080323
   end else begin
     Inc(g_nViewMinMapLv);
     DWMiniMap.GLeft := SCREENWIDTH - 200; //20080323
     DWMiniMap.GWidth := 200; //20080323
     DWMiniMap.GHeight:= 200; //20080323
   end;
  end;
end;

procedure TFrmDlg.DBotTradeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendDealTry;
   end;
end;

procedure TFrmDlg.DBotGuildClick(Sender: TObject; X, Y: Integer);
begin
  if DGuildDlg.Visible then begin
  	DGuildDlg.Visible := FALSE;
  end else if GetTickCount > g_dwQueryMsgTick then begin
  	g_dwQueryMsgTick := GetTickCount + 3000;
  	FrmMain.SendGuildDlg;
  end;
end;

procedure TFrmDlg.DBotGroupClick(Sender: TObject; X, Y: Integer);
begin
   ToggleShowGroupDlg;
end;

procedure TFrmDlg.ToggleShowGroupDlg;
begin
   DGroupDlg.Visible := not DGroupDlg.Visible;
end;

procedure TFrmDlg.DGroupDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   lx, ly, n: integer;
begin
   with DGroupDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if g_GroupMembers.Count > 0 then begin
        lx := SurfaceX(28) + GLeft;
        ly := SurfaceY(80) + GTop;
        dsurface.TextOut (lx, ly, clSilver, g_GroupMembers[0]);
        if g_GroupMembers.Count > 0 then //20080629
        for n:=1 to g_GroupMembers.Count-1 do begin
           lx := SurfaceX(28) + GLeft + ((n-1) mod 2) * 100;
           ly := SurfaceY(80 + 16) + GTop + ((n-1) div 2) * 16;
           dsurface.TextOut (lx, ly, clSilver, g_GroupMembers[n]);
        end;
      end;
   end;
end;

procedure TFrmDlg.DGrpDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
   DGroupDlg.Visible := FALSE;
end;

procedure TFrmDlg.DGrpAllowGroupDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if Downed then begin
           d := WLib.Images[FaceIndex-1];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           if g_boAllowGroup then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then
                 dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
           end;
        end;
      end;
   end;
end;

procedure TFrmDlg.DGrpAllowGroupClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChangeGroupModeTick then begin
      g_boAllowGroup := not g_boAllowGroup;
      g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
      FrmMain.SendGroupMode (g_boAllowGroup);
   end;
end;

procedure TFrmDlg.DGrpCreateClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count = 0) then begin
      DialogSize := 1;
      DMessageDlg ('输入想加入编组人物名称.', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
         FrmMain.SendCreateGroup (Trim (DlgEditText));
      end;
   end;
end;

procedure TFrmDlg.DGrpAddMemClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count > 0) then begin
      DialogSize := 1;
      DMessageDlg ('输入想加入编组人物名称.', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
         FrmMain.SendAddGroupMember (Trim (DlgEditText));
      end;
   end;
end;

procedure TFrmDlg.DGrpDelMemClick(Sender: TObject; X, Y: Integer);
var
   who: string;
begin
   if (GetTickCount > g_dwChangeGroupModeTick) and (g_GroupMembers.Count > 0) then begin
      DialogSize := 1;
      DMessageDlg ('输入想退出编组人物名称.', [mbOk, mbAbort]);
      who := Trim (DlgEditText);
      if who <> '' then begin
         g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
         FrmMain.SendDelGroupMember (Trim (DlgEditText));
      end;
   end;
end;

procedure TFrmDlg.DBotLogoutClick(Sender: TObject; X, Y: Integer);
begin
               //强行退出
               g_dwLatestStruckTick:=GetTickCount() + 10001;
               g_dwLatestMagicTick:=GetTickCount() + 10001;
               g_dwLatestHitTick:=GetTickCount() + 10001;
               //
   if (GetTickCount - g_dwLatestStruckTick > 10000) and
      (GetTickCount - g_dwLatestMagicTick > 10000) and
      (GetTickCount - g_dwLatestHitTick > 10000) or
      (g_MySelf.m_boDeath) then begin
      FrmMain.AppLogOut(True);
   end else
      DScreen.AddChatBoardString ('攻击状态不能退出游戏.', clYellow, clRed);
end;

procedure TFrmDlg.DBotExitClick(Sender: TObject; X, Y: Integer);
begin
 {              //强行退出
               g_dwLatestStruckTick:=GetTickCount() + 10001;
               g_dwLatestMagicTick:=GetTickCount() + 10001;
               g_dwLatestHitTick:=GetTickCount() + 10001;
               //
   if (GetTickCount - g_dwLatestStruckTick > 10000) and
      (GetTickCount - g_dwLatestMagicTick > 10000) and
      (GetTickCount - g_dwLatestHitTick > 10000) or
      (g_MySelf.m_boDeath) then begin
      FrmMain.AppExit;
   end else
      DScreen.AddChatBoardString ('攻击状态不能退出游戏.', clYellow, clRed); }
   frmMain.Close;
end;

procedure TFrmDlg.DBotPlusAbilClick(Sender: TObject; X, Y: Integer);
begin
   FrmDlg.OpenAdjustAbility;
end;

{******************************************************************************}
//打开交易对话框
procedure TFrmDlg.OpenDealDlg;
begin
   DDealRemoteDlg.GLeft := SCREENWIDTH-236-100;
   DDealRemoteDlg.GTop := 0;
   DDealDlg.GLeft := SCREENWIDTH-236-100;
   {$IF M2Version = 2}//1.76
   DItemBag.GLeft := 0;
   DItemBag.GTop := 0;
   {$ELSE}
   DItemBag.GLeft := -5; //475;
   DItemBag.GTop := {-25}69;//20090304修改
   {$IFEND}
   DItemBag.Visible := TRUE;
   DDealRemoteDlg.Visible := TRUE;
   DDealDlg.GTop  := DDealRemoteDlg.GHeight-15;
   DDealDlg.Visible := TRUE;


   FillCHar (g_DealItems, sizeof(TClientItem)*10, #0);
   FillCHar (g_DealRemoteItems, sizeof(TClientItem)*20, #0);
   g_nDealGold := 0;
   g_nDealRemoteGold := 0;
   g_boDealEnd := FALSE;
   ArrangeItembag;
end;
{******************************************************************************}
//打开挑战对话框
procedure TFrmDlg.OpenChallengeDlg;
begin
   DWChallenge.GLeft := 544;
   DWChallenge.GTop := 0;
   DItemBag.GLeft := -5; //475;
   DItemBag.GTop := {-25}69;//20090304修改
   DItemBag.Visible := TRUE;
   DWChallenge.Visible := TRUE;

   FillCHar (g_ChallengeItems, sizeof(TClientItem)*4, #0);
   FillCHar (g_ChallengeRemoteItems, sizeof(TClientItem)*4, #0);
   g_nChallengeGold := 0;
   g_nChallengeRemoteGold := 0;
   g_nChallengeDiamond := 0;
   g_nChallengeRemoteDiamond := 0;
   g_boChallengeEnd := FALSE;
   ArrangeItembag;
end;
procedure TFrmDlg.CloseChallengeDlg;
begin
   DWChallenge.Visible := FALSE;
   ArrangeItembag;
end;
{******************************************************************************}
procedure TFrmDlg.CloseDealDlg;
begin
   DDealDlg.Visible := FALSE;
   DDealRemoteDlg.Visible := FALSE;
   ArrangeItembag;
end;

procedure TFrmDlg.DDealOkClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
   if GetTickCount > g_dwDealActionTick then begin
      //CloseDealDlg;
      FrmMain.SendDealEnd;
      g_dwDealActionTick := GetTickCount + 4000;
      g_boDealEnd := TRUE;
      if g_boItemMoving then begin
         mi := g_MovingItem.Index;
         if (mi <= -20) and (mi > -30) then begin
            AddDealItem (g_MovingItem.Item);
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DDealCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwDealActionTick then begin
      CloseDealDlg;
      FrmMain.SendCancelDeal;
   end;
end;

procedure TFrmDlg.DDealRemoteDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DDealRemoteDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         dsurface.TextOut (SurfaceX(GLeft+64), SurfaceY(GTop+196-65), clWhite, GetGoldStr(g_nDealRemoteGold));
         dsurface.TextOut (SurfaceX(GLeft+59 + (106-FrmMain.Canvas.TextWidth(g_sDealWho)) div 2), SurfaceY(GTop+3)+3, clWhite, g_sDealWho);
   end;
end;

procedure TFrmDlg.DDealDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   with DDealDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         dsurface.TextOut (SurfaceX(GLeft+64), SurfaceY(GTop+196-65), clWhite, GetGoldStr(g_nDealGold));
         dsurface.TextOut (SurfaceX(GLeft+59 + (106-FrmMain.Canvas.TextWidth(FrmMain.CharName)) div 2), SurfaceY(GTop+3)+3, clWhite, FrmMain.CharName);
   end;
end;

procedure TFrmDlg.DealItemReturnBag (mitem: TClientItem);
begin
   if not g_boDealEnd then begin
      g_DealDlgItem := mitem;
      FrmMain.SendDelDealItem (g_DealDlgItem);
      g_dwDealActionTick := GetTickCount + 4000;
   end;
end;
//挑战物品返回包裹 20080705
procedure TFrmDlg.ChallengeItemReturnBag (mitem: TClientItem);
begin
   if not g_boChallengeEnd then begin
      g_ChallengeDlgItem := mitem;
      FrmMain.SendDelChallengeItem (g_ChallengeDlgItem);
      g_dwChallengeActionTick := GetTickCount + 4000;
   end;
end;

procedure TFrmDlg.ChangeProPage(nPage: Byte);
begin
  case nPage of
    0: begin
      //DScrollBoxPro.DScroll.First;
      DCBBookHPMan.GTop := 37-DScrollBoxPro.DScroll.Position;
      DCBBookMPMan.GTop := 61-DScrollBoxPro.DScroll.Position;
      if not DScrollBoxPro.InSuItem(DCBBookHPMan) then
      DScrollBoxPro.AddSuItem(DScrollBoxPro.Add, DCBBookHPMan);
      if not DScrollBoxPro.InSuItem(DCBBookMPMan) then
      DScrollBoxPro.AddSuItem(DScrollBoxPro.Add, DCBBookMPMan);

      DCheckBoxBookHPPro.Enabled := not g_ClientConf.boNoUseProtection;
      DEdtBookHPPro.Enabled := not g_ClientConf.boNoUseProtection;
      DCBBookHPMan.Enabled := not g_ClientConf.boNoUseProtection;
      DCheckBoxBookMPPro.Enabled := not g_ClientConf.boNoUseProtection;
      DEdtBookMPPro.Enabled := not g_ClientConf.boNoUseProtection;
      DCBBookMPMan.Enabled := not g_ClientConf.boNoUseProtection;

      DCBBookHPMan.Visible := True;
      DCBBookMPMan.Visible := True;
      DLabel3.Caption := '时使用';
      DLabel4.Caption := '时使用';
      DCheckBoxBookHPPro.Checked := g_Config.boHp1Chk;
      DEdtBookHPPro.Text := IntToStr(g_Config.wHp1Hp);
      DCBBookHPMan.ItemIndex := g_Config.btHp1Man;
      DCheckBoxBookMPPro.Checked := g_Config.boMp1Chk;
      DEdtBookMPPro.Text := IntToStr(g_Config.wMp1Mp);
      DCBBookMPMan.ItemIndex := g_Config.btMp1Man;
      DCheckBoxRenewHP.Checked := g_Config.boRenewHPIsAuto;
      DEdtRenewHP.Text := IntToStr(g_Config.wRenewHPPercent);
      DEdtRenewHPTime.Text := IntToStr(g_Config.wRenewHPTime);
      DCheckBoxRenewMP.Checked := g_Config.boRenewMPIsAuto;
      DEdtRenewMP.Text := IntToStr(g_Config.wRenewMPPercent);
      DEdtRenewMPTime.Text := IntToStr(g_Config.wRenewMPTime);
      DCheckBoxRenewHPSpecial.Checked := g_Config.boRenewSpecialHPIsAuto;
      DEdtRenewHPSpecial.Text := IntToStr(g_Config.wRenewSpecialHPPercent);
      DEdtRenewHPSpecialTime.Text := IntToStr(g_Config.wRenewSpecialHPTime);
      DCheckBoxRenewMpSpecial.Checked := g_Config.boRenewSpecialMpIsAuto;
      DEdtRenewMpSpecial.Text := IntToStr(g_Config.wRenewSpecialMpPercent);
      DEdtRenewMpSpecialTime.Text := IntToStr(g_Config.wRenewSpecialMpTime);
      DCheckBoxUseSuperMedica.Checked := g_Config.BoUseSuperMedica;

      DCheckBoxUseSuperMedicaItemName1.Checked := g_Config.SuperMedicaUses[0];
      DCheckBoxUseSuperMedicaItemName2.Checked := g_Config.SuperMedicaUses[1];
      DCheckBoxUseSuperMedicaItemName3.Checked := g_Config.SuperMedicaUses[2];
      DCheckBoxUseSuperMedicaItemName4.Checked := g_Config.SuperMedicaUses[3];
      DCheckBoxUseSuperMedicaItemName5.Checked := g_Config.SuperMedicaUses[4];
      DCheckBoxUseSuperMedicaItemName6.Checked := g_Config.SuperMedicaUses[5];
      DCheckBoxUseSuperMedicaItemName7.Checked := g_Config.SuperMedicaUses[6];
      DCheckBoxUseSuperMedicaItemName8.Checked := g_Config.SuperMedicaUses[7];
      DCheckBoxUseSuperMedicaItemName9.Checked := g_Config.SuperMedicaUses[8];
      DCheckBoxUseSuperMedicaItemName10.Checked := g_Config.SuperMedicaUses[9];
      DCheckBoxUseSuperMedicaItemName11.Checked := g_Config.SuperMedicaUses[10];
      DCheckBoxUseSuperMedicaItemName12.Checked := g_Config.SuperMedicaUses[11];
      DCheckBoxUseSuperMedicaItemName13.Checked := g_Config.SuperMedicaUses[12];
      DCheckBoxUseSuperMedicaItemName14.Checked := g_Config.SuperMedicaUses[13];

      DEditSuperMedicaHP1.Text := IntToStr(g_Config.SuperMedicaHPs[0]);
      DEditSuperMedicaHP2.Text := IntToStr(g_Config.SuperMedicaHPs[1]);
      DEditSuperMedicaHP3.Text := IntToStr(g_Config.SuperMedicaHPs[2]);
      DEditSuperMedicaHP4.Text := IntToStr(g_Config.SuperMedicaHPs[3]);
      DEditSuperMedicaHP5.Text := IntToStr(g_Config.SuperMedicaHPs[4]);
      DEditSuperMedicaHP6.Text := IntToStr(g_Config.SuperMedicaHPs[5]);
      DEditSuperMedicaHP7.Text := IntToStr(g_Config.SuperMedicaHPs[6]);
      DEditSuperMedicaHP8.Text := IntToStr(g_Config.SuperMedicaHPs[7]);
      DEditSuperMedicaHP9.Text := IntToStr(g_Config.SuperMedicaHPs[8]);
      DEditSuperMedicaHP10.Text := IntToStr(g_Config.SuperMedicaHPs[9]);
      DEditSuperMedicaHP11.Text := IntToStr(g_Config.SuperMedicaHPs[10]);
      DEditSuperMedicaHP12.Text := IntToStr(g_Config.SuperMedicaHPs[11]);
      DEditSuperMedicaHP13.Text := IntToStr(g_Config.SuperMedicaHPs[12]);
      DEditSuperMedicaHP14.Text := IntToStr(g_Config.SuperMedicaHPs[13]);

      DEditSuperMedicaHPTime1.Text := IntToStr(g_Config.SuperMedicaHPTimes[0]);
      DEditSuperMedicaHPTime2.Text := IntToStr(g_Config.SuperMedicaHPTimes[1]);
      DEditSuperMedicaHPTime3.Text := IntToStr(g_Config.SuperMedicaHPTimes[2]);
      DEditSuperMedicaHPTime4.Text := IntToStr(g_Config.SuperMedicaHPTimes[3]);
      DEditSuperMedicaHPTime5.Text := IntToStr(g_Config.SuperMedicaHPTimes[4]);
      DEditSuperMedicaHPTime6.Text := IntToStr(g_Config.SuperMedicaHPTimes[5]);
      DEditSuperMedicaHPTime7.Text := IntToStr(g_Config.SuperMedicaHPTimes[6]);
      DEditSuperMedicaHPTime8.Text := IntToStr(g_Config.SuperMedicaHPTimes[7]);
      DEditSuperMedicaHPTime9.Text := IntToStr(g_Config.SuperMedicaHPTimes[8]);
      DEditSuperMedicaHPTime10.Text := IntToStr(g_Config.SuperMedicaHPTimes[9]);
      DEditSuperMedicaHPTime11.Text := IntToStr(g_Config.SuperMedicaHPTimes[10]);
      DEditSuperMedicaHPTime12.Text := IntToStr(g_Config.SuperMedicaHPTimes[11]);
      DEditSuperMedicaHPTime13.Text := IntToStr(g_Config.SuperMedicaHPTimes[12]);
      DEditSuperMedicaHPTime14.Text := IntToStr(g_Config.SuperMedicaHPTimes[13]);

      DEditSuperMedicaMP1.Text := IntToStr(g_Config.SuperMedicaMPs[0]);
      DEditSuperMedicaMP2.Text := IntToStr(g_Config.SuperMedicaMPs[1]);
      DEditSuperMedicaMP3.Text := IntToStr(g_Config.SuperMedicaMPs[2]);
      DEditSuperMedicaMP4.Text := IntToStr(g_Config.SuperMedicaMPs[3]);
      DEditSuperMedicaMP5.Text := IntToStr(g_Config.SuperMedicaMPs[4]);
      DEditSuperMedicaMP6.Text := IntToStr(g_Config.SuperMedicaMPs[5]);
      DEditSuperMedicaMP7.Text := IntToStr(g_Config.SuperMedicaMPs[6]);
      DEditSuperMedicaMP8.Text := IntToStr(g_Config.SuperMedicaMPs[7]);
      DEditSuperMedicaMP9.Text := IntToStr(g_Config.SuperMedicaMPs[8]);
      DEditSuperMedicaMP10.Text := IntToStr(g_Config.SuperMedicaMPs[9]);
      DEditSuperMedicaMP11.Text := IntToStr(g_Config.SuperMedicaMPs[10]);
      DEditSuperMedicaMP12.Text := IntToStr(g_Config.SuperMedicaMPs[11]);
      DEditSuperMedicaMP13.Text := IntToStr(g_Config.SuperMedicaMPs[12]);
      DEditSuperMedicaMP14.Text := IntToStr(g_Config.SuperMedicaMPs[13]);

      DEditSuperMedicaMPTime1.Text := IntToStr(g_Config.SuperMedicaMPTimes[0]);
      DEditSuperMedicaMPTime2.Text := IntToStr(g_Config.SuperMedicaMPTimes[1]);
      DEditSuperMedicaMPTime3.Text := IntToStr(g_Config.SuperMedicaMPTimes[2]);
      DEditSuperMedicaMPTime4.Text := IntToStr(g_Config.SuperMedicaMPTimes[3]);
      DEditSuperMedicaMPTime5.Text := IntToStr(g_Config.SuperMedicaMPTimes[4]);
      DEditSuperMedicaMPTime6.Text := IntToStr(g_Config.SuperMedicaMPTimes[5]);
      DEditSuperMedicaMPTime7.Text := IntToStr(g_Config.SuperMedicaMPTimes[6]);
      DEditSuperMedicaMPTime8.Text := IntToStr(g_Config.SuperMedicaMPTimes[7]);
      DEditSuperMedicaMPTime9.Text := IntToStr(g_Config.SuperMedicaMPTimes[8]);
      DEditSuperMedicaMPTime10.Text := IntToStr(g_Config.SuperMedicaMPTimes[9]);
      DEditSuperMedicaMPTime11.Text := IntToStr(g_Config.SuperMedicaMPTimes[10]);
      DEditSuperMedicaMPTime12.Text := IntToStr(g_Config.SuperMedicaMPTimes[11]);
      DEditSuperMedicaMPTime13.Text := IntToStr(g_Config.SuperMedicaMPTimes[12]);
      DEditSuperMedicaMPTime14.Text := IntToStr(g_Config.SuperMedicaMPTimes[13]);
    end;
    {$IF M2Version <> 2}
    1: begin
      DScrollBoxPro.DelSuItem(DCBBookHPMan);
      DScrollBoxPro.DelSuItem(DCBBookMPMan);
      DCBBookHPMan.Visible := False;
      DCBBookMPMan.Visible := False;

      DCheckBoxBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DCheckBoxBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;

      DLabel3.Caption := '收英雄';
      DLabel4.Caption := '收英雄';
      DCheckBoxBookHPPro.Checked := g_Config.boHp2Chk;
      DEdtBookHPPro.Text := IntToStr(g_Config.wHp2Hp);
      //DCBBookHPMan.ItemIndex := g_Config.btHp2Man;
      DCheckBoxBookMPPro.Checked := g_Config.boMP2Chk;
      DEdtBookMPPro.Text := IntToStr(g_Config.wMP2MP);
      //DCBBookMPMan.ItemIndex := g_Config.btMP2Man;
      DCheckBoxRenewHP.Checked := g_Config.boRenewHeroNormalHpIsAuto;
      DEdtRenewHP.Text := IntToStr(g_Config.wRenewHeroNormalHpPercent);
      DEdtRenewHPTime.Text := IntToStr(g_Config.wRenewHeroNormalHpTime);
      DCheckBoxRenewMp.Checked := g_Config.boRenewHeroNormalMpIsAuto;
      DEdtRenewMp.Text := IntToStr(g_Config.wRenewHeroNormalMpPercent);
      DEdtRenewMpTime.Text := IntToStr(g_Config.wRenewHeroNormalMpTime);
      DCheckBoxRenewHPSpecial.Checked := g_Config.boRenewSpecialHeroNormalHpIsAuto;
      DEdtRenewHPSpecial.Text := IntToStr(g_Config.wRenewSpecialHeroNormalHpPercent);
      DEdtRenewHPSpecialTime.Text := IntToStr(g_Config.wRenewSpecialHeroNormalHpTime);
      DCheckBoxRenewMpSpecial.Checked := g_Config.boRenewSpecialHeroNormalMpIsAuto;
      DEdtRenewMpSpecial.Text := IntToStr(g_Config.wRenewSpecialHeroNormalMpPercent);
      DEdtRenewMpSpecialTime.Text := IntToStr(g_Config.wRenewSpecialHeroNormalMpTime);
      DCheckBoxUseSuperMedica.Checked := g_Config.hBoUseSuperMedica;

      DCheckBoxUseSuperMedicaItemName1.Checked := g_Config.hSuperMedicaUses[0];
      DCheckBoxUseSuperMedicaItemName2.Checked := g_Config.hSuperMedicaUses[1];
      DCheckBoxUseSuperMedicaItemName3.Checked := g_Config.hSuperMedicaUses[2];
      DCheckBoxUseSuperMedicaItemName4.Checked := g_Config.hSuperMedicaUses[3];
      DCheckBoxUseSuperMedicaItemName5.Checked := g_Config.hSuperMedicaUses[4];
      DCheckBoxUseSuperMedicaItemName6.Checked := g_Config.hSuperMedicaUses[5];
      DCheckBoxUseSuperMedicaItemName7.Checked := g_Config.hSuperMedicaUses[6];
      DCheckBoxUseSuperMedicaItemName8.Checked := g_Config.hSuperMedicaUses[7];
      DCheckBoxUseSuperMedicaItemName9.Checked := g_Config.hSuperMedicaUses[8];
      DCheckBoxUseSuperMedicaItemName10.Checked := g_Config.hSuperMedicaUses[9];
      DCheckBoxUseSuperMedicaItemName11.Checked := g_Config.hSuperMedicaUses[10];
      DCheckBoxUseSuperMedicaItemName12.Checked := g_Config.hSuperMedicaUses[11];
      DCheckBoxUseSuperMedicaItemName13.Checked := g_Config.hSuperMedicaUses[12];
      DCheckBoxUseSuperMedicaItemName14.Checked := g_Config.hSuperMedicaUses[13];

      DEditSuperMedicaHP1.Text := IntToStr(g_Config.hSuperMedicaHPs[0]);
      DEditSuperMedicaHP2.Text := IntToStr(g_Config.hSuperMedicaHPs[1]);
      DEditSuperMedicaHP3.Text := IntToStr(g_Config.hSuperMedicaHPs[2]);
      DEditSuperMedicaHP4.Text := IntToStr(g_Config.hSuperMedicaHPs[3]);
      DEditSuperMedicaHP5.Text := IntToStr(g_Config.hSuperMedicaHPs[4]);
      DEditSuperMedicaHP6.Text := IntToStr(g_Config.hSuperMedicaHPs[5]);
      DEditSuperMedicaHP7.Text := IntToStr(g_Config.hSuperMedicaHPs[6]);
      DEditSuperMedicaHP8.Text := IntToStr(g_Config.hSuperMedicaHPs[7]);
      DEditSuperMedicaHP9.Text := IntToStr(g_Config.hSuperMedicaHPs[8]);
      DEditSuperMedicaHP10.Text := IntToStr(g_Config.hSuperMedicaHPs[9]);
      DEditSuperMedicaHP11.Text := IntToStr(g_Config.hSuperMedicaHPs[10]);
      DEditSuperMedicaHP12.Text := IntToStr(g_Config.hSuperMedicaHPs[11]);
      DEditSuperMedicaHP13.Text := IntToStr(g_Config.hSuperMedicaHPs[12]);
      DEditSuperMedicaHP14.Text := IntToStr(g_Config.hSuperMedicaHPs[13]);

      DEditSuperMedicaHPTime1.Text := IntToStr(g_Config.hSuperMedicaHPTimes[0]);
      DEditSuperMedicaHPTime2.Text := IntToStr(g_Config.hSuperMedicaHPTimes[1]);
      DEditSuperMedicaHPTime3.Text := IntToStr(g_Config.hSuperMedicaHPTimes[2]);
      DEditSuperMedicaHPTime4.Text := IntToStr(g_Config.hSuperMedicaHPTimes[3]);
      DEditSuperMedicaHPTime5.Text := IntToStr(g_Config.hSuperMedicaHPTimes[4]);
      DEditSuperMedicaHPTime6.Text := IntToStr(g_Config.hSuperMedicaHPTimes[5]);
      DEditSuperMedicaHPTime7.Text := IntToStr(g_Config.hSuperMedicaHPTimes[6]);
      DEditSuperMedicaHPTime8.Text := IntToStr(g_Config.hSuperMedicaHPTimes[7]);
      DEditSuperMedicaHPTime9.Text := IntToStr(g_Config.hSuperMedicaHPTimes[8]);
      DEditSuperMedicaHPTime10.Text := IntToStr(g_Config.hSuperMedicaHPTimes[9]);
      DEditSuperMedicaHPTime11.Text := IntToStr(g_Config.hSuperMedicaHPTimes[10]);
      DEditSuperMedicaHPTime12.Text := IntToStr(g_Config.hSuperMedicaHPTimes[11]);
      DEditSuperMedicaHPTime13.Text := IntToStr(g_Config.hSuperMedicaHPTimes[12]);
      DEditSuperMedicaHPTime14.Text := IntToStr(g_Config.hSuperMedicaHPTimes[13]);

      DEditSuperMedicaMP1.Text := IntToStr(g_Config.hSuperMedicaMPs[0]);
      DEditSuperMedicaMP2.Text := IntToStr(g_Config.hSuperMedicaMPs[1]);
      DEditSuperMedicaMP3.Text := IntToStr(g_Config.hSuperMedicaMPs[2]);
      DEditSuperMedicaMP4.Text := IntToStr(g_Config.hSuperMedicaMPs[3]);
      DEditSuperMedicaMP5.Text := IntToStr(g_Config.hSuperMedicaMPs[4]);
      DEditSuperMedicaMP6.Text := IntToStr(g_Config.hSuperMedicaMPs[5]);
      DEditSuperMedicaMP7.Text := IntToStr(g_Config.hSuperMedicaMPs[6]);
      DEditSuperMedicaMP8.Text := IntToStr(g_Config.hSuperMedicaMPs[7]);
      DEditSuperMedicaMP9.Text := IntToStr(g_Config.hSuperMedicaMPs[8]);
      DEditSuperMedicaMP10.Text := IntToStr(g_Config.hSuperMedicaMPs[9]);
      DEditSuperMedicaMP11.Text := IntToStr(g_Config.hSuperMedicaMPs[10]);
      DEditSuperMedicaMP12.Text := IntToStr(g_Config.hSuperMedicaMPs[11]);
      DEditSuperMedicaMP13.Text := IntToStr(g_Config.hSuperMedicaMPs[12]);
      DEditSuperMedicaMP14.Text := IntToStr(g_Config.hSuperMedicaMPs[13]);

      DEditSuperMedicaMPTime1.Text := IntToStr(g_Config.hSuperMedicaMPTimes[0]);
      DEditSuperMedicaMPTime2.Text := IntToStr(g_Config.hSuperMedicaMPTimes[1]);
      DEditSuperMedicaMPTime3.Text := IntToStr(g_Config.hSuperMedicaMPTimes[2]);
      DEditSuperMedicaMPTime4.Text := IntToStr(g_Config.hSuperMedicaMPTimes[3]);
      DEditSuperMedicaMPTime5.Text := IntToStr(g_Config.hSuperMedicaMPTimes[4]);
      DEditSuperMedicaMPTime6.Text := IntToStr(g_Config.hSuperMedicaMPTimes[5]);
      DEditSuperMedicaMPTime7.Text := IntToStr(g_Config.hSuperMedicaMPTimes[6]);
      DEditSuperMedicaMPTime8.Text := IntToStr(g_Config.hSuperMedicaMPTimes[7]);
      DEditSuperMedicaMPTime9.Text := IntToStr(g_Config.hSuperMedicaMPTimes[8]);
      DEditSuperMedicaMPTime10.Text := IntToStr(g_Config.hSuperMedicaMPTimes[9]);
      DEditSuperMedicaMPTime11.Text := IntToStr(g_Config.hSuperMedicaMPTimes[10]);
      DEditSuperMedicaMPTime12.Text := IntToStr(g_Config.hSuperMedicaMPTimes[11]);
      DEditSuperMedicaMPTime13.Text := IntToStr(g_Config.hSuperMedicaMPTimes[12]);
      DEditSuperMedicaMPTime14.Text := IntToStr(g_Config.hSuperMedicaMPTimes[13]);
    end;
    2: begin
      DScrollBoxPro.DelSuItem(DCBBookHPMan);
      DScrollBoxPro.DelSuItem(DCBBookMPMan);
      DCBBookHPMan.Visible := False;
      DCBBookMPMan.Visible := False;

      DCheckBoxBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DCheckBoxBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;

      DLabel3.Caption := '收英雄';
      DLabel4.Caption := '收英雄';
      DCheckBoxBookHPPro.Checked := g_Config.boHp3Chk;
      DEdtBookHPPro.Text := IntToStr(g_Config.wHp3Hp);
      //DCBBookHPMan.ItemIndex := g_Config.btHp3Man;
      DCheckBoxBookMPPro.Checked := g_Config.boMP3Chk;
      DEdtBookMPPro.Text := IntToStr(g_Config.wMP3MP);
      //DCBBookMPMan.ItemIndex := g_Config.btMP3Man;
      DCheckBoxRenewHP.Checked := g_Config.boRenewzHeroNormalHpIsAuto;
      DEdtRenewHP.Text := IntToStr(g_Config.wRenewzHeroNormalHpPercent);
      DEdtRenewHPTime.Text := IntToStr(g_Config.wRenewzHeroNormalHpTime);
      DCheckBoxRenewMp.Checked := g_Config.boRenewzHeroNormalMpIsAuto;
      DEdtRenewMp.Text := IntToStr(g_Config.wRenewzHeroNormalMpPercent);
      DEdtRenewMpTime.Text := IntToStr(g_Config.wRenewzHeroNormalMpTime);
      DCheckBoxRenewHPSpecial.Checked := g_Config.boRenewSpecialzHeroNormalHpIsAuto;
      DEdtRenewHPSpecial.Text := IntToStr(g_Config.wRenewSpecialzHeroNormalHpPercent);
      DEdtRenewHPSpecialTime.Text := IntToStr(g_Config.wRenewSpecialzHeroNormalHpTime);
      DCheckBoxRenewMpSpecial.Checked := g_Config.boRenewSpecialzHeroNormalMpIsAuto;
      DEdtRenewMpSpecial.Text := IntToStr(g_Config.wRenewSpecialzHeroNormalMpPercent);
      DEdtRenewMpSpecialTime.Text := IntToStr(g_Config.wRenewSpecialzHeroNormalMpTime);
      DCheckBoxUseSuperMedica.Checked := g_Config.zBoUseSuperMedica;

      DCheckBoxUseSuperMedicaItemName1.Checked := g_Config.zSuperMedicaUses[0];
      DCheckBoxUseSuperMedicaItemName2.Checked := g_Config.zSuperMedicaUses[1];
      DCheckBoxUseSuperMedicaItemName3.Checked := g_Config.zSuperMedicaUses[2];
      DCheckBoxUseSuperMedicaItemName4.Checked := g_Config.zSuperMedicaUses[3];
      DCheckBoxUseSuperMedicaItemName5.Checked := g_Config.zSuperMedicaUses[4];
      DCheckBoxUseSuperMedicaItemName6.Checked := g_Config.zSuperMedicaUses[5];
      DCheckBoxUseSuperMedicaItemName7.Checked := g_Config.zSuperMedicaUses[6];
      DCheckBoxUseSuperMedicaItemName8.Checked := g_Config.zSuperMedicaUses[7];
      DCheckBoxUseSuperMedicaItemName9.Checked := g_Config.zSuperMedicaUses[8];
      DCheckBoxUseSuperMedicaItemName10.Checked := g_Config.zSuperMedicaUses[9];
      DCheckBoxUseSuperMedicaItemName11.Checked := g_Config.zSuperMedicaUses[10];
      DCheckBoxUseSuperMedicaItemName12.Checked := g_Config.zSuperMedicaUses[11];
      DCheckBoxUseSuperMedicaItemName13.Checked := g_Config.zSuperMedicaUses[12];
      DCheckBoxUseSuperMedicaItemName14.Checked := g_Config.zSuperMedicaUses[13];

      DEditSuperMedicaHP1.Text := IntToStr(g_Config.zSuperMedicaHPs[0]);
      DEditSuperMedicaHP2.Text := IntToStr(g_Config.zSuperMedicaHPs[1]);
      DEditSuperMedicaHP3.Text := IntToStr(g_Config.zSuperMedicaHPs[2]);
      DEditSuperMedicaHP4.Text := IntToStr(g_Config.zSuperMedicaHPs[3]);
      DEditSuperMedicaHP5.Text := IntToStr(g_Config.zSuperMedicaHPs[4]);
      DEditSuperMedicaHP6.Text := IntToStr(g_Config.zSuperMedicaHPs[5]);
      DEditSuperMedicaHP7.Text := IntToStr(g_Config.zSuperMedicaHPs[6]);
      DEditSuperMedicaHP8.Text := IntToStr(g_Config.zSuperMedicaHPs[7]);
      DEditSuperMedicaHP9.Text := IntToStr(g_Config.zSuperMedicaHPs[8]);
      DEditSuperMedicaHP10.Text := IntToStr(g_Config.zSuperMedicaHPs[9]);
      DEditSuperMedicaHP11.Text := IntToStr(g_Config.zSuperMedicaHPs[10]);
      DEditSuperMedicaHP12.Text := IntToStr(g_Config.zSuperMedicaHPs[11]);
      DEditSuperMedicaHP13.Text := IntToStr(g_Config.zSuperMedicaHPs[12]);
      DEditSuperMedicaHP14.Text := IntToStr(g_Config.zSuperMedicaHPs[13]);

      DEditSuperMedicaHPTime1.Text := IntToStr(g_Config.zSuperMedicaHPTimes[0]);
      DEditSuperMedicaHPTime2.Text := IntToStr(g_Config.zSuperMedicaHPTimes[1]);
      DEditSuperMedicaHPTime3.Text := IntToStr(g_Config.zSuperMedicaHPTimes[2]);
      DEditSuperMedicaHPTime4.Text := IntToStr(g_Config.zSuperMedicaHPTimes[3]);
      DEditSuperMedicaHPTime5.Text := IntToStr(g_Config.zSuperMedicaHPTimes[4]);
      DEditSuperMedicaHPTime6.Text := IntToStr(g_Config.zSuperMedicaHPTimes[5]);
      DEditSuperMedicaHPTime7.Text := IntToStr(g_Config.zSuperMedicaHPTimes[6]);
      DEditSuperMedicaHPTime8.Text := IntToStr(g_Config.zSuperMedicaHPTimes[7]);
      DEditSuperMedicaHPTime9.Text := IntToStr(g_Config.zSuperMedicaHPTimes[8]);
      DEditSuperMedicaHPTime10.Text := IntToStr(g_Config.zSuperMedicaHPTimes[9]);
      DEditSuperMedicaHPTime11.Text := IntToStr(g_Config.zSuperMedicaHPTimes[10]);
      DEditSuperMedicaHPTime12.Text := IntToStr(g_Config.zSuperMedicaHPTimes[11]);
      DEditSuperMedicaHPTime13.Text := IntToStr(g_Config.zSuperMedicaHPTimes[12]);
      DEditSuperMedicaHPTime14.Text := IntToStr(g_Config.zSuperMedicaHPTimes[13]);

      DEditSuperMedicaMP1.Text := IntToStr(g_Config.zSuperMedicaMPs[0]);
      DEditSuperMedicaMP2.Text := IntToStr(g_Config.zSuperMedicaMPs[1]);
      DEditSuperMedicaMP3.Text := IntToStr(g_Config.zSuperMedicaMPs[2]);
      DEditSuperMedicaMP4.Text := IntToStr(g_Config.zSuperMedicaMPs[3]);
      DEditSuperMedicaMP5.Text := IntToStr(g_Config.zSuperMedicaMPs[4]);
      DEditSuperMedicaMP6.Text := IntToStr(g_Config.zSuperMedicaMPs[5]);
      DEditSuperMedicaMP7.Text := IntToStr(g_Config.zSuperMedicaMPs[6]);
      DEditSuperMedicaMP8.Text := IntToStr(g_Config.zSuperMedicaMPs[7]);
      DEditSuperMedicaMP9.Text := IntToStr(g_Config.zSuperMedicaMPs[8]);
      DEditSuperMedicaMP10.Text := IntToStr(g_Config.zSuperMedicaMPs[9]);
      DEditSuperMedicaMP11.Text := IntToStr(g_Config.zSuperMedicaMPs[10]);
      DEditSuperMedicaMP12.Text := IntToStr(g_Config.zSuperMedicaMPs[11]);
      DEditSuperMedicaMP13.Text := IntToStr(g_Config.zSuperMedicaMPs[12]);
      DEditSuperMedicaMP14.Text := IntToStr(g_Config.zSuperMedicaMPs[13]);

      DEditSuperMedicaMPTime1.Text := IntToStr(g_Config.zSuperMedicaMPTimes[0]);
      DEditSuperMedicaMPTime2.Text := IntToStr(g_Config.zSuperMedicaMPTimes[1]);
      DEditSuperMedicaMPTime3.Text := IntToStr(g_Config.zSuperMedicaMPTimes[2]);
      DEditSuperMedicaMPTime4.Text := IntToStr(g_Config.zSuperMedicaMPTimes[3]);
      DEditSuperMedicaMPTime5.Text := IntToStr(g_Config.zSuperMedicaMPTimes[4]);
      DEditSuperMedicaMPTime6.Text := IntToStr(g_Config.zSuperMedicaMPTimes[5]);
      DEditSuperMedicaMPTime7.Text := IntToStr(g_Config.zSuperMedicaMPTimes[6]);
      DEditSuperMedicaMPTime8.Text := IntToStr(g_Config.zSuperMedicaMPTimes[7]);
      DEditSuperMedicaMPTime9.Text := IntToStr(g_Config.zSuperMedicaMPTimes[8]);
      DEditSuperMedicaMPTime10.Text := IntToStr(g_Config.zSuperMedicaMPTimes[9]);
      DEditSuperMedicaMPTime11.Text := IntToStr(g_Config.zSuperMedicaMPTimes[10]);
      DEditSuperMedicaMPTime12.Text := IntToStr(g_Config.zSuperMedicaMPTimes[11]);
      DEditSuperMedicaMPTime13.Text := IntToStr(g_Config.zSuperMedicaMPTimes[12]);
      DEditSuperMedicaMPTime14.Text := IntToStr(g_Config.zSuperMedicaMPTimes[13]);
    end;
    3: begin
      DScrollBoxPro.DelSuItem(DCBBookHPMan);
      DScrollBoxPro.DelSuItem(DCBBookMPMan);
      DCBBookHPMan.Visible := False;
      DCBBookMPMan.Visible := False;

      DCheckBoxBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DCheckBoxBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;

      DLabel3.Caption := '收英雄';
      DLabel4.Caption := '收英雄';
      DCheckBoxBookHPPro.Checked := g_Config.boHp4Chk;
      DEdtBookHPPro.Text := IntToStr(g_Config.wHp4Hp);
      //DCBBookHPMan.ItemIndex := g_Config.btHp4Man;
      DCheckBoxBookMPPro.Checked := g_Config.boMP4Chk;
      DEdtBookMPPro.Text := IntToStr(g_Config.wMP4MP);
      //DCBBookMPMan.ItemIndex := g_Config.btMP4Man;
      DCheckBoxRenewHP.Checked := g_Config.boRenewfHeroNormalHpIsAuto;
      DEdtRenewHP.Text := IntToStr(g_Config.wRenewfHeroNormalHpPercent);
      DEdtRenewHPTime.Text := IntToStr(g_Config.wRenewfHeroNormalHpTime);
      DCheckBoxRenewMp.Checked := g_Config.boRenewfHeroNormalMpIsAuto;
      DEdtRenewMp.Text := IntToStr(g_Config.wRenewfHeroNormalMpPercent);
      DEdtRenewMpTime.Text := IntToStr(g_Config.wRenewfHeroNormalMpTime);
      DCheckBoxRenewHPSpecial.Checked := g_Config.boRenewSpecialfHeroNormalHpIsAuto;
      DEdtRenewHPSpecial.Text := IntToStr(g_Config.wRenewSpecialfHeroNormalHpPercent);
      DEdtRenewHPSpecialTime.Text := IntToStr(g_Config.wRenewSpecialfHeroNormalHpTime);
      DCheckBoxRenewMpSpecial.Checked := g_Config.boRenewSpecialfHeroNormalMpIsAuto;
      DEdtRenewMpSpecial.Text := IntToStr(g_Config.wRenewSpecialfHeroNormalMpPercent);
      DEdtRenewMpSpecialTime.Text := IntToStr(g_Config.wRenewSpecialfHeroNormalMpTime);
      DCheckBoxUseSuperMedica.Checked := g_Config.fBoUseSuperMedica;

      DCheckBoxUseSuperMedicaItemName1.Checked := g_Config.fSuperMedicaUses[0];
      DCheckBoxUseSuperMedicaItemName2.Checked := g_Config.fSuperMedicaUses[1];
      DCheckBoxUseSuperMedicaItemName3.Checked := g_Config.fSuperMedicaUses[2];
      DCheckBoxUseSuperMedicaItemName4.Checked := g_Config.fSuperMedicaUses[3];
      DCheckBoxUseSuperMedicaItemName5.Checked := g_Config.fSuperMedicaUses[4];
      DCheckBoxUseSuperMedicaItemName6.Checked := g_Config.fSuperMedicaUses[5];
      DCheckBoxUseSuperMedicaItemName7.Checked := g_Config.fSuperMedicaUses[6];
      DCheckBoxUseSuperMedicaItemName8.Checked := g_Config.fSuperMedicaUses[7];
      DCheckBoxUseSuperMedicaItemName9.Checked := g_Config.fSuperMedicaUses[8];
      DCheckBoxUseSuperMedicaItemName10.Checked := g_Config.fSuperMedicaUses[9];
      DCheckBoxUseSuperMedicaItemName11.Checked := g_Config.fSuperMedicaUses[10];
      DCheckBoxUseSuperMedicaItemName12.Checked := g_Config.fSuperMedicaUses[11];
      DCheckBoxUseSuperMedicaItemName13.Checked := g_Config.fSuperMedicaUses[12];
      DCheckBoxUseSuperMedicaItemName14.Checked := g_Config.fSuperMedicaUses[13];

      DEditSuperMedicaHP1.Text := IntToStr(g_Config.fSuperMedicaHPs[0]);
      DEditSuperMedicaHP2.Text := IntToStr(g_Config.fSuperMedicaHPs[1]);
      DEditSuperMedicaHP3.Text := IntToStr(g_Config.fSuperMedicaHPs[2]);
      DEditSuperMedicaHP4.Text := IntToStr(g_Config.fSuperMedicaHPs[3]);
      DEditSuperMedicaHP5.Text := IntToStr(g_Config.fSuperMedicaHPs[4]);
      DEditSuperMedicaHP6.Text := IntToStr(g_Config.fSuperMedicaHPs[5]);
      DEditSuperMedicaHP7.Text := IntToStr(g_Config.fSuperMedicaHPs[6]);
      DEditSuperMedicaHP8.Text := IntToStr(g_Config.fSuperMedicaHPs[7]);
      DEditSuperMedicaHP9.Text := IntToStr(g_Config.fSuperMedicaHPs[8]);
      DEditSuperMedicaHP10.Text := IntToStr(g_Config.fSuperMedicaHPs[9]);
      DEditSuperMedicaHP11.Text := IntToStr(g_Config.fSuperMedicaHPs[10]);
      DEditSuperMedicaHP12.Text := IntToStr(g_Config.fSuperMedicaHPs[11]);
      DEditSuperMedicaHP13.Text := IntToStr(g_Config.fSuperMedicaHPs[12]);
      DEditSuperMedicaHP14.Text := IntToStr(g_Config.fSuperMedicaHPs[13]);

      DEditSuperMedicaHPTime1.Text := IntToStr(g_Config.fSuperMedicaHPTimes[0]);
      DEditSuperMedicaHPTime2.Text := IntToStr(g_Config.fSuperMedicaHPTimes[1]);
      DEditSuperMedicaHPTime3.Text := IntToStr(g_Config.fSuperMedicaHPTimes[2]);
      DEditSuperMedicaHPTime4.Text := IntToStr(g_Config.fSuperMedicaHPTimes[3]);
      DEditSuperMedicaHPTime5.Text := IntToStr(g_Config.fSuperMedicaHPTimes[4]);
      DEditSuperMedicaHPTime6.Text := IntToStr(g_Config.fSuperMedicaHPTimes[5]);
      DEditSuperMedicaHPTime7.Text := IntToStr(g_Config.fSuperMedicaHPTimes[6]);
      DEditSuperMedicaHPTime8.Text := IntToStr(g_Config.fSuperMedicaHPTimes[7]);
      DEditSuperMedicaHPTime9.Text := IntToStr(g_Config.fSuperMedicaHPTimes[8]);
      DEditSuperMedicaHPTime10.Text := IntToStr(g_Config.fSuperMedicaHPTimes[9]);
      DEditSuperMedicaHPTime11.Text := IntToStr(g_Config.fSuperMedicaHPTimes[10]);
      DEditSuperMedicaHPTime12.Text := IntToStr(g_Config.fSuperMedicaHPTimes[11]);
      DEditSuperMedicaHPTime13.Text := IntToStr(g_Config.fSuperMedicaHPTimes[12]);
      DEditSuperMedicaHPTime14.Text := IntToStr(g_Config.fSuperMedicaHPTimes[13]);

      DEditSuperMedicaMP1.Text := IntToStr(g_Config.fSuperMedicaMPs[0]);
      DEditSuperMedicaMP2.Text := IntToStr(g_Config.fSuperMedicaMPs[1]);
      DEditSuperMedicaMP3.Text := IntToStr(g_Config.fSuperMedicaMPs[2]);
      DEditSuperMedicaMP4.Text := IntToStr(g_Config.fSuperMedicaMPs[3]);
      DEditSuperMedicaMP5.Text := IntToStr(g_Config.fSuperMedicaMPs[4]);
      DEditSuperMedicaMP6.Text := IntToStr(g_Config.fSuperMedicaMPs[5]);
      DEditSuperMedicaMP7.Text := IntToStr(g_Config.fSuperMedicaMPs[6]);
      DEditSuperMedicaMP8.Text := IntToStr(g_Config.fSuperMedicaMPs[7]);
      DEditSuperMedicaMP9.Text := IntToStr(g_Config.fSuperMedicaMPs[8]);
      DEditSuperMedicaMP10.Text := IntToStr(g_Config.fSuperMedicaMPs[9]);
      DEditSuperMedicaMP11.Text := IntToStr(g_Config.fSuperMedicaMPs[10]);
      DEditSuperMedicaMP12.Text := IntToStr(g_Config.fSuperMedicaMPs[11]);
      DEditSuperMedicaMP13.Text := IntToStr(g_Config.fSuperMedicaMPs[12]);
      DEditSuperMedicaMP14.Text := IntToStr(g_Config.fSuperMedicaMPs[13]);

      DEditSuperMedicaMPTime1.Text := IntToStr(g_Config.fSuperMedicaMPTimes[0]);
      DEditSuperMedicaMPTime2.Text := IntToStr(g_Config.fSuperMedicaMPTimes[1]);
      DEditSuperMedicaMPTime3.Text := IntToStr(g_Config.fSuperMedicaMPTimes[2]);
      DEditSuperMedicaMPTime4.Text := IntToStr(g_Config.fSuperMedicaMPTimes[3]);
      DEditSuperMedicaMPTime5.Text := IntToStr(g_Config.fSuperMedicaMPTimes[4]);
      DEditSuperMedicaMPTime6.Text := IntToStr(g_Config.fSuperMedicaMPTimes[5]);
      DEditSuperMedicaMPTime7.Text := IntToStr(g_Config.fSuperMedicaMPTimes[6]);
      DEditSuperMedicaMPTime8.Text := IntToStr(g_Config.fSuperMedicaMPTimes[7]);
      DEditSuperMedicaMPTime9.Text := IntToStr(g_Config.fSuperMedicaMPTimes[8]);
      DEditSuperMedicaMPTime10.Text := IntToStr(g_Config.fSuperMedicaMPTimes[9]);
      DEditSuperMedicaMPTime11.Text := IntToStr(g_Config.fSuperMedicaMPTimes[10]);
      DEditSuperMedicaMPTime12.Text := IntToStr(g_Config.fSuperMedicaMPTimes[11]);
      DEditSuperMedicaMPTime13.Text := IntToStr(g_Config.fSuperMedicaMPTimes[12]);
      DEditSuperMedicaMPTime14.Text := IntToStr(g_Config.fSuperMedicaMPTimes[13]);
    end;
    4: begin
      DScrollBoxPro.DelSuItem(DCBBookHPMan);
      DScrollBoxPro.DelSuItem(DCBBookMPMan);
      DCBBookHPMan.Visible := False;
      DCBBookMPMan.Visible := False;

      DCheckBoxBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookHPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DCheckBoxBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;
      DEdtBookMPPro.Enabled := not g_ClientConf.boNoUseHeroProtection;

      DLabel3.Caption := '收英雄';
      DLabel4.Caption := '收英雄';
      DCheckBoxBookHPPro.Checked := g_Config.boHp5Chk;
      DEdtBookHPPro.Text := IntToStr(g_Config.wHp5Hp);
      //DCBBookHPMan.ItemIndex := g_Config.btHp5Man;
      DCheckBoxBookMPPro.Checked := g_Config.boMP5Chk;
      DEdtBookMPPro.Text := IntToStr(g_Config.wMP5MP);
      //DCBBookMPMan.ItemIndex := g_Config.btMP5Man;
      DCheckBoxRenewHP.Checked := g_Config.boRenewdHeroNormalHpIsAuto;
      DEdtRenewHP.Text := IntToStr(g_Config.wRenewdHeroNormalHpPercent);
      DEdtRenewHPTime.Text := IntToStr(g_Config.wRenewdHeroNormalHpTime);
      DCheckBoxRenewMp.Checked := g_Config.boRenewdHeroNormalMpIsAuto;
      DEdtRenewMp.Text := IntToStr(g_Config.wRenewdHeroNormalMpPercent);
      DEdtRenewMpTime.Text := IntToStr(g_Config.wRenewdHeroNormalMpTime);
      DCheckBoxRenewHPSpecial.Checked := g_Config.boRenewSpecialdHeroNormalHpIsAuto;
      DEdtRenewHPSpecial.Text := IntToStr(g_Config.wRenewSpecialdHeroNormalHpPercent);
      DEdtRenewHPSpecialTime.Text := IntToStr(g_Config.wRenewSpecialdHeroNormalHpTime);
      DCheckBoxRenewMpSpecial.Checked := g_Config.boRenewSpecialdHeroNormalMpIsAuto;
      DEdtRenewMpSpecial.Text := IntToStr(g_Config.wRenewSpecialdHeroNormalMpPercent);
      DEdtRenewMpSpecialTime.Text := IntToStr(g_Config.wRenewSpecialdHeroNormalMpTime);
      DCheckBoxUseSuperMedica.Checked := g_Config.dBoUseSuperMedica;

      DCheckBoxUseSuperMedicaItemName1.Checked := g_Config.dSuperMedicaUses[0];
      DCheckBoxUseSuperMedicaItemName2.Checked := g_Config.dSuperMedicaUses[1];
      DCheckBoxUseSuperMedicaItemName3.Checked := g_Config.dSuperMedicaUses[2];
      DCheckBoxUseSuperMedicaItemName4.Checked := g_Config.dSuperMedicaUses[3];
      DCheckBoxUseSuperMedicaItemName5.Checked := g_Config.dSuperMedicaUses[4];
      DCheckBoxUseSuperMedicaItemName6.Checked := g_Config.dSuperMedicaUses[5];
      DCheckBoxUseSuperMedicaItemName7.Checked := g_Config.dSuperMedicaUses[6];
      DCheckBoxUseSuperMedicaItemName8.Checked := g_Config.dSuperMedicaUses[7];
      DCheckBoxUseSuperMedicaItemName9.Checked := g_Config.dSuperMedicaUses[8];
      DCheckBoxUseSuperMedicaItemName10.Checked := g_Config.dSuperMedicaUses[9];
      DCheckBoxUseSuperMedicaItemName11.Checked := g_Config.dSuperMedicaUses[10];
      DCheckBoxUseSuperMedicaItemName12.Checked := g_Config.dSuperMedicaUses[11];
      DCheckBoxUseSuperMedicaItemName13.Checked := g_Config.dSuperMedicaUses[12];
      DCheckBoxUseSuperMedicaItemName14.Checked := g_Config.dSuperMedicaUses[13];

      DEditSuperMedicaHP1.Text := IntToStr(g_Config.dSuperMedicaHPs[0]);
      DEditSuperMedicaHP2.Text := IntToStr(g_Config.dSuperMedicaHPs[1]);
      DEditSuperMedicaHP3.Text := IntToStr(g_Config.dSuperMedicaHPs[2]);
      DEditSuperMedicaHP4.Text := IntToStr(g_Config.dSuperMedicaHPs[3]);
      DEditSuperMedicaHP5.Text := IntToStr(g_Config.dSuperMedicaHPs[4]);
      DEditSuperMedicaHP6.Text := IntToStr(g_Config.dSuperMedicaHPs[5]);
      DEditSuperMedicaHP7.Text := IntToStr(g_Config.dSuperMedicaHPs[6]);
      DEditSuperMedicaHP8.Text := IntToStr(g_Config.dSuperMedicaHPs[7]);
      DEditSuperMedicaHP9.Text := IntToStr(g_Config.dSuperMedicaHPs[8]);
      DEditSuperMedicaHP10.Text := IntToStr(g_Config.dSuperMedicaHPs[9]);
      DEditSuperMedicaHP11.Text := IntToStr(g_Config.dSuperMedicaHPs[10]);
      DEditSuperMedicaHP12.Text := IntToStr(g_Config.dSuperMedicaHPs[11]);
      DEditSuperMedicaHP13.Text := IntToStr(g_Config.dSuperMedicaHPs[12]);
      DEditSuperMedicaHP14.Text := IntToStr(g_Config.dSuperMedicaHPs[13]);

      DEditSuperMedicaHPTime1.Text := IntToStr(g_Config.dSuperMedicaHPTimes[0]);
      DEditSuperMedicaHPTime2.Text := IntToStr(g_Config.dSuperMedicaHPTimes[1]);
      DEditSuperMedicaHPTime3.Text := IntToStr(g_Config.dSuperMedicaHPTimes[2]);
      DEditSuperMedicaHPTime4.Text := IntToStr(g_Config.dSuperMedicaHPTimes[3]);
      DEditSuperMedicaHPTime5.Text := IntToStr(g_Config.dSuperMedicaHPTimes[4]);
      DEditSuperMedicaHPTime6.Text := IntToStr(g_Config.dSuperMedicaHPTimes[5]);
      DEditSuperMedicaHPTime7.Text := IntToStr(g_Config.dSuperMedicaHPTimes[6]);
      DEditSuperMedicaHPTime8.Text := IntToStr(g_Config.dSuperMedicaHPTimes[7]);
      DEditSuperMedicaHPTime9.Text := IntToStr(g_Config.dSuperMedicaHPTimes[8]);
      DEditSuperMedicaHPTime10.Text := IntToStr(g_Config.dSuperMedicaHPTimes[9]);
      DEditSuperMedicaHPTime11.Text := IntToStr(g_Config.dSuperMedicaHPTimes[10]);
      DEditSuperMedicaHPTime12.Text := IntToStr(g_Config.dSuperMedicaHPTimes[11]);
      DEditSuperMedicaHPTime13.Text := IntToStr(g_Config.dSuperMedicaHPTimes[12]);
      DEditSuperMedicaHPTime14.Text := IntToStr(g_Config.dSuperMedicaHPTimes[13]);

      DEditSuperMedicaMP1.Text := IntToStr(g_Config.dSuperMedicaMPs[0]);
      DEditSuperMedicaMP2.Text := IntToStr(g_Config.dSuperMedicaMPs[1]);
      DEditSuperMedicaMP3.Text := IntToStr(g_Config.dSuperMedicaMPs[2]);
      DEditSuperMedicaMP4.Text := IntToStr(g_Config.dSuperMedicaMPs[3]);
      DEditSuperMedicaMP5.Text := IntToStr(g_Config.dSuperMedicaMPs[4]);
      DEditSuperMedicaMP6.Text := IntToStr(g_Config.dSuperMedicaMPs[5]);
      DEditSuperMedicaMP7.Text := IntToStr(g_Config.dSuperMedicaMPs[6]);
      DEditSuperMedicaMP8.Text := IntToStr(g_Config.dSuperMedicaMPs[7]);
      DEditSuperMedicaMP9.Text := IntToStr(g_Config.dSuperMedicaMPs[8]);
      DEditSuperMedicaMP10.Text := IntToStr(g_Config.dSuperMedicaMPs[9]);
      DEditSuperMedicaMP11.Text := IntToStr(g_Config.dSuperMedicaMPs[10]);
      DEditSuperMedicaMP12.Text := IntToStr(g_Config.dSuperMedicaMPs[11]);
      DEditSuperMedicaMP13.Text := IntToStr(g_Config.dSuperMedicaMPs[12]);
      DEditSuperMedicaMP14.Text := IntToStr(g_Config.dSuperMedicaMPs[13]);

      DEditSuperMedicaMPTime1.Text := IntToStr(g_Config.dSuperMedicaMPTimes[0]);
      DEditSuperMedicaMPTime2.Text := IntToStr(g_Config.dSuperMedicaMPTimes[1]);
      DEditSuperMedicaMPTime3.Text := IntToStr(g_Config.dSuperMedicaMPTimes[2]);
      DEditSuperMedicaMPTime4.Text := IntToStr(g_Config.dSuperMedicaMPTimes[3]);
      DEditSuperMedicaMPTime5.Text := IntToStr(g_Config.dSuperMedicaMPTimes[4]);
      DEditSuperMedicaMPTime6.Text := IntToStr(g_Config.dSuperMedicaMPTimes[5]);
      DEditSuperMedicaMPTime7.Text := IntToStr(g_Config.dSuperMedicaMPTimes[6]);
      DEditSuperMedicaMPTime8.Text := IntToStr(g_Config.dSuperMedicaMPTimes[7]);
      DEditSuperMedicaMPTime9.Text := IntToStr(g_Config.dSuperMedicaMPTimes[8]);
      DEditSuperMedicaMPTime10.Text := IntToStr(g_Config.dSuperMedicaMPTimes[9]);
      DEditSuperMedicaMPTime11.Text := IntToStr(g_Config.dSuperMedicaMPTimes[10]);
      DEditSuperMedicaMPTime12.Text := IntToStr(g_Config.dSuperMedicaMPTimes[11]);
      DEditSuperMedicaMPTime13.Text := IntToStr(g_Config.dSuperMedicaMPTimes[12]);
      DEditSuperMedicaMPTime14.Text := IntToStr(g_Config.dSuperMedicaMPTimes[13]);
    end;
    {$IFEND}
  end;
end;

//元宝寄售返回包裹 20080316
procedure TFrmDlg.SellOffItemReturnBag(mitem: TClientItem);
begin
  g_SellOffDlgItem := mitem;
  FrmMain.SendDelSellOffItem (g_SellOffDlgItem);
end;

procedure TFrmDlg.DDGridGridSelect(Sender: TObject; ACol, ARow: Integer; Shift: TShiftState);
var
   mi, idx: integer;
begin
   if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
      if not g_boItemMoving then begin
         idx := ACol + ARow * DDGrid.ColCount;
         if idx in [0..9] then
            if g_DealItems[idx].S.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 20;
               g_MovingItem.Item := g_DealItems[idx];
               g_DealItems[idx].S.Name := '';
               ItemClickSound (g_MovingItem.Item.S);
            end;
      end else begin
         mi := g_MovingItem.Index;
         if (mi >= 0) or (mi <= -20) and (mi > -30) then begin //啊规,俊辑 柯巴父
            ItemClickSound (g_MovingItem.Item.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
               g_DealDlgItem := g_MovingItem.Item; //辑滚俊 搬苞甫 扁促府绰悼救 焊包
               FrmMain.SendAddDealItem (g_DealDlgItem);
               g_dwDealActionTick := GetTickCount + 4000;
            end else
               AddDealItem (g_MovingItem.Item);
            g_MovingItem.Item.S.name := '';
         end;
         if mi = -98 then DDGoldClick (self, 0, 0);
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DDGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then begin
    if g_DealItems[idx].S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_DealItems[idx].S.Looks);
      if d <> nil then begin
        with DDGrid do begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_DealItems[idx].S.StdMode = 17 then begin
             dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_DealItems[idx].Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_DealItems[idx].Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DDGridGridMouseMove(Sender: TObject; ACol, ARow: Integer;
  Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_DealItems[idx];
    with DDGrid do
    	ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                        SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DDRGridGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then begin
    if g_DealRemoteItems[idx].S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_DealRemoteItems[idx].S.Looks);
      if d <> nil then begin
        with DDRGrid do begin
           dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_DealRemoteItems[idx].S.StdMode = 17 then begin
             dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_DealRemoteItems[idx].Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_DealRemoteItems[idx].Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DDRGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  {$IF M2Version <> 2}
  iname, d1, d2, d3, d4, d5, d6, d7, hcolor: string;
  useable: Boolean;
  {$IFEND}
begin
  {$IF M2Version <> 2}
  DScreen.ClearHint;
  {$IFEND}
  idx := ACol + ARow * DDRGrid.ColCount;
  if idx in [0..19] then begin
    g_MouseItem := g_DealRemoteItems[idx];
    with DDRGrid do
    	ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                        SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DealZeroGold;
begin
   if not g_boDealEnd and (g_nDealGold > 0) then begin
      g_dwDealActionTick := GetTickCount + 4000;
      FrmMain.SendChangeDealGold (0);
   end;
end;

procedure TFrmDlg.DDGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then exit;
   if not g_boDealEnd and (GetTickCount > g_dwDealActionTick) then begin
      if not g_boItemMoving then begin
         if g_nDealGold > 0 then begin
            PlaySound (s_money);
            g_boItemMoving := TRUE;
            g_MovingItem.Index := -97;
            g_MovingItem.Item.S.Name := g_sGoldName{'金币'};
         end;
      end else begin
         if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then begin
            if (g_MovingItem.Index = -98) then begin
               if g_MovingItem.Item.S.Name = g_sGoldName{'金币'} then begin
                  DialogSize := 1;
                  g_boItemMoving := FALSE;
                  g_MovingItem.Item.S.Name := '';
                  DMessageDlg ('请输入 ' +g_sGoldName+ ' 数量', [mbOk, mbAbort]);
                  GetValidStrVal (DlgEditText, valstr, [' ']);
                  dgold := Str_ToInt (valstr, 0);
                  if (dgold <= (g_nDealGold+g_MySelf.m_nGold)) and (dgold > 0) then begin
                     FrmMain.SendChangeDealGold (dgold);
                     g_dwDealActionTick := GetTickCount + 4000;
                  end;
               end;
            end;
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.Name := '';
         end;
      end;
   end;
end;

{--------------------人物装备那栏2007.10.16----------------------}
procedure TFrmDlg.DUserState1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  pgidx, bbx, bby, idx, ax, ay, sex, hair: integer;
  d: TDirectDrawSurface;
  {$IF M2Version = 2}
  iname, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: Integer;
  {$IFEND}
  wm: TWMImages;
begin
  with DUserState1 do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    //观察别人的装备4格那
    sex := UserState1.Feature.nDress mod 2; //DRESSfeature (UserState1.Feature) mod 2;    //性别
    hair := UserState1.feature.btHair; //HAIRfeature (UserState1.Feature);
    {$IF M2Version = 2}
    if sex = 1 then pgidx := 377   //咯磊
    else pgidx := 376;     //巢磊
    bbx := GLeft + 38;
    bby := GTop + 52;
    d := g_WMainImages.Images[pgidx];
    {$ELSE}
    if sex = 1 then pgidx := 30{377}   //女
    else pgidx := 29{376};     //男
    bbx := GLeft + 38;
    bby := GTop + 52;
    d := g_WMain3Images.Images[pgidx];
    {$IFEND}
    if d <> nil then
      dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
    bbx := bbx - 7;
    bby := bby + 44;
    if UserState1.UseItems[U_DRESS].S.Name <> '' then begin
      idx := UserState1.UseItems[U_DRESS].S.Looks;
      if idx >= 0 then begin
        d := FrmMain.GetWStateImg(idx,ax,ay);
        if d <> nil then
           dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        //Modified By TasNat at: 2012-11-22 10:47:29
        with GetEffecItemList(UserState1.UseItems[U_DRESS].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_DRESS].nIndex);
              if g_DrawUseItems1[U_DRESS].nIndex > btShapeCount-1 then g_DrawUseItems1[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
      //观察别人人物发型2007.10.16 
    idx := 1799;
    if sex = 1 then idx := 2399;//480 + hair div 2;
    if sex = 0 then begin   //男
      if hair <> 0 then begin
        if idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end;
    end else if hair <> 1 then begin
      if idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
    end;
    if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin
      idx := UserState1.UseItems[U_WEAPON].S.Looks;
      if idx >= 0 then begin
        d := FrmMain.GetWStateImg(idx,ax,ay);
        if d <> nil then
           dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        //Modified By TasNat at: 2012-11-22 10:47:29
        with GetEffecItemList(UserState1.UseItems[U_WEAPON].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_WEAPON].nIndex);
              if g_DrawUseItems1[U_WEAPON].nIndex > btShapeCount-1 then g_DrawUseItems1[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
      //斗笠 20080417
    if UserState1.UseItems[U_ZHULI].S.Name <> '' then begin
      if UserState1.UseItems[U_ZHULI].S.Shape <> 2  then begin
        idx := UserState1.UseItems[U_ZHULI].S.Looks;
        if idx >= 0 then begin
          d := FrmMain.GetWStateImg(idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (UserState1.UseItems[U_HELMET].S.Looks = 103) or (UserState1.UseItems[U_HELMET].S.Looks = 106) or (UserState1.UseItems[U_HELMET].S.Looks = 344) or (UserState1.UseItems[U_HELMET].S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
            idx := UserState1.UseItems[U_HELMET].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx,ax,ay);
               if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          idx := UserState1.UseItems[U_ZHULI].S.Looks;
          if idx >= 0 then begin
            d := FrmMain.GetWStateImg(idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          idx := UserState1.UseItems[U_ZHULI].S.Looks;
          if idx >= 0 then begin
            d := FrmMain.GetWStateImg(idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
            idx := UserState1.UseItems[U_HELMET].S.Looks;
            if idx >= 0 then begin
               d := FrmMain.GetWStateImg(idx,ax,ay);
               if d <> nil then
                  dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
      if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
        //Modified By TasNat at: 2012-11-22 10:47:29
        with GetEffecItemList(UserState1.UseItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_HELMET].nIndex);
              if g_DrawUseItems1[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems1[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end
    end else if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
      idx := UserState1.UseItems[U_HELMET].S.Looks;
      if idx >= 0 then begin
        d := FrmMain.GetWStateImg(idx,ax,ay);
        if d <> nil then
           dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        //Modified By TasNat at: 2012-11-22 10:47:29
        with GetEffecItemList(UserState1.UseItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_HELMET].nIndex);
              if g_DrawUseItems1[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems1[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
      //名字和行会
    if g_nUserSelectName = 1 then //20080302
      Font.Color := clSilver
    else if g_nUserSelectName = 3 then
      Font.Color := clRed
    else Font.Color := UserState1.NameColor;
    dsurface.TextOut (SurfaceX(GLeft + 122 - FrmMain.Canvas.TextWidth(UserState1.UserName) div 2),
                      SurfaceY(GTop + 23), Font.Color, UserState1.UserName);
    if g_nUserSelectName = 2 then  //20080302
      Font.Color := clWhite
    else if g_nUserSelectName = 4 then
      Font.Color := clRed
    else Font.Color := clSilver;
    case g_boUserIsWho of
      1: dsurface.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
                 font.Color, UserState1.GuildName+' 的英雄');
      2: dsurface.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
               Font.Color, UserState1.GuildName+' 的分身');
      else dsurface.TextOut (SurfaceX(GLeft + 45), SurfaceY(GTop + 55),
               Font.Color, UserState1.GuildName + ' ' + UserState1.GuildRankName);
    end;
  end;
end;

procedure TFrmDlg.DUserState1MouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  lx,ly:integer;
begin
   lx := DUserState1.LocalX (X) - DUserState1.GLeft;
   ly := DUserState1.LocalY (Y) - DUserState1.GTop;
   if (lx >= 56) and (lx <= 180) and (ly >= 22) and (ly <= 35) then begin
      g_nUserSelectName := 3;
      g_boSelectText := True;
   end;
   if (lx >= 42) and (lx <= 201) and (ly >= 56) and (ly <= 69) then begin
      g_nUserSelectName := 4;
      g_boSelectText := True;
   end;
end;

procedure TFrmDlg.DUserState1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  lx,ly:integer;
begin
  DScreen.ClearHint;
  g_MouseUserStateItem.S.Name := '';
   if not g_boSelectText then 
      g_nUserSelectName := 0;   //20080302
   lx := DUserState1.LocalX (X) - DUserState1.GLeft;
   ly := DUserState1.LocalY (Y) - DUserState1.GTop;
   if (lx >= 56) and (lx <= 180) and (ly >= 22) and (ly <= 35) then begin
         if not g_boSelectText then
           g_nUserSelectName := 1;  //20080302
        if ssLeft in Shift then begin
          PlayScene.EdChat.Visible := TRUE;
          PlayScene.EdChat.Text := '/'+ UserState1.UserName+' ';
          PlayScene.EdChat.SetFocus;
          SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
          PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
        end;
   end;
   if (lx >= 42) and (lx <= 201) and (ly >= 56) and (ly <= 69) then begin
       if not g_boSelectText then
          g_nUserSelectName := 2;  //20080302
       if ssLeft in Shift then begin
          PlayScene.EdChat.Visible := TRUE;
          PlayScene.EdChat.Text := '/'+ UserState1.GuildName+' ';
          PlayScene.EdChat.SetFocus;
          SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
          PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
        end;
   end;


end;

procedure TFrmDlg.DWeaponUS1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   sel: integer;
   iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
   useable: Boolean;
   (*{$IF M2Version = 2}
   hcolor: Integer;
   {$ELSE}*)
   hcolor: string;
   //{$IFEND}
   nHintX,nHintY: Integer;
   TzHintInfo: pTTzHintInfo;
   Butt: TDButton;
   Lines: string;
begin
  try
    sel := -1;
    Butt:=TDButton(Sender);
    if Sender = DDressUS1 then sel := U_DRESS;
    if Sender = DWeaponUS1 then sel := U_WEAPON;
    if Sender = DHelmetUS1 then sel := U_HELMET;
    if Sender = DNecklaceUS1 then sel := U_NECKLACE;
    if Sender = DLightUS1 then sel := U_RIGHTHAND;
    if Sender = DRingLUS1 then sel := U_RINGL;
    if Sender = DRingRUS1 then sel := U_RINGR;
    if Sender = DArmRingLUS1 then sel := U_ARMRINGL;
    if Sender = DArmRingRUS1 then sel := U_ARMRINGR;

    if Sender = DBujukUS1 then sel := U_BUJUK;
    if Sender = DBeltUS1 then sel := U_BELT;
    if Sender = DBootsUS1 then sel := U_BOOTS;
    if Sender = DCharmUS1 then sel := U_CHARM;

    (*{$IF M2Version = 2}//1.76
    if sel >= 0 then begin
      g_MouseUserStateItem := UserState1.UseItems[sel];
      //if sel in [U_DRESS,U_WEAPON] then Exit;
      if UserState1.UseItems[sel].S.Name <> '' then begin
         TzHintInfo := GetTzInfo(UserState1.UseItems[sel].S.Name, 3);
         if TzHintInfo <> nil then begin
           if DUserState1.GLeft >= 350 then
             nHintX:=DUserState1.SurfaceX(DUserState1.GLeft)-10 - _Min(DScreen.HintWidth, 400)
           else
             nHintX:=DUserState1.SurfaceX(DUserState1.GLeft) + DStateWin.GWidth +10;

           nHintY:=Butt.SurfaceY(Butt.GTop) -50;
           if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin //指向头盔and斗笠不为空
             g_MouseItem := UserState1.UseItems[U_ZHULI];
             GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
             g_MouseItem.S.Name := '';
             with Butt as TDButton do     //显示有斗笠的
                DScreen.ShowTzHint (nHintX,
                                  nHintY,
                                  iname  + '\'+ d1 + '\' + d2 + '\' + d3 +
                                  TzHintInfo.sTzCaption+'~c\ \'+GetTzStateInfo(TzHintInfo,3), FALSE, True, 40);
           end else begin
             with Butt as TDButton do
                DScreen.ShowTzHint (nHintX,
                                  nHintY,
                                  TzHintInfo.sTzCaption+'~c\ \'+GetTzStateInfo(TzHintInfo,3), FALSE, True, 40);
           end;
         end else begin
            if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin
              g_MouseItem := UserState1.UseItems[U_ZHULI];
              GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
              if iname <> '' then begin
                if UserState1.UseItems[U_ZHULI].Dura = 0 then hcolor := clRed
                else hcolor := clYellow;

                nHintX:=DHelmetUS1.SurfaceX(DHelmetUS1.GLeft) + DHelmetUS1.GWidth * 2;
                nHintY:=DHelmetUS1.SurfaceY(DHelmetUS1.GTop);
                with Butt as TDButton do
                  DScreen.ShowHint(nHintX,nHintY,
                                 iname  + '\'+ d1 + '\' + d2 + '\' + d3, hcolor, FALSE);
              end;
              g_MouseItem.S.Name := '';
            end;
         end;
      end else begin
        if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin
          g_MouseItem := UserState1.UseItems[U_ZHULI];
          GetMouseItemInfo (iname, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
          if iname <> '' then begin
            if UserState1.UseItems[U_ZHULI].Dura = 0 then hcolor := clRed
            else hcolor := clYellow;

            nHintX:=DHelmetUS1.SurfaceX(DHelmetUS1.GLeft) + DHelmetUS1.GWidth * 2;
            nHintY:=DHelmetUS1.SurfaceY(DHelmetUS1.GTop);
            with Butt as TDButton do
              DScreen.ShowHint(nHintX,nHintY,
                             iname  + '\'+ d1 + '\' + d2 + '\' + d3, hcolor, FALSE);
          end;
          g_MouseItem.S.Name := '';
        end;
      end;
    end;
    {$ELSE} *)
    if sel >= 0 then begin
      g_MouseUserStateItem := UserState1.UseItems[sel];
      if (UserState1.UseItems[sel].S.Name <> '') or (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin
        if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin
          g_MouseItem := UserState1.UseItems[U_ZHULI];
          GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
          if iname <> '' then begin
            if UserState1.UseItems[U_ZHULI].Dura = 0 then hcolor := 'Red'
            else hcolor := '';
            //Lines := iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~Y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
            Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]);
          end;
        end;
        TzHintInfo := GetTzInfo(UserState1.UseItems[sel].S.Name, 3);
        if DUserState1.GLeft >= 350 then
          nHintX:=DUserState1.SurfaceX(DUserState1.GLeft) - _Min(DScreen.HintWidth, 400)
        else nHintX:=DUserState1.SurfaceX(DUserState1.GLeft)+DUserState1.GWidth;
        nHintY:=DUserState1.SurfaceY(DUserState1.GTop) + 50;
        g_MouseItem := UserState1.UseItems[sel];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
        if (iname <> '') or (Lines <> '') then begin
          if UserState1.UseItems[sel].Dura = 0 then hcolor := 'red'
          else hcolor := '';
          with Butt as TDButton do begin
            if TzHintInfo =nil then begin
              DScreen.ShowSpecialHint(nHintX,
                                      nHintY,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                      [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
            end else begin
              {DScreen.ShowSpecialHint(nHintX,
                                      nHintY,
                                      Lines + Format('<%s/c=Yellow>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                      [iname, d1, hColor, d2, d3, d4, d5, d6, d7]), False);                 }
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,3)]), False
                                      );
            end;
          end;
        end;
        g_MouseItem.S.Name := '';
      end;
    end;
    //{$IFEND}
  except
    DeBugOutStr('TFrmDlg.DWeaponUS1MouseMove');
  end;
end;

procedure TFrmDlg.DCloseUS1Click(Sender: TObject; X, Y: Integer);
begin
   DUserState1.Visible := FALSE;
end;

procedure TFrmDlg.DNecklaceUS1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  Idx, ax, ay: Integer;
  d: TDirectDrawSurface;
  nWhere: Integer;
  wm: TWMImages;
begin
  nWhere := -1;
  if Sender = DNecklaceUS1 then nWhere := U_NECKLACE;
  if Sender = DLightUS1 then nWhere := U_RIGHTHAND;
  if Sender = DArmringRUS1 then nWhere := U_ARMRINGR;
  if Sender = DArmringLUS1 then nWhere := U_ARMRINGL;
  if Sender = DRingRUS1 then nWhere := U_RINGR;
  if Sender = DRingLUS1 then nWhere := U_RINGL;
  if Sender = DBujukUS1 then nWhere := U_BUJUK;
  if Sender = DBeltUS1 then nWhere := U_BELT;
  if Sender = DBootsUS1 then nWhere := U_BOOTS;
  if Sender = DCharmUS1 then nWhere := U_CHARM;

  if nWhere >= 0 then begin
    if UserState1.UseItems[nWhere].S.Name <> '' then begin
      Idx := UserState1.UseItems[nWhere].S.looks;
      if Idx >= 0 then begin
        d := frmMain.GetWStateImg(Idx);
        if d <> nil then begin
          with TDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                          SurfaceY(GTop + (GHeight - d.Height) div 2),
                          d.ClientRect, d, TRUE);
            //Modified By TasNat at: 2012-11-22 10:47:29
            if GetEffecItemList(UserState1.UseItems[nWhere].S.Name).btShapeCount > 0 then begin
              with GetEffecItemList(UserState1.UseItems[nWhere].S.Name) do begin
                if GetTickCount - g_DrawUseItems1[nWhere].dwDrawTick >= 150 then begin
                  g_DrawUseItems1[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems1[nWhere].nIndex);
                  if g_DrawUseItems1[nWhere].nIndex > btShapeCount-1 then g_DrawUseItems1[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    DrawBlend(dsurface,SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d, 255);
                  end;
                end;
              end;
            end else begin
              if UserState1.UseItems[nWhere].S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  DrawBlend(dsurface,SurfaceX(GLeft-21), SurfaceY(GTop-23), d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowGuildDlg;
begin
   DGuildDlg.Visible := TRUE;  //not DGuildDlg.Visible;
   DGuildDlg.GTop := -3;
   DGuildDlg.GLeft := 0;
   if DGuildDlg.Visible then begin
      if GuildCommanderMode then begin
         DGDAddMem.Visible := TRUE;
         DGDDelMem.Visible := TRUE;
         DGDEditNotice.Visible := TRUE;
         DGDEditGrade.Visible := TRUE;
         DGDAlly.Visible := TRUE;
         DGDBreakAlly.Visible := TRUE;
         DGDWar.Visible := TRUE;
         DGDCancelWar.Visible := TRUE;
      end else begin
         DGDAddMem.Visible := FALSE;
         DGDDelMem.Visible := FALSE;
         DGDEditNotice.Visible := FALSE;
         DGDEditGrade.Visible := FALSE;
         DGDAlly.Visible := FALSE;
         DGDBreakAlly.Visible := FALSE;
         DGDWar.Visible := FALSE;
         DGDCancelWar.Visible := FALSE;
      end;

   end;
   GuildTopLine := 0;
end;

procedure TFrmDlg.ShowGuildEditNotice;
var
   d: TDirectDrawSurface;
   i: integer;
   data: string;
begin
   with DGuildEditNotice do begin
      if g_WMainImages <> nil then begin //20080701
        d := g_WMainImages.Images[204];
        if d <> nil then begin
           GLeft := (SCREENWIDTH - d.Width) div 2;
           GTop := (SCREENHEIGHT - d.Height) div 2;
        end;
      end;
      HideAllControls;
      DGuildEditNotice.ShowModal;

      Memo.Left := SurfaceX(GLeft+16);
      Memo.Top  := SurfaceY(GTop+36);
      Memo.Width := 571;
      Memo.Height := 246;
      Memo.Lines.Assign (GuildNotice);
      Memo.Visible := TRUE;

      while TRUE do begin
         if not DGuildEditNotice.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DGuildEditNotice.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
         data := '';
         if Memo.Lines.Count > 0 then //20080629
         for i:=0 to Memo.Lines.Count-1 do begin
            if Memo.Lines[i] = '' then
               data := data + Memo.Lines[i] + ' '#13
            else data := data + Memo.Lines[i] + #13;
         end;
         if Length(data) > 4000 then begin
            data := Copy (data, 1, 4000);
            DMessageDlg ('公告内容超过限制大小，公告内容将被截短！', [mbOk]);
         end;
         FrmMain.SendGuildUpdateNotice (data);
      end;
   end;
end;

procedure TFrmDlg.ShowGuildEditGrade;
var
   d: TDirectDrawSurface;
   data: string;
   i: integer;
begin
   if GuildMembers.Count <= 0 then begin
      DMessageDlg ('请先打开成员列表。', [mbOk]);
      Exit;
   end;

   with DGuildEditNotice do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
           GLeft := (SCREENWIDTH - d.Width) div 2;
           GTop := (SCREENHEIGHT - d.Height) div 2;
        end;
      end;
      HideAllControls;
      DGuildEditNotice.ShowModal;

      Memo.Left := SurfaceX(GLeft+16);
      Memo.Top  := SurfaceY(GTop+36);
      Memo.Width := 571;
      Memo.Height := 246;
      Memo.Lines.Assign (GuildMembers);
      Memo.Visible := TRUE;

      while TRUE do begin
         if not DGuildEditNotice.Visible then break;
         FrmMain.ProcOnIdle;
         Application.ProcessMessages;
         if Application.Terminated then exit;
      end;

      DGuildEditNotice.Visible := FALSE;
      RestoreHideControls;

      if DMsgDlg.DialogResult = mrOk then begin
         data := '';
         if Memo.Lines.Count > 0 then //20080629
         for i:=0 to Memo.Lines.Count-1 do begin
            data := data + Memo.Lines[i] + #13;
         end;
         if Length(data) > 5000 then begin
            data := Copy (data, 1, 5000);
            DMessageDlg ('内容超过限制大小，内容将被截短', [mbOk]);
         end;
         FrmMain.SendGuildUpdateGrade (data);
      end;
   end;
end;

procedure TFrmDlg.DGuildDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  i, n, bx, by: integer;
begin
   with DGuildDlg do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

         Font.Color := clWhite;
         dsurface.TextOut (GLeft+320, GTop+13, {Font.Color}clWhite, Guild); //行会名

         bx := GLeft + 24;
         by := GTop + 41;
         if GuildStrs.Count > 0 then //20080629
         for i:=GuildTopLine to GuildStrs.Count-1 do begin
            n := i-GuildTopLine;
            if n*14 > 356 then break;
            if Integer(GuildStrs.Objects[i]) <> 0 then Font.Color := TColor(GuildStrs.Objects[i])
            else begin
               if BoGuildChat then Font.Color := GetRGB (2)
               else Font.Color := clSilver;
            end;
            dsurface.TextOut (bx, by + n*14, Font.Color, GuildStrs[i]);
         end;

   end;
end;

procedure TFrmDlg.DGDUpClick(Sender: TObject; X, Y: Integer);
begin
   if GuildTopLine > 0 then Dec (GuildTopLine, 3);
   if GuildTopLine < 0 then GuildTopLine := 0;
end;

procedure TFrmDlg.DGDDownClick(Sender: TObject; X, Y: Integer);
begin
   if GuildTopLine+12 < GuildStrs.Count then Inc (GuildTopLine, 3);
end;

procedure TFrmDlg.DGDCloseClick(Sender: TObject; X, Y: Integer);
begin
   DGuildDlg.Visible := FALSE;
   BoGuildChat := FALSE;
end;

procedure TFrmDlg.DGDHomeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendGuildHome;
      BoGuildChat := FALSE;
   end;
end;

procedure TFrmDlg.DGDListClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendGuildMemberList;
      BoGuildChat := FALSE;
   end;
end;

procedure TFrmDlg.DGDAddMemClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('请输入想加入' + Guild + '的人物名称：', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendGuildAddMem (DlgEditText);
end;

procedure TFrmDlg.DGDDelMemClick(Sender: TObject; X, Y: Integer);
begin
   DMessageDlg ('请输入想要开除的人物名称：', [mbOk, mbAbort]);
   if DlgEditText <> '' then
      FrmMain.SendGuildDelMem (DlgEditText);
end;

procedure TFrmDlg.DGDEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
   GuildEditHint := '[修改行会通告内容]';
   ShowGuildEditNotice;
end;

procedure TFrmDlg.DGDEditGradeClick(Sender: TObject; X, Y: Integer);
begin
   GuildEditHint := '[修改行会成员的等级和职位。 # 警告 : 不能增加行会成员/删除行会成员]';
   ShowGuildEditGrade;
end;

//结盟
procedure TFrmDlg.DGDAllyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if mrOk = DMessageDlg ('对方结盟行会必需在 [允许结盟]状态下。\' +
                  '而且二个行会的管理者必须面对面。\' +
                  '是否确认行会结盟？', [mbOk, mbCancel])
  then begin
    msg := MakeDefaultMsg(aa(CM_GUILDALLY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg));
  end;
end;

//解除结盟
procedure TFrmDlg.DGDBreakAllyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  DMessageDlg ('请输入您想取消结盟的行会的名字.', [mbOk, mbAbort]);
  if DlgEditText <> '' then begin
    msg := MakeDefaultMsg(aa(CM_GUILDBREAKALLY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg)+EncodeString(DlgEditText));
  end;
end;

procedure TFrmDlg.DGuildEditNoticeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with DGuildEditNotice do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;

         dsurface.TextOut (GLeft+18, GTop+291, clSilver, GuildEditHint);
   end;
end;

procedure TFrmDlg.DGECloseClick(Sender: TObject; X, Y: Integer);
begin
   DGuildEditNotice.Visible := FALSE;
   Memo.Visible := FALSE;
   DMsgDlg.DialogResult := mrCancel;
end;

procedure TFrmDlg.DGEOkClick(Sender: TObject; X, Y: Integer);
begin
   DGECloseClick (self, 0, 0);
   DMsgDlg.DialogResult := mrOk;
end;

procedure TFrmDlg.AddGuildChat (str: string);
var
   i: integer;
begin
   GuildChats.Add (str);
   if GuildChats.Count > 500 then begin
      for i:=0 to 100 do GuildChats.Delete(0);
   end;
   if BoGuildChat then
      GuildStrs.Assign (GuildChats);
end;

procedure TFrmDlg.DGDChatClick(Sender: TObject; X, Y: Integer);
begin
   BoGuildChat := not BoGuildChat;
   if BoGuildChat then begin
      GuildStrs2.Assign (GuildStrs);
      GuildStrs.Assign (GuildChats);
   end else
      GuildStrs.Assign (GuildStrs2);
end;

procedure TFrmDlg.DGoldDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
   if g_MySelf = nil then exit;
   with DGold do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DAdjustAbilCloseClick(Sender: TObject; X, Y: Integer);
begin
   DAdjustAbility.Visible := FALSE;
   g_nBonusPoint := g_nSaveBonusPoint;
end;

procedure TFrmDlg.DAdjustAbilityDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
   procedure AdjustAb (abil: byte; val: word; var lov, hiv: Word);
   var
      lo, hi: byte;
      i: integer;
   begin
      lo := Lobyte(abil);
      hi := Hibyte(abil);
      lov := 0; hiv := 0;
      for i:=1 to val do begin
         if lo+1 < hi then begin Inc(lo); Inc(lov);
         end else begin Inc(hi); Inc(hiv); end;
      end;
   end;
var
   d: TDirectDrawSurface;
   l, m, adc, amc, asc, aac, amac: integer;
   ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
begin
   if g_MySelf = nil then exit;
   with dsurface.Canvas do begin
      with DAdjustAbility do begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
      Font.Color := clSilver;
      l := DAdjustAbility.SurfaceX(DAdjustAbility.GLeft) + 36;
      m := DAdjustAbility.SurfaceY(DAdjustAbility.GTop) + 22;
      dsurface.TextOut (l, m,   Font.Color,   '恭喜你已经到了下一个等级.');
      dsurface.TextOut (l, m+14, Font.Color,   '选择你想提高的能力');
      dsurface.TextOut (l, m+14*2, Font.Color, '这样的选择你只可以做一次');
      dsurface.TextOut (l, m+14*3, Font.Color, '最好能很小心地选择.');
      Font.Color := clWhite;

      l := DAdjustAbility.SurfaceX(DAdjustAbility.GLeft) + 100; //66;
      m := DAdjustAbility.SurfaceY(DAdjustAbility.GTop) + 101;
      //防止除0错误By TasNat at: 2012-10-19 09:17:49
      adc := (g_BonusAbilChg.DC) div _MAX(1, g_BonusTick.DC);
      amc := (g_BonusAbilChg.MC) div _MAX(1, g_BonusTick.MC);
      asc := (g_BonusAbilChg.SC) div _MAX(1, g_BonusTick.SC);
      aac := (g_BonusAbilChg.AC) div _MAX(1, g_BonusTick.AC);
      amac := (g_BonusAbilChg.MAC) div _MAX(1, g_BonusTick.MAC);
      AdjustAb (g_NakedAbil.DC, adc, ldc, hdc);
      AdjustAb (g_NakedAbil.MC, amc, lmc, hmc);
      AdjustAb (g_NakedAbil.SC, asc, lsc, hsc);
      AdjustAb (g_NakedAbil.AC, aac, lac, hac);
      AdjustAb (g_NakedAbil.MAC, amac, lmac, hmac);
      dsurface.TextOut (l, m+0, Font.Color, IntToStr(LoWord(g_MySelf.m_Abil.DC)+ldc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.DC) + hdc));
      dsurface.TextOut (l, m+20, Font.Color, IntToStr(LoWord(g_MySelf.m_Abil.MC)+lmc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MC) + hmc));
      dsurface.TextOut (l, m+40, Font.Color, IntToStr(LoWord(g_MySelf.m_Abil.SC)+lsc) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.SC) + hsc));
      dsurface.TextOut (l, m+60, Font.Color, IntToStr(LoWord(g_MySelf.m_Abil.AC)+lac) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.AC) + hac));
      dsurface.TextOut (l, m+80, Font.Color, IntToStr(LoWord(g_MySelf.m_Abil.MAC)+lmac) + '-' + IntToStr(HiWord(g_MySelf.m_Abil.MAC) + hmac));
      dsurface.TextOut (l, m+100, Font.Color, IntToStr(g_MySelf.m_Abil.MaxHP + (g_BonusAbil.HP + g_BonusAbilChg.HP) div _MAX(1, g_BonusTick.HP)));
      dsurface.TextOut (l, m+120, Font.Color, IntToStr(g_MySelf.m_Abil.MaxMP + (g_BonusAbil.MP + g_BonusAbilChg.MP) div _MAX(1, g_BonusTick.MP)));
      dsurface.TextOut (l, m+140, Font.Color, IntToStr(g_nMyHitPoint + (g_BonusAbil.Hit + g_BonusAbilChg.Hit) div _MAX(1, g_BonusTick.Hit)));
      dsurface.TextOut (l, m+160, Font.Color, IntToStr(g_nMySpeedPoint + (g_BonusAbil.Speed + g_BonusAbilChg.Speed) div _MAX(1, g_BonusTick.Speed)));
      Font.Color := clYellow;
      dsurface.TextOut (l, m+180, Font.Color, IntToStr(g_nBonusPoint));
      Font.Color := clWhite;
      l := DAdjustAbility.SurfaceX(DAdjustAbility.GLeft) + 155; //66;
      m := DAdjustAbility.SurfaceY(DAdjustAbility.GTop) + 101;
      if g_BonusAbilChg.DC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m, Font.Color, IntToStr(g_BonusAbilChg.DC + g_BonusAbil.DC) + '/' + IntToStr(g_BonusTick.DC));
      if g_BonusAbilChg.MC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+20, Font.Color, IntToStr(g_BonusAbilChg.MC + g_BonusAbil.MC) + '/' + IntToStr(g_BonusTick.MC));
      if g_BonusAbilChg.SC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+40, Font.Color, IntToStr(g_BonusAbilChg.SC + g_BonusAbil.SC) + '/' + IntToStr(g_BonusTick.SC));
      if g_BonusAbilChg.AC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+60, Font.Color, IntToStr(g_BonusAbilChg.AC + g_BonusAbil.AC) + '/' + IntToStr(g_BonusTick.AC));
      if g_BonusAbilChg.MAC > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+80, Font.Color, IntToStr(g_BonusAbilChg.MAC + g_BonusAbil.MAC) + '/' + IntToStr(g_BonusTick.MAC));
      if g_BonusAbilChg.HP > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+100, Font.Color, IntToStr(g_BonusAbilChg.HP + g_BonusAbil.HP) + '/' + IntToStr(g_BonusTick.HP));
      if g_BonusAbilChg.MP > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+120, Font.Color, IntToStr(g_BonusAbilChg.MP + g_BonusAbil.MP) + '/' + IntToStr(g_BonusTick.MP));
      if g_BonusAbilChg.Hit > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+140, Font.Color, IntToStr(g_BonusAbilChg.Hit + g_BonusAbil.Hit) + '/' + IntToStr(g_BonusTick.Hit));
      if g_BonusAbilChg.Speed > 0 then Font.Color := clWhite
      else Font.Color := clSilver;
      dsurface.TextOut (l, m+160, Font.Color, IntToStr(g_BonusAbilChg.Speed + g_BonusAbil.Speed) + '/' + IntToStr(g_BonusTick.Speed));
      Release;
   end;
end;

procedure TFrmDlg.DPlusDCClick(Sender: TObject; X, Y: Integer);
var
   incp: integer;
begin
   if g_nBonusPoint > 0 then begin
      if IsKeyPressed (VK_CONTROL) and (g_nBonusPoint > 10) then incp := 10
      else incp := 1;
      Dec(g_nBonusPoint, incp);
      if Sender = DPlusDC then Inc (g_BonusAbilChg.DC, incp);
      if Sender = DPlusMC then Inc (g_BonusAbilChg.MC, incp);
      if Sender = DPlusSC then Inc (g_BonusAbilChg.SC, incp);
      if Sender = DPlusAC then Inc (g_BonusAbilChg.AC, incp);
      if Sender = DPlusMAC then Inc (g_BonusAbilChg.MAC, incp);
      if Sender = DPlusHP then Inc (g_BonusAbilChg.HP, incp);
      if Sender = DPlusMP then Inc (g_BonusAbilChg.MP, incp);
      if Sender = DPlusHit then Inc (g_BonusAbilChg.Hit, incp);
      if Sender = DPlusSpeed then Inc (g_BonusAbilChg.Speed, incp);
   end;
end;

procedure TFrmDlg.DMinusDCClick(Sender: TObject; X, Y: Integer);
var
   decp: integer;
begin
   if IsKeyPressed (VK_CONTROL) and (g_nBonusPoint-10 > 0) then decp := 10
   else decp := 1;
   if Sender = DMinusDC then
      if g_BonusAbilChg.DC >= decp then begin
         Dec(g_BonusAbilChg.DC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMC then
      if g_BonusAbilChg.MC >= decp then begin
         Dec(g_BonusAbilChg.MC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusSC then
      if g_BonusAbilChg.SC >= decp then begin
         Dec(g_BonusAbilChg.SC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusAC then
      if g_BonusAbilChg.AC >= decp then begin
         Dec(g_BonusAbilChg.AC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMAC then
      if g_BonusAbilChg.MAC >= decp then begin
         Dec(g_BonusAbilChg.MAC, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusHP then
      if g_BonusAbilChg.HP >= decp then begin
         Dec(g_BonusAbilChg.HP, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusMP then
      if g_BonusAbilChg.MP >= decp then begin
         Dec(g_BonusAbilChg.MP, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusHit then
      if g_BonusAbilChg.Hit >= decp then begin
         Dec(g_BonusAbilChg.Hit, decp);
         Inc (g_nBonusPoint, decp);
      end;
   if Sender = DMinusSpeed then
      if g_BonusAbilChg.Speed >= decp then begin
         Dec(g_BonusAbilChg.Speed, decp);
         Inc (g_nBonusPoint, decp);
      end;
end;

procedure TFrmDlg.DAdjustAbilOkClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.SendAdjustBonus(g_nBonusPoint, g_BonusAbilChg);
   DAdjustAbility.Visible := FALSE;
end;

procedure TFrmDlg.DAdjustAbilityMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, lx, ly: integer;
   flag: Boolean;
begin
   with DAdjustAbility do begin
      lx := LocalX (X - GLeft);
      ly := LocalY (Y - GTop);
      flag := FALSE;
      if (lx >= 50) and (lx < 150) then
         for i:=0 to 8 do begin
            if (ly >= 98 + i*20) and (ly < 98 + (i+1)*20) then begin
               DScreen.ShowHint (SurfaceX(GLeft) + lx + 10,
                                 SurfaceY(GTop) + ly + 5,
                                 AdjustAbilHints[i],
                                 clWhite,
                                 FALSE);
               flag := TRUE;
               break;
            end;
         end;
      if not flag then
         DScreen.ClearHint;
   end;
end;

procedure TFrmDlg.DBotFactionMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  nLocalY:Integer;
  nHintX,nHintY:Integer;
  Butt:TDButton;
  sMsg:String;
  Int: Integer;
begin
  if g_MySelf = nil then Exit;
  Butt:=TDButton(Sender);
  if Sender = DBotMiniMap then sMsg:= '小地图\全景地图(TAB)';
  if Sender = DBotTrade then sMsg:= '物品交易';
  if Sender = DBotGuild then sMsg:= '行会信息';
  if Sender = DBotGroup then sMsg:= '组队控制/右键开关';
  if Sender = DBotPlusAbil then sMsg:= '属性点';
  {$IF M2Version <> 2}
  if Sender = DBotFaction then sMsg:= '师门';
  if (Sender = DBXinfaExpAbsorb) and g_boXinFaType then sMsg := '点击吸收心法经验进入丹田之中.';
  if Sender = DBNewHeroLiquorProgress then sMsg := '酒量提升进度%d';
  {$IFEND}
  if Sender = DBotFriend then sMsg:= '关系系统';
  if Sender = DBotLogout then sMsg:= '小退(Alt+X)';
  if Sender = DBotExit then sMsg:= '退出(Alt+Q)';
  if Sender = DBotMemo then sMsg:= '商铺(Ctrl+B)';
  if Sender = DMyState then sMsg:= '状态信息(F10)';
  if Sender = DMyBag then sMsg:= '包裹物品(F9)';
  if Sender = DMyMagic then sMsg:= '技能信息(F11)';
  if Sender = DOption then sMsg:= '音效开关';
  if Sender = DBRefusePublicChat then sMsg:= '拒绝所有公聊信息';
  if Sender = DBRefuseCRY then sMsg:= '拒绝所有喊话信息';
  if Sender = DBRefuseWHISPER then sMsg:= '拒绝所有私聊信息';
  if Sender = DBRefuseguild then sMsg:= '拒绝行会聊天信息';
  if Sender = DBAutoCRY then sMsg:= '自动喊话开关';
  if Sender = DBCommand then sMsg := '特殊命令';
  if Sender = DBInternet then sMsg:= '热点';
  if Sender = DDrunkScale then sMsg := '醉酒度: %d';
  if Sender = DLiquorProgress then sMsg := '酒量提升进度%d';
  if Sender = DBNewLiquorProgress then sMsg := '酒量提升进度%d';
  if Sender = DHeroLiquorProgress then sMsg := '酒量提升进度%d';
  if Sender = DNQBoxs then sMsg:= '每满一个节点槽，可开启宝箱一次\每亮起一棵灯，宝箱中的奖励就更好';
  {$IF M2Version = 1}
  if Sender = DBatterShowImg then begin
    if g_WinBatterMagicList.Count = 0 then Exit;
    if g_boCanUseBatter then
      sMsg:= '当前可以释放连击'
    else sMsg:= '当前连击技处于冷却时间';
    with Butt as TDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop), sMsg , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
  if (Sender = DLiquorProgress) or (Sender = DBNewLiquorProgress) then begin
    Int := _MAX(0, 100 * g_MySelf.m_Abil.Alcohol div _MAX(1, g_MySelf.m_Abil.MaxAlcohol));
    with Butt as TDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop + Butt.GHeight), Format(sMsg ,[Int]) + '%' , clWhite, FALSE);
    Exit;
  end;

  if Sender = DDrunkScale then begin
    Int := _MAX(0, 100 * g_MySelf.m_Abil.WineDrinkValue div _MAX(1, g_MySelf.m_Abil.MaxAlcohol));
    with Butt as TDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft)-Canvas.TextWidth(sMsg) + 36, Butt.SurfaceY(Butt.GTop + Butt.GHeight), Format(sMsg,[Int]) + '%', clWhite, FALSE);
    Exit;
  end;

  if (Sender = DHeroLiquorProgress) or (Sender = DBNewHeroLiquorProgress) then begin
    Int := _MAX(0, 100 * g_HeroSelf.m_Abil.Alcohol div _MAX(1, g_HeroSelf.m_Abil.MaxAlcohol));
    with Butt as TDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop + Butt.GHeight), Format(sMsg ,[Int]) + '%' , clWhite, FALSE);
    Exit;
  end;

  if (Sender = DBRefusePublicChat) or (Sender = DBRefuseCRY) or
     (Sender = DBRefuseWHISPER) or (Sender = DBRefuseguild) or (Sender = DBAutoCRY) or (Sender = DBCommand) then begin
    with Butt as TDButton do
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft)-Canvas.TextWidth(sMsg)-8, Butt.SurfaceY(Butt.GTop), sMsg, clWhite, FALSE);
    Exit;
  end;

  if Sender = DBCallHero then sMsg:= '召唤/收回英雄';
  if Sender = DBHeroState then sMsg:= '英雄状态信息';
  if Sender = DBHeroPackage then sMsg:= '英雄包裹';
  if Sender = DBCallDeputyHero then sMsg:= '召唤副将英雄';
  if Sender = Challenge then sMsg:= '挑战';
  if Sender = CharacterSranking then sMsg:= '人物排行';
  if Sender = DBWhisper then sMsg := '私聊记录';
  if Sender = DBotStall then sMsg := '摆摊';
  
  (*if Sender = DBottom then begin
    g_nUserSelectName := 0;
    {$IF M2Version = 1}
    if ((X>=42) and (X<=60)) and ((Y>=423) and (Y<=461)) then begin
      if g_MySelf.m_Abil.MaxTransferValue <= 0 then Exit;
      sMsg := IntToStr(g_MySelf.m_Abil.TransferValue)+ '/' + IntToStr(g_MySelf.m_Abil.MaxTransferValue);
      nHintX := 12;
      nHintY := 414;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end else
    {$IFEND}
    if ((X >= SCREENWIDTH - 135) and (X <= SCREENWIDTH - 96)) and ((Y >= SCREENHEIGHT - 108) and (Y <= SCREENHEIGHT - 92)) then begin
      sMsg := '当前等级';
      nHintX := SCREENWIDTH - 135;
      nHintY := SCREENHEIGHT - 92+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end
    else if ((X >= SCREENWIDTH - 135) and (X <= SCREENWIDTH - 55)) and ((Y >= SCREENHEIGHT - 77) and (Y <= SCREENHEIGHT - 63)) then begin
      sMsg := '当前经验';
      nHintX := SCREENWIDTH - 135;
      nHintY := SCREENHEIGHT - 63+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg+FloatToStrFixFmt(100 * (g_MySelf.m_Abil.Exp / g_MySelf.m_Abil.MaxExp), 3, 2) +'%', clWhite, TRUE);
      Exit;
    end
    else if ((X >= SCREENWIDTH - 135) and (X <= SCREENWIDTH - 55)) and ((Y >= SCREENHEIGHT - 44) and (Y <= SCREENHEIGHT - 28)) then begin
      sMsg := format('包裹负重%d/%d',[g_MySelf.m_Abil.Weight,g_MySelf.m_Abil.MaxWeight]);
      nHintX := SCREENWIDTH - 135;
      nHintY := SCREENHEIGHT - 28+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end;
  end;   *)
  if pos('\',sMsg) > 0 then
    nLocalY := 12
  else nLocalY := 0;

  with Butt as TDButton do
    DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop - 20 -nLocalY ), sMsg, clWhite, FALSE);
end;


procedure TFrmDlg.DFrdFriendDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if not Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           d := WLib.Images[FaceIndex + 1];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DBotFriendClick(Sender: TObject; X, Y: Integer);
begin
  OpenFriendDlg();
end;
procedure TFrmDlg.DBotFriendInitialize(Sender: TObject);
begin
  DBotFriend.SetImgIndex (g_WMain3Images,34);  //关系系统
end;

procedure TFrmDlg.OpenFriendDlg();
begin
  DFriendDlg.Visible:=not DFriendDlg.Visible;
end;

procedure TFrmDlg.DFrdCloseClick(Sender: TObject; X, Y: Integer);
begin
  OpenFriendDlg();
end;

procedure TFrmDlg.DChgGamePwdDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d:TDirectDrawSurface;
begin
  with Sender as TDWindow do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    dsurface.BoldTextOut (SurfaceX(GLeft+14), SurfaceY(GTop+12), clWhite, clBlack, 'GamePoint');
    frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];
    dsurface.BoldTextOut (SurfaceX(GLeft+11), SurfaceY(GTop+189), clYellow, clBlack, 'GameGold');
    frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];
  end;
end;


//召唤英雄
procedure TFrmDlg.DBCallHeroClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  if GetTickCount - g_CallHeroTick > 5000 then begin
    g_CallHeroTick := GetTickCount();
    if FrmDlg.DBCallHero.ShowHint then
        msg := MakeDefaultMsg (aa(CM_RECALLHERO, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount) //召唤英雄
    else
        msg := MakeDefaultMsg (aa(CM_HEROLOGOUT, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount); //英雄退出
     FrmMain.SendSocket (EncodeMessage (msg));
  end;
end;

//拒绝行会聊天信息
procedure TFrmDlg.DBRefuseguildClick(Sender: TObject; X, Y: Integer);
begin
  if g_Refuseguild then begin
      DBRefuseguild.SetImgIndex(g_WMain3Images,287);
      DBRefuseguild.GLeft:=175;
      DBRefuseguild.GTop:=180;
      g_Refuseguild:=false;
      FrmMain.SendSay ('@拒绝行会聊天');
  end else begin
      DBRefuseguild.SetImgIndex(g_WMain3Images,286);
      DBRefuseguild.GLeft:=175;
      DBRefuseguild.GTop:=180;
      g_Refuseguild:=true;
      FrmMain.SendSay ('@拒绝行会聊天');
  end;
end;

//拒绝私聊
procedure TFrmDlg.DBRefuseWHISPERClick(Sender: TObject; X, Y: Integer);
begin
if g_RefuseWHISPER then begin
  DBRefuseWHISPER.SetImgIndex(g_WMain3Images,285);
  DBRefuseWHISPER.GLeft:=175;
  DBRefuseWHISPER.GTop:=160;
  g_RefuseWHISPER:=false;
  FrmMain.SendSay ('@拒绝私聊'); end
  else begin
  DBRefuseWHISPER.SetImgIndex(g_WMain3Images,284);
  DBRefuseWHISPER.GLeft:=175;
  DBRefuseWHISPER.GTop:=160;
  g_RefuseWHISPER:=true;
  FrmMain.SendSay ('@拒绝私聊');
end;
end;

procedure TFrmDlg.DBHeroStateClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then exit;
  {$IF M2Version = 0} //合击
  if g_ClientConf.boUses176StateWin then
    DStateHero.Visible := not DStateHero.Visible
  else
  {$ifend}
  if g_boNewNewHeroState then begin
    DWNewStateHero.Visible := not DWNewStateHero.Visible;
  end else begin
    DStateHero.Visible := not DStateHero.Visible;
    DScreen.AddChatBoardString ('由于你的客户端资源过旧，强化技能、心法将无法使用，请更新最新资源！',clLime, clBlack);
  end;
{$IFEND}
end;

//关闭英雄信息栏
procedure TFrmDlg.DCloseHeroStateClick(Sender: TObject; X, Y: Integer); //$008 2007.10.21
begin
  DStateHero.Visible:=FALSE;
end;

//英雄装备栏绘制
procedure TFrmDlg.DStateHeroDirectPaint(Sender: TObject;     //$007 2007.10.21
  dsurface: TDirectDrawSurface);
var
   i, l, m, pgidx, magline, bbx, bby, mmx, idx, ax, ay, trainlv: integer;
   pm: PTClientMagic;
   d: TDirectDrawSurface;
   old, MagColor: integer;
   rc: TRect;
   wm: TWMImages;
begin
  if g_HeroSelf = nil then exit;
  DHeroLiquorProgress.Visible := False;
  DHeroJQExp.Visible := False;
  {$IF M2Version <> 2}
  DBHeroQSSSee.Visible := False;
  {$IFEND}
  with DStateHero do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_boIsHeroInternalForce then begin
      if HeroStateTab = 0 then
        d := g_WMain2Images.Images[746]
      else d := g_WMain2Images.Images[747];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+31, d.ClientRect, d, TRUE);
    end;
    if DHeroStateSsas.Visible then begin
      with DHeroStateSsas do begin
        if WLib <> nil then begin //20080701
          if HeroStateTab = 0 then begin
            d := WLib.Images[FaceIndex + HeroStatePage];
          end else begin
            d := WLib.Images[FaceIndex + 10 + HeroInternalForcePage];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if HeroStateTab = 0 then begin
          frmMain.Canvas.Font.Style:=[fsBold];
          if HeroStatePage = 0 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $00A8D4E8, clBlack, '装');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+21, $00A8D4E8, clBlack, '备');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $00708CA0, clBlack, '装');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+21, $00708CA0, clBlack, '备');
          end;
          if HeroStatePage = 1 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+56, $00A8D4E8, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+69, $00A8D4E8, clBlack, '态');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+56, $00708CA0, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+69, $00708CA0, clBlack, '态');
          end;
          if HeroStatePage = 2 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+102, $00A8D4E8, clBlack, '属');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+115, $00A8D4E8, clBlack, '性');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+102, $00708CA0, clBlack, '属');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+115, $00708CA0, clBlack, '性');
          end;
          if HeroStatePage = 3 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+146, $00A8D4E8, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+159, $00A8D4E8, clBlack, '能');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+146, $00708CA0, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+159, $00708CA0, clBlack, '能');
          end;
          if HeroStatePage = 4 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+190, $00A8D4E8, clBlack, '出');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+203, $00A8D4E8, clBlack, '战');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+190, $00708CA0, clBlack, '出');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+203, $00708CA0, clBlack, '战');
          end;
          frmMain.Canvas.Font.Style:=[];
        end else begin
          frmMain.Canvas.Font.Style:=[fsBold];
          if HeroInternalForcePage = 0 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+8, $0048A4E8, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+22, $0048A4E8, clBlack, '态');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+8, $006098B8, clBlack, '状');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+22, $006098B8, clBlack, '态');
          end;
          if HeroInternalForcePage = 1 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+58, $0048A4E8, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+72, $0048A4E8, clBlack, '能');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+58, $006098B8, clBlack, '技');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+72, $006098B8, clBlack, '能');
          end;
          {$IF M2Version = 1}
          if HeroInternalForcePage = 2 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+105, $0048A4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+119, $0048A4E8, clBlack, '络');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+104, $006098B8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+118, $006098B8, clBlack, '络');
          end;
          if HeroInternalForcePage = 3 then begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+150, $0048A4E8, clBlack, '连');
            dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+164, $0048A4E8, clBlack, '击');
          end else begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+150, $006098B8, clBlack, '连');
            dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+164, $006098B8, clBlack, '击');
          end;
          {$IFEND}
          frmMain.Canvas.Font.Style:=[];
        end;
      end;
    end;
    case HeroStateTab of
      0: begin
        case HeroStatePage of
          0: begin //自己装备  2007.10.16 
            pgidx := 380{376};              //男4格  2007.10.16 
            if g_HeroSelf <> nil then
               if g_HeroSelf.m_btSex = 1 then
               pgidx := 381{377};  //女4格  2007.10.16 
            bbx := GLeft + 38;
            bby := GTop + 52;
            d := g_WMain3Images.Images[pgidx];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            bbx := bbx - 7;
            bby := bby + 44;
            with g_HeroItems[U_DRESS] do begin//修复不显示衣服By TasNat at: 2012-11-02 09:57:01
              if S.Name <> '' then begin
              idx := S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
              //Modified By TasNat at: 2012-11-22 10:47:29
              if GetEffecItemList(S.Name).btShapeCount > 0 then with GetEffecItemList(S.Name) do begin
                if GetTickCount - g_DrawHeroUseItems[U_DRESS].dwDrawTick >= 150 then begin
                  g_DrawHeroUseItems[U_DRESS].dwDrawTick := GetTickCount;
                  Inc(g_DrawHeroUseItems[U_DRESS].nIndex);
                  if g_DrawHeroUseItems[U_DRESS].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_DRESS].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_DRESS].nIndex, ax, ay);
                  if d <> nil then begin
                    DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                  end;
                end;
              end;
              end;
              end;
            end;
            //自己人物发型  2007.10.16 
            idx := 1799;
            if g_HeroSelf.m_btSex = 1 then idx := 2399;
            if g_HeroSelf.m_btSex = 0 then begin  //男
              if g_HeroSelf.m_btHair <> 0 then begin
                if idx > 0 then begin
                  d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                  if d <> nil then
                     dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end;
            end else if g_HeroSelf.m_btHair <> 1 then begin
              if idx > 0 then begin
                d := g_WHairImgImages.GetCachedImage (idx, ax, ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
              end;
            end else begin
              d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
            if g_HeroItems[U_WEAPON].S.Name <> '' then begin
              idx := g_HeroItems[U_WEAPON].S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                //Modified By TasNat at: 2012-11-22 10:47:29
                with GetEffecItemList(g_HeroItems[U_WEAPON].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawHeroUseItems[U_WEAPON].dwDrawTick >= 150 then begin
                      g_DrawHeroUseItems[U_WEAPON].dwDrawTick := GetTickCount;
                      Inc(g_DrawHeroUseItems[U_WEAPON].nIndex);
                      if g_DrawHeroUseItems[U_WEAPON].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_WEAPON].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_WEAPON].nIndex, ax, ay); 
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end;
                //斗笠 20080417
            if g_HeroItems[U_ZHULI].S.Name <> '' then begin
              if g_HeroItems[U_ZHULI].S.Shape <> 2  then begin
                idx := g_HeroItems[U_ZHULI].S.Looks;
                if idx >= 0 then begin
                  d := FrmMain.GetWStateImg(idx,ax,ay);
                  if d <> nil then
                    dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                end;
              end else begin     //黑巾
                if (g_HeroItems[U_HELMET].S.Looks = 103) or (g_HeroItems[U_HELMET].S.Looks = 106) or (g_HeroItems[U_HELMET].S.Looks = 344) or (g_HeroItems[U_HELMET].S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
                  if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
                    idx := g_HeroItems[U_HELMET].S.Looks;
                    if idx >= 0 then begin
                      d := FrmMain.GetWStateImg(idx,ax,ay);
                      if d <> nil then
                        dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                  idx := g_HeroItems[U_ZHULI].S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                end else begin
                  idx := g_HeroItems[U_ZHULI].S.Looks;
                  if idx >= 0 then begin
                    d := FrmMain.GetWStateImg(idx,ax,ay);
                    if d <> nil then
                      dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                  end;
                  if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
                    idx := g_HeroItems[U_HELMET].S.Looks;
                    if idx >= 0 then begin
                       d := FrmMain.GetWStateImg(idx,ax,ay);
                       if d <> nil then
                          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                    end;
                  end;
                end;

              end;
              if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
                //Modified By TasNat at: 2012-11-22 10:47:29
                with GetEffecItemList(g_HeroItems[U_HELMET].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawHeroUseItems[U_HELMET].dwDrawTick >= 150 then begin
                      g_DrawHeroUseItems[U_HELMET].dwDrawTick := GetTickCount;
                      Inc(g_DrawHeroUseItems[U_HELMET].nIndex);
                      if g_DrawHeroUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_HELMET].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_HELMET].nIndex, ax, ay);
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end else
            if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
              idx := g_HeroItems[U_HELMET].S.Looks;
              if idx >= 0 then begin
                d := FrmMain.GetWStateImg(idx,ax,ay);
                if d <> nil then
                   dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
                //Modified By TasNat at: 2012-11-22 10:47:29
                with GetEffecItemList(g_HeroItems[U_HELMET].S.Name) do begin
                  if btShapeCount > 0 then begin
                    if GetTickCount - g_DrawHeroUseItems[U_HELMET].dwDrawTick >= 150 then begin
                      g_DrawHeroUseItems[U_HELMET].dwDrawTick := GetTickCount;
                      Inc(g_DrawHeroUseItems[U_HELMET].nIndex);
                      if g_DrawHeroUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_HELMET].nIndex := 0;
                    end;
                    wm := GetItemEffectWil(btShapeWilIndex);
                    if wm <> nil then begin
                      d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_HELMET].nIndex, ax, ay);
                      if d <> nil then begin
                        DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
                      end;
                    end;
                  end;
                end;
              end;
            end;
            dsurface.TextOut (SurfaceX(GLeft + 122 - frmMain.Canvas.TextWidth(g_HeroSelf.m_sUserName) div 2),
                              SurfaceY(GTop + 52), clWhite, g_HeroSelf.m_sUserName);
          end;
          1: begin //瓷仿摹
            bbx := GLeft + 38;
            bby := GTop + 52;
            d:=g_WUiMainImages.Images[30];
            if d<>nil then
              dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            l := GLeft + 110; //66;
            m := GTop + 97;
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+0), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.AC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.AC)));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+20), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.MAC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.MAC)));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+40), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.DC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.DC)));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+60), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.MC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.MC)));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+80), clWhite, clBlack, IntToStr(LoWord(g_HeroSelf.m_Abil.SC)) + '-' + IntToStr(HiWord(g_HeroSelf.m_Abil.SC)));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+100), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.HP) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxHP));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+120), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.MP) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxMP));
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+140), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.MedicineValue) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxMedicineValue));//20080624
            dsurface.BoldTextOut (SurfaceX(l), SurfaceY(m+160), clWhite, clBlack, IntToStr(g_HeroSelf.m_Abil.MaxAlcohol));
            DHeroLiquorProgress.Visible := True;
          end;
          2: begin //人物属性数值
            bbx := GLeft + 57;
            bby := GTop + 61;
            mmx := bbx + 85;
            dsurface.BoldTextOut (bbx, bby, clSilver, clBlack, '当前经验');
            dsurface.BoldTextOut (mmx, bby, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.nExp));
            dsurface.BoldTextOut (bbx, bby+14*1, clSilver, clBlack, '升级经验');
            dsurface.BoldTextOut (mmx, bby+14*1, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.nMaxExp));
            dsurface.BoldTextOut (bbx, bby+14*2, clSilver, clBlack, '背包重量');
            if g_HeroSelf.m_Abil.Weight > g_HeroSelf.m_Abil.MaxWeight then
              dsurface.BoldTextOut (mmx, bby+14*2, clRed, clBlack, IntToStr(g_HeroSelf.m_Abil.Weight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWeight))
            else dsurface.BoldTextOut (mmx, bby+14*2, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.Weight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWeight));
            dsurface.BoldTextOut (bbx, bby+14*3, clSilver, clBlack, '穿戴重量');
            if g_HeroSelf.m_Abil.WearWeight > g_HeroSelf.m_Abil.MaxWearWeight then
              dsurface.BoldTextOut (mmx, bby+14*3, clRed, clBlack, IntToStr(g_HeroSelf.m_Abil.WearWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWearWeight))
            else dsurface.BoldTextOut (mmx, bby+14*3, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.WearWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxWearWeight));
            dsurface.BoldTextOut (bbx, bby+14*4, clSilver, clBlack, '腕力');
            if g_HeroSelf.m_Abil.HandWeight > g_HeroSelf.m_Abil.MaxHandWeight then
              dsurface.BoldTextOut (mmx, bby+14*4, clRed, clBlack, IntToStr(g_HeroSelf.m_Abil.HandWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxHandWeight))
            else dsurface.BoldTextOut (mmx, bby+14*4, clSilver, clBlack, IntToStr(g_HeroSelf.m_Abil.HandWeight) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxHandWeight));
            dsurface.BoldTextOut (bbx, bby+14*5, clSilver, clBlack, '精确度');
            dsurface.BoldTextOut (mmx, bby+14*5, clSilver, clBlack, IntToStr(g_nHeroHitPoint));
            dsurface.BoldTextOut (bbx, bby+14*6, clSilver, clBlack, '敏捷度');
            dsurface.BoldTextOut (mmx, bby+14*6, clSilver, clBlack, IntToStr(g_nHeroSpeedPoint));
            dsurface.BoldTextOut (bbx, bby+14*7, clSilver, clBlack, '魔法防御');
            dsurface.BoldTextOut (mmx, bby+14*7, clSilver, clBlack, '+' + IntToStr(g_nHeroAntiMagic * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*8, clSilver, clBlack, '中毒防御');
            dsurface.BoldTextOut (mmx, bby+14*8, clSilver, clBlack, '+' + IntToStr(g_nHeroAntiPoison * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*9, clSilver, clBlack, '中毒恢复');
            dsurface.BoldTextOut (mmx, bby+14*9, clSilver, clBlack, '+' + IntToStr(g_nHeroPoisonRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*10, clSilver, clBlack, '体力恢复');
            dsurface.BoldTextOut (mmx, bby+14*10, clSilver, clBlack, '+' + IntToStr(g_nHeroHealthRecover * 10) + '%');
            dsurface.BoldTextOut (bbx, bby+14*11, clSilver, clBlack, '魔法恢复');
            dsurface.BoldTextOut (mmx, bby+14*11, clSilver, clBlack, '+' + IntToStr(g_nHeroSpellRecover * 10) + '%');
          end;
          3: begin //魔法背景
            bbx := GLeft + 38;
            bby := GTop + 52;
            d:=FrmMain.UiDXImageList.Items.Find('HeroAbility').PatternSurfaces[0];
            if d <> nil then
               dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, FALSE);
            HeroMagTop := HeroMagicPage * 6;
            magline := _MIN(HeroMagicPage*6+6, g_HeroMagicList.Count);
            for i:=HeroMagTop to magline-1 do begin
              pm := PTClientMagic (g_HeroMagicList[i]);
              m := i - HeroMagTop;
              d := g_WMainImages.Images[112]; //lv
              if d <> nil then begin
                if pm.Def.wMagicId = 68 then   //酒气护体
                  dsurface.Draw (bbx + 110, bby+15+m*37-7, d.ClientRect, d, TRUE)
                else dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);
              end;
              d := g_WMainImages.Images[111]; //exp
              if d <> nil then begin
                if pm.Def.wMagicId <> 68 then
                  dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
              end;
              case pm.Def.wMagicId of
                68: begin
                  if pm.Level < 100 then begin
                    DHeroJQExp.GLeft := 86;
                    DHeroJQExp.GTop := 79+m*37;
                    if not DHeroJQExp.Visible then DHeroJQExp.Visible := True;
                  end;
                end;
                {$IF M2Version <> 2}
                99: begin //强身术
                  DBHeroQSSSee.GLeft := 160;
                  DBHeroQSSSee.GTop := 60+m*37;
                  if not DBHeroQSSSee.Visible then DBHeroQSSSee.Visible := True;
                end;
                {$IFEND}
              end;
              {if (pm.Def.wMagicId = 68) and (pm.Level < 100) then begin
                DHeroJQExp.GLeft := 38 + 48;
                DHeroJQExp.GTop := 52+27+m*37;
                if not DHeroJQExp.Visible then DHeroJQExp.Visible := True;
              end;}
            end;
            for i:=HeroMagTop to magline-1 do begin
              pm := PTClientMagic (g_HeroMagicList[i]);
              if word(pm.Key) = 0 then MagColor := clSilver
                else MagColor := clGray;
              m := i - HeroMagTop;                                         
              if not (pm.Def.wMagicId in [68,95,99,104]) then
              if not (pm.Level in [0..4]) then pm.Level := 0;//20080111 技能等级显示

              if word(pm.Key) = 0 then
                dsurface.BoldTextOut (bbx + 47, bby + 7 + m*37, MagColor, clBlack, pm.Def.sMagicName)
              else dsurface.BoldTextOut (bbx + 47, bby + 7 + m*37, MagColor, clBlack, pm.Def.sMagicName+'[关]');
              if pm.Def.wMagicId = 68 then begin
                trainlv := pm.Level;
                dsurface.BoldTextOut (bbx + 123, bby + 14 + m*37-7, clSilver, clBlack, IntToStr(pm.Level));
              end else if pm.Def.wMagicId = 95 then begin //斗转星移
                dsurface.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-');
                Continue; //继续
              end else if pm.Def.wMagicId = 99 then begin  //强身术
                trainlv := pm.Level;
                dsurface.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Level = 99 then
                  dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-')
                else dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else if pm.Def.wMagicId = 104 then begin
                dsurface.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
                if pm.Level = 100 then
                  dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-')
                else dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
                Continue;//继续
              end else begin
                if pm.Level in [0..4] then trainlv := pm.Level//20080111 技能等级显示
                else trainlv := 0;
                dsurface.BoldTextOut (bbx + 63, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.Level));
              end;
              if trainlv = 4 then begin
                if (pm.Def.wMagicId <> 68) then
                dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-');
              end else
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                if (pm.Def.wMagicId <> 68) then begin
                  if trainlv < 3 then
                    dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else dsurface.BoldTextOut (bbx + 93, bby + 22 + m*37, MagColor, clBlack, '-');
                end;
              end;
            end;
          end;
        end;
      end;
      1: begin
        case HeroInternalForcePage of
          0: begin
            d := g_WMain2Images.Images[749];
            if d<>nil then begin
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (SurfaceX(GLeft) + 38, SurfaceY(GTop) + 52, rc, d, False);
            end;
            d:=g_WMain2Images.Images[752];
            if d<>nil then
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 109, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 134, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 159, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 184, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 209, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 234, d.ClientRect, d, TRUE);
            dsurface.Draw (SurfaceX(GLeft) + 122, SurfaceY(GTop) + 259, d.ClientRect, d, TRUE);

            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 111, clSilver, clBlack, '当前内功等级');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 136, clSilver, clBlack, '当前内功经验');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 161, clSilver, clBlack, '升级内功经验');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 186, clSilver, clBlack, '内 力 值');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 211, clSilver, clBlack, '内功恢复速度');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 236, clSilver, clBlack, '内功伤害增加');
            dsurface.BoldTextOut (SurfaceX(GLeft) + 45, SurfaceY(GTop) + 261, clSilver, clBlack, '内功伤害减免');

            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 111, clSilver, clBlack, IntToStr(g_dwHeroInternalForceLevel));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 136, clSilver, clBlack, IntToStr(g_dwHeroExp69));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 161, clSilver, clBlack, IntToStr(g_dwHeroMaxExp69));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 186, clSilver, clBlack, IntToStr(g_HeroSelf.m_Skill69NH)+'/'+IntToStr(g_HeroSelf.m_Skill69MaxNH));

            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 211, clSilver, clBlack, IntToStr(g_nHeroInternalRecovery));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 236, clSilver, clBlack, IntToStr(g_nHeroInternalHurtAdd));
            dsurface.BoldTextOut (SurfaceX(GLeft) + 127, SurfaceY(GTop) + 261, clSilver, clBlack, IntToStr(g_nHeroInternalHurtRelief));
          end;
          1: begin
            d := g_WMain2Images.Images[751];
            if d<>nil then begin
              bbx := GLeft + 38;
              bby := GTop + 52;
              rc := d.ClientRect;
              rc.Right := d.ClientRect.Right - 4;
              rc.Bottom := d.ClientRect.Bottom - 2;
              dsurface.Draw (SurfaceX(GLeft) + 38, SurfaceY(GTop) + 52, rc, d, False);

              HeroMagTop := HeroInternalForceMagicPage * 6;
              magline := _MIN(HeroInternalForceMagicPage*6+6, g_HeroInternalForceMagicList.Count);
              for i:=HeroMagTop to magline-1 do begin
                pm := PTClientMagic (g_HeroInternalForceMagicList[i]);
                m := i - HeroMagTop;
                {d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
                if d <> nil then
                    dsurface.Draw (bbx + 8, bby+7+m*37, d.ClientRect, d, TRUE);    }
                d := g_WMainImages.Images[112]; //lv
                if d <> nil then
                    dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);
                d := g_WMainImages.Images[111]; //exp
                if d <> nil then begin
                  if pm.Def.wMagicId <> 68 then
                    dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
                end;
              end;
              for i:=HeroMagTop to magline-1 do begin
                pm := PTClientMagic (g_HeroInternalForceMagicList[i]);
                if word(pm.Key) = 0 then MagColor := clSilver else MagColor := clGray;
                m := i - HeroMagTop;
                if not (pm.Level in [0..30]) then pm.Level := 0;
                if word(pm.Key) = 0 then
                	dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName)
                else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37, MagColor, clBlack, pm.Def.sMagicName+'[关]');

                if pm.Level in [0..30] then trainlv := pm.Level
                else trainlv := 0;
                dsurface.BoldTextOut (bbx + 64, bby + 23 + m*37, clSilver, clBlack, IntToStr(pm.Level));
                if pm.Def.MaxTrain[trainlv] > 0 then begin
                  if trainlv < 3 then
                    dsurface.BoldTextOut (bbx + 94, bby + 23 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                  else dsurface.BoldTextOut (bbx + 94, bby + 23 + m*37, clSilver, clBlack, '-');
                end;
              end;
            end;
          end;
        end;
      end;
    end;
    //本代码为显示人物身上所带物品信息，显示位置为人物下方
    if g_HeroBatterDesc.sName <> '' then begin
      old := frmMain.Canvas.Font.Size;
      frmMain.Canvas.Font.Size := 9;
      dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309), clYellow, clBlack, g_HeroBatterDesc.sName);
      dsurface.BoldTextOut (SurfaceX(GLeft+36+ frmMain.Canvas.TextWidth(g_HeroBatterDesc.sName)), SurfaceY(GTop+309), clWhite, clBlack, g_HeroBatterDesc.sLine1);
      dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+frmMain.Canvas.TextHeight('A')+2), clWhite, clBlack, g_HeroBatterDesc.sLine2);
      dsurface.BoldTextOut (SurfaceX(GLeft+36), SurfaceY(GTop+309+(frmMain.Canvas.TextHeight('A')+2)*2), clWhite, clBlack, g_HeroBatterDesc.sLine3);
      frmMain.Canvas.Font.Size := old;
    end(* else begin
        if g_HeroMouseStateItem.S.Name <> '' then begin
           g_HeroMouseItem := g_HeroMouseStateItem;
           GetMouseItemInfo (iname, d1, d2, d3, useable,2);
           if iname <> '' then begin
              if g_HeroMouseItem.Dura = 0 then hcolor := clRed
              else hcolor := clWhite;
                 BoldTextOut (dsurface,SurfaceX(GLeft+36), SurfaceY(GTop+309), clYellow, clBlack,iname);
                 BoldTextOut (dsurface,SurfaceX(GLeft+36+ frmMain.Canvas.TextWidth(iname)), SurfaceY(GTop+309), hcolor, clBlack,d1);
                 BoldTextOut (dsurface,SurfaceX(GLeft+36), SurfaceY(GTop+309+frmMain.Canvas.TextHeight('A')+2), hcolor, clBlack,d2);
                 BoldTextOut (dsurface,SurfaceX(GLeft+36), SurfaceY(GTop+309+(frmMain.Canvas.TextHeight('A')+2)*2), hcolor, clBlack,d3);
           end;
           g_HeroMouseItem.S.Name := '';
        end;
      end;  *)
  end;
end;

procedure TFrmDlg.DCloseHeroStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

//鼠标在装备栏某个装备上移动显示过程
procedure TFrmDlg.DSHWeaponMouseMove(Sender: TObject; Shift: TShiftState;   //$006 2007.10.21
  X, Y: Integer);
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  Butt:TDButton;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
begin
  if (HeroStateTab <> 0) or (HeroStatePage <> 0) then exit;
  sel := -1;
  Butt:=TDButton(Sender);
  if Sender = DSHDress then sel := U_DRESS;
  if Sender = DSHWeapon then sel := U_WEAPON;
  if Sender = DSHHelmet then sel := U_HELMET;
  if Sender = DSHNecklace then sel := U_NECKLACE;
  if Sender = DSHLight then sel := U_RIGHTHAND;
  if Sender = DSHRingL then sel := U_RINGL;
  if Sender = DSHRingR then sel := U_RINGR;
  if Sender = DSHArmRingL then sel := U_ARMRINGL;
  if Sender = DSHArmRingR then sel := U_ARMRINGR;
  if Sender = DSHBujuk then sel := U_BUJUK;
  if Sender = DSHBelt then sel := U_BELT;
  if Sender = DSHBoots then sel := U_BOOTS;
  if Sender = DSHCharm then sel := U_CHARM;

  if sel >= 0 then begin
    g_HeroMouseStateItem := g_HeroItems[sel];
    g_HeroBatterDesc.sName := '';
    if (g_HeroItems[sel].S.Name <> '') or (g_HeroItems[U_ZHULI].S.Name <> '') then begin
      if (sel = U_HELMET) and (g_HeroItems[U_ZHULI].S.Name <> '') then begin
        g_HeroMouseItem := g_HeroItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
        {if iname <> '' then begin
          if g_HeroItems[U_ZHULI].Dura = 0 then hcolor := '~r'
          else hcolor := '';
          Lines := iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~Y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;}
        if iname <> '' then begin
          if g_HeroItems[U_ZHULI].Dura = 0 then hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(g_HeroItems[sel].S.Name, 2);
      if DStateHero.GLeft >= 350 then
        nHintX:=DStateHero.SurfaceX(DStateHero.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DStateHero.SurfaceX(DStateHero.GLeft)+DStateHero.GWidth;
      nHintY:=DStateHero.SurfaceY(DStateHero.GTop) +50;
      g_HeroMouseItem := g_HeroItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
      if (iname <> '') or (Lines <> '') then begin
        if g_HeroItems[sel].Dura = 0 then hcolor := 'red'
        else hcolor := '';
        with Butt as TDButton do begin
          if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
            {DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, d1, hColor, d2, d3, d4, d5, d6, d7]), False);}
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,2)]), False
                                      );
          end;
        end;
      end;
      g_HeroMouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DBHeroPackageClick(Sender: TObject; X, Y: Integer);
begin
   if g_HeroSelf = nil then exit;
   DHeroItemBag.Visible := not DHeroItemBag.Visible;
   if DHeroItemBag.Visible then
   ArrangeHeroItemBag;
end;

//英雄显示装备
procedure TFrmDlg.DSHLightDirectPaint(Sender: TObject;  // $011 2007.10.21
  dsurface: TDirectDrawSurface);
var
   idx, nWhere, ax, ay: integer;
   d: TDirectDrawSurface;
   wm: TWMImages;
begin
  nWhere := -1;
  if (HeroStateTab = 0{基本页}) and (HeroStatePage = 0) then begin
    if Sender = DSHNecklace then nWhere := U_NECKLACE;
    if Sender = DSHLight then nWhere := U_RIGHTHAND;
    if Sender = DSHArmRingR then nWhere := U_ARMRINGR;
    if Sender = DSHArmRingL then nWhere := U_ARMRINGL;
    if Sender = DSHRingR then nWhere := U_RINGR;
    if Sender = DSHRingL then nWhere := U_RINGL;
    if Sender = DSHBujuk then nWhere := U_BUJUK;
    if Sender = DSHBelt then nWhere := U_BELT;
    if Sender = DSHBoots then nWhere := U_BOOTS;
    if Sender = DSHCharm then nWhere := U_CHARM;

    if nWhere >= 0 then begin
      if g_HeroItems[nWhere].S.Name <> '' then begin
        idx := g_HeroItems[nWhere].S.looks;
        if idx >= 0 then begin
          d := frmMain.GetWStateImg(idx);
          if d <> nil then begin
            with TDButton(Sender) do begin
              dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                            SurfaceY(GTop + (GHeight - d.Height) div 2),
                            d.ClientRect, d, TRUE);
              //Modified By TasNat at: 2012-11-22 10:47:29
              if GetEffecItemList(g_HeroItems[nWhere].S.Name).btShapeCount > 0 then begin
                with GetEffecItemList(g_HeroItems[nWhere].S.Name) do begin
                  if GetTickCount - g_DrawHeroUseItems[nWhere].dwDrawTick >= 150 then begin
                    g_DrawHeroUseItems[nWhere].dwDrawTick := GetTickCount;
                    Inc(g_DrawHeroUseItems[nWhere].nIndex);
                    if g_DrawHeroUseItems[nWhere].nIndex > btShapeCount-1 then g_DrawHeroUseItems[nWhere].nIndex := 0;
                  end;
                  wm := GetItemEffectWil(btShapeWilIndex);
                  if wm <> nil then begin
                    d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[nWhere].nIndex, ax, ay);
                    if d <> nil then begin
                      DrawBlend(dsurface,SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d, 255);
                    end;
                  end;
                end;
              end else begin
                if g_HeroItems[nWhere].S.Reserved1 = 1 then begin
                  ItemLightTimeImg(); //物品发光变换函数 20080223
                  d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                  if d <> nil then
                    DrawBlend(dsurface,SurfaceX(GLeft-21), SurfaceY(GTop-23), d, 255);
                end;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;


procedure TFrmDlg.DHeroItemBagDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   //d0, d1, d2, d3, d4, d5: string;
   {n,} HitY: integer;
   //useable: Boolean;
   d: TDirectDrawSurface;
begin
   if g_HeroSelf = nil then Exit;
      with DHeroItemBag do begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
         //GetMouseItemInfo (d0, d1, d2, d3, d4, d5, useable, 2{英雄});
         case g_HeroBagCount of
            10: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 375);
              DHeroItemGrid.RowCount:= 2;
              DHeroItemGrid.GHeight:= 63;
            end;
            20: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 376);
              DHeroItemGrid.RowCount:= 4;
              DHeroItemGrid.GHeight:= 126;
            end;
            30: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 377);
              DHeroItemGrid.RowCount:= 6;
              DHeroItemGrid.GHeight:= 192;
            end;
            35: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 378);
              DHeroItemGrid.RowCount:= 7;
              DHeroItemGrid.GHeight:= 224;
            end;
            40: begin
              DHeroItemBag.SetImgIndex (g_WMain3Images, 379);
              DHeroItemGrid.RowCount:= 8;
              DHeroItemGrid.GHeight:= 255;
            end;
         end;

          HitY := DHeroItemGrid.GHeight+41;

          //提示语句   20080222
         //if g_HeroMouseItem.S.Name = '' then begin
            dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+HitY), clWhite, 'ALT  + R 键刷新包裹');
            dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+HitY)+14, clWhite, 'Ctrl + 点击物品 放入人物包裹');
         //end;
          
         //盛大物品栏
         (* if d0 <> '' then begin
            n := FrmMain.Canvas.TextWidth (d0);
            dsurface.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY), clYellow, clBlack,d0);
            dsurface.BoldTextOut (SurfaceX(Left+13) + n, SurfaceY(Top+HitY), clWhite, clBlack,d1);
            dsurface.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY+14), clWhite, clBlack,d2);

            if not useable then
            dsurface.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY+14*2), clRed, clBlack,d3)
            else dsurface.BoldTextOut (SurfaceX(Left+13), SurfaceY(Top+HitY+14*2), clWhite, clBlack,d3);
          end;    *)
   end;           
end;

//英雄包裹绘制
procedure TFrmDlg.DHeroItemGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
  wm: TWMImages;
  ax, ay: Integer;
begin
  idx := ACol + ARow * DHeroItemGrid.ColCount;
  if idx in [0..g_HeroBagCount-1] then begin
    if g_HeroItemArr[idx].S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_HeroItemArr[idx].S.Looks);
      if d <> nil then begin
        with DHeroItemGrid do begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 -1),
                         SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                         d.ClientRect, d, TRUE);
          //Modified By TasNat at: 2012-11-22 10:47:29
          if GetEffecItemList(g_HeroItemArr[idx].S.Name).btBagCount > 0 then begin
            with GetEffecItemList(g_HeroItemArr[idx].S.Name) do begin
              if GetTickCount - g_DrawHeroBagItemsArr[idx].dwDrawTick >= 150 then begin
                g_DrawHeroBagItemsArr[idx].dwDrawTick := GetTickCount;
                Inc(g_DrawHeroBagItemsArr[idx].nIndex);
                if g_DrawHeroBagItemsArr[idx].nIndex > btBagCount-1 then g_DrawHeroBagItemsArr[idx].nIndex := 0;
              end;
              wm := GetItemEffectWil(btBagWilIndex);
              if wm <> nil then begin
                d := wm.GetCachedImage(wBagIndex+g_DrawHeroBagItemsArr[idx].nIndex, ax, ay);
                if d <> nil then begin
                  DrawBlend(dsurface, SurfaceX(Rect.Left)+ax+nBagX, SurfaceY(Rect.Top)+ay+nBagY, d, 255);
                end;
              end;
            end;
          end else begin
            if g_HeroItemArr[idx].S.Reserved1 = 1 then begin //发光 20080223
              ItemLightTimeImg();
              d := g_WMain2Images.Images[ItemLightImgIdx + 260];
              if d <> nil then
                DrawBlend(dsurface,SurfaceX(Rect.Left-21), SurfaceY(Rect.Top-23), d, 255);
            end;
          end;
          if g_HeroItemArr[idx].S.StdMode = 17 then begin
            dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_HeroItemArr[idx].Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_HeroItemArr[idx].Dura));
          end;
        end;
      end;
    end;
  end;
end;

//鼠标移动过程，鼠标经过某个物品上显示
procedure TFrmDlg.DHeroItemGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
  int: Byte;
begin
  DScreen.ClearHint;
   if ssRight in Shift then begin
      if g_boHeroItemMoving then
         DHeroItemGridGridSelect (self, ACol, ARow, Shift);
   end else begin
      idx := ACol + ARow * DHeroItemGrid.ColCount;
      if idx in [0..g_HeroBagCount-1] then begin
         if (g_HeroItemArr[idx].S.StdMode = 17) and (ssShift in Shift) and (ssLeft in Shift) then begin//拆分物品 20090615
           if g_HeroItemArr[idx].Dura > 1 then begin
             int := 0;
             DMessageDlg ('要拆分多少?', [mbOk, mbAbort]);
             if DlgEditText = '' then int := 1;
             if length(DlgEditText) > 5 then begin
               int := 3;
             end else begin
               if not IsStringNumber(DlgEditText) then int := 2;
             end;
             if int = 0 then begin
               if StrToInt(DlgEditText) >= g_HeroItemArr[idx].Dura then int := 4;//输入大于等于数量时，不做处理
             end;
             case int of
               0: frmMain.SendItemNumUpdateValue(g_HeroItemArr[idx].MakeIndex, StrToInt(DlgEditText), 1);
               1: DMessageDlg ('内容不能为空！', [mbOk]);
               2: DMessageDlg ('输入错误', [mbOk]);
               3: DMessageDlg ('数量不能超过5位', [mbOk]);
             end;
           end;
         end else begin
           g_HeroMouseItem := g_HeroItemArr[idx];
           with DHeroItemGrid do
             ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                               SurfaceY(GTop)+(ARow+1)*RowHeight, '', 2, False);
         end;
      end;
   end;
end;
//移动英雄装备
procedure TFrmDlg.DSHWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: integer;
  flag: Boolean;
  msg: TDefaultMessage;
  {$IF M2Version <> 2}
  MovItem: TMovingItem;
  msgWho: Byte; //2-主人 4-英雄
  {$IFEND}
begin
   if g_HeroSelf = nil then Exit;
   if (HeroStateTab <> 0) or (HeroStatePage <> 0) then exit;
   {$IF M2Version <> 2}
   //修补火龙之心
   if g_boHeroItemMoving or g_boItemMoving then begin
     if Sender = DSHBujuk then begin
       if (g_HeroItems[U_BUJUK].S.Shape = 9) and (g_HeroItems[U_BUJUK].S.StdMode = 25) and (g_HeroItems[U_BUJUK].S.Name <> '') then begin//20090205
         if g_boHeroItemMoving then begin
           if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
           if (g_MovingHeroItem.Item.S.Name = '') or (g_WaitingHeroUseItem.Item.S.Name <> '') then exit;
           MovItem := g_MovingHeroItem;
           msgWho := 4;
         end else if g_boItemMoving then begin
           if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
           if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
           MovItem := g_MovingItem;
           msgWho := 2;
         end;
         if MovItem.Item.S.Name <> '' then begin
           case MovItem.Item.S.StdMode of
             42: begin
               msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);//20071231
               FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.S.Name));//20071231
             end;
             15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
               if (MovItem.Item.S.Source = 127) and (MovItem.Item.S.Stock > 0) then begin
                 msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                 FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.S.Name));
               end;
             end;
             4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.Source = 127时认为是可以修复火龙之心，
               if (MovItem.Item.S.Source = 127) and (MovItem.Item.S.Reserved > 0) then begin
                 msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                 FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.S.Name));
               end;
             end;
           end;
           Exit;
         end;
       end;
     end
   end;
   {$IFEND}
   if g_boHeroItemMoving (*or g_boHeroRightItem{右键点物品}*)  then begin
      flag := FALSE;
      if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
      if (g_MovingHeroItem.Item.S.Name = '') or (g_WaitingHeroUseItem.Item.S.Name <> '') then exit;
      where := GetTakeOnPosition (g_MovingHeroItem.Item.S.StdMode);
      if g_MovingHeroItem.Index >= 0 then begin
         case where of
            U_DRESS: begin
               if Sender = DSHDress then begin
                  if g_HeroSelf.m_btSex = 0 then //男
                     if g_MovingHeroItem.Item.S.StdMode <> 10 then //男衣服
                        exit;
                  if g_HeroSelf.m_btSex = 1 then //女
                     if g_MovingHeroItem.Item.S.StdMode <> 11 then //女衣服
                        exit;
                  flag := TRUE;
               end;
            end;
            U_WEAPON: begin
               if Sender = DSHWEAPON then begin
                  flag := TRUE;
               end;
            end;
            {X_RepairFir: begin //修补火龙之心
              if Sender = DSHBujuk then begin
                if (g_HeroItems[U_BUJUK].S.Shape = 9) and (g_HeroItems[U_BUJUK].S.StdMode = 25) then begin//20090205
                  case g_MovingHeroItem.Item.S.StdMode of
                    42: begin
                      msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
                      FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));//20071231
                    end;
                    15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
                      if (g_MovingHeroItem.Item.S.Source = 127) and (g_MovingHeroItem.Item.S.Stock > 0) then begin
                        msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                        FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));
                      end;
                    end;
                    4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.Source = 127时认为是可以修复火龙之心，
                      if (g_MovingHeroItem.Item.S.Source = 127) and (g_MovingHeroItem.Item.S.Reserved > 0) then begin
                        msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                        FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));
                      end;
                    end;
                  end;
                end;   
              end;
            end;  }
            U_NECKLACE: begin
               if Sender = DSHNecklace then
                  flag := TRUE;
            end;
            U_RIGHTHAND: begin
               if Sender = DSHLight then
                  flag := TRUE;
            end;
            U_HELMET: begin  //头盔
               if Sender = DSHHelmet then
                  flag := TRUE;
            end;
            U_ZHULI: begin //斗笠
              if Sender = DSHHelmet then
                 flag := True;
            end;
            U_RINGR, U_RINGL: begin
               if Sender = DSHRingL then begin
                  where := U_RINGL;
                  flag := TRUE;
               end;
               if Sender = DSHRingR then begin
                  where := U_RINGR;
                  flag := TRUE;
               end;
            end;
            U_ARMRINGR: begin  //迫骂
               if Sender = DSHArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
               if Sender = DSHArmRingR then begin
                  where := U_ARMRINGR;
                  flag := TRUE;
               end;
            end;
            U_ARMRINGL: begin  //25,  刀啊风,迫骂
               if Sender = DSHArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            U_BUJUK: begin
               if Sender = DSHBujuk then begin
                  where := U_BUJUK;
                  flag := TRUE;
               end;
               if Sender = DSHArmRingL then begin
                  where := U_ARMRINGL;
                  flag := TRUE;
               end;
            end;
            U_BELT: begin
               if Sender = DSHBelt then begin
                  where := U_BELT;
                  flag := TRUE;
               end;
            end;
            U_BOOTS: begin
               if Sender = DSHBoots then begin
                  where := U_BOOTS;
                  flag := TRUE;
               end;
            end;
            U_CHARM: begin
               if Sender = DSHCharm then begin
                  where := U_CHARM;
                  flag := TRUE;
               end;
            end;
         end;
         {if Sender = DSHBujuk then begin
           if (g_HeroItems[U_BUJUK].S.Shape = 9) and (g_HeroItems[U_BUJUK].S.StdMode = 25) and (g_HeroItems[U_BUJUK].S.Name <> '') then begin//20090205
             case g_MovingHeroItem.Item.S.StdMode of
               42: begin
                 msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
                 FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));//20071231
               end;
               15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
                 if (g_MovingHeroItem.Item.S.Source = 127) and (g_MovingHeroItem.Item.S.Stock > 0) then begin
                   msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                   FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));
                 end;
               end;
               4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.Source = 127时认为是可以修复火龙之心，
                 if (g_MovingHeroItem.Item.S.Source = 127) and (g_MovingHeroItem.Item.S.Reserved > 0) then begin
                   msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);
                   FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));
                 end;
               end;
             end;
           end;
         end else begin  }
           if Sender = DSHCharm then begin
             if (g_HeroItems[U_CHARM].S.Shape = 5) and (g_HeroItems[U_CHARM].S.StdMode = 7) and (g_HeroItems[U_CHARM].S.Name <> '') then begin//20090205
               case g_MovingHeroItem.Item.S.StdMode of
                 7: begin
                   if g_MovingHeroItem.Item.S.Shape = 3 then begin
                     msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 2, 0, 0, frmMain.m_nSendMsgCount);//20071231
                     FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));//20071231
                     Exit;
                   end;
                 end;
               end;
             end;
           end;
         //end;
      end else begin
         n := -(g_MovingHeroItem.Index+1);
         if n in [0..13] then begin
            ItemClickSound (g_MovingHeroItem.Item.S);
            g_HeroItems[n] := g_MovingHeroItem.Item;
            g_MovingHeroItem.Item.S.Name := '';
            g_boHeroItemMoving := FALSE;
         end;
      end;
      if flag then begin
         ItemClickSound (g_MovingHeroItem.Item.S);
         g_WaitingHeroUseItem := g_MovingHeroItem;
         g_WaitingHeroUseItem.Index := where;
         FrmMain.SendTakeOnHeroItem (where, g_MovingHeroItem.Item.MakeIndex, g_MovingHeroItem.Item.S.Name);
         g_MovingHeroItem.Item.S.Name := '';
         g_boHeroItemMoving := FALSE;
      end;
      if (Sender = DSHBujuk) and (g_MovingHeroItem.Item.S.StdMode=25) and (g_MovingHeroItem.Item.S.Shape=9) and (g_boHeroItemMoving = FALSE) then begin
        DBHeroSpleenImg.Visible:=TRUE;
      end;   //20080319
   end else begin
      if g_boItemMoving then Exit;
      if (g_MovingHeroItem.Item.S.Name <> '') or (g_WaitingHeroUseItem.Item.S.Name <> '') then exit;
      
      sel := -1;
      if Sender = DSHDress then sel := U_DRESS;
      if Sender = DSHWeapon then sel := U_WEAPON;

      //斗笠
      if Sender = DSHHelmet then begin
        if g_HeroItems[U_ZHULI].S.Name <> '' then
         sel := U_ZHULI
        else sel := U_HELMET;
      end;

      if Sender = DSHNecklace then sel := U_NECKLACE;
      if Sender = DSHLight then sel := U_RIGHTHAND;
      if Sender = DSHRingL then sel := U_RINGL;
      if Sender = DSHRingR then sel := U_RINGR;
      if Sender = DSHArmRingL then sel := U_ARMRINGL;
      if Sender = DSHArmRingR then sel := U_ARMRINGR;

      if Sender = DSHBujuk then sel := U_BUJUK;
      if Sender = DSHBelt then sel := U_BELT;  //
      if Sender = DSHBoots then sel := U_BOOTS;
      if Sender = DSHCharm then sel := U_CHARM;

      if sel >= 0 then begin
         if g_HeroItems[sel].S.Name <> '' then begin
            ItemClickSound (g_HeroItems[sel].S);
            g_MovingHeroItem.Index := -(sel+1);
            g_MovingHeroItem.Item := g_HeroItems[sel];
            g_HeroItems[sel].S.Name := '';
            g_boHeroItemMoving := TRUE;
         end;
      end;
      if (Sender = DSHBujuk) and (g_HeroItems[U_BUJUK].S.Shape=9) and (g_boHeroItemMoving = TRUE) then begin
        DBHeroSpleenImg.Visible:=FALSE;
      end;
   end;
end;
//英雄翻页码过程 $013 2007.10.21
procedure TFrmDlg.HeroPageChanged;
begin
   DScreen.ClearHint;
   DLHeroNGUpLevel1.Visible := False;
   DLHeroNGUpLevel2.Visible := False;
   DLHeroNGUpLevel3.Visible := False;
   DLHeroNGUpLevel4.Visible := False;
   DLHeroNGUpLevel5.Visible := False;
   DLHeroNGUpLevel6.Visible := False;
   case HeroStatePage of
      3: begin
         DStMagHero1.Visible := TRUE;  DStMagHero2.Visible := TRUE;
         DStMagHero3.Visible := TRUE;  DStMagHero4.Visible := TRUE;
         DStMagHero5.Visible := TRUE;  DStMagHero6.Visible := TRUE;
         DSHPageUp.Visible := TRUE;
         DSHPageDown.Visible := TRUE;
         HeroMagicPage := 0;
         DCheckHeroDeputyHeroWarr.Visible := FALSE;
         DCheckHeroDeputyHeroWiz.Visible := FALSE;
         DCheckHeroDeputyHeroTaos.Visible := FALSE;
      end;
      4: begin
        DStMagHero1.Visible := FALSE;  DStMagHero2.Visible := FALSE;
        DStMagHero3.Visible := FALSE;  DStMagHero4.Visible := FALSE;
        DStMagHero5.Visible := FALSE;  DStMagHero6.Visible := FALSE;
        DSHPageUp.Visible := FALSE;
        DSHPageDown.Visible := FALSE;
        DCheckHeroDeputyHeroWarr.Visible := True;
        DCheckHeroDeputyHeroWiz.Visible := True;
        DCheckHeroDeputyHeroTaos.Visible := True;
        DCheckHeroDeputyHeroWarr.Checked := False;
        DCheckHeroDeputyHeroWiz.Checked := False;
        DCheckHeroDeputyHeroTaos.Checked := False;
        case m_btDeputyHeroJob of
          0: DCheckHeroDeputyHeroWarr.Checked := True;
          1: DCheckHeroDeputyHeroWiz.Checked := True;
          2: DCheckHeroDeputyHeroTaos.Checked := True;
          else DCheckHeroDeputyHeroWarr.Checked := True;
        end;
      end;
      else begin
         DStMagHero1.Visible := FALSE;  DStMagHero2.Visible := FALSE;
         DStMagHero3.Visible := FALSE;  DStMagHero4.Visible := FALSE;
         DStMagHero5.Visible := FALSE;  DStMagHero6.Visible := FALSE;
         DSHPageUp.Visible := FALSE;
         DSHPageDown.Visible := FALSE;
          DCheckHeroDeputyHeroWarr.Visible := FALSE;
          DCheckHeroDeputyHeroWiz.Visible := FALSE;
          DCheckHeroDeputyHeroTaos.Visible := FALSE;
      end;
   end;
end;
procedure TFrmDlg.DPrevStateHeroClick(Sender: TObject; X, Y: Integer);
begin
  if HeroStateTab = 0 then begin
   Dec (HeroStatePage);
   if HeroStatePage < 0 then
      HeroStatePage := MAXSTATEPAGE-1;
   HeroPageChanged;
  end else begin
    Dec (HeroInternalForcePage);
    if HeroInternalForcePage < 0 then
      HeroInternalForcePage := 1;
    HeroInternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DNextStateHeroClick(Sender: TObject; X, Y: Integer);
begin
  if HeroStateTab = 0 then begin
   Inc (HeroStatePage);
   if HeroStatePage > MAXSTATEPAGE-1 then
      HeroStatePage := 0;
   HeroPageChanged;
  end else begin
    Inc (HeroInternalForcePage);
    if HeroInternalForcePage > 1 then
      HeroInternalForcePage := 0;
    HeroInternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DBRefusePublicChatClick(Sender: TObject; X, Y: Integer);
begin
    g_boOwnerMsg := not g_boOwnerMsg;
    if g_boOwnerMsg then begin
      DBRefusePublicChat.SetImgIndex(g_WMain3Images,281);
      DScreen.AddChatBoardString('[禁止接收公聊]', GetRGB(219), clWhite);
    end else begin
      DBRefusePublicChat.SetImgIndex(g_WMain3Images,280);
      DScreen.AddChatBoardString('[允许接收公聊]', GetRGB(219), clWhite);
    end;
end;

procedure TFrmDlg.DHeroItemGridCloseClick(Sender: TObject; X, Y: Integer);
begin
   DHeroItemBag.Visible := FALSE;
end;

procedure TFrmDlg.DHeroItemGridGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
   idx, mi: integer;
   temp: TClientItem;
   TempIdx: Integer;
begin
  //20080803修正 主人装备拿下点英雄包里 物品重叠
  if (g_boItemMoving) and (-g_MovingItem.Index in [1..15]) then Exit;
{-------------------------------------------------------}
//从主人包裹到英雄包裹  2007.10.24
   if g_boItemMoving then begin
     if g_MovingItem.Item.S.Name <> '' then begin
       TempIdx := -(g_MovingItem.Index);
       if not (TempIdx in [1..15]) then begin
         g_WaitingUseItem := g_MovingItem;
         FrmMain.SendItemToHeroBag(-(g_MovingItem.Index+1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
         g_boItemMoving := FALSE;
         g_MovingItem.Item.S.Name:='';
         Exit; //20080331
       end;
     end;
   end;
{-------------------------------------------------------------}
  idx := ACol + ARow * DHeroItemGrid.ColCount;
  if idx in [0..g_HeroBagCount-1] then begin
    if ssCtrl in Shift then begin
      if (g_HeroItemArr[idx].S.Name <> '') and not g_boHeroItemMoving then begin
        g_WaitingHeroUseItem.Item := g_HeroItemArr[idx];
        FrmMain.SendItemToMasterBag(idx, g_HeroItemArr[idx].MakeIndex, g_HeroItemArr[idx].S.Name);
        g_HeroItemArr[idx].S.Name := '';
      end;
    end else begin
      if not g_boHeroItemMoving then begin
         if g_HeroItemArr[idx].S.Name <> '' then begin
            g_boHeroItemMoving := TRUE;
            g_MovingHeroItem.Index := idx;
            g_MovingHeroItem.Item := g_HeroItemArr[idx];
            g_HeroItemArr[idx].S.Name := '';
            ItemClickSound (g_HeroItemArr[idx].S);
         end;
      end else begin
         mi := g_MovingHeroItem.Index;
         if (mi = -97) or (mi = -98) then exit;
         if (mi < 0) and (mi >= -15 {-9}) then begin
            g_WaitingHeroUseItem := g_MovingHeroItem;
            FrmMain.SendTakeOffHeroItem (-(g_MovingHeroItem.Index+1), g_MovingHeroItem.Item.MakeIndex, g_MovingHeroItem.Item.S.Name);
            g_MovingHeroItem.Item.S.name := '';
            g_boHeroItemMoving := FALSE;
         end else begin
            if (mi <= -20) and (mi > -30) then
               DealItemReturnBag (g_MovingHeroItem.Item);
            if g_HeroItemArr[idx].S.Name <> '' then begin
               temp := g_HeroItemArr[idx];
               g_HeroItemArr[idx] := g_MovingHeroItem.Item;
               g_MovingHeroItem.Index := idx;
               g_MovingHeroItem.Item := temp
            end else begin
               g_HeroItemArr[idx] := g_MovingHeroItem.Item;
               g_MovingHeroItem.Item.S.name := '';
               g_boHeroItemMoving := FALSE;
            end;
         end;
         if (g_MovingHeroItem.Item.S.StdMode = 17) and (g_HeroItemArr[idx].S.StdMode = 17) and (g_MovingHeroItem.Item.MakeIndex <> g_HeroItemArr[idx].MakeIndex) then begin
           if (g_MergerItem.S.Name <> '') and (GetTickCount - g_dwMergerTime > 5000) then g_MergerItem.S.Name := '';
           if g_MergerItem.S.Name = '' then begin
             g_MergerItem := g_MovingHeroItem.Item;
             g_MovingHeroItem.Item.S.Name := '';
             g_dwMergerTime := GetTickCount;
             g_boHeroItemMoving := False;
             frmMain.SendItemMakeOne(g_MergerItem.MakeIndex, g_HeroItemArr[idx].MakeIndex, 1);
           end;
         end;
      end;
    end;
  end;
  ArrangeHeroItemBag;
end;

procedure TFrmDlg.DHeroItemGridDblClick(Sender: TObject);
var
   idx, where: integer;
   keyvalue: TKeyBoardState;
   cu: TClientItem;
begin
   idx := DHeroItemGrid.Col + DHeroItemGrid.Row * DHeroItemGrid.ColCount;
   if idx in [0..g_HeroBagCount-1] then begin
      if g_HeroItemArr[idx].S.Name <> '' then begin
         FillChar(keyvalue, sizeof(TKeyboardState), #0);
         GetKeyboardState (keyvalue);
         if keyvalue[VK_CONTROL] = $80 then begin   //ctrl
            cu := g_HeroItemArr[idx];
            g_HeroItemArr[idx].S.Name := '';
            AddHeroItemBag (cu);
         end else
         if (g_HeroItemArr[idx].S.StdMode <= 4) or (g_HeroItemArr[idx].S.StdMode = 31) then begin
           FrmMain.HeroEatItem (idx);
         end;
      end else begin
         if g_boHeroItemMoving and (g_MovingHeroItem.Item.S.Name <> '') then begin
            FillChar(keyvalue, sizeof(TKeyboardState), #0);
            GetKeyboardState (keyvalue);
            if keyvalue[VK_CONTROL] = $80 then begin
               cu := g_MovingHeroItem.Item;
               g_MovingHeroItem.Item.S.Name := '';
               g_boHeroItemMoving := FALSE;
               AddHeroItemBag (cu);
            end else
            if (g_MovingHeroItem.Index = idx) and
              (g_MovingHeroItem.Item.S.StdMode <= 4) or (g_HeroItemArr[idx].S.StdMode = 17) or
              (g_HeroItemArr[idx].S.StdMode = 31) or ((g_MovingHeroItem.Item.S.StdMode = 60) and (g_MovingHeroItem.Item.S.Shape <> 0)) or
              ((g_HeroItemArr[idx].S.StdMode = 51) and (g_HeroItemArr[idx].S.Shape in [2..3]))
            then begin
              FrmMain.HeroEatItem (-1);
            end else begin
              //双击穿装备
              where := GetTakeOnPosition(g_MovingHeroItem.Item.S.StdMode);
              if (where <> -1) then begin
                if where = U_RINGR then begin
                  if g_HeroItems[U_RINGR].S.Name = '' then begin
                    where := U_RINGR;
                  end else
                  if g_HeroItems[U_RINGL].S.Name = '' then begin
                    where := U_RINGL;
                  end else
                  if not g_boHeroRightItemRingEmpty then begin
                    where := U_RINGR;
                    g_boHeroRightItemRingEmpty := True;
                  end else begin
                    where := U_RINGL;
                    g_boHeroRightItemRingEmpty := False;
                  end;
                end;
                if where = U_ARMRINGR then begin
                  if g_HeroItems[U_ARMRINGR].S.Name = '' then begin
                    where := U_ARMRINGR;
                  end else
                  if g_HeroItems[U_ARMRINGL].S.Name = '' then begin
                    where := U_ARMRINGL;
                  end else
                  if not g_boHeroRightItemArmRingEmpty then begin
                    where := U_ARMRINGR;
                    g_boHeroRightItemArmRingEmpty := True;
                  end else begin
                    where := U_ARMRINGL;
                    g_boHeroRightItemArmRingEmpty := False;
                  end;
                end;
                g_WaitingHeroUseItem.Item := g_MovingHeroItem.Item;
                g_WaitingHeroUseItem.Index := where;
                FrmMain.SendTakeOnHeroItem(where, g_MovingHeroItem.Item.MakeIndex, g_MovingHeroItem.Item.S.Name);
                DelHeroItemBag(g_MovingHeroItem.Item.S.Name, g_MovingHeroItem.Item.MakeIndex);
                g_MovingHeroItem.Item.S.Name := '';
              end;
            end;
         end;
      end;
   end;
end;

//英雄图标性别 职业 图象区分     2007.11.2  代码$005
function TFrmDlg.HeroIcon(sex:integer;job:integer):integer;
begin
  case Sex of
    0:Result := 635+job;
    1:Result := 638+job;
    else Result := 635+job;
  end;
end;

//英雄底层背景绘制
procedure TFrmDlg.DHeroRoleIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  pgidx,bbx,bby:integer;
  d: TDirectDrawSurface;
  rc: TRect;
begin
  pgidx:=HeroIcon(g_HeroSelf.m_btSex,g_HeroSelf.m_btJob);
  if g_WUI1Images.Images[1290] <> nil then begin
    bbx := 30;
    bby := 21;
    with Sender as TDButton do begin
      d := g_WMain3Images.Images[pgidx];
      if (g_HeroSelf <> nil) and (g_HeroSelf.m_Abil.HP <= 0) and (g_HeroSelf.m_boDeath) then begin
        g_HeroSelf.m_Abil.MP := 0;
        g_HeroSelf.m_Abil.nExp := 0;
        if d <> nil then begin
          g_ImgMixSurface.SetSize(d.Width, d.Height);
          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
          DrawEffect(0, 0, g_ImgMixSurface, d, ceGrayScale);
          dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
        end;
      end else begin
        if d <> nil then
        dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, true);
      end;
    end;
    with DHeroIcon do begin
      dsurface.TextOut (SurfaceX(GLeft)+71 - FrmMain.Canvas.TextWidth(IntToStr(g_HeroSelf.m_Abil.Level)) div 2,SurfaceY(GTop)+91, clWhite, Inttostr(g_Heroself.m_Abil.Level));

      {d := g_WMain2Images.Images[513];
      if d <> nil then
         dsurface.Draw (47, 16, d.ClientRect, d, true); }

      //d := g_WMain2Images.Images[582];
      d := g_WUI1Images.Images[1296];
      if d <> nil then begin
         rc := d.ClientRect;
         if (g_HeroSelf.m_Abil.MaxAlcohol > 0) and (g_HeroSelf.m_Abil.WineDrinkValue > 0) then begin
           rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxAlcohol * (g_HeroSelf.m_Abil.MaxAlcohol - g_HeroSelf.m_Abil.WineDrinkValue));
           dsurface.Draw (SurfaceX(GLeft)+66, SurfaceY(GTop)+13+rc.Top, rc, d, True);
         end;
      end;

      {$IF M2Version = 1}
      if g_HeroSelf.m_Abil.MaxTransferValue > 0 then begin
        {d := g_WMainImages.Images[1205];
        if d <> nil then
          dsurface.Draw (20, 14, d.ClientRect, d, true);  }

        //d := g_WMainImages.Images[1206];
        d := g_WUI1Images.Images[1295];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxTransferValue * (g_HeroSelf.m_Abil.MaxTransferValue - g_HeroSelf.m_Abil.TransferValue));
          dsurface.Draw(SurfaceX(GLeft)+20, SurfaceY(GTop)+12+rc.Top, rc, d, True);
        end;
      end;
      {$IFEND}
    end;
  end else begin
    bbx := 17;
    bby := 18;
    with Sender as TDButton do begin
      d := g_WMain3Images.Images[pgidx];
      if (g_HeroSelf <> nil) and (g_HeroSelf.m_Abil.HP <= 0) and (g_HeroSelf.m_boDeath) then begin
        g_HeroSelf.m_Abil.MP := 0;
        g_HeroSelf.m_Abil.nExp := 0;
        if d <> nil then begin
          {DrawBlendEx(dsurface,SurfaceX(bbx),
                      SurfaceY(bby), d,0,0,d.Width,d.Height, 0, 150); }
          g_ImgMixSurface.SetSize(d.Width, d.Height);
          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
          DrawEffect(0, 0, g_ImgMixSurface, d, ceGrayScale);

          dsurface.Draw(SurfaceX(bbx), SurfaceY(bby), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
        end;
      end else begin
        if d <> nil then
        dsurface.Draw (SurfaceX(bbx), SurfaceY(bby), d.ClientRect, d, true);
      end;
    end;
    with DHeroIcon do begin
      if g_WMainImages.Images[1214] <> nil then
        dsurface.TextOut (SurfaceX(GLeft)+14 - FrmMain.Canvas.TextWidth(IntToStr(g_HeroSelf.m_Abil.Level)) div 2, SurfaceY(GTop)+73, clWhite, Inttostr(g_Heroself.m_Abil.Level))
      else dsurface.TextOut (SurfaceX(GLeft)+14 - FrmMain.Canvas.TextWidth(IntToStr(g_HeroSelf.m_Abil.Level)) div 2, SurfaceY(GTop)+61, clWhite, Inttostr(g_Heroself.m_Abil.Level));

      d := g_WMain2Images.Images[513];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+12, d.ClientRect, d, true);

      d := g_WMain2Images.Images[582];
      if d <> nil then begin
         rc := d.ClientRect;
         if (g_HeroSelf.m_Abil.MaxAlcohol > 0) and (g_HeroSelf.m_Abil.WineDrinkValue > 0) then begin
           rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxAlcohol * (g_HeroSelf.m_Abil.MaxAlcohol - g_HeroSelf.m_Abil.WineDrinkValue));
           dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+12+rc.Top, rc, d, True);
         end;
      end;
      {$IF M2Version = 1}
      if g_HeroSelf.m_Abil.MaxTransferValue > 0 then begin
        d := g_WMainImages.Images[1205];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+12, SurfaceY(GTop)+12, d.ClientRect, d, true);

        d := g_WMainImages.Images[1206];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_HeroSelf.m_Abil.MaxTransferValue * (g_HeroSelf.m_Abil.MaxTransferValue - g_HeroSelf.m_Abil.TransferValue));
          dsurface.Draw(SurfaceX(GLeft)+12, SurfaceY(GTop)+12+rc.Top, rc, d, True);
        end;
      end;
      {$IFEND}
    end;
  end;
end;

//英雄图标绘制
procedure TFrmDlg.DHeroIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc:Trect;
begin
  if g_HeroSelf = nil then Exit;
  with DHeroIcon do begin
    if g_WUI1Images.Images[1290] <> nil then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      d := g_WUI1Images.Images[1291];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxHP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxHP * g_Heroself.m_Abil.HP);
         dsurface.Draw (SurfaceX(GLeft) + 95, SurfaceY(GTop) + 34, rc, d, true);
      end;
      d := g_WUI1Images.Images[1292];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxMP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxMP * g_Heroself.m_Abil.MP);
         dsurface.Draw (SurfaceX(GLeft) + 98, SurfaceY(GTop) + 46, rc, d, TRUE);
      end;
      d := g_WUI1Images.Images[1293];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Skill69MaxNH > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_HeroSelf.m_Skill69MaxNH * g_Heroself.m_Skill69NH);
         dsurface.Draw (SurfaceX(GLeft) + 96, SurfaceY(GTop) + 58, rc, d, TRUE);
      end;
      d := g_WUI1Images.Images[1294];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.nMaxExp > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.nMaxExp * g_Heroself.m_Abil.nExp);
         dsurface.Draw (SurfaceX(GLeft) + 87, SurfaceY(GTop) + 70, rc, d, TRUE);
      end;
      dsurface.TextOut (SurfaceX(GLeft) + 15, SurfaceY(GTop) + 13, clWhite, GetHeroJobStr(g_Heroself.m_btJob));
      dsurface.TextOut (SurfaceX(GLeft) + 94, SurfaceY(GTop) + 18, clWhite, g_HeroSelf.m_sUserName);
      dsurface.TextOut (SurfaceX(GLeft) + 184, SurfaceY(GTop) + 17, $0088C4E8, g_sMyHeroType);
      case g_HeroSelf.m_btJob of
        0: begin  //战士
          if (g_HeroSelf.m_nState and $04000000 = 0){非麻痹} then dsurface.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clWhite, '石化')
          else dsurface.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clRed, '石化');
          if (g_HeroSelf.m_nState and $1000000 = 0){非冰冻} then dsurface.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clWhite, '冰冻')
          else dsurface.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clRed, '冰冻');
          if (g_HeroSelf.m_nState and $10000000 = 0){非网罩} then dsurface.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clWhite, '网罩')
          else dsurface.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clRed, '网罩');
        end;
        1: begin  //法师
          if (g_HeroSelf.m_nState and $00100000 <> 0){非破盾} then dsurface.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clWhite, '破盾')
          else dsurface.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clRed, '破盾');
          if (g_HeroSelf.m_nState and $04000000 = 0){非麻痹} then dsurface.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clWhite, '石化')
          else dsurface.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clRed, '石化');
          if (g_HeroSelf.m_nState and $1000000 = 0){非冰冻} then dsurface.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clWhite, '冰冻')
          else dsurface.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clRed, '冰冻');
        end;
        2: begin  //道士
          if g_boHeroInfuriating then
            dsurface.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clRed, '真气')
          else dsurface.TextOut (SurfaceX(GLeft) + 102, SurfaceY(GTop) + 85, clWhite, '真气');
          if (g_HeroSelf.m_nState and $04000000 = 0){非麻痹} then dsurface.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clWhite, '石化')
          else dsurface.TextOut (SurfaceX(GLeft) + 132, SurfaceY(GTop) + 85, clRed, '石化');
          if (g_HeroSelf.m_nState and $1000000 = 0){非冰冻} then dsurface.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clWhite, '冰冻')
          else dsurface.TextOut (SurfaceX(GLeft) + 162, SurfaceY(GTop) + 85, clRed, '冰冻');
        end;
      end;
      if g_boShowHeroStateNumber then begin
        dsurface.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 31, clWhite, Format('%d/%d',[g_HeroSelf.m_Abil.HP, g_HeroSelf.m_Abil.MaxHP]));
        dsurface.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 43, clWhite, Format('%d/%d',[g_HeroSelf.m_Abil.MP, g_HeroSelf.m_Abil.MaxMP]));
        dsurface.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 55, clWhite, Format('%d/%d',[g_HeroSelf.m_Skill69NH, g_HeroSelf.m_Skill69MaxNH]));
        if g_HeroSelf.m_Abil.nMaxExp > 0 then
        dsurface.TextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 67, clWhite, FloatToStrFixFmt (100 * (g_HeroSelf.m_Abil.nExp / g_HeroSelf.m_Abil.nMaxExp), 3, 2) + '%');
      end;
    end else begin
      if g_WMainImages.Images[1214] <> nil then begin
        if WLib <> nil then begin //20080701
          d := WLib.Images[FaceIndex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        d := g_WUiMainImages.Images[0];
        if d <> nil then begin
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
        end;
      end;

      d := g_WMain3Images.Images[386];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxHP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxHP * g_Heroself.m_Abil.HP);
         dsurface.Draw (SurfaceX(GLeft)+75, SurfaceY(GTop)+24, rc, d, true);
      end;
      d := g_WMain3Images.Images[387];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.MaxMP > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.MaxMP * g_Heroself.m_Abil.MP);
         dsurface.Draw (SurfaceX(GLeft)+80, SurfaceY(GTop)+37, rc, d, TRUE);
      end;
      d := g_WMain3Images.Images[388];
      if d <> nil then begin
         rc := d.ClientRect;
         if g_Heroself.m_Abil.nMaxExp > 0 then
         rc.Right := Round((rc.Right-rc.Left) / g_Heroself.m_Abil.nMaxExp * g_Heroself.m_Abil.nExp);
         dsurface.Draw (SurfaceX(GLeft)+80, SurfaceY(GTop)+49, rc, d, TRUE);
      end;
      dsurface.TextOut (SurfaceX(GLeft)+80, SurfaceY(GTop)+5, clWhite, g_HeroSelf.m_sUserName);
      if g_WMainImages.Images[1214] <> nil then
        dsurface.BoldTextOut(SurfaceX(GLeft)+300 div 2 - FrmMain.Canvas.TextWidth(formatfloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%') div 2,
            SurfaceY(GTop)+62, clWhite, clBlack, FormatFloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%')
      else dsurface.BoldTextOut(SurfaceX(GLeft)+240 div 2 - FrmMain.Canvas.TextWidth(formatfloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%') div 2,
            SurfaceY(GTop)+62, clWhite, clBlack, FormatFloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%');
      if g_WMainImages.Images[1214] <> nil then dsurface.TextOut (SurfaceX(GLeft)+83, SurfaceY(GTop)+63, $0000A4D8, g_sMyHeroType);
    end;
  end;
end;

//英雄怒气变换函数
procedure TFrmDlg.typeTimeimg;
begin
    if GetTickCount - typetime > 200 then begin
     typetime := GetTickCount;
     inc(imginsex);
    if imginsex > 1 then imginsex := 0;
    end;
end;

//英雄怒气
procedure TFrmDlg.DBHeroSpleenImgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc:Trect;
  nTop: Byte;
begin
  with DBHeroSpleenImg do begin
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1127];
      if d = nil then d := g_WMain3Images.Images[410];
    end else d := g_WMain3Images.Images[410];
    if d <> nil then
    begin
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    nTop := 0;
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1128];
      if d = nil then d := g_WMain3Images.Images[411] else nTop := 14;
    end else d := g_WMain3Images.Images[411];
    rc := d.ClientRect;
    if d <> nil then begin
      if nMaxFirDragonPoint > 0 then begin
       rc.Top := Round(rc.Bottom / nMaxFirDragonPoint * (nMaxFirDragonPoint - m_nFirDragonPoint));
       dsurface.Draw (SurfaceX(GLeft)+2, SurfaceY(GTop)+rc.Top+nTop+21, rc, d, FALSE);
      end;
    end;
    if m_nFirDragonPoint >= nMaxFirDragonPoint then begin
      typeTimeimg;//显示时间间隔
      if g_WinBatterMagicList.Count > 0 then begin
        d := g_WMainImages.Images[1128 + imginsex];
        if d = nil then  g_WMain3Images.Images[imginsex + 411] else nTop := 14;
      end else d := g_WMain3Images.Images[imginsex + 411];
      if d <> nil then
       dsurface.Draw (SurfaceX(GLeft)+2, SurfaceY(GTop)+rc.Top+nTop+21, d.ClientRect, d, false);
    end;
  end;
end;

procedure TFrmDlg.DSHPageUpClick(Sender: TObject; X, Y: Integer);
begin
  if HeroStateTab = 0 then begin
    if Sender = DSHPageUp then begin
      if HeroMagicPage > 0 then
         Dec (HeroMagicPage);
    end else begin
      if HeroMagicPage < (g_HeroMagicList.Count+5) div 6 - 1 then
         Inc (HeroMagicPage);
    end;
  end else begin
    if Sender = DSHPageUp then begin
      if HeroInternalForceMagicPage > 0 then begin
      	Dec (HeroInternalForceMagicPage);
        {$IF M2Version <> 2}
        NGUpLevelState(True);
        {$IFEND}
      end;
    end else begin
      if HeroInternalForceMagicPage < (g_HeroInternalForceMagicList.Count+5) div 6 - 1 then begin
      	Inc (HeroInternalForceMagicPage);
        {$IF M2Version <> 2}
        NGUpLevelState(True);
        {$IFEND}
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroIconClick(Sender: TObject; X, Y: Integer);
begin
if g_HeroSelf = nil then exit;
{-------------------------------------------------------}
//从主人包裹到英雄包裹  2007.10.24
  if g_boItemMoving then begin
    if g_MovingItem.Item.S.Name <> '' then begin
     {g_WaitingHeroUseItem}g_WaitingUseItem := g_MovingItem;
     FrmMain.SendItemToHeroBag(-(g_MovingItem.Index+1), g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
     g_boItemMoving := FALSE;
     g_MovingItem.Item.S.Name:='';
    end;
  end;
end;

procedure TFrmDlg.DStMagHero1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   idx, icon: integer;
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   wm: TWMImages;
begin
  with Sender as TDButton do begin
    pm := nil;
    if HeroStateTab = 0 then begin
      idx := _Max(Tag + HeroMagicPage * 6, 0);
      if idx < g_HeroMagicList.Count then begin
        pm := PTClientMagic (g_HeroMagicList[idx]);
        if pm <> nil then begin
          wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
          if wm <> nil then begin
            if icon >= 0 then begin
              if not Downed then begin
                d := wm.Images[icon];
                if d <> nil then begin
                  if word(pm.Key) = 0 then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                  else begin
                    g_ImgMixSurface.SetSize(d.Width, d.Height);
                    g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                    DrawEffect(0, 0, g_ImgMixSurface, d, ceBlack);
                    dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
                  end;
                 end;
              end else begin
                if (pm.Def.wMagicId in [3,4,60..65,67]) then begin
                  d := g_WMagIconImages.Images[icon];
                  if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end else begin
                  d := wm.Images[icon+1];
                  if d <> nil then
                    if word(pm.Key) = 0 then
                      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                    else begin
                      g_ImgMixSurface.SetSize(d.Width, d.Height);
                      g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                      DrawEffect(0, 0, g_ImgMixSurface, d, ceBlack);
                      dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
                    end;
                  end;
               end;
             end;
           end;
         end;
      end;
    end else begin
      idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
      if idx < g_HeroInternalForceMagicList.Count then begin
        pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        if pm <> nil then begin
          if not Downed then begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end else begin
            d := g_WMagIconImages.Images[pm.Def.btEffect * 2+1];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          if word(pm.Key) <> 0 then begin
            g_ImgMixSurface.SetSize(d.Width, d.Height);
            g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
            DrawEffect(0, 0, g_ImgMixSurface, d, ceBlack);
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateHeroMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
  g_HeroMouseStateItem.S.Name := '';
end;

procedure TFrmDlg.DBotMemoClick(Sender: TObject; X, Y: Integer);
begin
  if GetTickCount - g_dwShopTick > 2000 then begin
    g_dwShopTick := GetTickCount();
    Dshop.Visible:=True;
    DShopDecorateClick(DShopDecorate,x,y);
    ShopIndex := -1;
    ShopSpeciallyIndex := -1;
  end;
end;

(*******************************************************************************
  作用 : 商铺描述地方的分割符函数
  过程 : ShopStrWord(s:string;dsurface:TdirectDrawSurface;x,y:integer)
  参数 : s为描述的字符串. dsurface为输出场景. x,y为输出的坐标
*******************************************************************************)
procedure TFrmDlg.ShopStrWord(s:string;dsurface:TDirectDrawSurface;x,y:integer);//取|符号 左右边的内容
var
  i,j:integer;
  str:string;
begin
  j:=0;
  str:='';
  s:=s+'|';
  if Length(s)<=0 then begin //20080629
      exit;
  end;
  for i:=1 to length(s) do begin
    if (s[i]='|' ) then begin
      if str<>'' then begin
          j:=j+1;
          dsurface.TextOut (x, y+j*14, clWhite, str);
      end;
      str:='';
      continue;
    end;
    str:=str+s[i]
  end;
end;

procedure TFrmDlg.DShopDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I, bbx, bby, m:integer;
  d: TDirectDrawSurface;
  pm: pTShopInfo;
  Color: TColor;
begin
  with DShop do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WEffectImages.Images[380];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft+18), SurfaceY(GTop+35), d.ClientRect, d, true);
    if g_ShopSpeciallyItemList.Count > 0 then begin//20080629
      for I:=0 to g_ShopSpeciallyItemList.Count-1 do begin
        pm := pTShopInfo (g_ShopSpeciallyItemList[i]);
        if ShopSpeciallyIndex=i then begin
          ShopGifInfo(dsurface,SurfaceX(GLeft+18),SurfaceY(GTop+35),strtoint(pm.ImgBegin),strtoint(pm.Imgend));
        end;
      end;
    end;
    if g_ShopItemList.Count > 0 then begin//20080629
      for I:=0 to g_ShopItemList.Count-1 do begin
        pm := pTShopInfo (g_ShopItemList[i]);
        if ShopIndex=i then begin
          ShopGifInfo(dsurface,SurfaceX(GLeft+18),SurfaceY(GTop+35),strtoint(pm.ImgBegin),strtoint(pm.Imgend));
        end;
      end;
    end;
    bbx:=GLeft+170;
    bby:=GTop+10;
  end;
  if g_ShopItemList.Count > 0 then //20080629
  for i:=0 to g_ShopItemList.Count-1 do begin
    pm := pTShopInfo (g_ShopItemList[i]);
    m := i;
    if odd(i) then begin
      if ShopIndex=i then Color := clRed else Color := clWhite;
      dsurface.TextOut (bbx + 230, bby + 25 + m*27, Color, pm.StdItem.Name);
      dsurface.TextOut (bbx + 230, bby + 40 + m*27, Color, pm.Introduce1);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        dsurface.TextOut (bbx + 230, bby + 55 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        dsurface.TextOut (bbx + 230, bby + 55 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      dsurface.TextOut (bbx + 230, bby + 55 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
      if ShopIndex=i then begin
        g_ShopItemName :=pm.StdItem.Name;
        g_nShopItemGold := pm.StdItem.Price;
        Color := clWhite;
        ShopStrWord(pm.sIntroduce,dsurface,bbx -150,bby + 230);
      end;
    end else begin
      if ShopIndex=i then Color := clRed else Color := clWhite;
      dsurface.TextOut (bbx + 60, bby + 52 + m*27, Color, pm.StdItem.Name);
      dsurface.TextOut (bbx + 60, bby + 67 + m*27, Color, pm.Introduce1);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        dsurface.TextOut (bbx + 60, bby + 82 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        dsurface.TextOut (bbx + 60, bby + 82 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      dsurface.TextOut (bbx + 60, bby + 82 + m*27, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
      if ShopIndex=i then  begin
        g_ShopItemName :=pm.StdItem.Name;
        g_nShopItemGold := pm.StdItem.Price;
        Color := clWhite;
        ShopStrWord(pm.sIntroduce,dsurface,bbx -150,bby + 230);
      end;
    end;
  end;
  if g_ShopSpeciallyItemList.Count > 0 then //20080629
  for i:=0 to g_ShopSpeciallyItemList.Count-1 do begin
    pm := pTShopInfo (g_ShopSpeciallyItemList[i]);
    if ShopSpeciallyIndex=i then begin
      Color := clRed;
      dsurface.TextOut (bbx + 350, bby + 89 + i*65, Color, pm.StdItem.Name);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        dsurface.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        dsurface.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      dsurface.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
      Color := clWhite;
      ShopStrWord(pm.sIntroduce,dsurface,bbx -150,bby + 230);
      g_ShopItemName:=pm.StdItem.Name;
      g_nShopItemGold := pm.StdItem.Price;
    end else begin
      Color := clWhite;
      dsurface.TextOut (bbx + 350, bby + 89 + i*65, Color, pm.StdItem.Name);
      {$IF M2Version = 2}//1.76
      if g_boShopUseGold then begin
        dsurface.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGoldName]));
      end else begin
        dsurface.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      end;
      {$ELSE}
      dsurface.TextOut (bbx + 350, bby + 102 + i*65, Color, Format('%d %s',[pm.StdItem.Price div 100, g_sGameGoldName]));
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DShopCloseClick(Sender: TObject; X, Y: Integer);
begin
  Dshop.Visible := FALSE;
end;

procedure TFrmDlg.DShopImg1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  icon,idx:integer;
  pm:pTShopInfo;
  d:TDirectDrawSurface;
begin
    with Sender as TDButton do begin
      idx := _Max(Tag + 0 * 10, 0);
      if idx < g_ShopItemList.Count then begin
         pm := pTShopInfo (g_ShopItemList[idx]);
         icon := pm.StdItem.Looks;
         if icon >= 0 then begin
               d := frmMain.GetBagItemImg(icon);
               if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft+(50-d.Width) div 2), SurfaceY(GTop + (50 - d.Height) div 2), d.ClientRect, d, TRUE);
         end;
      end;
   end;
end;

procedure TFrmDlg.DShopNextClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
 I: Integer;
begin
if Sender = DShopPrev then begin
  if g_ShopPage > 0 then begin
     Dec (g_ShopPage);
     for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
      if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
       Dispose(PTShopInfo(g_ShopItemList.Items[i]));
     end;
     g_ShopItemList.Clear;
     msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, g_ShopPage{页数}, g_ShopTypePage{ShopType}, 0, frmMain.m_nSendMsgCount);
     FrmMain.SendSocket (EncodeMessage (msg));
  end;
end else begin
  if g_ShopPage < g_ShopReturnPage-1 then begin
     Inc (g_ShopPage);
     for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
      if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
       Dispose(PTShopInfo(g_ShopItemList.Items[i]));
     end;
     g_ShopItemList.Clear;
     msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, g_ShopPage{页数}, g_ShopTypePage{ShopType}, 0, frmMain.m_nSendMsgCount);
     FrmMain.SendSocket (EncodeMessage (msg));
  end;
end;
end;

procedure TFrmDlg.DShopDecorateClick(Sender: TObject; X, Y: Integer);
    procedure ShopClear();
    begin
       DShopDecorate.SetImgIndex(g_Wmain3Images,-1);
       DShopSupplies.SetImgIndex(g_Wmain3Images,-1);
       DshopStrengthen.SetImgIndex(g_Wmain3Images,-1);
       DShopFriend.SetImgIndex(g_Wmain3Images,-1);
       DShopCapacity.SetImgIndex(g_Wmain3Images,-1);
       ShopIndex:=-1;
       g_ShopItemName:='';
    end;
var
 msg: TDefaultMessage;
 I: Integer;
begin
  ShopClear();
  for I:=0 to g_ShopItemList.Count - 1  do begin  //20080718释放内存
    if PTShopInfo(g_ShopItemList.Items[i]) <> nil then
      Dispose(PTShopInfo(g_ShopItemList.Items[i]));
  end;
  g_ShopItemList.Clear;
  if Sender = DShopDecorate then begin
    DShopDecorate.SetImgIndex(g_Wmain3Images,299);
    msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 0{ShopType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
    g_ShopTypePage:=0;
    g_ShopPage:=0;
  end;
  if Sender = DShopSupplies then begin
    DShopSupplies.SetImgIndex(g_Wmain3Images,300);
        msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 1{ShopType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
    g_ShopTypePage:=1;
    g_ShopPage:=0;
  end;
  if Sender = DshopStrengthen then begin
    DshopStrengthen.SetImgIndex(g_Wmain3Images,301);
        msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 2{ShopType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
    g_ShopTypePage:=2;
    g_ShopPage:=0;
  end;
  if Sender = DShopFriend then begin
    DShopFriend.SetImgIndex(g_Wmain3Images,302);
        msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 3{ShopType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
    g_ShopTypePage:=3;
    g_ShopPage:=0;
  end;
  if Sender = DShopCapacity then begin
    DShopCapacity.SetImgIndex(g_Wmain3Images,303);
        msg := MakeDefaultMsg (aa(CM_OPENSHOP, frmMain.TempCertification), 0, 0{页数}, 4{ShopType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
    g_ShopTypePage:=4;
    g_ShopPage:=0;
  end;
end;

procedure TFrmDlg.DShopImg1Click(Sender: TObject; X, Y: Integer);
begin
  ShopGifFrame:=0;
  ShopSpeciallyIndex:=-1;
  ShopIndex:=TDButton(Sender).Tag
end;
(*******************************************************************************
  作用 : TextOut自动换行代码 (暂时未用)
  过程 : Itemstrorlist(str:string; WIDTH,HEIGH:integer);
  参数 : str为描述的字符串. 想要输出的WIDTH宽度. HEIGH想要输出的高度
*******************************************************************************)
procedure TFrmDlg.Itemstrorlist(str:string; WIDTH,HEIGH:integer);
var
   i, len, aline, n, MAXWIDTH,MAXEIGHS: integer;
    temp: string;
   loop: Boolean;
begin
   MAXWIDTH := WIDTH;
   MAXEIGHS := HEIGH;
   strorliscont := 0;
   n := 0;
   loop := TRUE;
  while loop do begin
   temp := '';
   i := 1;
   len := Length (str);
   while TRUE do begin
   if i > len then begin
        loop := FALSE;
        break;
        end;
         if byte (str[i]) >= MAXWIDTH then begin
            temp := temp + str[i];
            Inc (i);
            if i <= len then temp := temp + str[i]
            else begin
               loop := FALSE;
               break;
            end;
         end else
            temp := temp + str[i];

         aline := FrmMain.Canvas.TextWidth (temp);
         if aline > MAXWIDTH then begin
            strorlist[n] := temp;
            strorlistidx[n] := aline;
            Inc (strorliscont);
            Inc (n);
            if n >= MAXEIGHS then begin
            loop := FALSE;
               break;
            end;
            str := Copy (str, i+1, Len-i);
            temp := '';
            break;
         end;
         Inc (i);
      end;
      if temp <> '' then begin
         if n < MAXWIDTH then begin
            strorlist[n] := temp;
            strorlistidx[n] := FrmMain.Canvas.TextWidth (temp);
            Inc (strorliscont);
         end;
      end;
   end;
end;

procedure TFrmDlg.DShopBuyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
  DlgResult :TModalResult;
begin
  if g_ShopItemName <> '' then begin
    DlgResult := FrmDlg.DMessageDlg(Format('你确认购买 %s ？\（你可以使用%s购买，购买%s需要%d%s）', [g_ShopItemName, g_sGamePointName, g_ShopItemName, g_nShopItemGold, g_sGamePointName]),
                      [mbRetry, mbIgnore, mbCancel]);
    if DlgResult = mrRetry then begin//元宝购买
      msg := MakeDefaultMsg (aa(CM_BUYSHOPITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName));
    end else if DlgResult = mrIgnore then begin
      msg := MakeDefaultMsg (aa(CM_BUYSHOPITEM, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName));
    end;
  end;
end;

procedure TFrmDlg.DShopSpeciallyImg1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  icon,idx:integer;
  pm:pTShopInfo;
  d:TDirectDrawSurface;
begin
    with Sender as TDButton do begin
      idx := _Max(Tag-10, 0);
      if idx < g_ShopSpeciallyItemList.Count then begin
         pm := pTShopInfo (g_ShopSpeciallyItemList[idx]);
         icon := pm.StdItem.Looks;
         if icon >= 0 then begin
               d := frmMain.GetBagItemImg(icon);
               if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft+(120 - d.Width) div 2), SurfaceY(GTop + (31 - d.Height) div 2), d.ClientRect, d, TRUE);
         end;
      end;
   end;
end;

procedure TFrmDlg.DShopSpeciallyImg1Click(Sender: TObject; X, Y: Integer);
begin
  ShopGifFrame:=0;
  ShopIndex:=-1;
  ShopSpeciallyIndex:=TDButton(Sender).Tag-10;
end;
//Shop 物品动画演示
procedure TFrmDlg.ShopGifInfo(dsurface: TDirectDrawSurface;dx,dy,ShopGifBegin,ShopGifEnd:integer);
var
  d:TDirectDrawSurface;
  img: integer;
begin
    if ShopGifEnd = 0 then begin
      d := g_WEffectImages.Images[380];
      if d <> nil then
      dsurface.Draw (dx, dy, d.ClientRect, d, true);
      Exit;
    end;
    ShopGifExplosionFrame:=ShopGifEnd-ShopGifBegin;
    if GetTickCount - ShopGifTime >  700 then
    begin
      ShopGifTime:=GetTickCount;
      inc(ShopGifFrame);
    end;

    if ShopGifFrame > ShopGifExplosionFrame then
      ShopGifFrame := 0;

      img:=ShopGifBegin+ShopGifFrame;
           d := g_WEffectImages.Images[img];
      if d <> nil then
      dsurface.Draw(dx,dy,d.ClientRect,d, False);
end;

procedure TFrmDlg.DShopPresentClick(Sender: TObject; X, Y: Integer);
var
  who: string;
  msg: TDefaultMessage;
  DlgResult :TModalResult;
begin
  if g_ShopItemName <> '' then begin
    DlgResult := FrmDlg.DMessageDlg(Format('请输入%s要赠送的人物名：\（你可以使用%s购买，购买%s需要%d%s）', [g_ShopItemName, g_sGamePointName, g_ShopItemName, g_nShopItemGold, g_sGamePointName]),
                      [mbRetry, mbIgnore, mbCancel, mbAbort]);
    who := Trim (DlgEditText);
    if who <> '' then begin
      if DlgResult = mrRetry then begin//元宝购买
        msg := MakeDefaultMsg (aa(CM_BUYSHOPITEMGIVE, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName) + '/' + EncodeString(who) + '/' +EncodeString(g_MySelf.m_sUserName));
      end else if DlgResult = mrIgnore then begin
        msg := MakeDefaultMsg (aa(CM_BUYSHOPITEMGIVE, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket (EncodeMessage (msg)+EncodeString(g_ShopItemName) + '/' + EncodeString(who) + '/' +EncodeString(g_MySelf.m_sUserName));
      end;
    end;
  end;
end;

procedure TFrmDlg.CharacterSrankingClick(Sender: TObject; X, Y: Integer);
begin
  DWLevelOrder.Visible:=not DWLevelOrder.Visible;
  if DWLevelOrder.Visible then begin
    LevelOrderPage := 0;
    {$IF M2Version <> 2}
    nLevelOrderSortTypePage := 0;
    {$IFEND}
    LevelOrderPageChanged;
  end;
end;

procedure TFrmDlg.CharacterSrankingInitialize(Sender: TObject);
begin
  CharacterSranking.SetImgIndex (g_WMain3Images,460);  //人物排行
end;

procedure TFrmDlg.DLevelOrderCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWLevelOrder.Visible := False;
end;

procedure TFrmDlg.LevelOrderPageChanged;
var
  I: Integer;
begin
  DColonyHeroOrder.Visible := FALSE;  DWarriorOrder.Visible := FALSE;
  DWizerdOrder.Visible := FALSE;  DTaoistOrder.Visible := FALSE;
  DHeroAllOrder.Visible := FALSE;
  DWarriorHeroOrder.Visible := FALSE;
  DWizerdHeroOrder.Visible := FALSE;
  DTaoistHeroOrder.Visible := FALSE;
  DLevelOrderIndex.Visible := FALSE;
  DLevelOrderPrev.Visible := FALSE;
  DLevelOrderNext.Visible := FALSE;
  DLevelOrderLastPage.Visible := FALSE;
  DMyLevelOrder.Visible := FALSE;
  {$IF M2Version <> 2}
  DLevelOrderPrev.GLeft := 75;
  DLevelOrderNext.GLeft := 125;
  DBOrderWeapon.Visible := LevelOrderPage = 5;
  DBOrderRing.Visible := LevelOrderPage = 5;
  DBOrderDress.Visible := LevelOrderPage = 5;
  DBOrderBoots.Visible := LevelOrderPage = 5;
  DBOrderHelmet.Visible := LevelOrderPage = 5;
  DBOrderBelt.Visible := LevelOrderPage = 5;
  DBOrderNecklace.Visible := LevelOrderPage = 5;
  DBOrderMedal.Visible := LevelOrderPage = 5;
  DBOrderWristlet.Visible := LevelOrderPage = 5;
  DBOrderHat.Visible := LevelOrderPage = 5;
  DBItemLevelBelt1.Visible := LevelOrderPage = 6;
  DBItemLevelBelt2.Visible := LevelOrderPage = 6;
  DBItemLevelBelt3.Visible := LevelOrderPage = 6;
  DBItemLevelBelt4.Visible := LevelOrderPage = 6;
  DBItemLevelBelt5.Visible := LevelOrderPage = 6;
  DBItemLevelBelt6.Visible := LevelOrderPage = 6;
  DBItemLevelBelt7.Visible := LevelOrderPage = 6;
  DBItemLevelBelt8.Visible := LevelOrderPage = 6;
  DBItemLevelBelt9.Visible := LevelOrderPage = 6;
  DBItemLevelBelt10.Visible := LevelOrderPage = 6;
  if g_UserItemLevelList.Count > 0 then begin
    for I := 0 to g_UserItemLevelList.Count - 1 do begin
      if pTItemLevelSort(g_UserItemLevelList[i]) <> nil then
        Dispose(pTItemLevelSort(g_UserItemLevelList[i]));
    end;
    g_UserItemLevelList.Clear;
  end;
  {$IFEND}
  if m_PlayObjectLevelList.Count > 0 then begin   //人物等级排行
    for I := 0 to m_PlayObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_PlayObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_PlayObjectLevelList.Items[i]));
    end;
    m_PlayObjectLevelList.Clear;
  end;
  if m_WarrorObjectLevelList.Count > 0 then begin   //战士等级排行
    for I := 0 to m_WarrorObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_WarrorObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_WarrorObjectLevelList.Items[i]));
    end;
    m_WarrorObjectLevelList.Clear;
  end;
  if m_WizardObjectLevelList.Count > 0 then begin   //法师等级排行
    for I := 0 to m_WizardObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_WizardObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_WizardObjectLevelList.Items[i]));
    end;
    m_WizardObjectLevelList.Clear;
  end;
  if m_TaoistObjectLevelList.Count > 0 then begin   //道士等级排行
    for I := 0 to m_TaoistObjectLevelList.Count - 1 do begin
      if pTUserLevelSort(m_TaoistObjectLevelList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_TaoistObjectLevelList.Items[i]));
    end;
    m_TaoistObjectLevelList.Clear;
  end;
  if m_PlayObjectMasterList.Count > 0 then begin   //道士等级排行
    for I := 0 to m_PlayObjectMasterList.Count - 1 do begin
      if pTUserLevelSort(m_PlayObjectMasterList.Items[i]) <> nil then
        Dispose(pTUserLevelSort(m_PlayObjectMasterList.Items[i]));
    end;
    m_PlayObjectMasterList.Clear;
  end;
  if m_HeroObjectLevelList.Count > 0 then begin   //英雄等级排行
    for I := 0 to m_HeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_HeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_HeroObjectLevelList.Items[i]));
    end;
    m_HeroObjectLevelList.Clear;
  end;
  if m_WarrorHeroObjectLevelList.Count > 0 then begin   //英雄战士等级排行
    for I := 0 to m_WarrorHeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_WarrorHeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_WarrorHeroObjectLevelList.Items[i]));
    end;
    m_WarrorHeroObjectLevelList.Clear;
  end;
  if m_WizardHeroObjectLevelList.Count > 0 then begin   //英雄法师等级排行
    for I := 0 to m_WizardHeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_WizardHeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_WizardHeroObjectLevelList.Items[i]));
    end;
    m_WizardHeroObjectLevelList.Clear;
  end;
  if m_TaoistHeroObjectLevelList.Count > 0 then begin   //英雄道士等级排行
    for I := 0 to m_TaoistHeroObjectLevelList.Count - 1 do begin
      if pTHeroLevelSort(m_TaoistHeroObjectLevelList.Items[i]) <> nil then
        Dispose(pTHeroLevelSort(m_TaoistHeroObjectLevelList.Items[i]));
    end;
    m_TaoistHeroObjectLevelList.Clear;
  end;
  case LevelOrderPage of
    0: begin
      DColonyHeroOrder.Visible := TRUE;  DWarriorOrder.Visible := TRUE;
      DWizerdOrder.Visible := TRUE;  DTaoistOrder.Visible := TRUE;
    end;
    1: begin
      DHeroAllOrder.Visible := TRUE;
      DWarriorHeroOrder.Visible := TRUE;
      DWizerdHeroOrder.Visible := TRUE;
      DTaoistHeroOrder.Visible := TRUE;
    end;
    2: begin
      DLevelOrderIndex.Visible := TRUE;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
      DLevelOrderLastPage.Visible := TRUE;
      DMyLevelOrder.Visible := TRUE;
    end;
    3: begin
      DLevelOrderIndex.Visible := TRUE;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
      DLevelOrderLastPage.Visible := TRUE;
      DMyLevelOrder.Visible := TRUE;
    end;
    4: begin
      DLevelOrderIndex.Visible := TRUE;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
      DLevelOrderLastPage.Visible := TRUE;
      DMyLevelOrder.Visible := TRUE;
    end;
    {$IF M2Version <> 2}
    6: begin
      DLevelOrderPrev.GLeft := 110;
      DLevelOrderNext.GLeft := 168;
      DLevelOrderPrev.Visible := TRUE;
      DLevelOrderNext.Visible := TRUE;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DIndividualOrderClick(Sender: TObject; X, Y: Integer);
begin
   LevelOrderPage := TDButton(Sender).Tag;
   LevelOrderPageChanged;
   nLevelOrderSortTypePage := 0;
end;

procedure TFrmDlg.DIndividualOrderDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
    {$IF M2Version <> 2}
      if Tag = nLevelOrderSortTypePage then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    {$ELSE}
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DHeroOrderClick(Sender: TObject; X, Y: Integer);
begin
   LevelOrderPage := TDButton(Sender).Tag;
   LevelOrderPageChanged;
   nLevelOrderSortTypePage := 1;
end;

procedure TFrmDlg.DWLevelOrderDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  function GetSortList: TList;
  begin
    Result := nil;
    case nLevelOrderSortType of
      0: begin
        case nLevelOrderType of
          1: Result := m_PlayObjectLevelList;
          2: Result := m_WarrorObjectLevelList;
          3: Result := m_WizardObjectLevelList;
          4: Result := m_TaoistObjectLevelList;
        end;
      end;
      1: begin
        case nLevelOrderType of
          1: Result := m_HeroObjectLevelList;
          2: Result := m_WarrorHeroObjectLevelList;
          3: Result := m_WizardHeroObjectLevelList;
          4: Result := m_TaoistHeroObjectLevelList;
        end;
      end;
      2: Result := m_PlayObjectMasterList;
      {$IF M2Version <> 2}
      3: Result := g_UserItemLevelList;
      {$IFEND}
    end;
  end;
var
  d: TDirectDrawSurface;
  I: Integer;
  UserLevelSort: pTUserLevelSort;
  HeroLevelSort: pTHeroLevelSort;
  UserMasterSort: pTUserLevelSort;
  {$IF M2Version <> 2}
  ItemLevelSort: pTItemLevelSort;
  {$IFEND}
  bbx,bby: Integer;
  List: TList;
  cColor: TColor;
begin
  List := GetSortList;
  with DWLevelOrder do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    case LevelOrderPage of
      2: begin
        d := g_WMain3Images.Images[423];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      3: begin
        d := g_WMain3Images.Images[424];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      4: begin
        d := g_WMain3Images.Images[425];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      {$IF M2Version <> 2}
      6: begin //装备榜
        d := g_WUI1Images.Images[1341];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft+25), SurfaceY(GTop+91), d.ClientRect, d, true);
      end;
      {$IFEND}
    end;
    bbx:=GLeft+20;
    bby:=GTop+120;
  end;
  cColor := clWhite;
  if (List <> nil) and (List.Count > 0) then begin
    case nLevelOrderSortType of
      0: begin
        for I:= 0 to List.Count-1 do begin
          if I = nLevelOrderIndex then
            cColor := clYellow
          else cColor := clWhite;
          if pTUserLevelSort(List[i]) <> nil then begin
            UserLevelSort := pTUserLevelSort (List[i]);
            dsurface.TextOut (bbx + 35, bby + i*22, cColor, Inttostr(UserLevelSort.nIndex));
            dsurface.TextOut (bbx + 95, bby + i*22, cColor, UserLevelSort.sChrName);
            dsurface.TextOut (bbx + 240, bby + i*22, cColor, Inttostr(UserLevelSort.wLevel));
            {$IF M2Version <> 2}
            if UserLevelSort.nHeartLevel > 0 then
              dsurface.TextOut (bbx + 240 + MainForm.Canvas.TextWidth(Inttostr(UserLevelSort.wLevel)), bby + i*22, clYellow, Format('+%d', [UserLevelSort.nHeartLevel]));
            {$IFEND}
          end;
        end;
      end;
      1: begin
        for I:= 0 to List.Count-1 do begin
          if I = nLevelOrderIndex then
            cColor := clYellow
          else cColor := clWhite;
          if pTHeroLevelSort(List[i]) <> nil then begin
            HeroLevelSort := pTHeroLevelSort (List[i]);
            dsurface.TextOut (bbx + 18, bby + i*22, cColor, inttostr(HeroLevelSort.nIndex));
            dsurface.TextOut (bbx + 50, bby + i*22, cColor, HeroLevelSort.sHeroName);
            dsurface.TextOut (bbx + 145, bby + i*22, cColor, HeroLevelSort.sChrName);
            dsurface.TextOut (bbx + 255, bby + i*22, cColor, inttostr(HeroLevelSort.wLevel));
          end;
        end;
      end;
      2: begin
        for I:= 0 to List.Count-1 do begin
          if I = nLevelOrderIndex then   
            cColor := clYellow
          else cColor := clWhite;
          if pTUserLevelSort(List[i]) <> nil then begin
            UserMasterSort := pTUserLevelSort(List[i]);
            dsurface.TextOut (bbx + 35, bby + i*22, cColor, inttostr(UserMasterSort.nIndex));
            dsurface.TextOut (bbx + 95, bby + i*22, cColor, UserMasterSort.sChrName);
            dsurface.TextOut (bbx + 240, bby + i*22, cColor, inttostr(UserMasterSort.wLevel));
          end;
        end;
      end;
      {$IF M2Version <> 2}
      3: begin
        for I:=0 to List.Count - 1 do begin
          if pTItemLevelSort(List[i]) <> nil then begin
            ItemLevelSort := pTItemLevelSort(List[i]);
            dsurface.TextOut (bbx + 24 - frmMain.Canvas.TextWidth(IntToStr(ItemLevelSort.nIndex)) div 2, bby + i*21, $008CC7EF, IntToStr(ItemLevelSort.nIndex));
            dsurface.TextOut (bbx + 200 - frmMain.Canvas.TextWidth(ItemLevelSort.sChrName) div 2, bby + i*21, $008CC7EF, ItemLevelSort.sChrName);
            dsurface.TextOut (bbx + 270 - frmMain.Canvas.TextWidth(IntToStr(ItemLevelSort.wLevel)) div 2, bby + i*21, $008CC7EF, IntToStr(ItemLevelSort.wLevel));
          end;
        end;
      end;
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DWLevelOrderMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
{$IFEND}
end;

procedure TFrmDlg.DColonyHeroOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  LevelOrderPage := 2;
  LevelOrderPageChanged;
  nLevelOrderTypePage := TDButton(Sender).Tag;
  if Sender = DColonyHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 1{nType}, 0, frmMain.m_nSendMsgCount);
  if Sender = DWarriorOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 2{nType}, 0, frmMain.m_nSendMsgCount);
  if Sender = DWizerdOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 3{nType}, 0, frmMain.m_nSendMsgCount);
  if Sender = DTaoistOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 0{nSortType}, 4{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DHeroAllOrderClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
 msg: TDefaultMessage;
{$IFEND}
begin
  {$IF M2Version <> 2}
  LevelOrderPage := 3;
  LevelOrderPageChanged;
  nLevelOrderTypePage := TDButton(Sender).Tag;
  if g_boOpenHero then begin
    if Sender = DHeroAllOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 1{nType}, 0, frmMain.m_nSendMsgCount);
    if Sender = DWarriorHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 2{nType}, 0, frmMain.m_nSendMsgCount);
    if Sender = DWizerdHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 3{nType}, 0, frmMain.m_nSendMsgCount);
    if Sender = DTaoistHeroOrder then msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 1{nSortType}, 4{nType}, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
  end;
  {$IFEND}
end;

procedure TFrmDlg.DMasterOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  LevelOrderPage := 4;
  LevelOrderPageChanged;           
  nLevelOrderSortTypePage := 2;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, 2{nSortType}, 0{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DBLevelOrderUseItemClick(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if Sender = DBLevelOrderUseItem then
      LevelOrderPage := 5
    else LevelOrderPage := 7;
    LevelOrderPageChanged;
    nLevelOrderSortTypePage := Tag;
  end;
end;

procedure TFrmDlg.DMyLevelOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  nLevelOrderIndex := 0;
  LevelOrderPageChanged;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), -1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DLevelOrderIndexClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  LevelOrderPageChanged;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DLevelOrderLastPageClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  LevelOrderPageChanged;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), nLevelOrderTypePageCount-1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DLevelOrderNextClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if Sender = DLevelOrderNext then begin
    if nLevelOrderPage < nLevelOrderTypePageCount-1 then begin
      LevelOrderPageChanged;
      msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), nLevelOrderPage+1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
    end;
  end else begin
    if nLevelOrderPage > 0 then begin
      LevelOrderPageChanged;
      msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), nLevelOrderPage-1{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderTypePage{nType}, 0, frmMain.m_nSendMsgCount);
      FrmMain.SendSocket (EncodeMessage (msg));
    end;
  end;
end;

procedure TFrmDlg.DBottomMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  {g_nUserSelectName := 0; //20080302
  DScreen.ClearHint; }
end;
{******************************************************************************}
//宝箱系统
procedure TFrmDlg.DBoxsDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Shape :integer;
  BackImages: Integer; //宝箱背景图
begin
  with DBoxs do begin
    if g_boNewBoxs = 1 then BackImages := 210 else BackImages := 510;
    if DBoxs.FaceIndex = BackImages then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
    if g_boPutBoxsKey then begin
      if GetTickCount - g_dwBoxsTick > 200 then begin
        g_dwBoxsTick := GetTickCount;
        Inc(g_nBoxsImg);
        if g_nBoxsImg > 6 then begin
          g_nBoxsImg := 0;
          g_boPutBoxsKey := False;
          if g_boNewBoxs = 1 then begin
            DBoxs.SetImgIndex(g_WMain2Images, 210);
          end else begin
            DBoxs.SetImgIndex(g_WMain3Images, 510);
          end;
          if g_BoxsIsFill <> 3 then begin //新宝箱全部物品更新 不重新调整窗口位置
            if g_boNewBoxs = 1 then begin
              DBoxs.GLeft := 450;
              DBoxs.GTop  := 100;
            end else begin
              DBoxs.GLeft := 332;
              DBoxs.GTop  := 192;
            end;
          end;
          if g_boNewBoxs = 1 then
            d := g_WMain2Images.Images[210]
          else
            d := g_WMain3Images.Images[510];
          if d <> nil then  
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          ShowBoxsGird(True, g_boNewBoxs); //显示宝箱格
          if g_boNewBoxs = 1 then begin  //新宝箱
            DBNewHelpBtn.Visible := True;
            DCheckAutoOpenBoxs.Visible := True;
            DBoxsTautology.SetImgIndex(g_WMain2Images, 215);
            DBoxsTautology.GTop := 232;
            DBoxsTautology.GLeft := 65;
            DBoxsTautology.Visible := True;
          end else begin //老宝箱
            DBoxsTautology.SetImgIndex(g_WMain3Images, 511);
            DBoxsTautology.GTop := 175;
            DBoxsTautology.GLeft := 77;
            DBoxsTautology.Visible := True;
          end;
        end;
      end;
    end;

    if DBoxsBelt1.Visible then Exit;
    case g_EatingItem.S.Shape of
      1: Shape := 520;
      2: Shape := 540;
      3: Shape := 560;
      4: Shape := 580;
      5: Shape := 130;
      else Shape := 520;
    end;
    if Shape <> 130 then begin
      DBoxs.SetImgIndex(g_WMain3Images, Shape);
      d := g_WMain3Images.Images[Shape+g_nBoxsImg];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
      d := g_WMain3Images.Images[Shape+7+g_nBoxsImg];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 255);
    end else begin
      DBoxs.SetImgIndex(g_WMain2Images, Shape);
      d := g_WMain2Images.Images[Shape+g_nBoxsImg];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
      d := g_WMain2Images.Images[Shape+7+g_nBoxsImg];
      if d <> nil then
        DrawBlend(dsurface,SurfaceX(GLeft), SurfaceY(GTop), d, 255);
    end;
  end;
end;

procedure TFrmDlg.DBoxsClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
  butt: TDButton;
begin
  if g_boJNBox then Exit;
  if g_boNewBoxs = 1 then butt := DBNewHelpBtn else butt := DBoxsTautology;
  if not butt.Visible then begin
    if (not g_boItemMoving) and (g_MovingItem.Item.S.Name = '') and (not g_boPutBoxsKey) then  begin
      AddItemBag (g_EatingItem);
      DBoxS.Visible := False;
      ShowBoxsGird(False, g_boNewBoxs); //显示宝箱格
      g_BoxsShowPosition := -1;
      Exit;
    end;
    if g_boItemMoving then begin
      if g_MovingItem.Item.S.Shape = g_EatingItem.S.AniCount then begin
        msg := MakeDefaultMsg(aa(CM_OPENBOXS, frmMain.TempCertification), g_EatingItem.MakeIndex, 0, 0, 0, frmMain.m_nSendMsgCount);
        FrmMain.SendSocket(EncodeMessage(msg) + EncodeString(Inttostr(g_MovingItem.Item.MakeIndex)));
        g_BoxsTempKeyItems := g_MovingItem.Item;  //把钥匙存放到临时物品     失败则返回
        g_boItemMoving := False;
        g_MovingItem.Item.S.Name := '';  //把钥匙变没
        g_MovingItem.Item.S.Shape := 0;  //把钥匙变没
      end;
    end;
  end;
end;

procedure TFrmDlg.ShowBoxsGird(Show:Boolean; IsNewBoxs: Byte);
begin
  if Show and (IsNewBoxs = 1) then begin
    DBoxsBelt1.GLeft := 31;
    DBoxsBelt1.GTop  := 88;
    DBoxsBelt2.GLeft := 83;
    DBoxsBelt2.GTop  := 88;
    DBoxsBelt3.GLeft := 134;
    DBoxsBelt3.GTop  := 88;
    DBoxsBelt4.GLeft := 31;
    DBoxsBelt4.GTop  := 136;
    DBoxsBelt5.GLeft := 83;
    DBoxsBelt5.GTop  := 137;
    DBoxsBelt6.GLeft := 134;
    DBoxsBelt6.GTop  := 136;
    DBoxsBelt7.GLeft := 31;
    DBoxsBelt7.GTop  := 184;
    DBoxsBelt8.GLeft := 83;
    DBoxsBelt8.GTop  := 184;
    DBoxsBelt9.GLeft := 134;
    DBoxsBelt9.GTop  := 184;
  end else begin
    DBoxsBelt1.GLeft := 30;
    DBoxsBelt1.GTop  := 28;
    DBoxsBelt2.GLeft := 80;
    DBoxsBelt2.GTop  := 28;
    DBoxsBelt3.GLeft := 130;
    DBoxsBelt3.GTop  := 28;
    DBoxsBelt4.GLeft := 30;
    DBoxsBelt4.GTop  := 76;
    DBoxsBelt5.GLeft := 80;
    DBoxsBelt5.GTop  := 76;
    DBoxsBelt6.GLeft := 130;
    DBoxsBelt6.GTop  := 76;
    DBoxsBelt7.GLeft := 30;
    DBoxsBelt7.GTop  := 124;
    DBoxsBelt8.GLeft := 80;
    DBoxsBelt8.GTop  := 124;
    DBoxsBelt9.GLeft := 130;
    DBoxsBelt9.GTop  := 124;
  end;
  DBoxsNewBelt1.Visible := False;
  DBoxsNewBelt2.Visible := False;
  DBoxsNewBelt3.Visible := False;
  if g_boNewBoxs = 1 then begin
    DBoxsNewBelt1.Visible := Show;
    DBoxsNewBelt2.Visible := Show;
    DBoxsNewBelt3.Visible := Show;
  end;
  if g_boNewBoxs <> 2 then begin
    DBoxsBelt1.Visible := Show;
    DBoxsBelt2.Visible := Show;
    DBoxsBelt3.Visible := Show;
    DBoxsBelt4.Visible := Show;
    DBoxsBelt5.Visible := Show;
    DBoxsBelt6.Visible := Show;
    DBoxsBelt7.Visible := Show;
    DBoxsBelt8.Visible := Show;
    DBoxsBelt9.Visible := Show;
  end else begin
    DJLBoxBelt1.Visible := Show;
    DJLBoxBelt2.Visible := Show;
    DJLBoxBelt3.Visible := Show;
    DJLBoxBelt4.Visible := Show;
    DJLBoxBelt5.Visible := Show;
    DJLBoxBelt6.Visible := Show;
    DJLBoxBelt7.Visible := Show;
    DJLBoxBelt8.Visible := Show;
  end;
end;

procedure TFrmDlg.DBoxsBelt5DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
  Butt:TDButton;
  Sel: Integer;
begin
  BoxsRunning(dsurface);//宝箱转动
  Butt:=TDButton(Sender);
  Sel := 0;
  idx := 0;
  if Sender = DBoxsBelt1 then Sel := 0;
  if Sender = DBoxsBelt2 then Sel := 1;
  if Sender = DBoxsBelt3 then Sel := 2;
  if Sender = DBoxsBelt4 then Sel := 7;
  if Sender = DBoxsBelt5 then Sel := 8;
  if Sender = DBoxsBelt6 then Sel := 3;
  if Sender = DBoxsBelt7 then Sel := 6;
  if Sender = DBoxsBelt8 then Sel := 5;
  if Sender = DBoxsBelt9 then Sel := 4;
  if Sender = DBoxsNewBelt1 then Sel := 9;
  if Sender = DBoxsNewBelt2 then Sel := 10;
  if Sender = DBoxsNewBelt3 then Sel := 11;
  with Butt do begin
    if g_boNewBoxs = 0 then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if Sender = DBoxsBelt5 then begin
        if not g_boJNBox then //金牛宝箱
          d := g_Wmain3Images.Images[513]
        else d := g_WmainImages.Images[595];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft-5), SurfaceY(GTop-5), d.ClientRect, d, true);
      end;
    end;
    if (g_BoxsIsFill = 0) and (g_BoxsShowPosition = Butt.Tag) then BoxsFlash(Butt, dsurface);
    if g_BoxSItems[Sel].S.Name <> '' then begin
      idx := g_BoxSItems[Sel].S.Looks;
      if idx >= 0 then begin
        if g_BoxsShowPosition = Butt.Tag then begin
          d := frmMain.GetBagItemImg(idx);
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                         SurfaceY(GTop + (GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
        end else begin
          d := frmMain.GetBagItemImg(idx);
          if d <> nil then begin
            if Sel in [9..11] then
              if (g_BoxsIsFill = 1) and (g_nFilledGetItmesID = Butt.Tag) then begin
                dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2),d.Width, d.Height ),Rect(0,0,d.Width, d.Height),d);
                BoxsFillFlash(Butt, dsurface);  //显示宝箱填充动画
              end else begin
                dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE)
              end
            else begin
              dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2),d.Width, d.Height ),Rect(0,0,d.Width, d.Height),d);
            end;
          end;
        end;
      end;
      if g_BoxsIsFill = 3 then BoxsFillFlash(Butt, dsurface);
    end;
    if (g_BoxsShowPosition = Butt.Tag) and (g_BoxsIsFill = 2) then BoxsFillFlash(Butt, dsurface); //下面填充
  end;
end;

procedure TFrmDlg.DBoxsBelt5MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  Sel: Integer;
  Butt:TDButton;
begin
  Sel := -1;
  Butt:=TDButton(Sender);
  if Sender = DBoxsBelt1 then Sel := 0;
  if Sender = DBoxsBelt2 then Sel := 1;
  if Sender = DBoxsBelt3 then Sel := 2;
  if Sender = DBoxsBelt4 then Sel := 7;
  if Sender = DBoxsBelt5 then Sel := 8;
  if Sender = DBoxsBelt6 then Sel := 3;
  if Sender = DBoxsBelt7 then Sel := 6;
  if Sender = DBoxsBelt8 then Sel := 5;
  if Sender = DBoxsBelt9 then Sel := 4;
  if Sender = DBoxsNewBelt1 then Sel := 9;
  if Sender = DBoxsNewBelt2 then Sel := 10;
  if Sender = DBoxsNewBelt3 then Sel := 11;
  if (g_BoxsItems[sel].S.Name = '经验') or (g_BoxsItems[sel].S.Name = '经验(大量)') or (g_BoxsItems[sel].S.Name = '经验(海量)') or
     (g_BoxsItems[sel].S.Name = '声望') or
     (g_BoxsItems[sel].S.Name = '内功') or (g_BoxsItems[sel].S.Name = '内功(大量)') or (g_BoxsItems[sel].S.Name = '内功(海量)') or
     (g_BoxSItems[Sel].S.Name = g_sGameGird) or (g_BoxSItems[Sel].S.Name = Format('%s(大量)',[g_sGameGird{'灵符'}])) or (g_BoxSItems[Sel].S.Name = Format('%s(海量)',[g_sGameGird{'灵符'}])) or
     (g_BoxsItems[sel].S.Name = g_sGameDiaMond) or (not (g_BoxsItems[sel].S.StdMode in [5..6,10..11,15..16,19..24,26,30,52..54,62..64])) then begin
    iname := g_BoxsItems[sel].S.Name + '\' + '数量: '+IntToStr(g_BoxsItems[sel].S.Price);
    if (g_BoxsShowPosition = Butt.Tag) and not g_boBoxsLockGetItems then
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname+ '\' + '(双击获得)', clYellow, FALSE)
    else
      DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname, clWhite, FALSE);
    g_MouseItem.S.Name := '';
  end else begin
    if g_BoxsItems[sel].S.Name <> '' then begin
      g_MouseItem := g_BoxsItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable ,1);
      if (g_BoxsShowPosition = Butt.Tag) and (not g_boBoxsLockGetItems) then
        DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname + d1 + '\' + d2 + '\' + d3 + '\' + '(双击获得)', clYellow, FALSE)
      else
        DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft + Butt.GWidth), Butt.SurfaceY(Butt.GTop), iname + d1 + '\' + d2 + '\' + d3 , clWhite, FALSE);
      g_MouseItem.S.Name := '';
    end;
  end;
end;

procedure TFrmDlg.DBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

//宝箱物品闪烁函数
procedure TFrmDlg.BoxsFlash(Button: TDButton;dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if GetTickCount - g_dwBoxsFlashTick > 100 then begin
    g_dwBoxsFlashTick := GetTickCount;
    Inc(g_BoxsFlashImg);
    if g_BoxsFlashImg > 2 then g_BoxsFlashImg := 0;
  end;
  if g_BoxsFlashImg = 2 then Exit;
  d := g_WMain3Images.Images[g_BoxsbsImg+g_BoxsFlashImg];
  if d <> nil then
    DrawBlend(dsurface,Button.SurfaceX(Button.GLeft-10),Button.SurfaceY(Button.GTop-11), d, 255);
end;

procedure TFrmDlg.BoxsFillFlash(Button: TDButton;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  msg: TDefaultMessage;
begin
  if g_BoxsIsFill <> 0 then begin
    case g_BoxsIsFill of
      1: begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 100 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 10 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsItems[g_nPlayGetItmesID] := g_BoxsItems[g_nFilledGetItmesID];
            g_BoxsItems[g_nFilledGetItmesID].S.Name := '';
            g_BoxsItems[g_nFilledGetItmesID].MakeIndex := 0;
            g_BoxsIsFill := 2;
          end;
        end;
        if g_BoxsFilleFlashImg = 10 then Exit;
        d := g_WMain2Images.Images[240+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,Button.SurfaceX(Button.GLeft-20),Button.SurfaceY(Button.GTop-20), d, 255);
      end;
      2: begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 100 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 10 then begin
            g_BoxsFilleFlashImg := 0;
            if g_nFilledGetItmesID = 0 then begin //最后一个填充动画
               msg := MakeDefaultMsg(aa(CM_UPDADEBOXSITMES, frmMain.TempCertification), 0{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
               FrmMain.SendSocket(EncodeMessage(msg));
            end;
            if not DCheckAutoOpenBoxs.Checked then begin
              DBoxsNewClose.Visible := True;
            end;
            DBoxsTautology.SetImgIndex(g_WMain2Images, 225);
            DBoxsTautology.Visible := True;
            if DCheckAutoOpenBoxs.Checked then begin
              msg := MakeDefaultMsg(aa(CM_ROTATIONBOX, frmMain.TempCertification), 1{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
              FrmMain.SendSocket(EncodeMessage(msg));
            end;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsFilleFlashImg = 10 then Exit;
        d := g_WMain2Images.Images[230+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,Button.SurfaceX(Button.GLeft-20),Button.SurfaceY(Button.GTop-20), d, 255);
      end;
      3: begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 7 then begin
            g_BoxsFilleFlashImg := 0;
            if FrmDlg.DCheckAutoOpenBoxs.Checked then begin
              msg := MakeDefaultMsg(aa(CM_ROTATIONBOX, frmMain.TempCertification), 1{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
              FrmMain.SendSocket(EncodeMessage(msg));
            end;
            g_BoxsIsFill := 0;
          end;
        end;
        if (g_BoxsFilleFlashImg = 8) or (g_BoxsIsFill = 0) then Exit;
        d := g_WMain2Images.Images[250+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,Button.SurfaceX(Button.GLeft-20),Button.SurfaceY(Button.GTop-20), d, 255);
      end;
    end;
  end;
end;

//宝箱物品随机取图
procedure TFrmDlg.BoxsRandomImg;
var
    vList:   TList;
    I,   J:   Integer;
    vData:   Integer;
begin
  Randomize;   //播下随机种子
  vList := TList.Create;
  try
    for I:=600 to 617 do vList.Add(Pointer(I));//得到一副顺序排列的扑克
    for I:=1 to 8 do begin  //取8个数
      J := Random(vList.Count);  //从余下的扑克中随机选一张
      vData := Integer(vList[J]);
      if vData= 601 then Continue;
      if vData= 603 then Continue;
      if vData= 605 then Continue;
      if vData= 607 then Continue;
      if vData= 609 then Continue;
      if vData= 611 then Continue;
      if vData= 613 then Continue;
      if vData= 615 then Continue;
      if vData= 617 then Continue;
      vList.Delete(J); //抽取完后从列表中删除
      g_BoxsbsImg := vData;
      break;
    end;
  finally
    vList.Free;
  end;
end;

procedure TFrmDlg.DBoxsTautologyClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  BoxsRandomImg; //变换颜色
  if not g_boBoxsShowPosition then begin
    if g_boNewBoxs = 1 then begin//新宝箱转动模式
      msg := MakeDefaultMsg (aa(CM_ROTATIONBOX, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
    end else //老宝箱转动模式
      msg := MakeDefaultMsg (aa(CM_MOVEBOXS, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket(EncodeMessage(msg));
    if g_BoxsMoveDegree < 1 then begin
      if g_boNewBoxs = 0 then begin
        g_boBoxsShowPosition := True;
        g_BoxsCircleNum := 0; //圈数设为0
        g_boBoxsMiddleItems := False; //显示中间物品
        g_BoxsFirstMove := True;
        Inc(g_BoxsMoveDegree);
      end;
    end;
    //end;
  end;
end;
//宝箱转动
procedure TFrmDlg.BoxsRunning(dsurface: TDirectDrawSurface);
var
  msg: TDefaultMessage;
  dwBoxsShowPositionTime: Word;
begin
  if g_boBoxsShowPosition then begin
    if (g_BoxsCircleNum > 0) and (g_BoxsCircleNum < 9) then dwBoxsShowPositionTime := 50 else dwBoxsShowPositionTime := 400;//g_BoxsShowPositionTime := 50 else g_BoxsShowPositionTime := 400;
    if GetTickCount - g_BoxsShowPositionTick > dwBoxsShowPositionTime then begin//g_BoxsShowPositionTime then begin
     g_BoxsShowPositionTick := GetTickCount;
     Inc(g_BoxsShowPosition);
      MyPlaySound (SelectBoxFlash_ground); //点宝箱声音
      if g_BoxsShowPosition > 7 then begin
        g_BoxsShowPosition := 0;
        Inc(g_BoxsCircleNum); //转动圈数
      end;
      if g_BoxsCircleNum = 9 then begin
        if g_BoxSItems[g_BoxsShowPosition].MakeIndex = g_BoxsMakeIndex then begin
          g_boBoxsShowPosition := False;
          if DCheckAutoOpenBoxs.Checked then begin
            msg := MakeDefaultMsg(aa(CM_GETBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
            FrmMain.SendSocket(EncodeMessage(msg));
            g_BoxSItems[g_BoxsShowPosition].S.Name := ''; //隐藏物品
            g_boBoxsLockGetItems := True;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBoxsTautologyMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if g_boNewBoxs = 0 then
  DScreen.ShowHint(DBoxsTautology.SurfaceX(DBoxsTautology.GLeft)-62, DBoxsTautology.SurfaceY(DBoxsTautology.GTop)-16, '启动乾坤挪移换取一件外圈物品', clWhite, FALSE);
end;

procedure TFrmDlg.DBPrevTitleInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do
    SetImgIndex(g_WUI1Images, 681);
{$IFEND}
end;

procedure TFrmDlg.DBProMySelfClick(Sender: TObject; X, Y: Integer);
begin
  with Sender as TDButton do begin
    if Tag <> m_btProPage then begin
      m_btProPage := Tag;
      ChangeProPage(m_btProPage);
    end;
  end;
end;

procedure TFrmDlg.DBProMySelfDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2+1, SurfaceY(GTop) + 4, $004AA6EF, clBlack, Hint);
      end else begin
        if MouseMoveing then begin
          if Tag = m_btProPage then
            d := WLib.Images[FaceIndex + 1]
          else d := WLib.Images[FaceIndex];
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
            dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $00ADD7EF, clBlack, TDButton(Sender).Hint);
          end;
        end else begin
          if Tag = m_btProPage then
            d := WLib.Images[FaceIndex + 1]
          else d := WLib.Images[FaceIndex];
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $008CC7EF, clBlack, TDButton(Sender).Hint);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBProMySelfInitialize(Sender: TObject);
begin
  with Sender as TDButton do begin
    SetImgIndex(g_qingqingImages, 23);
  end;
end;

procedure TFrmDlg.DBQJPracticeCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if g_QJPracticeItems.S.Name <> '' then begin
    if m_boQJPracticeHero then begin
      if g_HeroSelf <> nil then
        AddHeroItemBag(g_QJPracticeItems);
      g_QJPracticeItems.S.Name := '';
    end else begin
      if g_MySelf <> nil then
        AddItemBag(g_QJPracticeItems);
      g_QJPracticeItems.S.Name := '';
    end;
  end;
  DWQJPractice.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBQJPracticeCloseInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DBQJPracticeClose.SetImgIndex(g_WMain2Images, 148);
  {$IFEND}
end;

procedure TFrmDlg.DBQJPracticePage1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  OldFontStyle: TFontStyles;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      if Caption <> '' then begin
        OldFontStyle := MainForm.Canvas.Font.Style;
        MainForm.Canvas.Font.Style := Font.Style;
        if Downed then begin
          dsurface.BoldTextOut(SurfaceX(GLeft)+3, SurfaceY(GTop)+6, $00ADD7EF, clBlack, Caption);
        end else begin
          dsurface.BoldTextOut(SurfaceX(GLeft)+2, SurfaceY(GTop)+5, $00ADD7EF, clBlack, Caption);
        end;
        MainForm.Canvas.Font.Style := OldFontStyle;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBQJPracticePage1Initialize(Sender: TObject);
begin
  DBQJPracticePage1.SetImgIndex(g_WMainImages, 1178);
end;

procedure TFrmDlg.DBQJPracticeStartClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if g_QJPracticeItems.S.Name <> '' then begin
    if m_boQJPracticeHero then begin
      if g_HeroSelf <> nil then begin
        if not g_boQJHeroDZXY99 and (m_btQjPracticeSkillLevel = 64) then
          frmMain.SendOpenupSkill95(g_QJPracticeItems.MakeIndex, 1)
        else frmMain.SendQJPractice(g_QJPracticeItems.MakeIndex, 0, 1);
      end;
    end else begin
      if g_MySelf <> nil then begin
        if not g_boQJDZXY99 and (m_btQjPracticeSkillLevel = 64) then
          frmMain.SendOpenupSkill95(g_QJPracticeItems.MakeIndex, 0)
        else frmMain.SendQJPractice(g_QJPracticeItems.MakeIndex, 0, 0);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBQJPracticeStartInitialize(Sender: TObject);
begin
  DBQJPracticeStart.SetImgIndex(g_WMainImages, 1173);
end;

procedure TFrmDlg.DBoxsBelt1DblClick(Sender: TObject);
var
  msg: TDefaultMessage;
  Sel: Byte;
begin
  if not g_boBoxsShowPosition then begin //转盘停止中。。
    Sel := 0;
    if Sender = DBoxsBelt1 then Sel := 0;
    if Sender = DBoxsBelt2 then Sel := 1;
    if Sender = DBoxsBelt3 then Sel := 2;
    if Sender = DBoxsBelt4 then Sel := 7;
    if Sender = DBoxsBelt5 then Sel := 8;
    if Sender = DBoxsBelt6 then Sel := 3;
    if Sender = DBoxsBelt7 then Sel := 6;
    if Sender = DBoxsBelt8 then Sel := 5;
    if Sender = DBoxsBelt9 then Sel := 4;
    if Sel <> 8 then begin //不为中间物品
      if g_BoxsShowPosition = Sel then begin
        if g_BoxSItems[Sel].S.Name <> '' then begin
          if not g_boBoxsLockGetItems then begin
            msg := MakeDefaultMsg(aa(CM_GETBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
            FrmMain.SendSocket(EncodeMessage(msg));
            if g_boNewBoxs = 0 then begin
              DBoxS.Visible := False; //宝箱 界面隐藏
              g_boJNBox := False;
            end else begin
              g_BoxSItems[Sel].S.Name := ''; //隐藏物品
              g_boBoxsLockGetItems := True;
            end;
          end;
        end;
      end;
    end else begin //中间物品
      if g_BoxsMoveDegree = 0 then begin
        if g_BoxSItems[Sel].S.Name <> '' then begin
          msg := MakeDefaultMsg(aa(CM_GETBOXS, frmMain.TempCertification), 5, 0, 0, 0, frmMain.m_nSendMsgCount);
          FrmMain.SendSocket(EncodeMessage(msg));
          DBoxS.Visible := False;   //宝箱 界面隐藏
          if g_boNewBoxs =0 then g_boJNBox := False;
        end;
      end;
    end;
  end;
end;

{******************************************************************************}
procedure TFrmDlg.DLieDragonDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  d:=g_WUiMainImages.Images[1];
  if d<>nil then begin
     dsurface.Draw(DLieDragon.SurfaceX(DLieDragon.GLeft), DLieDragon.SurfaceY(DLieDragon.GTop), d.ClientRect, d, TRUE);
  end;
  case g_LieDragonPage of
    0: begin
      d:=g_WUiMainImages.Images[8];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    1: begin
      d:=g_WUiMainImages.Images[9];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    2: begin
      d:=g_WUiMainImages.Images[10];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    3: begin
      d:=g_WUiMainImages.Images[11];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
    4: begin
      d:=g_WUiMainImages.Images[12];
      if d<>nil then
       dsurface.Draw (DLieDragon.SurfaceX(DLieDragon.GLeft+43), DLieDragon.SurfaceY(DLieDragon.GTop+30), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DLieDragonCloseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if TDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[2];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[3];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLieDragonCloseClick(Sender: TObject; X, Y: Integer);
begin
  DLieDragon.Visible := False;
end;

procedure TFrmDlg.DLieDragonNextPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if TDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[4];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[5];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLieDragonPrevPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if TDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[6];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[7];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLieDragonNextPageClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DLieDragonNextPage then begin
     Inc (g_LieDragonPage);
     if g_LieDragonPage > 0 then DLieDragonPrevPage.Visible := True;
     if g_LieDragonPage >= 4 then begin
       DLieDragonNextPage.Visible := False;
       DGoToLieDragon.Visible := True;
     end;
  end else begin
     Dec (g_LieDragonPage);
     if g_LieDragonPage < 4 then begin
       DLieDragonNextPage.Visible := True;
       DGoToLieDragon.Visible := False;
       if g_LieDragonPage <= 0 then DLieDragonPrevPage.Visible := False;
     end;
  end;
end;

procedure TFrmDlg.DGoToLieDragonDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if TDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[13];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[14];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;     
end;

procedure TFrmDlg.DLieDragonNpcDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  case g_LieDragonNpcIndex of
    1: begin
      d:=g_WUiMainImages.Images[15];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    2: begin
      d:=g_WUiMainImages.Images[16];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    3: begin
      d:=g_WUiMainImages.Images[17];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    4: begin
      d:=g_WUiMainImages.Images[18];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
    5: begin
      d:=g_WUiMainImages.Images[19];
      if d<>nil then
         dsurface.Draw (DLieDragonNpc.SurfaceX(DLieDragonNpc.GLeft), DLieDragonNpc.SurfaceY(DLieDragonNpc.GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DLieDragonNpcCloseClick(Sender: TObject; X, Y: Integer);
begin
  DLieDragonNpc.Visible := False;
end;

procedure TFrmDlg.DGoToLieDragonClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendMerchantDlgSelect (g_nCurMerchant, '@goHero1');
  DLieDragon.Visible := False;
end;

procedure TFrmDlg.DItemsUpButMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ShowHint(DItemsUpBut.SurfaceX(DItemsUpBut.GLeft), DItemsUpBut.SurfaceY(DItemsUpBut.GTop + DItemsUpBut.GHeight), '升级装备', clWhite, FALSE);
end;

procedure TFrmDlg.DItemsUpButClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DItemsUpBut then
    DItemsUp.Visible := True
  else DItemsUp.Visible := False;
end;

procedure TFrmDlg.DItemBagMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DCIDSpleenDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
{  d:=FrmMain.UiDXImageList.Items.Find('vigourbar1').PatternSurfaces[0];
  if d<>nil then begin
     dsurface.Draw (DCIDSpleen.SurfaceX(DCIDSpleen.Left), DCIDSpleen.SurfaceY(DCIDSpleen.Top), d.ClientRect, d, TRUE);
  end;   }
end;

procedure TFrmDlg.DBQJPracticeItemClick(Sender: TObject; X, Y: Integer);
{$IF M2Version =1}
var
  temp: TClientItem;
  function GetMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_MySelf <> nil then begin
      for I:=0 to g_MagicList.Count - 1 do begin
        pm := PTClientMagic(g_MagicList[I]);
        if pm <>nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
  function GetHeroMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_HeroSelf <> nil then begin
      for I:=0 to g_HeroMagicList.Count - 1 do begin
        pm := PTClientMagic(g_HeroMagicList[I]);
        if pm <>nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
begin
{$IF M2Version =1}
  with Sender as TDButton do begin
    if m_boQJPracticeHero then begin
      if not g_boHeroItemMoving then begin
        if g_QJPracticeItems.S.Name <> '' then begin
           ItemClickSound (g_QJPracticeItems.s);
           if g_MovingHeroItem.Item.S.Name <> '' then Exit;
           g_boHeroItemMoving := TRUE;
           g_MovingHeroItem.Item := g_QJPracticeItems;
           g_QJPracticeItems.S.Name := '';
        end;
      end else begin
        if (g_MovingHeroItem.Item.S.Name <> '') and (g_MovingHeroItem.Index >= 0) and
          ((((GetHeroMagicLevel < 64) or ((GetHeroMagicLevel < 99) and g_boQJHeroDZXY99)) and (g_MovingHeroItem.Item.S.StdMode = 17) and (g_MovingHeroItem.Item.S.Shape = 238)) or (((GetHeroMagicLevel = 64) and not g_boQJHeroDZXY99) and (g_MovingHeroItem.Item.S.StdMode = 44) and (g_MovingHeroItem.Item.S.Shape = 248))) then begin
          ItemClickSound (g_MovingHeroItem.Item.S);
          if g_QJPracticeItems.S.Name <> '' then begin
            temp := g_QJPracticeItems;
            g_QJPracticeItems := g_MovingHeroItem.Item;
            g_MovingHeroItem.Item := temp
          end else begin
            g_QJPracticeItems := g_MovingHeroItem.Item;
            g_MovingHeroItem.Item.S.name := '';
            g_boHeroItemMoving := FALSE;
          end;
        end;
      end;
    end else begin
      if not g_boItemMoving then begin
        if g_QJPracticeItems.S.Name <> '' then begin
           ItemClickSound (g_QJPracticeItems.s);
           if g_MovingItem.Item.S.Name <> '' then Exit;
           g_boItemMoving := TRUE;
           g_MovingItem.Item := g_QJPracticeItems;
           g_QJPracticeItems.S.Name := '';
        end;
      end else begin
        if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) and
          ((((GetMagicLevel < 64) or ((GetMagicLevel < 99) and g_boQJDZXY99)) and (g_MovingItem.Item.S.StdMode = 17) and (g_MovingItem.Item.S.Shape = 238)) or (((GetMagicLevel = 64) and not g_boQJDZXY99) and (g_MovingItem.Item.S.StdMode = 44) and (g_MovingItem.Item.S.Shape = 248))) then begin
          ItemClickSound (g_MovingItem.Item.S);
          if g_QJPracticeItems.S.Name <> '' then begin
            temp := g_QJPracticeItems;
            g_QJPracticeItems := g_MovingItem.Item;
            g_MovingItem.Item := temp
          end else begin
            g_QJPracticeItems := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBQJPracticeItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  Idx: Integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
//  dsurface.FillRect(DBQJPracticeItem.ClientRect, 0);
  {$IF M2Version = 1}
  with Sender as TDButton do begin
    if g_QJPracticeItems.S.Name <> '' then begin
      idx := g_QJPracticeItems.S.Looks;
      if idx >= 0 then begin
          d := frmMain.GetBagItemImg(idx);
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                         SurfaceY(GTop + (GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
          if g_QJPracticeItems.S.StdMode = 17 then
          dsurface.TextOut (SurfaceX(GLeft+35-frmMain.Canvas.TextWidth(IntToStr(g_QJPracticeItems.Dura))), SurfaceY(GTop+20), clWhite, InttoStr(g_QJPracticeItems.Dura));
      end;
    end else if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
      g_ImgMixSurface.SetSize(GWidth, GHeight);
      g_ImgMixSurface.FastFill($00003255);
      if g_ImgMixSurface <> nil then begin
        DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBQJFurnaceCloseClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if not g_boQJFurnaceGet then DWQJFurnace.Visible := False;
  {$IFEND}
end;

procedure TFrmDlg.DBQJFurnaceCloseInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DBQJFurnaceClose.SetImgIndex(g_WMain2Images, 148);
  {$IFEND}
end;

procedure TFrmDlg.DBQJFurnaceStartClick(Sender: TObject; X, Y: Integer);
  {$IF M2Version = 1}
var
  msg: TDefaultMessage;
  {$IFEND}
begin
  {$IF M2Version = 1}
  if g_boQJFurnaceGet then begin
    msg := MakeDefaultMsg (aa(CM_CLENTGETLIANQIPRACTICE, FrmMain.TempCertification), g_btQJFurnaceType, 0, 0, 0, FrmMain.m_nSendMsgCount);
  end else begin
    msg := MakeDefaultMsg (aa(CM_LIANQIPRACTICE, FrmMain.TempCertification), g_btQJFurnaceType, 0, 0, 0, FrmMain.m_nSendMsgCount);
  end;
  FrmMain.SendSocket (EncodeMessage (msg));//20071231
  if g_btQJFurnaceType = 1 then begin //强化练气
    with FrmDlg do begin
      DBQJFurnaceStart.SetImgIndex(g_WMainImages, 1312);
      DBQJFurnaceStart.GLeft := 210;
      DBQJFurnaceStart.GTop := 100;
    end;
  end else begin
    with FrmDlg do begin
      DBQJFurnaceStart.SetImgIndex(g_WMainImages, 1292);
      DBQJFurnaceStart.GLeft := 220;
      DBQJFurnaceStart.GTop := 100;
    end;
  end;
  g_btQJFurnacePosition := 0;
  g_boQJFurnaceGet := False;
  {$IFEND}
end;

procedure TFrmDlg.DButton4DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
//var
 // d: TDirectDrawSurface;
 // rc:Trect;
begin
  {d := FrmMain.UiDXImageList.Items.Find('vigourbar2').PatternSurfaces[0];
  rc := d.ClientRect;
  if d <> nil then begin
     rc.Top := Round(rc.Bottom / nMaxDragonPoint * (nMaxDragonPoint - m_nDragonPoint));
     dsurface.Draw (DCIDSpleen.Left + rc.Left, DCIDSpleen.Top+DBottom.top+rc.Top, rc, d, FALSE);
  end;
  if g_boHintDragonPoint then begin  //20080401
    with dsurface.Canvas do begin
      SetBkMode (Handle, TRANSPARENT);
      BoldTextOut(dsurface,86- TextWidth(IntToStr(m_nDragonPoint)+'/'+IntToStr(nMaxDragonPoint)) div 2, SCREENHEIGHT - 120, clWhite, clBlack,IntToStr(m_nDragonPoint)+'/'+IntToStr(nMaxDragonPoint));
      Release;
    end;
  end;  }//20080619
end;

procedure TFrmDlg.DBRefuseCRYClick(Sender: TObject; X, Y: Integer);
begin
  if g_RefuseCRY then begin
      DBRefuseCRY.SetImgIndex(g_WMain3Images,283);
      g_RefuseCRY:=false;
      FrmMain.SendSay ('@禁止喊话');
  end else begin
      DBRefuseCRY.SetImgIndex(g_WMain3Images,282);
      g_RefuseCRY:=true;
      FrmMain.SendSay ('@禁止喊话');
  end;
end;

procedure TFrmDlg.DBAutoCRYClick(Sender: TObject; X, Y: Integer);
begin
  g_boAutoTalk := not g_boAutoTalk;
  if g_boAutoTalk then begin
     DBAutoCRY.SetImgIndex(g_WMain3Images,289);
     g_sAutoTalkStr := PlayScene.EdChat.Text;
     g_btAutoTalkNum := 0;
     DScreen.AddChatBoardString('[启用了自动喊话功能，聊天框中的内容已记录为喊话内容]', GetRGB(219), clWhite)
  end else begin
     DBAutoCRY.SetImgIndex(g_WMain3Images,288);
     g_sAutoTalkStr := '';
     DScreen.AddChatBoardString('[自动喊话功能已关闭]', GetRGB(219), clWhite)
  end;
end;

//物品发光变换函数 20080223
procedure TFrmDlg.ItemLightTimeImg();
begin
  if GetTickCount - ItemLightTimeTick > 200 then begin
    ItemLightTimeTick := GetTickCount;
    Inc(ItemLightImgIdx);
    if ItemLightImgIdx > 5 then ItemLightImgIdx := 0;
  end;
end;

procedure TFrmDlg.DBHelpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if TDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DGameGirdExchangeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if TDButton(Sender).Downed then begin
    d:=g_WUiMainImages.Images[23];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end else begin
    d:=g_WUiMainImages.Images[24];
    if d<>nil then
      with TDButton(Sender) do
       dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DGameGirdExchangeClick(Sender: TObject; X, Y: Integer);
var
  int, i: Integer;
  msg: TDefaultMessage;
  DlgResult :TModalResult;
  Num: Integer;
begin
  DlgResult := DMessageDlg (Format('请输入需要兑换的%s数量(1-1000)：\（100%s可以兑换一个%s）', [g_sGameGird, g_sGamePointName, g_sGameGird]), [mbRetry, mbIgnore, mbCancel, mbAbort]);
  Num := StrToIntDef(DlgEditText, -1);
  if (Num > 0) and (Num < 1001) then begin
    if DlgResult = mrRetry then begin//元宝购买
      if g_MySelf.m_nGameGold > 0 then begin
        FrmMain.SendBuyGameGird(Num, 0);
      end else DMessageDlg ('你没有足够的'+g_sGameGoldName+'。', [mbOk]);
    end else if DlgResult = mrIgnore then begin
      if g_MySelf.m_nGamePoint > 0 then begin
        FrmMain.SendBuyGameGird(Num, 1);
      end else DMessageDlg ('你没有足够的'+g_sGamePointName+'。', [mbOk]);
    end;
  end else begin
    DMessageDlg ('输入的'+g_sGameGird+'数量不正确。', [mbOk]);
  end;
end;

//得到排行榜点击的索引  20080304
procedure TFrmDlg.DWLevelOrderClick(Sender: TObject; X, Y: Integer);
function GetSortList: TList;
  begin
    Result := nil;
    case nLevelOrderSortType of
      0: begin
          case nLevelOrderType of
            1: Result := m_PlayObjectLevelList;
            2: Result := m_WarrorObjectLevelList;
            3: Result := m_WizardObjectLevelList;
            4: Result := m_TaoistObjectLevelList;
          end;
        end;
      1: begin
          case nLevelOrderType of
            1: Result := m_HeroObjectLevelList;
            2: Result := m_WarrorHeroObjectLevelList;
            3: Result := m_WizardHeroObjectLevelList;
            4: Result := m_TaoistHeroObjectLevelList;
          end;
        end;
      2: begin
          Result := m_PlayObjectMasterList;
        end;
    end;
  end;
var
  lx,ly: Integer;
  List: TList;
  idx: Integer;
  UserLevelSort: pTUserLevelSort;
  HeroLevelSort: pTHeroLevelSort;
  UserMasterSort: pTUserLevelSort;
begin
   lx := DWLevelOrder.LocalX (X) - DWLevelOrder.GLeft;
   ly := DWLevelOrder.LocalY (Y) - DWLevelOrder.GTop;
   List := GetSortList;
   case nLevelOrderSortType of
     0: begin
        if (lx >= 24) and (lx <= 304) and (ly >= 118) and (ly <= 330){ 2008.02.13} then begin
          idx := (ly-118) div 22;
          if List <> nil then begin
            if idx < List.Count then begin
               PlaySound (s_glass_button_click);
               nLevelOrderIndex := idx;
               UserLevelSort := pTUserLevelSort (List[idx]);
               PlayScene.EdChat.Visible := TRUE;
               PlayScene.EdChat.Text := '/'+ UserLevelSort.sChrName+' ';
               PlayScene.EdChat.SetFocus;
               SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
               PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
            end;
          end;
        end;
     end;
     1: begin
        if (lx >= 24) and (lx <= 304) and (ly >= 118) and (ly <= 330){ 2008.02.13} then begin
          idx := (ly-118) div 22 + 0;
          if idx < List.Count then begin
             PlaySound (s_glass_button_click);
             nLevelOrderIndex := idx;
             HeroLevelSort := pTHeroLevelSort (List[idx]);
             PlayScene.EdChat.Visible := TRUE;
             PlayScene.EdChat.Text := '/'+ HeroLevelSort.sChrName+' ';
             PlayScene.EdChat.SetFocus;
             SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
             PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
     end;
     2: begin
        if (lx >= 24) and (lx <= 304) and (ly >= 118) and (ly <= 330){ 2008.02.13} then begin
          idx := (ly-118) div 22 + 0;
          if idx < List.Count then begin
             PlaySound (s_glass_button_click);
             nLevelOrderIndex := idx;
             UserMasterSort := pTUserLevelSort(List[idx]);
             PlayScene.EdChat.Visible := TRUE;
             PlayScene.EdChat.Text := '/'+ UserMasterSort.sChrName+' ';
             PlayScene.EdChat.SetFocus;
             SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
             PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
     end;
   end; //case
end;
{******************************************************************************}
//元宝寄售显示窗口 20080316
procedure TFrmDlg.ShowShopSellOffDlg;
begin
   DWSEllOff.Visible := TRUE;
   DMenuDlg.Visible := FALSE;
   DItemBag.Visible := TRUE;
   LastestClickTime := GetTickCount;
   g_sSellPriceStr := '';
   g_SellOffName := '';
   g_SellOffGameGold := 0;
   g_SellOffGameDiaMond := 0;
end;
procedure TFrmDlg.DSellOffCloseClick(Sender: TObject; X, Y: Integer);
begin
   FrmMain.SendCancelSellOffItem;
   g_SellOffName := '';//寄售对方名字
   g_SellOffGameGold := 0; //寄售的元宝数量
   g_SellOffGameDiaMond := 0;
   DWSEllOff.Visible := False;
   ArrangeItembag;
end;

procedure TFrmDlg.DSellOffItemGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DDGrid.ColCount;
  if idx in [0..8] then begin
    g_MouseItem := g_SellOffItems[idx];
    with DSellOffItemGrid do
      ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth, SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DSellOffItemGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DSellOffItemGrid.ColCount;
  if idx in [0..8] then begin
    if g_SellOffItems[idx].S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_SellOffItems[idx].S.Looks);
      if d <> nil then begin
        with DSellOffItemGrid do begin
          dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                        SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                        d.ClientRect,
                        d, TRUE);
          if g_SellOffItems[idx].S.StdMode = 17 then begin
             dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_SellOffItems[idx].Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_SellOffItems[idx].Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DSellOffItemGridGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
   mi, idx, i: integer;
   int: Byte;
begin
  idx := ACol + ARow * DSellOffItemGrid.ColCount;  //索引
  if not g_boItemMoving then begin   //如果不是移动物品  那么选择这里的物品
     if idx in [0..8] then begin
        if g_SellOffItems[idx].S.Name <> '' then begin
           g_boItemMoving := TRUE;
           g_MovingItem.Index := -idx - 30;
           g_MovingItem.Item := g_SellOffItems[idx];
           g_SellOffItems[idx].S.Name := '';
           ItemClickSound (g_MovingItem.Item.S);
        end;
     end else begin
        if idx = 9 then begin
            int := 0;
            DMessageDlg ('请输入'+g_sGameDiaMond+'数量，在0-9999之间', [mbOk, mbAbort]);
            if DlgEditText = '' then int := 1;
            for i:=1 to length(DlgEditText) do
              if (DlgEditText[i] <'0') or ( DlgEditText[i] > '9') then int := 2;
            if length(DlgEditText) > 4 then int := 3;
            case int of
              0:g_SellOffGameDiaMond := StrToInt(DlgEditText);
              1:DMessageDlg ('内容不能为空！', [mbOk]);
              2:DMessageDlg ('输入的'+g_sGameDiaMond+'错误', [mbOk]);
              3:DMessageDlg (g_sGameDiaMond + '数量不能超过4位', [mbOk]);
            end;
        end;
     end;
  end else begin
     mi := g_MovingItem.Index;
     if idx in [0..8] then begin
       if (mi >= 0) or (mi <= -30) and (mi > -40) then begin
          ItemClickSound (g_MovingItem.Item.S);
          g_boItemMoving := FALSE;
          if mi >= 0 then begin
             g_SellOffDlgItem := g_MovingItem.Item;
             FrmMain.SendAddSellOffItem (g_SellOffDlgItem);  //发消息
             //g_dwDealActionTick := GetTickCount + 4000;      //这个限制 到时候加上
          end else
             AddSellOffItem (g_MovingItem.Item);
          g_MovingItem.Item.S.name := '';
       end;
     end;
  end;
  ArrangeItemBag;
end;

procedure TFrmDlg.DWSellOffDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with DWSellOff do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
      dsurface.TextOut (GLeft + 174 - FrmMain.Canvas.TextWidth('0') div 2, GTop + 64, clWhite, IntToStr(g_SellOffGameDiaMond));
      dsurface.TextOut (GLeft + 158, GTop + 78, clWhite, g_sGameDiaMond);
  end;
end;

procedure TFrmDlg.DSellOffOkClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
  FrmMain.SendSellOffEnd;
  if g_boItemMoving then begin
     mi := g_MovingItem.Index;
     if (mi <= -30) and (mi > -40) then begin
        AddSellOffItem (g_MovingItem.Item);
        g_boItemMoving := FALSE;
        g_MovingItem.Item.S.name := '';
     end;
  end;
end;

procedure TFrmDlg.DSellOffCancelClick(Sender: TObject; X, Y: Integer);
begin
   //if GetTickCount > g_dwDealActionTick then begin
      //CloseDealDlg;
      FrmMain.SendCancelSellOffItem;
      g_SellOffName := '';//寄售对方名字
      g_SellOffGameGold := 0; //寄售的元宝数量
      g_SellOffGameDiaMond := 0;
      ArrangeItembag;
   //end;
end;

//显示寄售列表界面 20080317
procedure TFrmDlg.ShowSellOffListDlg;
begin
   MenuIndex := -1;
   DMerchantDlg.GLeft := 0;
   DMerchantDlg.GTop := 0;
   DMerchantDlg.Visible := TRUE;

   DWSellOffList.GLeft := 0;
   DWSellOffList.GTop  := 176;
   DWSellOffList.Visible := TRUE;

   DSellOffListCancel.Visible := False;
   DSellOffBuyCancel.Visible := False;
   DSellOffBuy.Visible := False;

   DItemBag.GLeft := 440;
   DItemBag.GTop := -25;
   DItemBag.Visible := TRUE;

   LastestClickTime := GetTickCount;
end;
{******************************************************************************}
procedure TFrmDlg.DEditSellOffNameClick(Sender: TObject; X, Y: Integer);
var
  int: Byte;
begin
    int := 0;
    DMessageDlg ('请输入对方的名字', [mbOk, mbAbort]);
    if DlgEditText = '' then int := 1;
    if length(DlgEditText) > 14 then int := 2;
    case int of
      0:g_SellOffName := DlgEditText;
      1:DMessageDlg ('内容不能为空！', [mbOk]);
      2:DMessageDlg ('输入的对方名字错误', [mbOk]);
    end;
end;

procedure TFrmDlg.DEditSellOffNumClick(Sender: TObject; X, Y: Integer);
var
  i: Integer;
  int: Byte;
begin
    int := 0;
    DMessageDlg ('请输入'+g_sGameGoldName+'数量,最多8位数。', [mbOk, mbAbort]);
    if DlgEditText = '' then int := 1;
    for i:=1 to length(DlgEditText) do
      if (DlgEditText[i] <'0') or ( DlgEditText[i] > '9') then int := 2;
    if length(DlgEditText) > 8 then int := 3;
    case int of
      0:g_SellOffGameGold := StrToInt(DlgEditText);
      1:DMessageDlg ('内容不能为空！', [mbOk]);
      2:DMessageDlg ('输入的' + g_sGameGoldName + '错误', [mbOk]);
      3:DMessageDlg (g_sGameGoldName + '数量不能超过8位', [mbOk]);
    end;
end;

procedure TFrmDlg.DEditSellOffNameDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  with DEditSellOffName do begin
        dsurface.TextOut (SurfaceX(GLeft+1), SurfaceY(GTop+3), clWhite, g_SellOffName);
  end;
end;

procedure TFrmDlg.DEditSellOffNumDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  with DEditSellOffNum do begin
        dsurface.TextOut (SurfaceX(GLeft+1), SurfaceY(GTop+3), clWhite, IntToStr(g_SellOffGameGold));
  end;
end;

procedure TFrmDlg.DSellOffListColseClick(Sender: TObject; X, Y: Integer);
begin
  DWSellOffList.Visible := False;
end;

procedure TFrmDlg.DWSellOffListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   str: string;
begin
  with DWSellOffList do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    with dsurface.Canvas do begin
      dsurface.TextOut (GLeft + 18, GTop + 12, clWhite, '交易明细');
      dsurface.TextOut (GLeft + 180, GTop + 12, clWhite, '物品列表');
      dsurface.TextOut (GLeft + 18, GTop + 32, clWhite, '卖方角色：');
      dsurface.TextOut (GLeft + 18, GTop + 32 + 20 * 1, clWhite, '买方角色：');
      dsurface.TextOut (GLeft + 18, GTop + 32 + 20 * 2, clWhite, '元宝数量：');
      case g_SellOffInfo.nSellGold of
            0..9: Font.Color := clWhite;
          10..99: Font.Color := clYellow;
        100..999: Font.Color := clAqua;
      else Font.Color := clFuchsia;
      end;
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];  //字体变粗体
      dsurface.TextOut (GLeft + 78, GTop + 32 + 20 * 2, Font.Color, IntToStr(g_SellOffInfo.nSellGold));
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsBold];  //字体去掉粗体
      frmMain.Canvas.Font.Color := clWhite;
      dsurface.TextOut (GLeft + 18, GTop + 32 + 20 * 3, Font.Color, '提交日期：');
      dsurface.TextOut (GLeft + 78, GTop + 32 + 20 * 3, Font.Color, DateToStr(g_SellOffInfo.dSellDateTime));
      dsurface.TextOut (GLeft + 18, GTop + 32 + 20 * 4, Font.Color, '交易状态：');
      case g_SellOffInfo.N of
        0: str := '正常';
        2: str := '完成';
        3: str := '对方取消收购';
      end;
      dsurface.TextOut (GLeft + 78, GTop + 32 + 20 * 4, Font.Color, str);
      Font.Color := clLime;
      dsurface.TextOut (GLeft + 78, GTop + 32, Font.Color, g_SellOffInfo.sDealCharName);
      dsurface.TextOut (GLeft + 78, GTop + 32 + 20, Font.Color, g_SellOffInfo.sBuyCharName);
      Release;
    end;
  end;
end;

procedure TFrmDlg.DSellOffItem0DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
begin
  if Sender = DSellOffItem0 then begin
    if g_SellOffInfo.UseItems[0].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[0].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem0 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 0 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[0].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem1 then begin
    if g_SellOffInfo.UseItems[1].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[1].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem1 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 1 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[1].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem2 then begin
    if g_SellOffInfo.UseItems[2].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[2].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem2 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 2 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[2].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem3 then begin
    if g_SellOffInfo.UseItems[3].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[3].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem3 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 3 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[3].s.Name);
           Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem4 then begin
    if g_SellOffInfo.UseItems[4].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[4].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem4 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 4 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[4].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem5 then begin
    if g_SellOffInfo.UseItems[5].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[5].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem5 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 5 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[5].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem6 then begin
    if g_SellOffInfo.UseItems[6].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[6].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem6 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 6 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[6].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem7 then begin
    if g_SellOffInfo.UseItems[7].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[7].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem7 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 7 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[7].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem8 then begin
    if g_SellOffInfo.UseItems[8].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[8].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem8 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 8 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[8].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;

  if Sender = DSellOffItem9 then begin
    if g_SellOffInfo.UseItems[9].s.Name <> '' then begin
      idx := g_SellOffInfo.UseItems[9].s.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        with DSellOffItem9 do begin
          if d <> nil then
              dsurface.StretchDraw (Rect(SurfaceX(GLeft), SurfaceY(GTop), SurfaceX(GLeft + 16), SurfaceY(GTop + 16)), d.ClientRect,d, True);
          with dsurface.Canvas do begin
            if g_SellOffItemIndex = 9 then Font.Color := clRed else
              Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft) + 17, SurfaceY(GTop) + 2, Font.Color, g_SellOffInfo.UseItems[9].s.Name);
            Release;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DSellOffItem0Click(Sender: TObject; X, Y: Integer);
var
  iname: string;
  useable: Boolean;
  sel: integer;
  Butt:TDButton;
begin
   g_SellOffItemIndex := TDButton(Sender).Tag;
    sel := -1;
   Butt:=TDButton(Sender);
   if Sender = DSellOffItem0 then sel := 0;
   if Sender = DSellOffItem1 then sel := 1;
   if Sender = DSellOffItem2 then sel := 2;
   if Sender = DSellOffItem3 then sel := 3;
   if Sender = DSellOffItem4 then sel := 4;
   if Sender = DSellOffItem5 then sel := 5;
   if Sender = DSellOffItem6 then sel := 6;
   if Sender = DSellOffItem7 then sel := 7;
   if Sender = DSellOffItem8 then sel := 8;
   if Sender = DSellOffItem9 then sel := 9;

   if (g_SellOffInfo.UseItems[sel].Dura = High(Word)) and (g_SellOffInfo.UseItems[sel].DuraMax = High(Word))
      and (Pos(g_sGameDiaMond,g_SellOffInfo.UseItems[sel].S.Name ) > 0)
      and (g_SellOffInfo.UseItems[sel].S.Price > 0)
      and (g_SellOffInfo.UseItems[sel].S.Looks = High(Word))then begin
      iname := g_sGameDiaMond + ' 数量 '+IntToStr(g_SellOffInfo.UseItems[sel].S.Price) + ' 颗';
      with Butt as TDButton do
        DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft) + 115, Butt.SurfaceY(Butt.GTop), iname, clWhite, FALSE);
        g_MouseItem.S.Name := '';
   end else begin
      //原为注释掉 显示人物身上带的物品信息
      g_MouseItem := g_SellOffInfo.UseItems[sel];
      with Butt as TDButton do
        ShowMouseItemInfo(SurfaceX(Butt.GLeft) + 115, SurfaceY(Butt.GTop), '', 1, False);
   end;
end;

procedure TFrmDlg.DSellOffListCancelClick(Sender: TObject; X, Y: Integer);
begin
      FrmMain.SendCancelMySellOffIteming;
      ArrangeItembag;
      DWSellOffList.Visible := False;
      FillChar (g_SellOffInfo, sizeof(TClientDealOffInfo), #0); //清空寄售列表物品 20080318
end;

procedure TFrmDlg.DSellOffBuyCancelClick(Sender: TObject; X, Y: Integer);
begin
      FrmMain.SendSellOffBuyCancel;
      DWSellOffList.Visible := False;
      FillChar (g_SellOffInfo, sizeof(TClientDealOffInfo), #0); //清空寄售列表物品 20080318
end;

procedure TFrmDlg.DSellOffBuyClick(Sender: TObject; X, Y: Integer);
begin
      FrmMain.SendSellOffBuy;
end;

procedure TFrmDlg.DWGameGoldMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  g_MouseItem.S.Name := '元宝信息';
  g_MouseItem.MakeIndex := 3000;
  g_MouseItem.Dura := 3000;
  g_MouseItem.DuraMax := 3000;
end;

procedure TFrmDlg.DWMiniMap1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin

end;
//获得新小地图号  20080324
function TFrmDlg.GetMiniMapNum(num:Integer): TDirectDrawSurface;
begin
  case num of
    10301: Result := g_WUiMainImages.Images[20];
    10302: Result := g_WUiMainImages.Images[25];
    10303: Result := g_WUiMainImages.Images[26];
    10304: Result := g_WUiMainImages.Images[27];
    10306: Result := g_WUiMainImages.Images[28];
    10307: Result := g_WUiMainImages.Images[32];
    10308: Result := g_WUiMainImages.Images[33];
    10309: Result := g_WUiMainImages.Images[34];
    10310: Result := g_WUiMainImages.Images[35];
    10311: Result := g_WUiMainImages.Images[36];
    10312: Result := g_WUiMainImages.Images[37];
    10313: Result := g_WUiMainImages.Images[38];
    10314: Result := g_WUiMainImages.Images[39];
    10315: Result := g_WUiMainImages.Images[40];
    10316: Result := g_WUiMainImages.Images[41];
    10317: Result := g_WUiMainImages.Images[42];
    10318: Result := g_WUiMainImages.Images[43];
    10319: Result := g_WUiMainImages.Images[44];
    10320: Result := g_WUiMainImages.Images[45];
    10321: Result := g_WUiMainImages.Images[46];
    10322: Result := g_WUiMainImages.Images[47];
    10323: Result := g_WUiMainImages.Images[48];
    10324: Result := g_WUiMainImages.Images[49];
    10325: Result := g_WUiMainImages.Images[50];
    10326: Result := g_WUiMainImages.Images[51];
    10327: Result := g_WUiMainImages.Images[52];
    10328: Result := g_WUiMainImages.Images[53];
    10329: Result := g_WUiMainImages.Images[54];
    10330: Result := g_WUiMainImages.Images[55];
    10402: Result := g_WUiMainImages.Images[56];
    13021: Result := g_WUiMainImages.Images[57];
    13022: Result := g_WUiMainImages.Images[58];
    13023: Result := g_WUiMainImages.Images[59];
    10331: Result := g_WUiMainImages.Images[60];
  else Result := nil;
  end;
end;



procedure TFrmDlg.DSelectChrMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DCIDSpleenMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
 // g_boHintDragonPoint := True;
end;

procedure TFrmDlg.DUserState1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  g_boSelectText := False;
end;

procedure TFrmDlg.DHeroIconMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
  {$IF M2Version=1}
  function GetTransferOK(): string;
  begin
    if g_HeroSelf.m_Abil.MaxTransferValue > 0 then begin
      Result := '\斗转星移：' + IntToStr(g_HeroSelf.m_Abil.TransferValue) + '/' + IntToStr(g_HeroSelf.m_Abil.MaxTransferValue);
    end else Result := '';
  end;
  {$IFEND}
begin
  if g_Heroself = nil then Exit;
  if g_HeroSelf.m_Abil.nMaxExp > 0 then
    DScreen.ShowHint(DHeroIcon.SurfaceX(DHeroIcon.GLeft) + DheroIcon.GWidth - 2, DHeroIcon.SurfaceY(DHeroIcon.GTop)+18,
       '体力值: ' + IntToStr(g_Heroself.m_Abil.HP)+ '/' + IntToStr(g_Heroself.m_Abil.MaxHP) + '\' +
       '魔法值: ' + IntToStr(g_Heroself.m_Abil.MP)+ '/' + IntToStr(g_Heroself.m_Abil.MaxMP) + '\' +
       '内力值: ' + IntToStr(g_Heroself.m_Skill69NH)+ '/' + IntToStr(g_Heroself.m_Skill69MaxNH) + '\' +
       '经验值: ' + FloatToStrFixFmt (100 * (g_HeroSelf.m_Abil.nExp / g_HeroSelf.m_Abil.nMaxExp), 3, 2) + '%' + '\' +
       '忠诚度: ' + FormatFloat('0.00',g_HeroSelf.m_nLoyal / 100)+'%' + '\' +
       '醉酒度: ' + IntToStr(_MAX(0, 100 * g_HeroSelf.m_Abil.WineDrinkValue div _MAX(1, g_HeroSelf.m_Abil.MaxAlcohol))) + '%'
       {$IF M2Version = 1} + GetTransferOk(){$IFEND}
       , clWhite, FALSE);
end;

procedure TFrmDlg.DBoxsTautologyDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DBoxsTautology do begin
    if g_boNewBoxs = 0 then begin //老宝箱
      if DBoxsTautology.Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
      if GetTickCount - g_dwBoxsTautologyTick > 400 then begin
        g_dwBoxsTautologyTick := GetTickCount;
        Inc(g_BoxsTautologyImg);
        if g_BoxsTautologyImg > 3 then g_BoxsTautologyImg := 0;
      end;
      d := g_WMain3Images.Images[515+g_BoxsTautologyImg];
      if d <> nil then DrawBlend(dsurface,SurfaceX(GLeft- 10),SurfaceY(GTop - 20), d, 255);
    end else begin  //新宝箱
      if DBoxsTautology.Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex+1];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemsUpBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
begin
  if Sender = DItemsUpBelt1 then begin
    if g_ItemsUpItem[0].S.Name <> '' then begin
      idx := g_ItemsUpItem[0].S.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        if d <> nil then
          dsurface.Draw (DItemsUpBelt1.SurfaceX(DItemsUpBelt1.GLeft + (DItemsUpBelt1.GWidth - d.Width) div 2),
                         DItemsUpBelt1.SurfaceY(DItemsUpBelt1.GTop + (DItemsUpBelt1.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DItemsUpBelt2 then begin
    if g_ItemsUpItem[1].S.Name <> '' then begin
      idx := g_ItemsUpItem[1].S.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        if d <> nil then
          dsurface.Draw (DItemsUpBelt2.SurfaceX(DItemsUpBelt2.GLeft + (DItemsUpBelt2.GWidth - d.Width) div 2),
                         DItemsUpBelt2.SurfaceY(DItemsUpBelt2.GTop + (DItemsUpBelt2.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
      end;
    end;
  end;
  if Sender = DItemsUpBelt3 then begin
    if g_ItemsUpItem[2].S.Name <> '' then begin
      idx := g_ItemsUpItem[2].S.Looks;
      if idx >= 0 then begin
        d :=frmMain.GetBagItemImg(idx);
        if d <> nil then
          dsurface.Draw (DItemsUpBelt3.SurfaceX(DItemsUpBelt3.GLeft + (DItemsUpBelt3.GWidth - d.Width) div 2),
                         DItemsUpBelt3.SurfaceY(DItemsUpBelt3.GTop + (DItemsUpBelt3.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DItemsUpBelt1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
   butt: TDButton;
   sel: Integer;
begin
   butt := TDButton(Sender);
   sel := 0;
   if not g_boItemMoving then begin
      if g_ItemsUpItem[butt.Tag].S.Name <> '' then begin
         ItemClickSound (g_ItemsUpItem[butt.Tag].s);
         if (g_MovingItem.Item.S.Name <> '') or (g_WaitingItemUp.Item.S.Name <> '') then exit;
         sel := -1;
         if Sender = DItemsUpBelt1 then sel := 0;
         if Sender = DItemsUpBelt2 then sel := 1;
         if Sender = DItemsUpBelt3 then sel := 2;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(sel + 41);
         g_MovingItem.Item := g_ItemsUpItem[butt.Tag];
         g_ItemsUpItem[butt.Tag].S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -41) or (g_MovingItem.Index = -42) or
         (g_MovingItem.Index = -43) then begin
         ItemClickSound (g_MovingItem.Item.S);
         if g_ItemsUpItem[butt.Tag].S.Name <> '' then begin //磊府俊 乐栏搁
            temp := g_ItemsUpItem[butt.Tag];
            g_ItemsUpItem[butt.Tag] := g_MovingItem.Item;
            g_MovingItem.Index := -(sel + 41);
            g_MovingItem.Item := temp
         end else begin
            g_ItemsUpItem[butt.Tag] := g_MovingItem.Item;
            g_MovingItem.Item.S.name := '';
            g_boItemMoving := FALSE;
         end;
      end;
   end;
end;



procedure TFrmDlg.DItemsUpOkClick(Sender: TObject; X, Y: Integer);
begin
  if (g_ItemsUpItem[0].S.Name = '') or (g_ItemsUpItem[1].S.Name = '') or (g_ItemsUpItem[2].S.Name = '') then Exit;
  FrmMain.SendItemUpOK();
end;

procedure TFrmDlg.DItemsUpBelt1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   idx: integer;
begin
   idx := TDButton(Sender).Tag;
   if idx in [0..2] then begin
      if g_ItemsUpItem[idx].S.Name <> '' then begin
         g_MouseItem := g_ItemsUpItem[idx];
      end;
   end;
end;

procedure TFrmDlg.DItemsUpCloseClick(Sender: TObject; X, Y: Integer);
begin
  DItemsUp.Visible := False;
  if g_ItemsUpItem[0].S.Name <> '' then begin
    AddItemBag(g_ItemsUpItem[0]);
    g_ItemsUpItem[0].S.Name := '';
  end;
  if g_ItemsUpItem[1].S.Name <> '' then begin
    AddItemBag(g_ItemsUpItem[1]);
    g_ItemsUpItem[1].S.Name := '';
  end;
  if g_ItemsUpItem[2].S.Name <> '' then begin
    AddItemBag(g_ItemsUpItem[2]);
    g_ItemsUpItem[2].S.Name := '';
  end;
end;

procedure TFrmDlg.DGetHeroCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWiGetHero.Visible := False;
end;

procedure TFrmDlg.DBGloryDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with DBGlory do begin
   d := g_WUiMainImages.Images[31];
    if d <> nil then
     dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
     dsurface.TextOut (SurfaceX(GLeft) + 50 - frmMain.Canvas.TextWidth(IntToStr(g_btGameGlory)) div 2, SurfaceY(GTop) + 4, clWhite, IntToStr(g_btGameGlory));
  end;
end;

procedure TFrmDlg.DSelHero1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if not TDButton(Sender).Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           d := WLib.Images[FaceIndex + 2];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TfrmDlg.DPlayGameNum();
var
  J, vData: Integer;
begin
    if GetTickCount - g_DwPlayDrinkTick > 50 then begin
      g_DwPlayDrinkTick := GetTickCount;
      if g_nImgLeft < 130 then Inc(g_nImgLeft,30)
       else Inc(g_nPlayDrinkDelay);
      if g_nImgLeft > 100 then DPlayDrinkWhoWin.Visible := True;  //显示谁赢
      if g_nPlayDrinkDelay > 30 then begin
        g_boPlayDrink := False;
        ShowPlayDrinkImg(False);
        if g_btWhoWin = 1 then begin //NPC赢
          if g_NpcRandomDrinkList.Count= 0 then Exit;
          Randomize(); //随机种子
          J := Random(g_NpcRandomDrinkList.Count);//从余下的酒中随机选一瓶
          vData := Integer(g_NpcRandomDrinkList[J]);
          g_NpcRandomDrinkList.Delete(J); //抽取完后从列表中删除
          g_btNpcDrinkTarget := vData; //随机目标
          g_boNpcAutoSelDrink := True;  //自动选酒
          g_nNpcSelDrinkPosition := -1; //位置初始化
          g_btNpcAutoSelDrinkCircleNum := 0; //初始化圈数
        end;
      end;
    end;
end;

procedure TFrmDlg.DPlayDrinkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   MyIcon: Integer;
   Butt: TDButton;
   rc: Trect;
   IconFlash: Integer; //定位NPC或玩家头像处喝酒图
begin
  with DPlayDrink do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_btDrinkValue[0] <= 92 then begin
       d := g_WMain2Images.Images[342+g_btNpcIcon]; //NPC头像
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
//------------------------NPC喝酒动画显示
    if g_btShowPlayDrinkFlash = 1 then begin
      if GetTickCount - g_DwShowPlayDrinkFlashTick > 150 then begin
         g_DwShowPlayDrinkFlashTick := GetTickCount;
         inc(g_nShowPlayDrinkFlashImg);
         if g_btTempDrinkValue[0] > 92 then begin//NPC喝醉了
            if g_nShowPlayDrinkFlashImg > 14 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[0] := g_btTempDrinkValue[0];
            end;
         end else begin
            if g_nShowPlayDrinkFlashImg > 10 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[0] := g_btTempDrinkValue[0];
            end;
         end;
      end;
      case g_btNpcIcon of
        0: IconFlash := 370;
        1: IconFlash := 390;
        2: IconFlash := 410;
        else IconFlash := 370;
      end;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
    if g_btDrinkValue[0] > 92 then begin //喝醉了最后的图
      case g_btNpcIcon of
        0: IconFlash := 370;
        1: IconFlash := 390;
        2: IconFlash := 410;
        else IconFlash := 370;
      end;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg - 1];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
//-----------------
    if g_btDrinkValue[1] <= 92 then begin
     if g_Myself.m_btSex = 0 then MyIcon := 337 else MyIcon := 338;
     if MyIcon > 0 then begin //玩家头像
      if g_WMain2Images <> nil then begin
       d := g_WMain2Images.Images[MyIcon];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 248), d.ClientRect, d, TRUE);
      end;
     end;
    end;
//-------------玩家喝酒动画显示
    if g_btShowPlayDrinkFlash = 2 then begin
      if GetTickCount - g_DwShowPlayDrinkFlashTick > 150 then begin
         g_DwShowPlayDrinkFlashTick := GetTickCount;
         inc(g_nShowPlayDrinkFlashImg);
         if g_btTempDrinkValue[1] > 92 then begin//NPC喝醉了
            if g_nShowPlayDrinkFlashImg > 14 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[1] := g_btTempDrinkValue[1];
            end;
         end else begin
            if g_nShowPlayDrinkFlashImg > 10 then begin
              g_btShowPlayDrinkFlash := 0;
              g_btDrinkValue[1] := g_btTempDrinkValue[1];
            end;
         end;
      end;
      if g_Myself.m_btSex = 0 then IconFlash := 430 else IconFlash := 450;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 248), d.ClientRect, d, TRUE);
    end;
    if g_btDrinkValue[1] > 92 then begin //喝醉了最后的图
      if g_Myself.m_btSex = 0 then IconFlash := 430 else IconFlash := 450;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg - 1];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 248), d.ClientRect, d, TRUE);
    end;
//-----------------
    d := g_WMain2Images.Images[369];  //NPC酒气
    if d <> nil then begin
       rc := d.ClientRect;
       rc.Right := Round((rc.Right-rc.Left) /100 * g_btDrinkValue[0]);
       dsurface.Draw (SurfaceX(GLeft + 111), SurfaceY(GTop + 97), rc, d, true);
    end;
    d := g_WMain2Images.Images[369];  //玩家酒气
    if d <> nil then begin
       rc := d.ClientRect;
       rc.Right := Round((rc.Right-rc.Left) /100 * g_btDrinkValue[1]);
       dsurface.Draw (SurfaceX(GLeft + 111), SurfaceY(GTop + 326), rc, d, true);
    end;
     with dsurface.Canvas do  begin
      Brush.Color := clRed;
      FillRect(rect(SurfaceX(GLeft)+313,  //左边      填充白色背景
                    SurfaceY(GTop) + 97,      //上边
                    SurfaceX(GLeft)+315,   //右边
                    SurfaceY(GTop)+ 106));//下边
      FillRect(rect(SurfaceX(GLeft)+313,  //左边      填充白色背景
                    SurfaceY(GTop) + 326,      //上边
                    SurfaceX(GLeft)+315,   //右边
                    SurfaceY(GTop)+ 335));//下边
      Release;
     end;
      dsurface.TextOut(SurfaceX(GLeft) + 60 - FrmMain.Canvas.TextWidth(g_sNpcName) div 2 , SurfaceY(GTop) + 97, clWhite, g_sNpcName);
      dsurface.TextOut(SurfaceX(GLeft) + 60 - FrmMain.Canvas.TextWidth(g_MySelf.m_sUserName) div 2 , SurfaceY(GTop) + 326, clWhite, g_MySelf.m_sUserName);

    d := g_WMain2Images.Images[348];
    if d <> nil then begin
      if g_boStopPlayDrinkGame then begin
        DrawBlendEx(dsurface,SurfaceX(GLeft) + 395,
                  SurfaceY(GTop) + 240, d,0,0,d.Width,d.Height, 150)
      end else dsurface.Draw (SurfaceX(GLeft) + 395, SurfaceY(GTop) + 240, d.ClientRect, d, TRUE);
    end;
    d := g_WMain2Images.Images[350];
    if d <> nil then begin
      if g_boStopPlayDrinkGame then begin
        DrawBlendEx(dsurface,SurfaceX(GLeft) + 351,
                  SurfaceY(GTop) + 250, d,0,0,d.Width,d.Height, 150)
      end else dsurface.Draw (SurfaceX(GLeft) + 351, SurfaceY(GTop) + 250, d.ClientRect, d, TRUE);
    end;
    d := g_WMain2Images.Images[352];
    if d <> nil then begin
      if g_boStopPlayDrinkGame then begin
        DrawBlendEx(dsurface,SurfaceX(GLeft) + 342,
                  SurfaceY(GTop) + 294, d,0,0,d.Width,d.Height, 150)
      end else dsurface.Draw (SurfaceX(GLeft) + 342, SurfaceY(GTop) + 294, d.ClientRect, d, TRUE);
    end;
     if not g_boStopPlayDrinkGame then begin
      if g_btPlayDrinkGameNum <= 2 then begin
        if DPlayDrinkFist.Tag = g_btPlayDrinkGameNum then butt := DPlayDrinkFist;
        if DPlayDrinkScissors.Tag = g_btPlayDrinkGameNum then butt := DPlayDrinkScissors;
        if DPlayDrinkCloth.Tag = g_btPlayDrinkGameNum then butt := DPlayDrinkCloth;
        if butt.Tag = g_btPlayDrinkGameNum then begin
            if GetTickCount - g_dwPlayDrinkSelImgTick > 100 then begin
               g_dwPlayDrinkSelImgTick := GetTickCount;
               inc(g_nPlayDrinkSelImg);
              if g_nPlayDrinkSelImg > 1 then g_nPlayDrinkSelImg := 0;
            end;
          with butt do begin
            d := g_WMain2Images.Images[361 + g_nPlayDrinkSelImg];
            if d <> nil then
                DrawBlend(dsurface,SurfaceX(GLeft), SurfaceY(GTop), d, 255);
          end;
        end;
      end;
     end;
    if not g_boPlayDrink then begin
      DMerchantDlgShowText(Sender, dsurface, g_sPlayDrinkStr1,
      SelectMenuStr, 120, 46, g_PlayDrinkPoints,
      g_boRequireAddPoints1);
      DMerchantDlgShowText(Sender, dsurface, g_sPlayDrinkStr2,
      SelectMenuStr, 120, 274, g_PlayDrinkPoints,
      g_boRequireAddPoints2);
    end;

    if g_boPlayDrink then begin
      d := g_WMain2Images.Images[339];
      if d <> nil then begin
            DrawBlendEx(dsurface,SurfaceX(GLeft),
                    SurfaceY(GTop), d,0,0,d.Width,d.Height, 150);
      end;
      DPlayGameNum();
      DPlayDrinkNpcNum.GLeft := 0 + g_nImgLeft;
      d := g_WMain2Images.Images[345];
        if d <> nil then
      DPlayDrinkPlayNum.GLeft := DPlayDrink.GWidth - d.Width - g_nImgLeft;

    end;
  end;
end;

procedure TFrmDlg.ChallengeClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwQueryMsgTick then begin
      g_dwQueryMsgTick := GetTickCount + 3000;
      FrmMain.SendChallenge;
   end;
end;
//酒馆NPC自动选酒中。。
procedure TFrmDlg.NpcAutoSelDrinkRuning(dsurface: TDirectDrawSurface);
begin
  if g_boNpcAutoSelDrink then begin     //NPC自动选酒中
    if GetTickCount - g_DwShowNpcSelDrinkTick > 150 then begin
     g_DwShowNpcSelDrinkTick := GetTickCount;
     Inc(g_nNpcSelDrinkPosition);  //下一个位置
      if g_nNpcSelDrinkPosition > 5 then begin
        g_nNpcSelDrinkPosition := 0;
        Inc(g_btNpcAutoSelDrinkCircleNum); //转动圈数
      end;

    if g_btNpcAutoSelDrinkCircleNum = 2 then begin
      if g_nNpcSelDrinkPosition = 0 then
        if DDrink1.Tag = g_btNpcDrinkTarget then begin
          DDrink1.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 1 then
        if DDrink2.Tag = g_btNpcDrinkTarget then begin
          DDrink2.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 2 then
        if DDrink4.Tag = g_btNpcDrinkTarget then begin
          DDrink4.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 3 then
        if DDrink6.Tag = g_btNpcDrinkTarget then begin
          DDrink6.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 4 then
        if DDrink5.Tag = g_btNpcDrinkTarget then begin
          DDrink5.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
      if g_nNpcSelDrinkPosition = 5 then
        if DDrink3.Tag = g_btNpcDrinkTarget then begin
          DDrink3.Visible := False;
          g_boNpcAutoSelDrink := False;
          FrmMain.SendDrinkUpdateValue(g_nCurMerchant, 0, 0);
        end;
    end;
    end;
  end;
end;

procedure TFrmDlg.DDrink1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  NpcAutoSelDrinkRuning(dsurface);
   with TDButton(Sender) do begin
     if g_boPermitSelDrink then begin  //酒不让透明，允许玩家选酒
        if TDButton(Sender).ShowHint then begin//鼠标移动到了这瓶酒  高亮
          d := g_WMain2Images.Images[329];
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin   //普通显示
          d := g_WMain2Images.Images[363];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if g_boNpcAutoSelDrink then begin   //NPC自动选
          if TDButton(Sender).Tag = g_nNpcSelDrinkPosition then begin
            d := g_WMain2Images.Images[329];
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
        end else begin   //玩家选酒
          if TDButton(Sender).Tag = g_btPlaySelDrink then begin
            d := g_WMain2Images.Images[329];
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
        end;
     end else begin
       d := g_WMain2Images.Images[363];
       if d <> nil then begin
         DrawBlendEx(dsurface,SurfaceX(GLeft),
                  SurfaceY(GTop), d,0,0,d.Width,d.Height, 150);
       end;
     end;
   end;
end;

procedure TFrmDlg.DWiGetHeroDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  function GetHeroIcon(Job,Sex: Byte): Integer;
  var
    Icon: Integer;
  begin
    case Job of
      0:Icon := 502;
      1:Icon := 506;
      2:Icon := 504;
      else Icon := 502;
    end;
    if Sex = 1 then Result := Icon +1
    else Result := Icon;
  end;
  function GetHeroJob(Job: Byte): string;
  begin
    case Job of
      0:Result := '战士';
      1:Result := '法师';
      2:Result := '道士';
    end;
  end;
var
   d: TDirectDrawSurface;
   Job: string;
   Icon: Integer;
begin
  with DWiGetHero do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    if g_GetHeroData[0].sChrName <> '' then begin
      Icon := GetHeroIcon(g_GetHeroData[0].btJob, g_GetHeroData[0].btSex);
      d := g_WMain2Images.Images[Icon];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft) + 32, SurfaceY(GTop) + 76, d.ClientRect, d, TRUE);
    end;

    if g_GetHeroData[1].sChrName <> '' then begin
      Icon := GetHeroIcon(g_GetHeroData[1].btJob, g_GetHeroData[1].btSex);
      d := g_WMain2Images.Images[Icon];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft) + 150, SurfaceY(GTop) + 77, d.ClientRect, d, TRUE);
    end;
    with dsurface.Canvas do  begin
      if g_GetHeroData[0].sChrName <> '' then begin
        dsurface.TextOut(SurfaceX(GLeft) + 74 - FrmMain.Canvas.TextWidth(g_GetHeroData[0].sChrName) div 2 , SurfaceY(GTop) + 58, clSkyBlue, g_GetHeroData[0].sChrName);
        Font.Color := $0040BBF1;
        dsurface.TextOut(SurfaceX(GLeft) + 67 , SurfaceY(GTop) + 192, Font.Color, IntToStr(g_GetHeroData[0].Level));
        Job := GetHeroJob(g_GetHeroData[0].btJob);
        dsurface.TextOut(SurfaceX(GLeft) + 67 , SurfaceY(GTop) + 206, Font.Color, Job);
      end;
      if g_GetHeroData[1].sChrName <> '' then begin
        dsurface.TextOut(SurfaceX(GLeft) + 192 - FrmMain.Canvas.TextWidth(g_GetHeroData[1].sChrName) div 2 , SurfaceY(GTop) + 58, clSkyBlue, g_GetHeroData[1].sChrName);
        Font.Color := $0040BBF1;
        dsurface.TextOut(SurfaceX(GLeft) + 184 , SurfaceY(GTop) + 192, Font.Color, IntToStr(g_GetHeroData[1].Level));
        Job := GetHeroJob(g_GetHeroData[1].btJob);
        dsurface.TextOut(SurfaceX(GLeft) + 184 , SurfaceY(GTop) + 206, Font.Color, Job);
      end;
      Release;
    end;
  end;
end;

procedure TFrmDlg.DSelHero1Click(Sender: TObject; X, Y: Integer);
begin
  if g_GetHeroData[TDButton(Sender).Tag].sChrName <> '' then begin
    FrmMain.SendSelHeroName(g_GetHeroData[TDButton(Sender).Tag].btType, g_GetHeroData[TDButton(Sender).Tag].sChrName);
    DWiGetHero.Visible := False;
  end;
end;

procedure TFrmDlg.DPlayFistClick(Sender: TObject; X, Y: Integer);
begin
  if g_boStopPlayDrinkGame then Exit;
  FrmMain.SendPlayDrinkGame(g_nCurMerchant,g_btPlayDrinkGameNum); //发送猜拳码数
  g_boPermitSelDrink := True;
  DPlayFist.Visible := False;
end;

procedure TFrmDlg.DPlayDrinkCloseDirctPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if not Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            if g_boPlayDrink then begin
              DrawBlendEx(dsurface,SurfaceX(GLeft),
                  SurfaceY(GTop), d,0,0,d.Width,d.Height, 150);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            if g_boPlayDrink then begin
              DrawBlendEx(dsurface,SurfaceX(GLeft),
                  SurfaceY(GTop), d,0,0,d.Width,d.Height, 150);
            end else dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
   end;
end;

procedure TFrmDlg.ShowPlayDrink (Who1: integer; msgstr: string);
var
   i: integer;
begin
   if Who1 = 1 then   //上面的人
   g_sPlayDrinkStr1 := msgstr
   else if Who1 = 2 then   g_sPlayDrinkStr2 := msgstr;  //下面的人
   if g_PlayDrinkPoints.Count > 0 then //20080629
   for i:=0 to g_PlayDrinkPoints.Count-1 do
      Dispose (pTClickPoint (g_PlayDrinkPoints[i]));
   g_PlayDrinkPoints.Clear;
   if Who1 = 1 then
   g_boRequireAddPoints1 := TRUE;
   if who1 = 2 then
   g_boRequireAddPoints2 := TRUE;
end;
procedure TFrmDlg.DPlayDrinkMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   SelectMenuStr := '';
   L := DPlayDrink.GLeft;
   T := DPlayDrink.GTop;
   with DPlayDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
end;

procedure TFrmDlg.DPlayDrinkMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DPlayDrinkClick(Sender: TObject; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   L := DPlayDrink.GLeft;
   T := DPlayDrink.GTop;
   with DPlayDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            FrmMain.SendPlayDrinkDlgSelect (g_nCurMerchant, p.RStr);
            break;
         end;
      end;
end;

procedure TFrmDlg.DWPleaseDrinkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  IconFlash: Integer;
begin
  with DWPleaseDrink do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

       d := g_WMain2Images.Images[342+g_btNpcIcon]; //NPC头像
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
          
//------------------------NPC喝酒动画显示
    if g_btShowPlayDrinkFlash = 1 then begin
      if GetTickCount - g_DwShowPlayDrinkFlashTick > 150 then begin
         g_DwShowPlayDrinkFlashTick := GetTickCount;
         inc(g_nShowPlayDrinkFlashImg);
         if g_nShowPlayDrinkFlashImg > 10 then begin
           g_btShowPlayDrinkFlash := 0;
           g_btDrinkValue[0] := g_btTempDrinkValue[0];
         end;
      end;
      case g_btNpcIcon of
        0: IconFlash := 370;
        1: IconFlash := 390;
        2: IconFlash := 410;
        else IconFlash := 370;
      end;
      d := g_WMain2Images.Images[IconFlash + g_nShowPlayDrinkFlashImg];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft + 16), SurfaceY(GTop + 19), d.ClientRect, d, TRUE);
    end;
      dsurface.TextOut(SurfaceX(GLeft) + 60 - FrmMain.Canvas.TextWidth(g_sNpcName) div 2 , SurfaceY(GTop) + 97, clWhite, g_sNpcName);

    DMerchantDlgShowText(Sender, dsurface, g_sPlayDrinkStr1,
      SelectMenuStr, 115, 55, g_PlayDrinkPoints,
      g_boRequireAddPoints1);
    DMerchantDlgShowText(Sender, dsurface, g_sPlayDrinkStr2,
      SelectMenuStr, 30, 263, g_PlayDrinkPoints,
      g_boRequireAddPoints2);

    d := g_WMain2Images.Images[364];
    if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 96), SurfaceY(GTop + 186), d.ClientRect, d, TRUE);
    if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 290), SurfaceY(GTop + 196), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DPDrink1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if Sender = DPDrink1 then begin
    d := g_WMain2Images.Images[365];
    if d <> nil then begin
      if DPDrink1.ShowHint then begin
         DrawBlendEx(dsurface,DPDrink1.SurfaceX(DPDrink1.GLeft),
            DPDrink1.SurfaceY(DPDrink1.GTop), d,0,0,d.Width,d.Height, 150)
      end else
         dsurface.Draw (DPDrink1.SurfaceX(DPDrink1.GLeft + (DPDrink1.GWidth - d.Width) div 2),
                     DPDrink1.SurfaceY(DPDrink1.GTop + (DPDrink1.GHeight - d.Height) div 2),
                     d.ClientRect, d, TRUE);
    end;
    if g_PDrinkItem[0].S.Name <> '' then begin
        d := g_WMain2Images.Images[363];
        if d <> nil then begin
          if DPDrink1.ShowHint then begin
             DrawBlendEx(dsurface,DPDrink1.SurfaceX(DPDrink1.GLeft),
                DPDrink1.SurfaceY(DPDrink1.GTop), d,0,0,d.Width,d.Height, 150);
          end else
             dsurface.Draw (DPDrink2.SurfaceX(DPDrink1.GLeft + (DPDrink1.GWidth - d.Width) div 2),
                         DPDrink2.SurfaceY(DPDrink1.GTop + (DPDrink1.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
        end;
    end;
  end;

  if Sender = DPDrink2 then begin
    d := g_WMain2Images.Images[365];
    if d <> nil then begin
      if DPDrink2.ShowHint then begin
         DrawBlendEx(dsurface,DPDrink2.SurfaceX(DPDrink2.GLeft),
            DPDrink2.SurfaceY(DPDrink2.GTop), d,0,0,d.Width,d.Height, 150);
      end else
        dsurface.Draw (DPDrink2.SurfaceX(DPDrink2.GLeft + (DPDrink2.GWidth - d.Width) div 2),
                     DPDrink2.SurfaceY(DPDrink2.GTop + (DPDrink2.GHeight - d.Height) div 2),
                     d.ClientRect, d, TRUE);
    end;
    if g_PDrinkItem[1].S.Name <> '' then begin
        d := g_WMain2Images.Images[363];
        if d <> nil then begin
          if DPDrink2.ShowHint then begin
             DrawBlendEx(dsurface,DPDrink2.SurfaceX(DPDrink2.GLeft),
                DPDrink2.SurfaceY(DPDrink2.GTop), d,0,0,d.Width,d.Height, 150);
          end else
            dsurface.Draw (DPDrink2.SurfaceX(DPDrink2.GLeft + (DPDrink2.GWidth - d.Width) div 2),
                         DPDrink2.SurfaceY(DPDrink2.GTop + (DPDrink2.GHeight - d.Height) div 2),
                         d.ClientRect, d, TRUE);
        end;
    end;
  end;
end;

procedure TFrmDlg.DPlayDrinkCloseClick(Sender: TObject; X, Y: Integer);
begin
  DPlayDrink.Visible := False;
end;

procedure TFrmDlg.DPlayDrinkFistClick(Sender: TObject; X, Y: Integer);
begin
  if g_boPlayDrink then Exit;
  if g_boNpcAutoSelDrink then Exit;
  if g_btWhoWin = 0 then if not g_boHumWinDrink then Exit; //20080614 玩家赢，是否喝了酒
  g_btPlayDrinkGameNum := TDButton(Sender).Tag;
  DPlayFist.Visible := True;
end;

procedure TFrmDlg.DPlayDrinkNpcNumDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DPlayDrinkNpcNum do begin
    d := g_WMain2Images.Images[366 + g_btNpcNum];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DPlayDrinkPlayNumDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DPlayDrinkPlayNum do begin
    d := g_WMain2Images.Images[345 + g_btPlayNum];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DPlayDrinkWhoWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DPlayDrinkWhoWin do begin
    d := g_WMain2Images.Images[334 + g_btWhoWin];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
  end;
end;

//是否显示斗酒一些图
procedure TFrmDlg.ShowPlayDrinkImg(Show: Boolean);
begin
    DPlayDrinkWhoWin.Visible := Show;
    DPlayDrinkNpcNum.Visible := Show;
    DPlayDrinkPlayNum.Visible := Show;
end;

procedure TFrmDlg.DPlayDrinkFistDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
 //这个过程不能删除  让斗酒的按钮为空显示
end;

procedure TFrmDlg.DDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  if g_boPlayDrink then Exit;
  if g_boNpcAutoSelDrink then Exit;
  TDButton(Sender).ShowHint := True;
end;

procedure TFrmDlg.DPlayDrinkMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DDrink1.ShowHint := False;
  DDrink2.ShowHint := False;
  DDrink3.ShowHint := False;
  DDrink4.ShowHint := False;
  DDrink5.ShowHint := False;
  DDrink6.ShowHint := False;
end;

procedure TFrmDlg.DDrink1Click(Sender: TObject; X, Y: Integer);
begin
  if g_boPlayDrink then Exit;
  if g_boNpcAutoSelDrink then Exit;
  if not g_boPermitSelDrink then Exit;
  g_btPlaySelDrink := TDButton(Sender).Tag;  //玩家选的酒
  FrmMain.ClientGetPlayDrinkSay(g_nCurMerchant,2,'这坛酒给谁喝好呢？  <对方/@@@对方> <自己/@@@自己>');
end;

procedure TFrmDlg.DPDrink1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
   butt: TDButton;
   sel: Integer;
begin
   butt := TDButton(Sender);
   if not g_boItemMoving then begin
      if g_PDrinkItem[butt.Tag].S.Name <> '' then begin
         ItemClickSound (g_PDrinkItem[butt.Tag].s);
         if (g_MovingItem.Item.S.Name <> '') or (g_WaitingItemUp.Item.S.Name <> '') then exit;
         sel := -1;
         if Sender = DPDrink1 then sel := 0;
         if Sender = DPDrink2 then sel := 1;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(sel + 45);
         g_MovingItem.Item := g_PDrinkItem[butt.Tag];
         g_PDrinkItem[butt.Tag].S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -45) or (g_MovingItem.Index = -46) then begin
         if (g_MovingItem.Item.S.StdMode = 60) and (g_MovingItem.Item.S.Shape = 0) then begin  //是烧酒
           ItemClickSound (g_MovingItem.Item.S);
           if g_PDrinkItem[butt.Tag].S.Name <> '' then begin
              temp := g_PDrinkItem[butt.Tag];
              g_PDrinkItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(sel + 45);
              g_MovingItem.Item := temp
           end else begin
              g_PDrinkItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.S.name := '';
              g_boItemMoving := FALSE;
           end;
         end;
      end;
   end;
end;

procedure TFrmDlg.DPDrink1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  TDButton(Sender).ShowHint := True;
end;

procedure TFrmDlg.DWPleaseDrinkMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DPDrink1.ShowHint := False;
  DPDrink2.ShowHint := False;
end;

procedure TFrmDlg.DPleaseDrinkExitClick(Sender: TObject; X, Y: Integer);
begin
  DWPleaseDrink.Visible := False;
  if g_PDrinkItem[0].S.Name <> '' then begin
    AddItemBag(g_PDrinkItem[0]);
    g_PDrinkItem[0].S.Name := '';
  end;
  if g_PDrinkItem[1].S.Name <> '' then begin
    AddItemBag(g_PDrinkItem[1]);
    g_PDrinkItem[1].S.Name := '';
  end;
end;

procedure TFrmDlg.DPleaseDrinkDrinkClick(Sender: TObject; X, Y: Integer);
begin
  if g_PDrinkItem[0].S.Name = '' then begin
     FrmMain.ClientGetPlayDrinkSay(g_nCurMerchant,1,'年轻人，你不是请我喝酒吗？我的酒呢？');
     Exit;
  end;
  if g_PDrinkItem[1].S.Name = '' then begin
     FrmMain.ClientGetPlayDrinkSay(g_nCurMerchant,1,'年轻人，你请我喝酒，怎么自己不喝呢？');
     Exit;
  end;
  FrmMain.SendDrinkDrinkOK();
end;

procedure TFrmDlg.DWPFLingPaiInitialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  DWPFLingPai.SetImgIndex(g_WUI1Images, 61);
{$IFEND}
end;

procedure TFrmDlg.DWPleaseDrinkClick(Sender: TObject; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   L := DWPleaseDrink.GLeft;
   T := DWPleaseDrink.GTop;
   with DWPleaseDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            FrmMain.SendPlayDrinkDlgSelect (g_nCurMerchant, p.RStr);
            break;
         end;
      end;
end;

procedure TFrmDlg.DWPleaseDrinkMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   SelectMenuStr := '';
   L := DWPleaseDrink.GLeft;
   T := DWPleaseDrink.GTop;
   with DWPleaseDrink do
      if g_PlayDrinkPoints.Count > 0 then //20080629
      for i:=0 to g_PlayDrinkPoints.Count-1 do begin
         p := PTClickPoint (g_PlayDrinkPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
end;

procedure TFrmDlg.DWPleaseDrinkMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DWQJFurnaceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  str: string;
  rc: TRect;
  r: Real;
  bbx, bby: Integer;
begin
  {$IF M2Version = 1}
  with DWQJFurnace do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d<>nil then 
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

      d := WLib.Images[1310];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+214, SurfaceY(GTop)+60, d.ClientRect, d, TRUE);

      d := WLib.Images[1311];
      if d <> nil then begin
        rc := d.ClientRect;
        if g_dwQJFurnaceExp > 0 then r := g_dwQJFurnaceMaxExp / g_dwQJFurnaceExp
        else r := 0;
        if r > 0 then rc.Right := Round (rc.Right / r)
        else rc.Right := 0;
        dsurface.Draw (SurfaceX(GLeft)+214, SurfaceY(GTop)+60, rc, d, TRUE);
      end;

      if g_boQJFurnaceMove then begin //转动
        if GetTickCount - g_dwQJFurnaceTick > 100 then begin
          g_dwQJFurnaceTick := GetTickCount();
          Inc(g_btQJFurnacePosition);
          if g_btQJFurnacePosition > 7 then begin
            g_btQJFurnacePosition := 0;
            if g_btQJFurnaceTarget >= 7 then Dec(g_btQJFurnaceTarget, 7);
          end;
          if g_btQJFurnacePosition = g_btQJFurnaceTarget then begin
            g_boQJFurnaceMove := False;
            DBQJFurnaceStart.Visible := True;
          end;
        end;
      end;

      d := WLib.Images[1299];
      if d <> nil then begin
        case g_btQJFurnacePosition of
          0: begin
            bbx := 26;
            bby := 57;
          end;
          1: begin
            bbx := 26;
            bby := 96;
          end;
          2: begin
            bbx := 57;
            bby := 122;
          end;
          3: begin
            bbx := 95;
            bby := 122;
          end;
          4: begin
            bbx := 126;
            bby := 96;
          end;
          5: begin
            bbx := 126;
            bby := 57;
          end;
          6: begin
            bbx := 95;
            bby := 30;
          end;
          7: begin
            bbx := 57;
            bby := 30;
          end;
        end;
        dsurface.Draw (SurfaceX(GLeft)+bbx, SurfaceY(GTop)+bby, d.ClientRect, d, TRUE);
      end;
      


      dsurface.BoldTextOut(SurfaceX(GLeft)+280, SurfaceY(GTop)+76, $008CC7EF, clBlack, Format('%d/%d', [g_dwQJFurnaceExp, g_dwQJFurnaceMaxExp]));
      if g_btQJFurnaceType = 1 then begin
        str := ForMat('每次至少需要消耗%d%s和%d%s', [g_dwQJFurnaceLingfu, g_sGameGird, g_dwQJFurnaceGold, g_sGoldName]);
      end else begin
        str := ForMat('每次炼气需要消耗%d%s', [g_dwQJFurnaceGold, g_sGoldName]);
      end;
      dsurface.BoldTextOut(SurfaceX(GLeft)+254 - frmMain.Canvas.TextWidth(str) div 2, SurfaceY(GTop)+140, clYellow, clBlack, str);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWQJFurnaceInitialize(Sender: TObject);
begin
  {$IF M2Version = 1}
  DWQJFurnace.SetImgIndex(g_WMainImages, 1290);
  {$IFEND}
end;

procedure TFrmDlg.DWQJPracticeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  OldFontStyle: TFontStyles;
  I: Integer;
  pm: PTClientMagic;
  boOpen95: Boolean;
begin
{$IF M2Version = 1}
  with DWQJPractice do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      d := g_WMainImages.Images[112];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+118, SurfaceY(GTop) + 183, d.ClientRect, d, TRUE);

      if m_boQJPracticeHero then begin
        if g_HeroSelf <> nil then begin
          boOpen95 := g_boQJHeroDZXY99;
          for I:=0 to g_HeroMagicList.Count-1 do begin
            pm := PTClientMagic (g_HeroMagicList[I]);
            if pm <> nil then begin
              if pm.Def.wMagicId = 95 then begin //斗转星移
                m_btQjPracticeSkillLevel := pm.Level;
                m_dwQjPracticeCurTrain := pm.CurTrain;
                m_dwQJpracticeMaxTrain := pm.Def.MaxTrain[0];
                Break;
              end;
            end;
          end;
          if not g_boQJHeroDZXY99 and (m_btQjPracticeSkillLevel = 64) then begin
            OldFontStyle := MainForm.Canvas.Font.Style;
            MainForm.Canvas.Font.Style := [fsBold];
            dsurface.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+164, clWhite, '斗转');
            dsurface.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+178, clWhite, '灵丹');
            MainForm.Canvas.Font.Style := OldFontStyle;
          end;
        end;
      end else begin
        if g_MySelf <> nil then begin
          boOpen95 := g_boQJDZXY99;
          for I:=0 to g_MagicList.Count-1 do begin
            pm := PTClientMagic (g_MagicList[I]);
            if pm <> nil then begin
              if pm.Def.wMagicId = 95 then begin //斗转星移
                m_btQjPracticeSkillLevel := pm.Level;
                m_dwQjPracticeCurTrain := pm.CurTrain;
                m_dwQJpracticeMaxTrain := pm.Def.MaxTrain[0];
                Break;
              end;
            end;
          end;
          if not g_boQJDZXY99 and (m_btQjPracticeSkillLevel = 64) then begin
            OldFontStyle := MainForm.Canvas.Font.Style;
            MainForm.Canvas.Font.Style := [fsBold];
            dsurface.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+164, clWhite, '斗转');
            dsurface.TextOut(SurfaceX(GLeft)+195, SurfaceY(GTop)+178, clWhite, '灵丹');
            MainForm.Canvas.Font.Style := OldFontStyle;
          end;
        end;
      end;
      OldFontStyle := MainForm.Canvas.Font.Style;
      MainForm.Canvas.Font.Style := [fsBold];
      dsurface.BoldTextOut(SurfaceX(GLeft)+128 - frmMain.Canvas.TextWidth(m_sQJPracticeObjectName) div 2, SurfaceY(GTop)+47, $00ADD7EF, clBlack, m_sQJPracticeObjectName);
      dsurface.BoldTextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+84, $00ADD7EF, clBlack, '神冲穴');
      
      dsurface.BoldTextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+100, $00ADD7EF, clBlack, IntToStr(m_btQjPracticeSkillLevel));


      if (m_btQjPracticeSkillLevel < 64) or ((m_btQjPracticeSkillLevel < 99) and boOpen95 ) then
        dsurface.BoldTextOut(SurfaceX(GLeft)+105, SurfaceY(GTop)+131, $00ADD7EF, clBlack, ForMat('%d/%d', [m_dwQjPracticeCurTrain, m_dwQJpracticeMaxTrain]))
      else dsurface.BoldTextOut(SurfaceX(GLeft)+105, SurfaceY(GTop)+131, $00ADD7EF, clBlack, '-/-');

      dsurface.BoldTextOut(SurfaceX(GLeft)+114, SurfaceY(GTop)+166, $00ADD7EF, clBlack, '斗转星移');
      dsurface.BoldTextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+182, $00ADD7EF, clBlack, IntToStr(m_btQjPracticeSkillLevel));
      MainForm.Canvas.Font.Style := OldFontStyle;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWQJPracticeInitialize(Sender: TObject);
begin
  DWQJPractice.SetImgIndex(g_WMainImages, 1177);
end;

procedure TFrmDlg.DLOGODirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if GetTickCount - g_dwLogoTick > 1000 then begin
    g_dwLogoTick := GetTickCount;
    Inc(g_nLogoTimer);
    if g_nLogoTimer > 5 then begin
      DLOGOClick( DLOGO, 0, 0);
      Exit;
    end;
  end;
  {$IF GVersion <> 1}
  d:=FrmMain.UiDXImageList.Items.Find('LOGO').PatternSurfaces[0];
  {$ELSE}
  d:=FrmMain.UiDXImageList.Items.Find('LOGO1').PatternSurfaces[0];
  {$IFEND}
  if d<>nil then begin
  dsurface.FillRect(rect(0,  //左边      填充白色背景
                    0,      //上边
                    800,   //右边
                    600),GetRGB(255));//下边
  dsurface.Draw ((800 - d.Width) div 2, (600 - d.Height) div 2, d.ClientRect, d, TRUE);
  end;
end;

procedure TFrmDlg.DLQJPracticeLink1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  with Sender as TDLabel do begin
    if m_boQJPracticeHero then
      FrmMain.SendQJAutoPractice(Tag, 1)
    else FrmMain.SendQJAutoPractice(Tag, 0);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLQJPracticeLink3Click(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version = 1}
  msg := MakeDefaultMsg (aa(CM_CLOSEGAMEGIRDUPSKILL95, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg));
{$IFEND}
end;

procedure TFrmDlg.DLQJPracticeLink4Click(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version = 1}
  if m_boQJPracticeHero then begin
    msg := MakeDefaultMsg (aa(CM_QUERYGAMEGIRDUPSKILL95, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
  end else begin
    msg := MakeDefaultMsg (aa(CM_QUERYGAMEGIRDUPSKILL95, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  end;
  frmMain.SendSocket (EncodeMessage (msg));
{$IFEND}
end;

procedure TFrmDlg.DLOGOClick(Sender: TObject; X, Y: Integer);
begin
  if not g_boLOGINKEYOk or (g_dwSocketConnectTick = 0) or (g_dwSocketConnectTick - GetTickCount < 1500) then Exit;//防止过快点击导致连不上
  
  DLOGO.Visible := False;
  FrmMain.UiDXImageList.Items[34].Picture.Assign(nil);
  //{$IF GVersion <> 2}
  frmMain.SendConn;//通知账号程序发来服务区信息 20090310
  //{$IFEND}
  PlayBGM (bmg_intro);
end;

procedure TFrmDlg.DFriendDlgFrdDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   b: TDButton;
   d: TDirectDrawSurface;
begin
   b := nil;
   case g_btFriendTypePage of
      1: b := DFriendDlgFrd;
      2: b := DFriendDlgTanget;
      3: b := DHeiMingDan;
   end;
   if b = Sender then begin
      with b do begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
   end;
end;

procedure TFrmDlg.DFriendDlgFrdClick(Sender: TObject; X, Y: Integer);
begin
  g_btFriendTypePage := TDButton(Sender).Tag;
  DFriendList.Visible := True;
  DAddFriend.Visible := True;
  DDelFriend.Visible := True;
  DPrevFriendDlg.Visible := True;
  DNextFriendDlg.Visible := True;
  g_btFriendPage := 0;
end;

procedure TFrmDlg.DFriendDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d:TDirectDrawSurface;
begin
  with DFriendDlg do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DFriendListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  msgtop, msgline, I,M: Integer;
begin
  with DFriendList do begin
    with dsurface.Canvas do begin
      Font.Color := clWhite;
      case g_btFriendTypePage of
        1: begin
          msgtop := g_btFriendPage * 10;
          msgline := _MIN(g_btFriendPage * 10 + 10, g_FriendList.Count);
          for I:= msgtop to msgline-1 do begin
            m := I - msgtop;
            if I = g_btFriendIndex then Font.Color := clRed
            else Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop) + M*17, Font.Color, g_FriendList.Strings[I]);
          end;
        end;
        2: begin
          msgtop := g_btFriendPage * 10;
          msgline := _MIN(g_btFriendPage * 10 + 10, g_TargetList.Count);
          for I:= msgtop to msgline-1 do begin
            m := I - msgtop;
            if I = g_btFriendIndex then Font.Color := clRed
            else Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop) + M*17, Font.Color, g_TargetList.Strings[I]);
          end;
        end;
        3: begin
          msgtop := g_btFriendPage * 10;
          msgline := _MIN(g_btFriendPage * 10 + 10, g_HeiMingDanList.Count);
          for I:= msgtop to msgline-1 do begin
            m := I - msgtop;
            if I = g_btFriendIndex then Font.Color := clRed
            else Font.Color := clWhite;
            dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop) + M*17, Font.Color, g_HeiMingDanList.Strings[I]);
          end;
        end;
      end;
      Release;
    end;
  end;
end;

procedure TFrmDlg.DFriendListDblClick(Sender: TObject);
var
  lx,ly, idx, msgtop: Integer;
begin
  lx := g_btFriendMoveX - DFriendList.GLeft;
  ly := g_btFriendMoveY - DFriendList.GTop;
  case g_btFriendTypePage of
    1: begin
      if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
        idx := ly div 17;
        if idx < g_FriendList.Count then begin
          msgtop := g_btFriendPage * 10;
          g_btFriendIndex := idx + msgtop;
          if g_FriendList.Strings[g_btFriendIndex] <> '' then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.Text := '/'+ g_FriendList.Strings[g_btFriendIndex]+' ';
            PlayScene.EdChat.SetFocus;
            SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
      end;
    end;
    2: begin
      if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
        idx := ly div 17;
        if idx < g_TargetList.Count then begin
          msgtop := g_btFriendPage * 10;
          g_btFriendIndex := idx + msgtop;
          if g_TargetList.Strings[g_btFriendIndex] <> '' then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.Text := '/'+ g_TargetList.Strings[g_btFriendIndex]+' ';
            PlayScene.EdChat.SetFocus;
            SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
      end;
    end;
    3: begin
      if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
        idx := ly div 17;
        if idx < g_HeiMingDanList.Count then begin
          msgtop := g_btFriendPage * 10;
          g_btFriendIndex := idx + msgtop;
          if g_HeiMingDanList.Strings[g_btFriendIndex] <> '' then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.Text := '/'+ g_HeiMingDanList.Strings[g_btFriendIndex]+' ';
            PlayScene.EdChat.SetFocus;
            SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
            PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DFriendListMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  lx,ly, idx, msgtop: Integer;
begin
  g_btFriendMoveX := x;
  g_btFriendMoveY := Y;
   lx := X - DFriendList.GLeft;
   ly := Y - DFriendList.GTop;
   case g_btFriendTypePage of
     1: begin
        if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
          idx := ly div 17;
          if idx < g_FriendList.Count then begin
            msgtop := g_btFriendPage * 10;
            g_btFriendIndex := idx + msgtop;
          end;
        end;
     end;
     2: begin
        if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
          idx := ly div 17;
          if idx < g_TargetList.Count then begin
            msgtop := g_btFriendPage * 10;
            g_btFriendIndex := idx + msgtop;
          end;
        end;
     end;
     3: begin
        if (lx >= 0) and (lx <= DFriendList.GWidth) and (ly >= 0) and (ly <= 330) then begin
          idx := ly div 17;
          if idx < g_HeiMingDanList.Count then begin
            msgtop := g_btFriendPage * 10;
            g_btFriendIndex := idx + msgtop;
          end;
        end;
     end;
   end;
end;

procedure TFrmDlg.DPrevFriendDlgClick(Sender: TObject; X, Y: Integer);
begin      
  if Sender = DPrevFriendDlg then begin
      if g_btFriendPage > 0 then
         Dec (g_btFriendPage);
  end else begin
     {if g_btFriendTypePage = 1 then begin
       if g_btFriendPage < (g_FriendList.Count+9) div 10 - 1 then
          Inc (g_btFriendPage);
     end;
     if g_btFriendTypePage = 3 then begin
       if g_btFriendPage < (g_HeiMingDanList.Count+9) div 10 - 1 then
          Inc (g_btFriendPage);
     end; }
    case g_btFriendTypePage of
      1: if g_btFriendPage < (g_FriendList.Count+9) div 10 - 1 then Inc (g_btFriendPage);
      2: if g_btFriendPage < (g_TargetList.Count+9) div 10 - 1 then Inc (g_btFriendPage);
      3: if g_btFriendPage < (g_HeiMingDanList.Count+9) div 10 - 1 then Inc (g_btFriendPage);
    end;
  end;
end;

procedure TFrmDlg.DAddFriendClick(Sender: TObject; X, Y: Integer);
  function GetPageCount(List: TStringList): Integer;
  begin
    Result := List.Count div 10;
    if List.Count mod 10 > 0 then Inc(Result);
  end;
var
  int: Integer;
begin
  {if g_btFriendTypePage = 1 then begin
    int := 0;
    DMessageDlg ('添加新的好友', [mbOk, mbAbort]);
    if DlgEditText = '' then Exit;
    if length(DlgEditText) > 14 then int := 3;
    if int = 0 then begin
        g_FriendList.Add(DlgEditText);
        g_btFriendPage := GetPageCount(g_FriendList) - 1;
    end else DMessageDlg ('人物名必须小于15位', [mbOk]);
  end else begin
    int := 0;
    DMessageDlg ('添加新的黑名单', [mbOk, mbAbort]);
    if DlgEditText = '' then Exit;
    if length(DlgEditText) > 14 then int := 3;
    if int = 0 then begin
        g_HeiMingDanList.Add(DlgEditText);
        g_btFriendPage := GetPageCount(g_HeiMingDanList) - 1;
    end else DMessageDlg ('人物名必须小于15位', [mbOk]);
  end;   }
  int := 0;
  case g_btFriendTypePage of
    1: begin
      DMessageDlg ('添加新的好友', [mbOk, mbAbort]);
      if DlgEditText = '' then Exit;
      if length(DlgEditText) > 14 then int := 3;
      if int = 0 then begin
          g_FriendList.Add(DlgEditText);
          g_btFriendPage := GetPageCount(g_FriendList) - 1;
      end else DMessageDlg ('人物名必须小于15位', [mbOk]);
    end;
    2: begin
      DMessageDlg ('添加新的目标名单（使用Ctrl + R快速标示目标）', [mbOk, mbAbort]);
      if DlgEditText = '' then Exit;
      if length(DlgEditText) > 14 then int := 3;
      if int = 0 then begin
          g_TargetList.Add(DlgEditText);
          g_btFriendPage := GetPageCount(g_TargetList) - 1;
      end else DMessageDlg ('人物名必须小于15位', [mbOk]);
    end;
    3: begin
      DMessageDlg ('添加新的黑名单', [mbOk, mbAbort]);
      if DlgEditText = '' then Exit;
      if length(DlgEditText) > 14 then int := 3;
      if int = 0 then begin
          g_HeiMingDanList.Add(DlgEditText);
          g_btFriendPage := GetPageCount(g_HeiMingDanList) - 1;
      end else DMessageDlg ('人物名必须小于15位', [mbOk]);
    end;
  end;
end;

procedure TFrmDlg.DDelFriendClick(Sender: TObject; X, Y: Integer);
var
  sUserName: string;
begin
  case g_btFriendTypePage of
    1: begin
      if g_FriendList.Count > 0 then begin
        if g_btFriendIndex < g_FriendList.Count then begin
          sUserName := g_FriendList.Strings[g_btFriendIndex];
          if mrOk = FrmDlg.DMessageDlg ('你确认删除 [ ' + sUserName+' ] 吗？', [mbOk, mbCancel]) then begin
            g_FriendList.Delete(g_btFriendIndex)
          end;
        end;
      end;
    end;
    2: begin
      if g_TargetList.Count > 0 then begin
        if g_btFriendIndex < g_TargetList.Count then begin
          sUserName := g_TargetList.Strings[g_btFriendIndex];
          if mrOk = FrmDlg.DMessageDlg ('你确认删除 [ ' + sUserName+' ] 吗？', [mbOk, mbCancel]) then begin
            g_TargetList.Delete(g_btFriendIndex)
          end;
        end;
      end;
    end;
    3: begin
      if g_HeiMingDanList.Count > 0 then begin
        if g_btFriendIndex < g_HeiMingDanList.Count then begin
          sUserName := g_HeiMingDanList.Strings[g_btFriendIndex];
          if mrOk = FrmDlg.DMessageDlg ('你确认删除 [ ' + sUserName+' ] 吗？', [mbOk, mbCancel]) then begin
            g_HeiMingDanList.Delete(g_btFriendIndex)
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBInternetClick(Sender: TObject; X, Y: Integer);
begin
  if g_sGameESystem <> '' then frmBrowser.Open(g_sGameESystem);
  //frmBrowser.Open('http://www.igem2.com:8081');
end;

procedure TFrmDlg.DStMagHero1Click(Sender: TObject; X, Y: Integer);
var
   idx: integer;
   keych: char;
   pm: PTClientMagic;
begin
  if (HeroStatePage = 3) or (HeroInternalForcePage = 1) then begin
    if HeroStateTab = 0 then begin
      idx := TDButton(Sender).Tag + HeroMagTop;
      if (idx >= 0) and (idx < g_HeroMagicList.Count) then begin
      	pm := PTClientMagic (g_HeroMagicList[idx]);
        if pm.Def.wMagicId <> 99 then begin
          if not (pm.Def.wMagicId in [3,4,60..65,67,88,95]) then begin
            if word(pm.Key) = 0 then
              keych := char(word(1))
            else keych := char(word(0));
            pm.Key := keych;
            FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych,'');
          end;
        {$IF M2Version <> 2}
        end else begin
          SetHeroSkillMemoDlg(pm.Def.wMagicId, pm.Def.btEffect, pm.Def.sMagicName, '强身术修炼');
        {$IFEND}
        end;
      end;
    end else begin
      idx := TDButton(Sender).Tag + HeroMagTop;
      if (idx >= 0) and (idx < g_HeroInternalForceMagicList.Count) then begin
        pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        if word(pm.Key) = 0 then
          keych := char(word(1))
        else keych := char(word(0));
        pm.Key := keych;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych, '');
      end;
    end;
  end;
end;

procedure TFrmDlg.DWCheckNumDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with DWCheckNum do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];  //字体变粗体
      dsurface.BoldTextOut (GLeft + 14, GTop + 14, $0040BBF1, clBlack, '图片验证码:');
      frmMain.Canvas.Font.Style := [];  //字体去掉粗体
    d := FrmMain.UiDXImageList.Items.Find('CheckNum').PatternSurfaces[0];
    if d <> nil then begin
       dsurface.Draw (SurfaceX(GLeft)+60, SurfaceY(GTop)+50, d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DCheckNumOKDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if not TDButton(Sender).Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft) + 27 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $008CC6EF, clBlack, TDButton(Sender).Hint);
          frmMain.Canvas.Font.Style := [];
      end else begin
        if WLib <> nil then begin //20080701
          d := WLib.Images[FaceIndex + 1];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
        dsurface.BoldTextOut (SurfaceX(GLeft) + 29 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 6, $0040BBF1, clBlack, TDButton(Sender).Hint);
        frmMain.Canvas.Font.Style := [];
      end;
   end;
end;

procedure TFrmDlg.DCheckNumOKClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendCheckNum(DEditCheckNum.Text);
//g_boIsChangeCheckNum:= True;

end;

procedure TFrmDlg.DEditCheckNumKeyPress(Sender: TObject; var Key: Char);
begin
  if not (Key in ['0'..'9','a'..'z','A'..'Z', #8, #13]) then
    Key := #0;
end;

procedure TFrmDlg.DEditCheckNumKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = 13 then DCheckNumOKClick(DCheckNumOK ,0 , 0);
end;

procedure TFrmDlg.DCheckNumChangeClick(Sender: TObject; X, Y: Integer);
begin
  FrmMain.SendChangeCheckNum();
end;

procedure TFrmDlg.DWMakeWineDeskDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DWMakeWineDesk do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;


      d := g_WMain2Images.Images[586];   //上面图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop + 9), d.ClientRect, d, TRUE);
      if g_MakeTypeWine = 0 then begin  //普通酒
        if g_WineItem[0].S.Name <> '' then begin
          d := g_WMain2Images.Images[598];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 235), SurfaceY(GTop + 124), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[1].S.Name <> '' then begin
          d := g_WMain2Images.Images[596];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 121), SurfaceY(GTop + 109), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[2].S.Name <> '' then begin
          d := g_WMain2Images.Images[597];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 155), SurfaceY(GTop + 167), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[4].S.Name <> '' then begin
          d := g_WMain2Images.Images[599];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 288), SurfaceY(GTop + 119), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[5].S.Name <> '' then begin
          d := g_WMain2Images.Images[600];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 330), SurfaceY(GTop + 137), d.ClientRect, d, TRUE);
        end;
        if g_WineItem[6].S.Name <> '' then begin
          d := g_WMain2Images.Images[601];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 294), SurfaceY(GTop + 147), d.ClientRect, d, TRUE);
        end;
    end else begin  //药酒
        if g_DrugWineItem[0].S.Name <> '' then begin
          d := g_WMain2Images.Images[603];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 244), SurfaceY(GTop + 107), d.ClientRect, d, TRUE);
        end;
        if g_DrugWineItem[1].S.Name <> '' then begin
          d := g_WMain2Images.Images[602];   //图中酒的配置图
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 158), SurfaceY(GTop + 132), d.ClientRect, d, TRUE);
        end;
    end;

    if g_sNpcName <> '' then begin  //画NPC名字
         dsurface.TextOut (GLeft + 50 - FrmMain.Canvas.TextWidth(g_sNpcName) div 2, GTop + 110, clWhite, g_sNpcName);
    end;

    if DMaterialMemo.ShowHint then begin
         d := g_WMain2Images.Images[589];   //材料说明
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + 102), SurfaceY(GTop + 13), d.ClientRect, d, True);
     if g_MakeTypeWine = 0 then begin    //普通酒
          dsurface.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 20), clWhite, clBlack, '材料的品质是酒品质的基础，品质越好，才越');
          dsurface.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 34), clWhite, clBlack, '有可能酿出好酒。还有，如果你有比我这里清');
          dsurface.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 48), clWhite, clBlack, '水更甘甜的水，那用它来酿酒就更好了。');
      end else begin   //药酒
          dsurface.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 20), clWhite, clBlack, '药酒的功效主要源自药材，不同的药材会有不');
          dsurface.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 34), clWhite, clBlack, '同的效果。据说还有一些独特的药酒，可能会');
          dsurface.BoldTextOut (SurfaceX(GLeft + 107), SurfaceY(GTop + 48), clWhite, clBlack, '对配置药酒的瓶子另有要求。');
      end;
    end;

    if g_MakeTypeWine = 0 then begin    //普通酒
      d := g_WMain2Images.Images[585];   //下面图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 98), SurfaceY(GTop + 200), d.ClientRect, d, TRUE);
    end else begin //药酒
      d := g_WMain2Images.Images[587];   //下面图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 98), SurfaceY(GTop + 200), d.ClientRect, d, TRUE);
    end;


    if DMakeWineHelp.ShowHint then begin  //如何酿酒
      if g_MakeTypeWine = 0 then begin    //普通酒
        d := g_WMain2Images.Images[592];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop - 2), d.ClientRect, d, TRUE);
      end else begin  //药酒
        d := g_WMain2Images.Images[593];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop - 2), d.ClientRect, d, TRUE);
      end;
    end;
    if DStartMakeWine.ShowHint then begin
      d := g_WMain2Images.Images[588];   //正在酿酒的背景图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 100), SurfaceY(GTop + 9), d.ClientRect, d, TRUE);
      if GetTickCount - g_dwShowStartMakeWineTick > 150 then begin
        g_dwShowStartMakeWineTick := GetTickCount;
        inc(g_nShowStartMakeWineImg);
        if g_nShowStartMakeWineImg > 18 then begin
          DStartMakeWine.ShowHint := False;
          FrmMain.SendMakeWineItems;
        end;
      end;
      d := g_WMain2Images.Images[610+g_nShowStartMakeWineImg];   //正在酿酒的背景图
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft + 165), SurfaceY(GTop + 9), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DMakeWineHelpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if DStartMakeWine.ShowHint then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft + 35 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2), SurfaceY(GTop) + 4, $0099A8AC, clBlack, TDButton(Sender).Hint);
          frmMain.Canvas.Font.Style := [];
        Exit;
      end;

      if not TDButton(Sender).Downed then begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft + 35 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2), SurfaceY(GTop) + 4, $008CC6EF, clBlack, TDButton(Sender).Hint);
          frmMain.Canvas.Font.Style := [];
      end else begin
        if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex + 1];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft + 37 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2), SurfaceY(GTop) + 5, $0040BBF1, clBlack, TDButton(Sender).Hint);
          frmMain.Canvas.Font.Style := [];
      end;
   end;
end;

procedure TFrmDlg.DMakeWineDeskCloseClick(Sender: TObject; X, Y: Integer);
var
 I: Integer;
begin
  if DStartMakeWine.ShowHint then Exit;
  DWMakeWineDesk.Visible := False;
  DItemBag.Visible := False;
  if g_MakeTypeWine = 0 then begin //普通酒
    for I:=Low(g_WineItem) to High(g_WineItem) do begin
      if g_WineItem[I].S.Name <> '' then begin
        AddItemBag(g_WineItem[I]);
        g_WineItem[I].S.Name := '';
      end;
    end;
  end else begin
    for I:=Low(g_DrugWineItem) to High(g_DrugWineItem) do begin
      if g_DrugWineItem[I].S.Name <> '' then begin  //药酒
        AddItemBag(g_DrugWineItem[I]);
        g_DrugWineItem[I].S.Name := '';
      end;
    end;
  end;
end;

procedure TFrmDlg.DMakeWineHelpClick(Sender: TObject; X, Y: Integer);
begin
  if DStartMakeWine.ShowHint then Exit;
  ShowMakeWine(False); //隐藏下面BUTTON
  DMakeWineHelp.ShowHint := True;   //按下此按钮
end;

procedure TFrmDlg.DMaterialMemoClick(Sender: TObject; X, Y: Integer);
begin
  if DStartMakeWine.ShowHint then Exit;
  ShowMakeWine(True); //显示下面BUTTON
  DMakeWineHelp.ShowHint := False;   //去掉如何酿久按下为FALSE
  DMaterialMemo.ShowHint := True;    //按下此按钮
end;

procedure TFrmDlg.DBMateriaMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  Butt:TDButton;
begin
   Butt:=TDButton(Sender);
   DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop - 18), Butt.Hint, clWhite, FALSE);
   g_MouseItem := g_WineItem[Butt.Tag];
end;

procedure TFrmDlg.DWMakeWineDeskMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
  g_MouseItem.S.Name := '';
end;

procedure TFrmDlg.ShowMakeWine(bool:Boolean);
begin
    DBMateria.Visible := False;
    DBWineSong.Visible := False;
    DBWater.Visible := False;
    DBWineCrock.Visible := False;
    DBAssistMaterial1.Visible := False;
    DBAssistMaterial2.Visible := False;
    DBAssistMaterial3.Visible := False;
    DBDrug.Visible := False;
    DBWine.Visible := False;
    DBWineBottle.Visible := False;
  if g_MakeTypeWine = 0 then begin //普通酒
    DBMateria.Visible := bool;
    DBWineSong.Visible := bool;
    DBWater.Visible := bool;
    DBWineCrock.Visible := bool;
    DBAssistMaterial1.Visible := bool;
    DBAssistMaterial2.Visible := bool;
    DBAssistMaterial3.Visible := bool;
  end else begin  //药酒
    DBDrug.Visible := bool;
    DBWine.Visible := bool;
    DBWineBottle.Visible := bool;
  end;
end;

procedure TFrmDlg.DBMateriaClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
   butt: TDButton;
begin
   if DStartMakeWine.ShowHint then Exit;
   butt := TDButton(Sender);
   if not g_boItemMoving then begin
      if g_WineItem[butt.Tag].S.Name <> '' then begin
         ItemClickSound (g_WineItem[butt.Tag].s);
         if (g_MovingItem.Item.S.Name <> '')then exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(butt.Tag + 47);
         g_MovingItem.Item := g_WineItem[butt.Tag];
         g_WineItem[butt.Tag].S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -47) or (g_MovingItem.Index = -48) or (g_MovingItem.Index = -49)
         or (g_MovingItem.Index = -50) or (g_MovingItem.Index = -51) or (g_MovingItem.Index = -52) or (g_MovingItem.Index = -53) then begin
           case butt.Tag of
             0,4..6: if g_MovingItem.Item.S.StdMode <> 8 then Exit;
             1: if g_MovingItem.Item.S.StdMode <> 13 then Exit;
             2: if g_MovingItem.Item.S.StdMode <> 9 then Exit;
             3: if g_MovingItem.Item.S.StdMode <> 12 then Exit;
           end;
           ItemClickSound (g_MovingItem.Item.S);
           if g_WineItem[butt.Tag].S.Name <> '' then begin
              temp := g_WineItem[butt.Tag];
              g_WineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(butt.Tag + 47);
              g_MovingItem.Item := temp
           end else begin
              g_WineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.S.name := '';
              g_boItemMoving := FALSE;
           end;
      end;
   end;
end;

procedure TFrmDlg.DBMateriaDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
  Butt:TDButton;
begin
  Butt:=TDButton(Sender);
  if Sender = DBMateria then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 8) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBWineSong then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 13) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBWater then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 9) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
        end;
      end;
    end;
  end;
  if Sender = DBWineCrock then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 12) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBAssistMaterial1 then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 8) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBAssistMaterial2 then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 8) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBAssistMaterial3 then begin
    with Butt do begin
      if g_WineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_WineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 8) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBDrugDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
  Butt:TDButton;
begin
  if Sender = DBDrug then begin
    Butt:=TDButton(Sender);
    with Butt do begin
      if g_DrugWineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_DrugWineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 14) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBWine then begin
    Butt:=TDButton(Sender);
    with Butt do begin
      if g_DrugWineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_DrugWineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 60) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
  if Sender = DBWineBottle then begin
    Butt:=TDButton(Sender);
    with Butt do begin
      if g_DrugWineItem[Butt.Tag].S.Name <> '' then begin
        idx := g_DrugWineItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_MovingItem.Item.S.StdMode = 12) and g_boItemMoving then begin
          d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBDrugClick(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
   butt: TDButton;
begin
   if DStartMakeWine.ShowHint then Exit;
   butt := TDButton(Sender);
   if not g_boItemMoving then begin
      if g_DrugWineItem[butt.Tag].S.Name <> '' then begin
         ItemClickSound (g_DrugWineItem[butt.Tag].s);
         if (g_MovingItem.Item.S.Name <> '') or (g_WaitingDrugWineItem.Item.S.Name <> '') then exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(butt.Tag + 54);
         g_MovingItem.Item := g_DrugWineItem[butt.Tag];
         g_DrugWineItem[butt.Tag].S.Name := '';
      end;
   end else begin
      if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) or (g_MovingItem.Index = -99) then Exit;  //-97 -98 是金币
      if (g_MovingItem.Index = -45) or (g_MovingItem.Index = -46) then Exit;  //-45 .. -46 是请酒里的烧酒物品
      if (g_MovingItem.Index = -47) or (g_MovingItem.Index = -48) or (g_MovingItem.Index = -49)
         or (g_MovingItem.Index = -50) or (g_MovingItem.Index = -51) or (g_MovingItem.Index = -52) or (g_MovingItem.Index = -53) then Exit; //普通酒物品
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -54) or (g_MovingItem.Index = -55) or (g_MovingItem.Index = -56) then begin
           case butt.Tag of
             0: if g_MovingItem.Item.S.StdMode <> 14 then Exit;
             1: if g_MovingItem.Item.S.StdMode <> 60 then Exit;
             2: if g_MovingItem.Item.S.StdMode <> 12 then Exit;
           end;
           ItemClickSound (g_MovingItem.Item.S);
           if g_DrugWineItem[butt.Tag].S.Name <> '' then begin
              temp := g_DrugWineItem[butt.Tag];
              g_DrugWineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(butt.Tag + 54);
              g_MovingItem.Item := temp
           end else begin
              g_DrugWineItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.S.name := '';
              g_boItemMoving := FALSE;
           end;
      end;
   end;
end;

procedure TFrmDlg.DStartMakeWineClick(Sender: TObject; X, Y: Integer);
begin
  if g_boItemMoving then Exit;
  if DStartMakeWine.ShowHint then Exit;
  if g_MakeTypeWine = 0 then begin //普通酒
     if (g_WineItem[0].S.Name = '') or (g_WineItem[2].S.Name = '') or (g_WineItem[3].S.Name = '')
      or (g_WineItem[4].S.Name = '') or (g_WineItem[5].S.Name = '') or (g_WineItem[6].S.Name = '') then Exit;
  end else begin  //药酒
    if (g_DrugWineItem[0].S.Name = '') or (g_DrugWineItem[1].S.Name = '') or (g_DrugWineItem[2].S.Name = '') then Exit;
  end;
  if DMakeWineHelp.ShowHint then begin
   DMakeWineHelp.ShowHint := False;
   ShowMakeWine(False); //显示下面BUTTON
  end;
  DStartMakeWine.ShowHint := True;
  g_nShowStartMakeWineImg := 0;
end;

procedure TFrmDlg.DDrunkScaleDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc: Trect;
begin
  with DDrunkScale do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[583];
    if d <> nil then begin
       rc := d.ClientRect;
       if (g_MySelf.m_Abil.WineDrinkValue > 0) then begin
       rc.Top := _Max(0,Round(rc.Bottom / g_MySelf.m_Abil.MaxAlcohol * (g_MySelf.m_Abil.MaxAlcohol - g_MySelf.m_Abil.WineDrinkValue)));
       dsurface.Draw (SurfaceX(GLeft) + rc.Left, SurfaceY(GTop)+rc.Top, rc, d, FALSE);
       end;
    end;
  end;     
end;

procedure TFrmDlg.DLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc: Trect;
begin
  with DLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;

      if g_MySelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_MySelf.m_Abil.MaxAlcohol * g_MySelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBDrugMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  Butt:TDButton;
begin
   Butt:=TDButton(Sender);
   DScreen.ShowHint(Butt.SurfaceX(Butt.GLeft), Butt.SurfaceY(Butt.GTop - 18), Butt.Hint, clWhite, FALSE);
   g_MouseItem := g_DrugWineItem[Butt.Tag];
end;

procedure TFrmDlg.DHeroLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc: Trect;
begin
  with DHeroLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;
      if g_HeroSelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_HeroSelf.m_Abil.MaxAlcohol * g_HeroSelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DCheckSdoNameShowDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with Sender as TDCheckBox do begin
    if WLib <> nil then begin
      d := nil;
      if Checked and Enabled then begin
        d := WLib.Images[FaceIndex + 1];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then begin
      	if Enabled then begin
        	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        end else begin
          g_ImgMixSurface.SetSize(d.Width, d.Height);
          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
          DrawEffect(0, 0, g_ImgMixSurface, d, ceGrayScale);
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DCheckSdoNameShowInitialize(Sender: TObject);
begin
  with Sender as TDCheckBox do begin
    SetImgIndex(g_qingqingImages, 7);
  end;
end;

procedure TFrmDlg.DNewSdoBasicDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if Tag <> g_btSdoAssistantPage then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 24 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, clWhite, clBlack, Hint);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop) - 2, d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 24 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 1, clWhite, clBlack, Hint);
    end;
  end;
end;

procedure TFrmDlg.DWNewSdoAssistantDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DWNewSdoAssistant do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    case g_btSdoAssistantPage of
      0: begin //基本
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 49, clSilver, clBlack, '基本功能设置');
          {$IF M2Version <> 2}
          dsurface.BoldTextOut (SurfaceX(GLeft) + 224, SurfaceY(GTop) + 49, clSilver, clBlack, '自动探索');
          {$IFEND}
          frmMain.Canvas.Font.Style := [];
      end;
      1: begin //物品
        with dsurface.Canvas do begin
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft) + 26, SurfaceY(GTop) + 46, clSilver, clBlack, '物品名称');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 128, SurfaceY(GTop) + 46, clSilver, clBlack, '极品提示');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 214, SurfaceY(GTop) + 46, clSilver, clBlack, '自动拾取');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 300, SurfaceY(GTop) + 46, clSilver, clBlack, '显示名字');
          frmMain.Canvas.Font.Style := [];
          Pen.Color := $00808080;    //化边界线
          MoveTo(SurfaceX(GLeft)+26,   SurfaceY(GTop)+63);
          LineTo(SurfaceX(GLeft)+374,  SurfaceY(GTop)+63);
          Release;
        end;
      end;
      2: begin //保护
        with dsurface.Canvas do begin
          {$IF M2Version <> 2}
          d := g_qingqingImages.Images[7];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft)+70, SurfaceY(GTop) + 217, d.ClientRect, d, TRUE);
          {$IFEND}
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          {$IF M2Version <> 2}
          dsurface.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 171, clSilver, clBlack, '英雄保护设置');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 49, clSilver, clBlack, '自动饮酒');
          {$IFEND}
          frmMain.Canvas.Font.Style := [];
          {$IF M2Version <> 2}
          dsurface.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 75, clSilver, clBlack, '普通酒');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 99, clSilver, clBlack, '普通酒(英雄)');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 122, clSilver, clBlack, '药酒');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 39, SurfaceY(GTop) + 148, clSilver, clBlack, '药酒(英雄)');

          dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 75, clSilver, clBlack, '% 醉酒度');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 99, clSilver, clBlack, '% 醉酒度');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 122, clSilver, clBlack, '分钟');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 148, clSilver, clBlack, '分钟');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 69, SurfaceY(GTop) + 195, clSilver, clBlack, '躲闪血量:');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 167, SurfaceY(GTop) + 195, clSilver, clBlack, 'HP');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 91, SurfaceY(GTop) + 219, clSilver, clBlack, '怪物狂化保护');
          pen.Color := $00638494;
          Brush.Color := clBlack;
                   //左                    //上                //右
          Rectangle(SurfaceX(GLeft) + 125,SurfaceY(GTop) + 193,SurfaceX(GLeft) + 165,SurfaceY(GTop) + 212);
          dsurface.TextOut(SurfaceX(GLeft) + 127, SurfaceY(GTop) + 196,clWhite,'0');
          Release;
          {$IFEND}
        end;
      end;
      3: begin //药品

      end;
      4: begin //技能
        with dsurface.Canvas do begin
          frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
          dsurface.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 49, clSilver, clBlack, '战士技能');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 147, SurfaceY(GTop) + 49, clSilver, clBlack, '道士技能');         //
          //dsurface.BoldTextOut (SurfaceX(GLeft) + 29, SurfaceY(GTop) + 171, clSilver, clBlack, '法师技能');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 265, SurfaceY(GTop) + 49, clSilver, clBlack, '法师技能');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 147, SurfaceY(GTop) + 158, clSilver, clBlack, '自动练功');
          {dsurface.BoldTextOut (SurfaceX(GLeft) + 263, SurfaceY(GTop) + 95, clSilver, clBlack,  '打开自动练功后,使用');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 263, SurfaceY(GTop) + 109, clSilver, clBlack, '一次要修炼的技能,该');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 263, SurfaceY(GTop) + 123, clSilver, clBlack, '技能会按照您设定的');
          dsurface.BoldTextOut (SurfaceX(GLeft) + 263, SurfaceY(GTop) + 137, clSilver, clBlack, '间隔时间重复使用.');  }
          frmMain.Canvas.Font.Style := [];
          //dsurface.BoldTextOut (SurfaceX(GLeft) + 375, SurfaceY(GTop) + 76, clSilver, clBlack, '秒');
          //=================================================
          //dsurface.FastFrameRect(Bounds(SurfaceX(GLeft)+130, SurfaceY(GTop)+150, 130, 85),$00638494);
          {pen.Color := ;    //化边界线
          MoveTo(SurfaceX(GLeft)+260,   SurfaceY(GTop)+69);
          LineTo(SurfaceX(GLeft)+390,   SurfaceY(GTop)+69);
          LineTo(SurfaceX(GLeft)+390,   SurfaceY(GTop)+154);
          LineTo(SurfaceX(GLeft)+260,   SurfaceY(GTop)+154);
          LineTo(SurfaceX(GLeft)+260,   SurfaceY(GTop)+69);
          //==================================================
          Release;   }
        end;
      end;
      (*5: begin//按键
        with dsurface.Canvas do begin
          {$IF M2Version = 2}
              frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 65, clSilver, clBlack, '功能描述');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 149, SurfaceY(GTop) + 65, clSilver, clBlack, '默认快捷键');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 279, SurfaceY(GTop) + 65, clSilver, clBlack, '自定义快捷键');
              frmMain.Canvas.Font.Style := [];
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 88, clSilver, clBlack, '切换攻击模式');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 110, clSilver, clBlack, '切换小地图');
              pen.Color := $00808080;    //化边界线
              MoveTo(SurfaceX(GLeft)+26,   SurfaceY(GTop)+82);
              LineTo(SurfaceX(GLeft)+390,   SurfaceY(GTop)+82);
              //画格
              pen.Color := clGray;
              Brush.Color := clBlack;
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+86,SurfaceX(GLeft)+245,SurfaceY(GTop)+105);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+108,SurfaceX(GLeft)+245,SurfaceY(GTop)+127);
              Release;
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 89, clSilver, clBlack, 'Ctrl+H');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 111, clSilver, clBlack, 'Tab');
          {$ELSE}
            {$IF M2Version = 0}
              frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 65, clSilver, clBlack, '功能描述');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 149, SurfaceY(GTop) + 65, clSilver, clBlack, '默认快捷键');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 279, SurfaceY(GTop) + 65, clSilver, clBlack, '自定义快捷键');
              frmMain.Canvas.Font.Style := [];
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 88, clSilver, clBlack, '召唤英雄');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 110, clSilver, clBlack, '英雄攻击目标');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 132, clSilver, clBlack, '使用合击技');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 154, clSilver, clBlack, '切换英雄状态');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 176, clSilver, clBlack, '英雄守护');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 198, clSilver, clBlack, '切换攻击模式');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 220, clSilver, clBlack, '切换小地图');
              pen.Color := $00808080;    //化边界线
              MoveTo(SurfaceX(GLeft)+26,   SurfaceY(GTop)+82);
              LineTo(SurfaceX(GLeft)+390,   SurfaceY(GTop)+82);
              //画格
              pen.Color := clGray;
              Brush.Color := clBlack;
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+86,SurfaceX(GLeft)+245,SurfaceY(GTop)+105);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+108,SurfaceX(GLeft)+245,SurfaceY(GTop)+127);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+130,SurfaceX(GLeft)+245,SurfaceY(GTop)+149);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+152,SurfaceX(GLeft)+245,SurfaceY(GTop)+171);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+174,SurfaceX(GLeft)+245,SurfaceY(GTop)+193);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+196,SurfaceX(GLeft)+245,SurfaceY(GTop)+215);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+218,SurfaceX(GLeft)+245,SurfaceY(GTop)+237);
              Release;
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 111, clSilver, clBlack, 'Ctrl+W');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 133, clSilver, clBlack, 'Ctrl+S');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 155, clSilver, clBlack, 'Ctrl+E');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 177, clSilver, clBlack, 'Ctrl+Q');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 199, clSilver, clBlack, 'Ctrl+H');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 221, clSilver, clBlack, 'Tab');
            {$ELSE}
              frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsBold];
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 54, clSilver, clBlack, '功能描述');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 149, SurfaceY(GTop) + 54, clSilver, clBlack, '默认快捷键');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 279, SurfaceY(GTop) + 54, clSilver, clBlack, '自定义快捷键');
              frmMain.Canvas.Font.Style := [];
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 75, clRed, clBlack, '连击技');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 89+8, clSilver, clBlack, '召唤英雄');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 111+8, clSilver, clBlack, '英雄攻击目标');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 133+8, clSilver, clBlack, '使用合击技');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 155+8, clSilver, clBlack, '切换英雄状态');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 177+8, clSilver, clBlack, '英雄守护');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 199+8, clSilver, clBlack, '切换攻击模式');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 27, SurfaceY(GTop) + 221+8, clSilver, clBlack, '切换小地图');
              pen.Color := $00808080;    //化边界线
              MoveTo(SurfaceX(GLeft)+26,   SurfaceY(GTop)+70);
              LineTo(SurfaceX(GLeft)+390,   SurfaceY(GTop)+70);
              //画格
              pen.Color := clGray;
              Brush.Color := clBlack;
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+64+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+83+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+86+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+105+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+108+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+127+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+130+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+149+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+152+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+171+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+174+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+193+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+196+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+215+9);
              Rectangle(SurfaceX(GLeft)+115,SurfaceY(GTop)+218+9,SurfaceX(GLeft)+245,SurfaceY(GTop)+237+9);
              Release;
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 68+8, clSilver, clBlack, 'Ctrl+D');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 112+8, clSilver, clBlack, 'Ctrl+W');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 134+8, clSilver, clBlack, 'Ctrl+S');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 156+8, clSilver, clBlack, 'Ctrl+E');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 178+8, clSilver, clBlack, 'Ctrl+Q');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 159, SurfaceY(GTop) + 200+8, clSilver, clBlack, 'Ctrl+H');
              dsurface.BoldTextOut (SurfaceX(GLeft) + 169, SurfaceY(GTop) + 222+8, clSilver, clBlack, 'Tab');
            {$IFEND}
          {$IFEND}  
        end;      
      end;       *)
    end;
  end;
end;

procedure TFrmDlg.NewSdoAssistantPageChanged;
begin
  //基本
  DCheckSdoNameShow.Visible := False;
  DCheckSdoDuraWarning.Visible := False;
  DCheckSdoAvoidShift.Visible := False;
  DCheckSdoExpFiltrate.Visible := False;
  DEdtSdoExpFiltrate.Visible := False;
  DCheckSdoMapDesc.Visible := False;
  DCheckMyHp.Visible := False;
  DCheckBoxHideShiti.Visible := False;
  {$IF M2Version <> 2}
  DCheckAutoButch.Visible := False;
  DCheckAutoUseHuolongzhu.Visible := False;
  DCheckAutoUseJingyuandan.Visible := False;
  DCheckScreenShake.Visible := False;
  DCheckShowHeroStateNumber.Visible := False;
  DCheckHeroLevelHint.Visible := False;
  DCheckHideHumanWing.Visible := False;
  DCheckHideWeaponEffect.Visible := False;
  DCheckBoxHideTitle.Visible := False;
  {$IFEND}
  //物品
  DListViewFilterItem.Visible := False;
  DScrollBarFilterItem.Visible := False;
  DCBFilterItemStdMode.Visible := False;
  DEdtFilterItemStdMode.Visible := False;
  DBtnDefaultFilterItem.Visible := False;
  DCheckBFilterItemPickUpAll.Visible := False;
  //保护
  {$IF M2Version <> 2}
  DCheckSdoAutoDrinkWine.Visible := False;
  DEdtSdoDrunkWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkWine.Visible := False;
  DEdtSdoHeroDrunkWineDegree.Visible := False;
  DCheckSdoAutoDrinkDrugWine.Visible := False;
  DEdtSdoDrunkDrugWineDegree.Visible := False;
  DCheckSdoHeroAutoDrinkDrugWine.Visible := False;
  DEdtSdoHeroDrunkDrugWineDegree.Visible := False;
  {$IFEND}
  //药品
  DScrollBoxPro.Visible := False;
  DScrollBarPro.Visible := False;
  //技能
  DCheckSdoLongHit.Visible := False;
  DCheckSdoPosLongHit.Visible := False;
  DCheckSdoAutoWideHit.Visible := False;
  DCheckSdoAutoFireHit.Visible := False;
  DCheckSdoAutoShield.Visible := False;
  {$if M2Version <> 2}
  DCheckSdoZhuri.Visible := False;
  DCheckSdoHeroShield.Visible := False;
  {$IFEND}
  DCheckSdoAutoHide.Visible := False;
  DCheckSdoAutoMagic.Visible := False;
  DEdtSdoAutoMagicTimer.Visible := False;
  {$IF M2Version <> 2}
  DCheckHeroBatterNotMob.Visible := False;
  DCheckShowSpecialDamage.Visible := False;
  DCheckAutoDragInBody.Visible := False;
  {$IFEND}
  //按键页里
  DScrollBoxKey.Visible := False;
  DScrollBarKey.Visible := False;
  (*DCheckSdoStartKey.Visible := False;
  {$IF M2Version <> 2}
  DBtnSdoCallHeroKey.Visible := False;
  DBtnSdoHeroAttackTargetKey.Visible := False;
  DBtnSdoHeroGotethKey.Visible := False;
  DBtnSdoHeroStateKey.Visible := False;
  DBtnSdoHeroGuardKey.Visible := False;
  DBtnSdoSeriesKillKey.Visible := False;
  {$IFEND}
  DBtnSdoAttackModeKey.Visible := False;
  DBtnSdoMinMapKey.Visible := False; *)
  //帮助
  DSdoMemo.Visible := False;
  case g_btSdoAssistantPage of
    0: begin //基本
      DCheckSdoNameShow.Visible := True;
      DCheckSdoDuraWarning.Visible := True;
      DCheckSdoAvoidShift.Visible := True;
      DCheckSdoExpFiltrate.Visible := True;
      DEdtSdoExpFiltrate.Visible := True;
      DCheckSdoMapDesc.Visible := True;
      DCheckMyHp.Visible := True;
      DCheckBoxHideShiti.Visible := True;
      {$IF M2Version <> 2}
      DCheckAutoButch.Visible := True;
      DCheckAutoUseHuolongzhu.Visible := True;
      DCheckAutoUseJingyuandan.Visible := True;
      DCheckScreenShake.Visible := True;
      DCheckShowHeroStateNumber.Visible := True;
      DCheckHeroLevelHint.Visible := True;
      DCheckHideHumanWing.Visible := True;
      DCheckHideWeaponEffect.Visible := True;
      DCheckBoxHideTitle.Visible := True;
      {$IFEND}
    end;
    1: begin //物品
      DListViewFilterItem.Visible := True;
      DScrollBarFilterItem.Visible := True;
      DCBFilterItemStdMode.Visible := True;
      DEdtFilterItemStdMode.Visible := True;
      DBtnDefaultFilterItem.Visible := True;
      DCheckBFilterItemPickUpAll.Visible := True;
    end;
    2: begin //保护
      {$IF M2Version <> 2}
      DCheckSdoAutoDrinkWine.Visible := True;
      DEdtSdoDrunkWineDegree.Visible := True;
      DCheckSdoHeroAutoDrinkWine.Visible := True;
      DEdtSdoHeroDrunkWineDegree.Visible := True;
      DCheckSdoAutoDrinkDrugWine.Visible := True;
      DEdtSdoDrunkDrugWineDegree.Visible := True;
      DCheckSdoHeroAutoDrinkDrugWine.Visible := True;
      DEdtSdoHeroDrunkDrugWineDegree.Visible := True;
      {$IFEND}
    end;
    3: begin //药品
      DScrollBoxPro.Visible := True;
      DScrollBarPro.Visible := True;
    end;
    4: begin //技能
      DCheckSdoLongHit.Visible := True;
      DCheckSdoAutoWideHit.Visible := True;
      DCheckSdoAutoFireHit.Visible := True;
      DCheckSdoPosLongHit.Visible := not g_ClientConf.boNoCanUseComparThrust;
      {$if M2Version <> 2}
      if g_ClientConf.boNoCanUseComparThrust then
      	DCheckSdoZhuri.GTop := DCheckSdoPosLongHit.GTop
    	else DCheckSdoZhuri.GTop := 169;
      DCheckSdoZhuri.Visible := True;
      DCheckSdoHeroShield.Visible := True;
      {$IFEND}
      DCheckSdoAutoShield.Visible := True;
      DCheckSdoAutoHide.Visible := True;
      DCheckSdoAutoMagic.Visible := True;
      DEdtSdoAutoMagicTimer.Visible := True;
      {$IF M2Version <> 2}
      DCheckHeroBatterNotMob.Visible := True;
      {$IFEND}
      {$IF M2Version <> 2}
      DCheckShowSpecialDamage.Visible := True;
      DCheckAutoDragInBody.Visible := True;
      {$IFEND}
    end;
    5: begin//按键
      DScrollBoxKey.Visible := True;
      DScrollBarKey.Visible := True;
    end;
    6: begin//帮助
      DSdoMemo.Visible := True;
    end;
  end;
end;

procedure TFrmDlg.DNewSdoBasicClick(Sender: TObject; X, Y: Integer);
begin
  g_btSdoAssistantPage := TDButton(Sender).Tag;
  NewSdoAssistantPageChanged();
end;

procedure TFrmDlg.DEdtSdoAutoMagicTimerDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  with Sender as TDEdit do begin
    with dsurface.Canvas do begin
        //=================================================
        if Enabled then begin
          if TDEdit(Sender).Moveed then
            pen.Color := $00387B9C    //画边界线
          else pen.Color := $00638494;    //画边界线
          if TDEdit(Sender).Focused then pen.Color := $005993BD;
        end else pen.Color := clGray;
        MoveTo(SurfaceX(GLeft),   SurfaceY(GTop));
        LineTo(SurfaceX(GLeft)+GWidth,   SurfaceY(GTop));
        LineTo(SurfaceX(GLeft)+GWidth,   SurfaceY(GTop)+GHeight);
        LineTo(SurfaceX(GLeft),   SurfaceY(GTop)+GHeight);
        LineTo(SurfaceX(GLeft),   SurfaceY(GTop));
        //==================================================
      Release;
    end;
  end;
end;

procedure TFrmDlg.DNewSdoAssistantCloseClick(Sender: TObject; X,
  Y: Integer);
begin
  FrmMain.OpenSdoAssistant;
end;

procedure TFrmDlg.DBtnSdoCallHeroKeyDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   TextColor: TColor;
begin
  with Sender as TDButton do begin
    if TDButton(Sender).MouseMoveing then begin
      Color := $005993BD;
      TextColor := clYellow;
    end else begin
      Color := $00638494;
      TextColor := clWhite;
    end;
    dsurface.FastFillRect(ClientRect, $00040404);
    if Focused then begin
      Color := $005993BD;
      TextColor := clAqua;
      dsurface.FastFrameRect(Rect(ClientRect.Left+1, ClientRect.Top+1, ClientRect.Right-1, ClientRect.Bottom-1), Color);
    end;
    dsurface.FastFrameRect(ClientRect, Color);
    dsurface.BoldTextOut (SurfaceX(GLeft) + 56-FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 3, TextColor, clBlack, Hint);
  end;
end;

procedure TFrmDlg.DCheckSdoNameShowClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCheckSdoNameShow then begin
    g_boShowName := DCheckSdoNameShow.Checked
  end;

  if Sender = DCheckSdoDuraWarning then begin
    g_boDuraWarning := DCheckSdoDuraWarning.Checked;
  end;
  if Sender = DCheckSdoAvoidShift then begin
    g_boNoShift := DCheckSdoAvoidShift.Checked;
  end;

  if Sender = DCheckBFilterItemPickUpAll then begin
      g_boAutoPuckUpItem := DCheckBFilterItemPickUpAll.Checked;
  end;

  //自动练功DCheckSdoAutoMagic
  if Sender = DCheckSdoAutoMagic then begin
    g_boAutoMagic := DCheckSdoAutoMagic.Checked;
  end;
  //经验显示过滤
  if Sender = DCheckSdoExpFiltrate then begin
    g_boExpFiltrate := DCheckSdoExpFiltrate.Checked;
  end;
  //显示小地图标实
  if Sender = DCheckSdoMapDesc then begin
    g_boShowMimiMapDesc := DCheckSdoMapDesc.Checked;
  end;
  //显示英雄状态数字
  if Sender = DCheckShowHeroStateNumber then begin
    g_boShowHeroStateNumber := DCheckShowHeroStateNumber.Checked;
  end;

  if Sender = DCheckBoxHideShiti then begin
    g_boHideHummanShiTi := DCheckBoxHideShiti.Checked;
  end;
  {$IF M2Version <> 2}
  if Sender = DCheckHideHumanWing then begin
    g_boHideHumanWing := DCheckHideHumanWing.Checked;
  end;
  if Sender = DCheckHideWeaponEffect then begin
    g_boHideWeaponEffect := DCheckHideWeaponEffect.Checked;
  end;

  {$IFEND}
end;

procedure TFrmDlg.DCheckSdoCommonHpClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCheckSdoStartKey then begin
    if not DCheckSdoStartKey.Checked then begin
      with FrmMain do begin
        ActSeriesKillKey.Enabled := False;
        ActCallHeroKey.Enabled := False;
        ActCallHero1Key.Enabled := False;
        ActHeroAttackTargetKey.Enabled := False;
        ActHeroGotethKey.Enabled := False;
        ActHeroStateKey.Enabled := False;
        ActHeroGuardKey.Enabled := False;
        ActAttackModeKey.Enabled := False;
        ActMinMapKey.Enabled := False;
      end;
    end else begin
      with FrmMain do begin
        ActSeriesKillKey.Enabled := True;
        ActCallHeroKey.Enabled := True;
        ActCallHero1Key.Enabled := True;
        ActHeroAttackTargetKey.Enabled := True;
        ActHeroGotethKey.Enabled := True;
        ActHeroStateKey.Enabled := True;
        ActHeroGuardKey.Enabled := True;
        ActAttackModeKey.Enabled := True;
        ActMinMapKey.Enabled := True;
      end;
    end;
  end;
  //未开通的功能
  if Sender = DCheckSdoAutoDrinkWine then begin
    g_boAutoEatWine := DCheckSdoAutoDrinkWine.Checked;
  end;
  if Sender = DCheckSdoHeroAutoDrinkWine then begin
    g_boAutoEatHeroWine := DCheckSdoHeroAutoDrinkWine.Checked;
  end;
  if Sender = DCheckSdoAutoDrinkDrugWine then begin
    g_boAutoEatDrugWine := DCheckSdoAutoDrinkDrugWine.Checked;
  end;
  if Sender = DCheckSdoHeroAutoDrinkDrugWine then begin
    g_boAutoEatHeroDrugWine := DCheckSdoHeroAutoDrinkDrugWine.Checked;
  end;
end;

procedure TFrmDlg.DEdtSdoCommonHpChange(Sender: TObject);
begin
  if Sender = DEdtSdoAutoMagicTimer then begin
    if DEdtSdoAutoMagicTimer.Text = '' then Exit;
    g_nAutoMagicTime := StrToInt(DEdtSdoAutoMagicTimer.Text);
  end;

  if Sender = DEdtSdoDrunkWineDegree then begin
    if DEdtSdoDrunkWineDegree.Text = '' then Exit;
    g_btEditWine := StrToInt(DEdtSdoDrunkWineDegree.Text);
  end;

  if Sender = DEdtSdoHeroDrunkWineDegree then begin
    if DEdtSdoHeroDrunkWineDegree.Text = '' then Exit;
    g_btEditHeroWine := StrToInt(DEdtSdoHeroDrunkWineDegree.Text);
  end;

  if Sender = DEdtSdoDrunkDrugWineDegree then begin
    if DEdtSdoDrunkDrugWineDegree.Text = '' then Exit;
    g_btEditDrugWine := StrToInt(DEdtSdoDrunkDrugWineDegree.Text);
  end;

  if Sender = DEdtSdoHeroDrunkDrugWineDegree then begin
    if DEdtSdoHeroDrunkDrugWineDegree.Text = '' then Exit;
    g_btEditHeroDrugWine := StrToInt(DEdtSdoHeroDrunkDrugWineDegree.Text);
  end;

  if Sender = DEdtSdoExpFiltrate then begin
    if DEdtSdoExpFiltrate.Text = '' then Exit;
    g_dwEditExpFiltrate := Str_ToInt(DEdtSdoExpFiltrate.Text,2000);
  end;

end;

procedure TFrmDlg.DCheckSdoLongHitClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DCheckSdoLongHit then begin
    if FrmMain.GetMagicByID(12) or g_boCanLongHit4 then //刺杀
      g_boLongHit := DCheckSdoLongHit.Checked
    else begin
      DCheckSdoLongHit.Checked := False;
      g_boLongHit := False;
      Exit;
    end;
  end else
  if Sender = DCheckSdoPosLongHit then begin
    if FrmMain.GetMagicByID(12) or g_boCanLongHit4 then //隔位刺杀
      g_boPosLongHit := DCheckSdoPosLongHit.Checked
    else begin
      DCheckSdoPosLongHit.Checked := False;
      g_boLongHit := False;
      Exit;
    end;
  end else
  if Sender = DCheckSdoAutoWideHit then begin
    if FrmMain.GetMagicByID(25) or FrmMain.GetMagicByID(90) then begin //半月，圆月弯刀
       g_boAutoWideHit := DCheckSdoAutoWideHit.Checked;
    end else begin
       DCheckSdoAutoWideHit.Checked := False;
       g_boAutoWideHit := False;
       Exit;
    end;
  end else
  if Sender = DCheckSdoAutoFireHit then begin
    if not FrmMain.GetMagicByID(26) then begin //烈火
       DCheckSdoAutoFireHit.Checked := False;
       g_boAutoFireHit := False;
       Exit;
    end;
    g_boAutoFireHit := DCheckSdoAutoFireHit.Checked;
  end else
  if Sender = DCheckSdoZhuri then begin
    if not FrmMain.GetMagicByID(74) then begin //逐日
       DCheckSdoZhuri.Checked := False;
       g_boAutoZhuRiHit := False;
       Exit;
    end;
    g_boAutoZhuRiHit := DCheckSdoZhuri.Checked;
  end else
  if Sender = DCheckSdoAutoShield then begin
    if FrmMain.GetMagicByID(31) or FrmMain.GetMagicByID(66){4级魔法盾} then begin //自动开盾
       g_boAutoShield := DCheckSdoAutoShield.Checked;
    end else begin
       DCheckSdoAutoShield.Checked := False;
       g_boAutoShield := False;
       Exit;
    end;
  end else
  if Sender = DCheckSdoAutoHide then begin
    if not FrmMain.GetMagicByID(18) then begin //自动隐身
       DCheckSdoAutoHide.Checked := False;
       g_boAutoHide := False;
       Exit;
    end;
    g_boAutoHide := DCheckSdoAutoHide.Checked;
  end else
  if Sender = DCheckSdoHeroShield then begin
     if g_HeroSelf <> nil then begin
       if g_HeroSelf.m_btJob = 1 then begin
         if DCheckSdoHeroShield.Checked then FrmMain.SendHeroAutoOpenDefence(1)
         else FrmMain.SendHeroAutoOpenDefence(2);
       end else DCheckSdoHeroShield.Checked := False;
     end else DCheckSdoHeroShield.Checked := False;
     g_boHeroAutoDEfence := DCheckSdoHeroShield.Checked;
  end else
  if Sender = DCheckHeroBatterNotMob then begin
    if g_HeroSelf <> nil then begin
      if DCheckHeroBatterNotMob.Checked then FrmMain.SendHeroUseBatterToMon(1)
      else FrmMain.SendHeroUseBatterToMon(2);
    end else DCheckHeroBatterNotMob.Checked := False;
  end else
  if Sender = DCheckShowSpecialDamage then begin
    g_boShowSpecialDamage := DCheckShowSpecialDamage.Checked;
  end else
  {$IF M2Version <> 2}
  if Sender = DCheckAutoDragInBody then begin
    g_boAutoDragInBody := DCheckAutoDragInBody.Checked;
  end else
  if Sender = DCheckBoxHideTitle then begin
    g_boHideTitle := DCheckBoxHideTitle.Checked;
    if DCheckBoxHideTitle.Checked then
      frmMain.SendHideTitle(0)
    else frmMain.SendHideTitle(1);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBtnSdoCallHeroKeyKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  CombinationKey: Integer;
begin
  if Key in [DBtnSdoSeriesKillKey.Tag,DBtnSdoCallHeroKey.Tag,DBtnSdoCallHero1Key.Tag,DBtnSdoHeroAttackTargetKey.Tag,DBtnSdoHeroGotethKey.Tag,DBtnSdoHeroStateKey.Tag,DBtnSdoHeroGuardKey.Tag,DBtnSdoAttackModeKey.Tag,DBtnSdoMinMapKey.Tag] then begin
    Exit;
  end;
  if key in [0..7,9..11,12,14..15,21..32,41..45,47..92,94..123,144..145,186..192,219..222,226] then begin
    TDButton(Sender).Hint:='';
    CombinationKey:=0;
    if ssCtrl in Shift then
      TDButton(Sender).Hint := 'Ctrl+';
    if ssShift in Shift then
      TDButton(Sender).Hint := TDButton(Sender).Hint+'Shift+';
    if ssAlt in Shift then
      TDButton(Sender).Hint := TDButton(Sender).Hint+'Alt+';
    case Key of
     0..7,9..11,14..15,21..26,28..32,41..44,47..92,94..95:
      TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key);
     12: TDButton(Sender).Hint := TDButton(Sender).Hint+'Num 5';
     27: TDButton(Sender).Hint := TDButton(Sender).Hint+'Esc';
     45: TDButton(Sender).Hint := TDButton(Sender).Hint+'Insert';
     96..105: //小键盘
      TDButton(Sender).Hint := TDButton(Sender).Hint+'Num '+Char(key-48);
     106..111:
      TDButton(Sender).Hint := TDButton(Sender).Hint+'Num '+Char(key-64);
     112..122: //功能键
      TDButton(Sender).Hint := TDButton(Sender).Hint+'F'+IntToStr(Key-112+1);
     123: begin
       frmMain.OpenSdoAssistant();
       Exit;
     end;
     144: //Pause 小键开启灯那个
      TDButton(Sender).Hint := TDButton(Sender).Hint+'Pause';
     145: //Scroll Lock
      TDButton(Sender).Hint := TDButton(Sender).Hint+'Scroll Lock';
     192:
      TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key-96);
     186:
       TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key-127);
     187..191:
      TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key-144);
     219..221:
      TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key-128);
     222:
       TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key-183);
     226:
      TDButton(Sender).Hint := TDButton(Sender).Hint+Char(key-134);
    else
      //TDButton(Sender).Hint := inttostr(key);
    end;
  //if  not DCheckSdoStartKey.Checked then begin TDButton(Sender).Tag := Key //else begin
      if Pos ('Ctrl',TDButton(Sender).Hint) > 0 then  CombinationKey := 16384;
      if Pos ('Shift',TDButton(Sender).Hint) > 0 then  CombinationKey := CombinationKey + 8192;
      if Pos ('Alt',TDButton(Sender).Hint) > 0 then  CombinationKey := CombinationKey + 32768;
      TDButton(Sender).Tag := Key;
    if Sender = DBtnSdoSeriesKillKey then begin
      frmMain.ActSeriesKillKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoCallHeroKey then begin
      FrmMain.ActCallHeroKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoCallHero1Key then begin
      frmMain.ActCallHero1Key.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroAttackTargetKey then begin
      FrmMain.ActHeroAttackTargetKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroGotethKey then begin
      FrmMain.ActHeroGotethKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroStateKey then begin
      FrmMain.ActHeroStateKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoHeroGuardKey then begin
      FrmMain.ActHeroGuardKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoAttackModeKey then begin
      FrmMain.ActAttackModeKey.ShortCut := CombinationKey + Key;
    end else if Sender = DBtnSdoMinMapKey then begin
      FrmMain.ActMinMapKey.ShortCut := CombinationKey + Key;
    end;
  //end;
  end;
end;

procedure TFrmDlg.DBtnSdoCallHeroKeyMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbRight then begin
    if Sender = DBtnSdoSeriesKillKey then begin
      DBtnSdoSeriesKillKey.Hint := '';
      DBtnSdoSeriesKillKey.Tag := 0;
      frmMain.ActSeriesKillKey.ShortCut := 0;
    end else if Sender = DBtnSdoCallHeroKey then begin
      DBtnSdoCallHeroKey.Hint := '';
      DBtnSdoCallHeroKey.Tag := 0;
      FrmMain.ActCallHeroKey.ShortCut := 0;
    end else if Sender = DBtnSdoCallHero1Key then begin
      DBtnSdoCallHero1Key.Hint := '';
      DBtnSdoCallHero1Key.Tag := 0;
      FrmMain.ActCallHero1Key.ShortCut := 0;
    end else if Sender = DBtnSdoHeroAttackTargetKey then begin
      DBtnSdoHeroAttackTargetKey.Hint := '';
      DBtnSdoHeroAttackTargetKey.Tag := 0;
      FrmMain.ActHeroAttackTargetKey.ShortCut := 0;
    end else if Sender = DBtnSdoHeroGotethKey then begin
      DBtnSdoHeroGotethKey.Hint := '';
      DBtnSdoHeroGotethKey.Tag := 0;
      FrmMain.ActHeroGotethKey.ShortCut := 0;
    end else if Sender = DBtnSdoHeroStateKey then begin
      DBtnSdoHeroStateKey.Hint := '';
      DBtnSdoHeroStateKey.Tag := 0;
      FrmMain.ActHeroStateKey.ShortCut := 0;
    end else if Sender = DBtnSdoHeroGuardKey then begin
      DBtnSdoHeroGuardKey.Hint := '';
      DBtnSdoHeroGuardKey.Tag := 0;
      FrmMain.ActHeroGuardKey.ShortCut := 0;
    end else if Sender = DBtnSdoAttackModeKey then begin
      DBtnSdoAttackModeKey.Hint := '';
      DBtnSdoAttackModeKey.Tag := 0;
      FrmMain.ActAttackModeKey.ShortCut := 0;
    end else if Sender = DBtnSdoMinMapKey then begin
      DBtnSdoMinMapKey.Hint := '';
      DBtnSdoMinMapKey.Tag := 0;
      FrmMain.ActMinMapKey.ShortCut := 0;
    end;
  end;
end;

procedure TFrmDlg.DEdtSdoCommonHpKeyPress(Sender: TObject; var Key: Char);
begin
  if not (Key in ['0'..'9', #8, #13]) then Key := #0;
end;

procedure TFrmDlg.DWChallengeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DWChallenge do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
      dsurface.TextOut (GLeft + 30, GTop + 137, clYellow, FrmMain.CharName);
      dsurface.TextOut (GLeft + 30, GTop + 36, clYellow, g_sChallengeWho);
      dsurface.TextOut (GLeft + 80, GTop + 202, clLime, IntToStr(g_nChallengeGold));
      dsurface.TextOut (GLeft + 80, GTop + 101, clLime, IntToStr(g_nChallengeRemoteGold));
      dsurface.TextOut (GLeft + 196 - FrmMain.Canvas.TextWidth(IntToStr(g_nChallengeDiamond)) div 2, GTop + 176, clLime, IntToStr(g_nChallengeDiamond));
      dsurface.TextOut (GLeft + 196 - FrmMain.Canvas.TextWidth(IntToStr(g_nChallengeRemoteDiamond)) div 2, GTop + 75, clLime, IntToStr(g_nChallengeRemoteDiamond));
      dsurface.TextOut (GLeft + 179, GTop + 163, clWhite, g_sGameDiaMond);
      dsurface.TextOut (GLeft + 179, GTop + 62, clWhite, g_sGameDiaMond);
      dsurface.TextOut (GLeft + 52, GTop + 270, clWhite, '挑战中将已武馆教头的挑战规');
      dsurface.TextOut (GLeft + 28, GTop + 284, clWhite, '则做为评判胜负的标准，如果你同');
      dsurface.TextOut (GLeft + 28, GTop + 298, clWhite, '意就请开始挑战吧。');
  end;
end;

procedure TFrmDlg.DChallengeGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DChallengeGrid.ColCount;
  if idx in [0..3] then begin
    g_MouseItem := g_ChallengeItems[idx];
    with DChallengeGrid do
      ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                        SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DChallengeGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DChallengeGrid.ColCount;
  if idx in [0..3] then begin
    if g_ChallengeItems[idx].S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_ChallengeItems[idx].S.Looks);
      if d <> nil then begin
        with DChallengeGrid do begin
           dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_ChallengeItems[idx].S.StdMode = 17 then begin
            dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_ChallengeItems[idx].Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_ChallengeItems[idx].Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DChallengeGridGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
   I, mi, idx: integer;
   int: Byte;
begin
   if not g_boChallengeEnd and (GetTickCount > g_dwChallengeActionTick) then begin
      if not g_boItemMoving then begin
         idx := ACol + ARow * DChallengeGrid.ColCount;
         if idx in [0..3] then begin
            if g_ChallengeItems[idx].S.Name <> '' then begin
               g_boItemMoving := TRUE;
               g_MovingItem.Index := -idx - 57;
               g_MovingItem.Item := g_ChallengeItems[idx];
               g_ChallengeItems[idx].S.Name := '';
               ItemClickSound (g_MovingItem.Item.S);
            end;
         end else begin
            if idx = 4 then begin
                int := 0;
                DMessageDlg ('请输入'+g_sGameDiaMond+'数量，在0-9999之间', [mbOk, mbAbort]);
                if DlgEditText = '' then int := 1;
                for I:=1 to length(DlgEditText) do
                  if (DlgEditText[i] <'0') or ( DlgEditText[i] > '9') then int := 2;
                if length(DlgEditText) > 4 then int := 3;
                case int of
                  0: begin
                    if (StrToInt(DlgEditText) > 0) and (StrToInt(DlgEditText) < 10000) then begin
                      FrmMain.SendChangeChallengeDiamond(StrToInt(DlgEditText));
                    end;
                  end;
                  1:DMessageDlg ('内容不能为空！', [mbOk]);
                  2:DMessageDlg ('输入的'+g_sGameDiaMond+'错误', [mbOk]);
                  3:DMessageDlg (g_sGameDiaMond + '数量不能超过4位', [mbOk]);
                end;
            end;
         end;
      end else begin
         mi := g_MovingItem.Index;
         if (mi >= 0) or (mi <= -57) and (mi > -63) then begin
            ItemClickSound (g_MovingItem.Item.S);
            g_boItemMoving := FALSE;
            if mi >= 0 then begin
               g_ChallengeDlgItem := g_MovingItem.Item;
               FrmMain.SendAddChallengeItem (g_ChallengeDlgItem);
               g_dwChallengeActionTick := GetTickCount + 4000;
            end else
               AddChallengeItem (g_MovingItem.Item);
            g_MovingItem.Item.S.name := '';
         end;
         if mi = -98 then DDGoldClick (self, 0, 0);
      end;
      ArrangeItemBag;
   end;
end;

procedure TFrmDlg.DChallengeCloseClick(Sender: TObject; X, Y: Integer);
begin
   if GetTickCount > g_dwChallengeActionTick then begin
      CloseChallengeDlg;
      FrmMain.SendCancelChallenge;
   end;
end;

procedure TFrmDlg.DRChallengeGridGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: integer;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DRChallengeGrid.ColCount;
  if idx in [0..3] then begin
    g_MouseItem := g_ChallengeRemoteItems[idx];
    with DRChallengeGrid do
    	ShowMouseItemInfo(SurfaceX(GLeft)+(ACol)*ColWidth+ColWidth,
                      	SurfaceY(GTop)+(ARow+1)*RowHeight, '', 1, False);
  end;
end;

procedure TFrmDlg.DRChallengeGridGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DRChallengeGrid.ColCount;
  if idx in [0..3] then begin
    if g_ChallengeRemoteItems[idx].S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_ChallengeRemoteItems[idx].S.Looks);
      if d <> nil then begin
        with DRChallengeGrid do begin
           dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                          SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                          d.ClientRect,
                          d, TRUE);
          if g_ChallengeRemoteItems[idx].S.StdMode = 17 then begin
             dsurface.TextOut (SurfaceX(Rect.Left+35-frmMain.Canvas.TextWidth(IntToStr(g_ChallengeRemoteItems[idx].Dura))), SurfaceY(Rect.Top+20), clLime, InttoStr(g_ChallengeRemoteItems[idx].Dura));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DChallengeOKClick(Sender: TObject; X, Y: Integer);
var
   mi: integer;
begin
   if GetTickCount > g_dwChallengeActionTick then begin
      FrmMain.SendChallengeEnd;
      g_dwChallengeActionTick := GetTickCount + 4000;
      g_boChallengeEnd := TRUE;
      if g_boItemMoving then begin
         mi := g_MovingItem.Index;
         if (mi <= -57) and (mi > -61) then begin
            AddChallengeItem (g_MovingItem.Item);
            g_boItemMoving := FALSE;
            g_MovingItem.Item.S.name := '';
         end;
      end;
   end;
end;

procedure TFrmDlg.DChallengeGoldClick(Sender: TObject; X, Y: Integer);
var
   dgold: integer;
   valstr: string;
begin
   if g_MySelf = nil then Exit;
   if not g_boChallengeEnd and (GetTickCount > g_dwChallengeActionTick) then begin
    PlaySound (s_money);
    DialogSize := 1;
    DMessageDlg ('你想抵押多少' +g_sGoldName + '？', [mbOk, mbAbort]);
    GetValidStrVal (DlgEditText, valstr, [' ']);
    dgold := Str_ToInt (valstr, 0);
    if (dgold <= (g_nChallengeGold+g_MySelf.m_nGold)) and (dgold > 0) then begin
       FrmMain.SendChangeChallengeGold (dgold);
       g_dwChallengeActionTick := GetTickCount + 4000;
    end;
   end;
end;

procedure TFrmDlg.btnRecvChrCloseClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
begin
  dwRecoverChr.Visible := False;
  if g_DelChrList <> nil then begin
    if g_DelChrList.Count > 0 then begin//20080629
      for I := 0 to g_DelChrList.Count - 1 do begin //20080304 释放
        if pTDelChr(g_DelChrList.Items[I]) <> nil then Dispose(pTDelChr(g_DelChrList.Items[I]));
      end;
    end;
    FreeAndNil(g_DelChrList);
  end;
end;

procedure TFrmDlg.dgrdRecoverNameGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
   Idx: integer;
   DelChr: pTDelChr;
   sJob: string;
begin
   idx := ACol + ARow * dgrdRecoverName.ColCount;
   if idx in [0..9] then begin
     if g_DelChrList.Count >= idx+1 then begin
       if g_DelChrList.Items[idx] <> nil then begin
         DelChr := pTDelChr(g_DelChrList.Items[idx]);
         if DelChr <> nil then begin
           if DelChr.ChrInfo.Name <> '' then begin
              with dgrdRecoverName do begin
                with dsurface.Canvas do begin
                  if Idx = dgrdRecoverName.Tag then begin
                     Font.Color := clRed;
                     dsurface.TextOut (SurfaceX(Rect.Left), SurfaceY(Rect.Top)+4, Font.Color, '√');
                  end else Font.Color := clWhite;
                  dsurface.TextOut (SurfaceX(Rect.Left) + 14, SurfaceY(Rect.Top)+4, Font.Color, DelChr.ChrInfo.Name);
                  dsurface.TextOut (SurfaceX(Rect.Left) + 100, SurfaceY(Rect.Top)+4,Font.Color, IntToStr(DelChr.ChrInfo.Level)+'级');
                  case DelChr.ChrInfo.Job of
                    0: sJob := '武士';
                    1: sJob := '法师';
                    2: sJob := '道士';
                  end;
                  dsurface.TextOut (SurfaceX(Rect.Left) + 140, SurfaceY(Rect.Top)+4, Font.Color, sJob);
                  if DelChr.ChrInfo.sex = 0 then
                    dsurface.TextOut (SurfaceX(Rect.Left) + 190, SurfaceY(Rect.Top)+4, Font.Color, '男')
                  else
                    dsurface.TextOut (SurfaceX(Rect.Left) + 190, SurfaceY(Rect.Top)+4, Font.Color, '女');
                  Release;
                end;
              end;
           end;
         end;
       end;
     end;
   end;
end;

procedure TFrmDlg.dgrdRecoverNameGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  Idx: Integer;
begin
  Idx := ACol + ARow * dgrdRecoverName.ColCount;
  if Idx in [0..9] then begin
    dgrdRecoverName.Tag := Idx;
  end;
end;

procedure TFrmDlg.btnRecoverClick(Sender: TObject; X, Y: Integer);
begin
  if dgrdRecoverName.Tag in [0..9] then begin
    FrmMain.SendResDelChr(pTDelChr(g_DelChrList.Items[dgrdRecoverName.Tag]).ChrInfo.Name);
    dgrdRecoverName.Tag := 20;
    btnRecvChrCloseClick (self, 0, 0);
  end;
end;

procedure TFrmDlg.DWChallengeMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DEdtSdoCommonHpTimerKeyDown(Sender: TObject;
  var Key: Word; Shift: TShiftState);
begin
  if Key = 123 then begin
    frmMain.OpenSdoAssistant();
  end;
end;

procedure TFrmDlg.DCheckSdoExpFiltrateMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  Butt:TDCheckBox;
  sMsg:String;
begin
  if g_MySelf = nil then Exit;
  Butt:=TDCheckBox(Sender);
  if Sender = DCheckSdoNameShow then sMsg := '选中此项将全屏显示玩家名字';
  if Sender = DCheckSdoDuraWarning then sMsg := '选中此项将在装备低持久时\进行提示';
  if Sender = DCheckSdoAvoidShift then sMsg := '选中此项将不需要按下SHIFT\键也能攻击其他玩家';
  if Sender = DCheckSdoExpFiltrate then sMsg := '选中此项将隐藏聊天框中低\于“右边的编辑框内”的经验值增长提示';
  if Sender = DCheckSdoMapDesc then sMsg := '选中此项将自动显示地图标实';
  if Sender = DCheckAutoButch then sMsg := '选中此项将在使用(Alt+鼠标\左键)时持续探索怪物身上的\宝物';
  if Sender = DCheckAutoUseHuolongzhu then sMsg := '选中此项将自动使用探索得\到的“火龙珠”';
  if Sender = DCheckAutoUseJingyuandan then sMsg := '选中此项将自动使用探索得\到的“精元丹”';
  if Sender =  DCheckScreenShake then sMsg := '勾选此项后触发相应事件屏幕将震动';
  if Sender = DCheckMyHp then sMsg := '勾选此项将高亮自己和英雄\的血条显示';
  if Sender = DCheckHeroBatterNotMob then sMsg := '勾选此项英雄不施放连击打怪，不影响玩家间PK';
  if Sender = DCheckBFilterItemPickUpAll then sMsg := '勾选此项将自动拣取地面掉\落的物品';
  if Sender = DCheckHideHumanWing then sMsg := '勾选此项将不显示人物翅膀效果，可避免\电脑较差且翅膀显示过多而导致卡的问题';
  if Sender = DCheckHideWeaponEffect then sMsg := '勾选此项将不显示武器发光效果，可避免\电脑较差且武器发光显示过多而导致卡的问题';
  if Sender = DCheckBoxUseSuperMedica then sMsg := '根据玩家失血的血量使用药品，而不是剩余血量。\血量设置相同的情况下，排列靠后的药品优先使用\。-HP/-MP设置为0则无效';
  if Sender = DCheckBoxRenewHPSpecial then sMsg := '此类药品名字中包含“特效”';
  if Sender = DCheckBoxRenewMPSpecial then sMsg := '此类药品名字中包含“特效”';
  if Sender = DCheckBoxHideTitle then sMsg := '勾选此项将隐藏自己和他人的称号';
  if Sender = DCheckSdoAutoMagic then sMsg := '打开自动练习后，使用\一次要修炼的技能，该\技能会按照你设定的间\隔时间重复使用。';

  with Butt as TDCheckBox do
    DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop + GHeight), sMsg, clYellow, FALSE);
end;

procedure TFrmDlg.DWNewSdoAssistantMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DHeroItemBagMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DStateTabClick(Sender: TObject; X, Y: Integer);
var
  lx: Integer;
begin
  lx := X - DStateTab.GLeft;
  if (lx >= 13) and (lx <= 83) then begin
    StateTab := 0;
    DStateWinPulse.Visible := False;
    DStateWinBatter.Visible := False;
    PageChanged;
  end else
  if (lx >= 84) and (lx <= 152) then begin
    StateTab := 1;
    InternalForcePageChanged;
    {$IF M2Version <> 2}
    DBTitleMan.Visible := False;
    DBTitle1.Visible := False;
    DBTitle2.Visible := False;
    DBTitle3.Visible := False;
    DBTitle4.Visible := False;
    DBPrevTitle.Visible := False;
    DBNextTitle.Visible := False;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DStateTabDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
//var
//   d: TDirectDrawSurface;
begin
  { with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if StateTab = 0 then
           d := WLib.Images[FaceIndex]
        else
           d := WLib.Images[FaceIndex+1];
        if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end; }
end;

procedure TFrmDlg.DHeroStateTabDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
//var
//   d: TDirectDrawSurface;
begin
{   with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if HeroStateTab = 0 then
           d := WLib.Images[FaceIndex]
        else
           d := WLib.Images[FaceIndex+1];
        if d <> nil then
          dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
      end;
   end;}
end;

procedure TFrmDlg.DHeroStateTabClick(Sender: TObject; X, Y: Integer);
var
  lx: Integer;
begin
  lx := X - DStateTab.GLeft;
  if (lx >= 13) and (lx <= 83) then begin
    HeroStateTab := 0;
    DHeroStateWinPulse.Visible := False;
    DHeroStateWinBatter.Visible := False;
    HeroPageChanged;
  end else
  if (lx >= 84) and (lx <= 152) then begin
    HeroStateTab := 1;
    HeroInternalForcePageChanged;
  end;
end;

procedure TFrmDlg.DSighIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if not TDButton(Sender).Downed then begin
        if GetTickCount - SighIconTimeTick > 500 then begin
          SighIconTimeTick := GetTickCount;
          Inc(SighIconImginsex);
          if SighIconImginsex > 1 then SighIconImginsex := 0;
        end;
        d := WLib.Images[FaceIndex+SighIconImginsex];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        d := WLib.Images[FaceIndex+2];
        if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DSighIconClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  DSighIcon.Visible := False;
  msg := MakeDefaultMsg (aa(CM_CLICKSIGHICON, frmMain.TempCertification), 0, 1, 0, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg) + EncodeString(g_sSighIcon));
end;

procedure TFrmDlg.DCrystalExpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
 DScreen.ShowHint(DWExpCrystal.SurfaceX(DWExpCrystal.GLeft) + DWExpCrystal.GWidth - 12, DWExpCrystal.SurfaceY(DWExpCrystal.GTop)+60,
     '经验: ' + IntToStr(g_dwCrystalExp)+ '/' + IntToStr(g_dwCrystalMaxExp) + '\' +
     '内功: ' + IntToStr(g_dwCrystalNGExp)+ '/' + IntToStr(g_dwCrystalNGMaxExp)
     , clWhite, FALSE);
end;

procedure TFrmDlg.DExpCrystalTopMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if  g_btCrystalLevel-1 = 0 then begin
    DScreen.ShowHint(DWExpCrystal.SurfaceX(DWExpCrystal.GLeft) + DWExpCrystal.GWidth - 2, DWExpCrystal.SurfaceY(DWExpCrystal.GTop)+26,
       '当经验池散发光辉时，点击释放经验及内功'
       , clWhite, FALSE);
  end else begin
    DScreen.ShowHint(DWExpCrystal.SurfaceX(DWExpCrystal.GLeft) + DWExpCrystal.GWidth - 2, DWExpCrystal.SurfaceY(DWExpCrystal.GTop)+26,
       '点击释放经验及内功'
       , clWhite, FALSE);
  end;
end;

procedure TFrmDlg.DWExpCrystalMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   al, at: integer;
begin
  if ssLeft in Shift then begin
      if (DWExpCrystal.SpotX <> X) or (DWExpCrystal.SpotY <> Y) then begin
         al := DWExpCrystal.GLeft + (X - DWExpCrystal.SpotX);
         at := DWExpCrystal.GTop + (Y - DWExpCrystal.SpotY);
         if al+DWExpCrystal.GWidth < WINLEFT then al := WINLEFT - DWExpCrystal.GWidth;
         if al > WINRIGHT then al := WINRIGHT;
         if at+DWExpCrystal.GHeight < WINTOP then at := WINTOP - DWExpCrystal.GHeight;
         if at+DWExpCrystal.GHeight > BOTTOMEDGE-200 then at := BOTTOMEDGE-DWExpCrystal.GHeight-200;
         DWExpCrystal.GLeft := al;
         DWExpCrystal.GTop := at;
         DWExpCrystal.SpotX := X;
         DWExpCrystal.SpotY := Y;
      end;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DCrystalExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc:Trect;
begin
  if Sender = DCrystalExp then begin
    case g_btCrystalLevel-1 of
      0: d := g_WMainImages.Images[476];
      1: d := g_WMainImages.Images[478];
      2: d := g_WMainImages.Images[480];
      3: d := g_WMainImages.Images[482];
      4: d := g_WMainImages.Images[482];
      else d := nil;
    end;
    if d <> nil then begin
      rc := d.ClientRect;
      if g_dwCrystalMaxExp > 0 then begin
        if g_dwCrystalExp >= g_dwCrystalMaxExp then
          rc.Top := Round(rc.Bottom / g_dwCrystalMaxExp * (g_dwCrystalMaxExp - g_dwCrystalMaxExp))
        else
          rc.Top := Round(rc.Bottom / g_dwCrystalMaxExp * (g_dwCrystalMaxExp - g_dwCrystalExp));
        dsurface.Draw (DCrystalExp.SurfaceX(DCrystalExp.GLeft) + rc.Left, DCrystalExp.SurfaceY(DCrystalExp.GTop)+rc.Top, rc, d, FALSE);
      end;
    end;
  end;
  if Sender = DCrystalNGExp then begin
    case g_btCrystalLevel-1 of
      0: d := g_WMainImages.Images[477];
      1: d := g_WMainImages.Images[479];
      2: d := g_WMainImages.Images[481];
      3: d := g_WMainImages.Images[483];
      4: d := g_WMainImages.Images[483];
      else d := nil;
    end;
    if d <> nil then begin
      rc := d.ClientRect;
      if g_dwCrystalNGMaxExp > 0 then begin
        if g_dwCrystalNGExp >= g_dwCrystalNGMaxExp then
          rc.Top := Round(rc.Bottom / g_dwCrystalNGMaxExp * (g_dwCrystalNGMaxExp - g_dwCrystalNGMaxExp))
        else
          rc.Top := Round(rc.Bottom / g_dwCrystalNGMaxExp * (g_dwCrystalNGMaxExp - g_dwCrystalNGExp));
        dsurface.Draw (DCrystalNGExp.SurfaceX(DCrystalNGExp.GLeft) + rc.Left, DCrystalNGExp.SurfaceY(DCrystalNGExp.GTop)+rc.Top, rc, d, FALSE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DExpCrystalTopDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  case g_btCrystalLevel-1 of
    1,2,3,4: begin
      with Sender as TDButton do begin
        if WLib <> nil then begin //20080701
          if GetTickCount - ExpCrystalTopTimeTick > 800 then begin
           ExpCrystalTopTimeTick := GetTickCount;
           Inc(ExpCrystalTopImginsex);
           if ExpCrystalTopImginsex > 1 then ExpCrystalTopImginsex := 0;
          end;
          d := WLib.Images[FaceIndex+ExpCrystalTopImginsex];
          if d <> nil then
             dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          if g_btCrystalLevel-1 = 4 then begin
            if GetTickCount - ExpCrystalTopEffectTimeTick > 100 then begin
             ExpCrystalTopEffectTimeTick := GetTickCount;
             Inc(ExpCrystalTopEffectImginsex);
             if ExpCrystalTopEffectImginsex > 3 then ExpCrystalTopEffectImginsex := 0;
            end;
            d := WLib.Images[525+ExpCrystalTopEffectImginsex];
            if d <> nil then
            DrawBlend(dsurface,SurfaceX(GLeft)-18, SurfaceY(GTop)-24, d, 255);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DExpCrystalTopClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  if g_btCrystalLevel-1 <> 0 then begin //不为0级
    msg := MakeDefaultMsg (aa(CM_CLICKCRYSTALEXPTOP, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket (EncodeMessage (msg));
  end;
end;

function Mz_InternalReadComponentData(var Instance: TComponent; const DfmData: string): Boolean;
var
  StrStream: TStringStream;
begin
  StrStream := nil;

  try
    StrStream := TStringStream.Create(DfmData);
    Instance := StrStream.ReadComponent(Instance);
  finally
    StrStream.Free;
  end;

  Result := True;
end;

procedure TFrmDlg.DBotGroupMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
   if ssRight in Shift then begin
     if GetTickCount > g_dwChangeGroupModeTick then begin
        g_boAllowGroup := not g_boAllowGroup;
        g_dwChangeGroupModeTick := GetTickCount + 5000; //timeout 5檬
        FrmMain.SendGroupMode (g_boAllowGroup);
     end;
     if g_boAllowGroup then begin
       DScreen.AddChatBoardString('[允许组队]',clGreen, ClWhite);
     end else begin
       DScreen.AddChatBoardString('[拒绝组队]',clGreen, clBlack);
     end;
   end;
end;

procedure TFrmDlg.DNewBoxsHelpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Int: Integer;
begin
  with DNewBoxsHelp do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
      Int := 14;
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22, clYellow, '1.双击包裹中的宝箱');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int, clYellow, '就可开启宝箱');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*2, clYellow, '2.宝箱中获得的奖励');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*3, clYellow, '将自动进入包裹');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*4, clYellow, '3.勾选自动开启宝箱');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*5, clYellow, '选项可以自动帮您开');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*6, clYellow, '启包裹中的所有同类');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*7, clYellow, '宝箱');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*8, clYellow, '4.当包裹中有同类宝');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*9, clYellow, '箱时上方的三个特殊');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*10, clYellow, '奖励将会自动移到被');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*11, clYellow, '领取的奖励位置上，');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*12, clYellow, '选择再开一个就有机');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*13, clYellow, '会领取到特殊奖励');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*14, clYellow, '5.连续开启四个宝箱');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*15, clYellow, '后所有奖励会自动进');
      dsurface.TextOut(SurfaceX(GLeft) + 10, SurfaceY(GTop) + 22 + Int*16, clYellow, '行更换');
  end;
end;

procedure TFrmDlg.DBNewHelpBtnClick(Sender: TObject; X, Y: Integer);
begin
  DNewBoxsHelp.GTop := 0;
  DNewBoxsHelp.GLeft := DBoxs.GWidth-4;
  DNewBoxsHelp.Visible := not DNewBoxsHelp.Visible;
end;

procedure TFrmDlg.DNewBoxsHelpCloseClick(Sender: TObject; X, Y: Integer);
begin
  DNewBoxsHelp.Visible := False;
end;

procedure TFrmDlg.DCheckAutoOpenBoxsDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  with Sender as TDCheckBox do begin
    if not TDCheckBox(Sender).Checked then begin
      d := g_WMain2Images.Images[228];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end else begin
      d := g_WMain2Images.Images[229];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end
  end;
end;

procedure TFrmDlg.DCheckBoxBookHPProClick(Sender: TObject; X, Y: Integer);
begin
  case m_btProPage of
    0: begin
      if Sender = DCheckBoxBookHPPro then
        g_Config.boHp1Chk := DCheckBoxBookHPPro.Checked
      else if Sender = DCheckBoxBookMPPro then
        g_Config.boMp1Chk := DCheckBoxBookMPPro.Checked
      else if Sender = DCheckBoxRenewHP then
        g_Config.boRenewHPIsAuto := DCheckBoxRenewHP.Checked
      else if Sender = DCheckBoxRenewMP then
        g_Config.boRenewMPIsAuto := DCheckBoxRenewMP.Checked
      else if Sender = DCheckBoxRenewHPSpecial then
        g_Config.boRenewSpecialHPIsAuto := DCheckBoxRenewHPSpecial.Checked
      else if Sender = DCheckBoxRenewMPSpecial then
        g_Config.boRenewSpecialMPIsAuto := DCheckBoxRenewMPSpecial.Checked
      else if Sender = DCheckBoxUseSuperMedica then
        g_Config.BoUseSuperMedica := DCheckBoxUseSuperMedica.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName1 then
        g_Config.SuperMedicaUses[0] := DCheckBoxUseSuperMedicaItemName1.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName2 then
        g_Config.SuperMedicaUses[1] := DCheckBoxUseSuperMedicaItemName2.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName3 then
        g_Config.SuperMedicaUses[2] := DCheckBoxUseSuperMedicaItemName3.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName4 then
        g_Config.SuperMedicaUses[3] := DCheckBoxUseSuperMedicaItemName4.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName5 then
        g_Config.SuperMedicaUses[4] := DCheckBoxUseSuperMedicaItemName5.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName6 then
        g_Config.SuperMedicaUses[5] := DCheckBoxUseSuperMedicaItemName6.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName7 then
        g_Config.SuperMedicaUses[6] := DCheckBoxUseSuperMedicaItemName7.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName8 then
        g_Config.SuperMedicaUses[7] := DCheckBoxUseSuperMedicaItemName8.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName9 then
        g_Config.SuperMedicaUses[8] := DCheckBoxUseSuperMedicaItemName9.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName10 then
        g_Config.SuperMedicaUses[9] := DCheckBoxUseSuperMedicaItemName10.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName11 then
        g_Config.SuperMedicaUses[10] := DCheckBoxUseSuperMedicaItemName11.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName12 then
        g_Config.SuperMedicaUses[11] := DCheckBoxUseSuperMedicaItemName12.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName13 then
        g_Config.SuperMedicaUses[12] := DCheckBoxUseSuperMedicaItemName13.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName14 then
      g_Config.SuperMedicaUses[13] := DCheckBoxUseSuperMedicaItemName14.Checked;
    end;
    {$IF M2Version <> 2}
    1: begin
      if Sender = DCheckBoxBookHPPro then
        g_Config.boHp2Chk := DCheckBoxBookHPPro.Checked
      else if Sender = DCheckBoxBookMPPro then
        g_Config.boMp2Chk := DCheckBoxBookMPPro.Checked
      else if Sender = DCheckBoxRenewHP then
        g_Config.boRenewHeroNormalHpIsAuto := DCheckBoxRenewHP.Checked
      else if Sender = DCheckBoxRenewMP then
        g_Config.boRenewHeroNormalMpIsAuto := DCheckBoxRenewMP.Checked
      else if Sender = DCheckBoxRenewHPSpecial then
        g_Config.boRenewSpecialHeroNormalHpIsAuto := DCheckBoxRenewHPSpecial.Checked
      else if Sender = DCheckBoxRenewMPSpecial then
        g_Config.boRenewSpecialHeroNormalMPIsAuto := DCheckBoxRenewMPSpecial.Checked
      else if Sender = DCheckBoxUseSuperMedica then
        g_Config.hBoUseSuperMedica := DCheckBoxUseSuperMedica.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName1 then
        g_Config.hSuperMedicaUses[0] := DCheckBoxUseSuperMedicaItemName1.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName2 then
        g_Config.hSuperMedicaUses[1] := DCheckBoxUseSuperMedicaItemName2.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName3 then
        g_Config.hSuperMedicaUses[2] := DCheckBoxUseSuperMedicaItemName3.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName4 then
        g_Config.hSuperMedicaUses[3] := DCheckBoxUseSuperMedicaItemName4.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName5 then
        g_Config.hSuperMedicaUses[4] := DCheckBoxUseSuperMedicaItemName5.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName6 then
        g_Config.hSuperMedicaUses[5] := DCheckBoxUseSuperMedicaItemName6.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName7 then
        g_Config.hSuperMedicaUses[6] := DCheckBoxUseSuperMedicaItemName7.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName8 then
        g_Config.hSuperMedicaUses[7] := DCheckBoxUseSuperMedicaItemName8.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName9 then
        g_Config.hSuperMedicaUses[8] := DCheckBoxUseSuperMedicaItemName9.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName10 then
        g_Config.hSuperMedicaUses[9] := DCheckBoxUseSuperMedicaItemName10.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName11 then
        g_Config.hSuperMedicaUses[10] := DCheckBoxUseSuperMedicaItemName11.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName12 then
        g_Config.hSuperMedicaUses[11] := DCheckBoxUseSuperMedicaItemName12.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName13 then
        g_Config.hSuperMedicaUses[12] := DCheckBoxUseSuperMedicaItemName13.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName14 then
      g_Config.hSuperMedicaUses[13] := DCheckBoxUseSuperMedicaItemName14.Checked;
    end;
    2: begin
      if Sender = DCheckBoxBookHPPro then
        g_Config.boHp3Chk := DCheckBoxBookHPPro.Checked
      else if Sender = DCheckBoxBookMPPro then
        g_Config.boMp3Chk := DCheckBoxBookMPPro.Checked
      else if Sender = DCheckBoxRenewHP then
        g_Config.boRenewzHeroNormalHpIsAuto := DCheckBoxRenewHP.Checked
      else if Sender = DCheckBoxRenewMP then
        g_Config.boRenewzHeroNormalMPIsAuto := DCheckBoxRenewMP.Checked
      else if Sender = DCheckBoxRenewHPSpecial then
        g_Config.boRenewSpecialzHeroNormalHpIsAuto := DCheckBoxRenewHPSpecial.Checked
      else if Sender = DCheckBoxRenewMPSpecial then
        g_Config.boRenewSpecialzHeroNormalMPIsAuto := DCheckBoxRenewMPSpecial.Checked
      else if Sender = DCheckBoxUseSuperMedica then
        g_Config.zBoUseSuperMedica := DCheckBoxUseSuperMedica.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName1 then
        g_Config.zSuperMedicaUses[0] := DCheckBoxUseSuperMedicaItemName1.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName2 then
        g_Config.zSuperMedicaUses[1] := DCheckBoxUseSuperMedicaItemName2.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName3 then
        g_Config.zSuperMedicaUses[2] := DCheckBoxUseSuperMedicaItemName3.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName4 then
        g_Config.zSuperMedicaUses[3] := DCheckBoxUseSuperMedicaItemName4.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName5 then
        g_Config.zSuperMedicaUses[4] := DCheckBoxUseSuperMedicaItemName5.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName6 then
        g_Config.zSuperMedicaUses[5] := DCheckBoxUseSuperMedicaItemName6.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName7 then
        g_Config.zSuperMedicaUses[6] := DCheckBoxUseSuperMedicaItemName7.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName8 then
        g_Config.zSuperMedicaUses[7] := DCheckBoxUseSuperMedicaItemName8.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName9 then
        g_Config.zSuperMedicaUses[8] := DCheckBoxUseSuperMedicaItemName9.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName10 then
        g_Config.zSuperMedicaUses[9] := DCheckBoxUseSuperMedicaItemName10.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName11 then
        g_Config.zSuperMedicaUses[10] := DCheckBoxUseSuperMedicaItemName11.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName12 then
        g_Config.zSuperMedicaUses[11] := DCheckBoxUseSuperMedicaItemName12.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName13 then
        g_Config.zSuperMedicaUses[12] := DCheckBoxUseSuperMedicaItemName13.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName14 then
      g_Config.zSuperMedicaUses[13] := DCheckBoxUseSuperMedicaItemName14.Checked;
    end;
    3: begin
      if Sender = DCheckBoxBookHPPro then
        g_Config.boHp4Chk := DCheckBoxBookHPPro.Checked
      else if Sender = DCheckBoxBookMPPro then
        g_Config.boMp4Chk := DCheckBoxBookMPPro.Checked
      else if Sender = DCheckBoxRenewHP then
        g_Config.boRenewfHeroNormalHpIsAuto := DCheckBoxRenewHP.Checked
      else if Sender = DCheckBoxRenewMP then
        g_Config.boRenewfHeroNormalMPIsAuto := DCheckBoxRenewMP.Checked
      else if Sender = DCheckBoxRenewHPSpecial then
        g_Config.boRenewSpecialfHeroNormalHpIsAuto := DCheckBoxRenewHPSpecial.Checked
      else if Sender = DCheckBoxRenewMPSpecial then
        g_Config.boRenewSpecialfHeroNormalMPIsAuto := DCheckBoxRenewMPSpecial.Checked
      else if Sender = DCheckBoxUseSuperMedica then
        g_Config.fBoUseSuperMedica := DCheckBoxUseSuperMedica.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName1 then
        g_Config.fSuperMedicaUses[0] := DCheckBoxUseSuperMedicaItemName1.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName2 then
        g_Config.fSuperMedicaUses[1] := DCheckBoxUseSuperMedicaItemName2.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName3 then
        g_Config.fSuperMedicaUses[2] := DCheckBoxUseSuperMedicaItemName3.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName4 then
        g_Config.fSuperMedicaUses[3] := DCheckBoxUseSuperMedicaItemName4.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName5 then
        g_Config.fSuperMedicaUses[4] := DCheckBoxUseSuperMedicaItemName5.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName6 then
        g_Config.fSuperMedicaUses[5] := DCheckBoxUseSuperMedicaItemName6.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName7 then
        g_Config.fSuperMedicaUses[6] := DCheckBoxUseSuperMedicaItemName7.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName8 then
        g_Config.fSuperMedicaUses[7] := DCheckBoxUseSuperMedicaItemName8.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName9 then
        g_Config.fSuperMedicaUses[8] := DCheckBoxUseSuperMedicaItemName9.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName10 then
        g_Config.fSuperMedicaUses[9] := DCheckBoxUseSuperMedicaItemName10.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName11 then
        g_Config.fSuperMedicaUses[10] := DCheckBoxUseSuperMedicaItemName11.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName12 then
        g_Config.fSuperMedicaUses[11] := DCheckBoxUseSuperMedicaItemName12.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName13 then
        g_Config.fSuperMedicaUses[12] := DCheckBoxUseSuperMedicaItemName13.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName14 then
      g_Config.fSuperMedicaUses[13] := DCheckBoxUseSuperMedicaItemName14.Checked;
    end;
    4: begin
      if Sender = DCheckBoxBookHPPro then
        g_Config.boHp5Chk := DCheckBoxBookHPPro.Checked
      else if Sender = DCheckBoxBookMPPro then
        g_Config.boMp5Chk := DCheckBoxBookMPPro.Checked
      else if Sender = DCheckBoxRenewHP then
        g_Config.boRenewdHeroNormalHpIsAuto := DCheckBoxRenewHP.Checked
      else if Sender = DCheckBoxRenewMP then
        g_Config.boRenewdHeroNormalMPIsAuto := DCheckBoxRenewMP.Checked
      else if Sender = DCheckBoxRenewHPSpecial then
        g_Config.boRenewSpecialdHeroNormalHpIsAuto := DCheckBoxRenewHPSpecial.Checked
      else if Sender = DCheckBoxRenewMPSpecial then
        g_Config.boRenewSpecialdHeroNormalMPIsAuto := DCheckBoxRenewMPSpecial.Checked
      else if Sender = DCheckBoxUseSuperMedica then
        g_Config.dBoUseSuperMedica := DCheckBoxUseSuperMedica.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName1 then
        g_Config.dSuperMedicaUses[0] := DCheckBoxUseSuperMedicaItemName1.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName2 then
        g_Config.dSuperMedicaUses[1] := DCheckBoxUseSuperMedicaItemName2.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName3 then
        g_Config.dSuperMedicaUses[2] := DCheckBoxUseSuperMedicaItemName3.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName4 then
        g_Config.dSuperMedicaUses[3] := DCheckBoxUseSuperMedicaItemName4.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName5 then
        g_Config.dSuperMedicaUses[4] := DCheckBoxUseSuperMedicaItemName5.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName6 then
        g_Config.dSuperMedicaUses[5] := DCheckBoxUseSuperMedicaItemName6.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName7 then
        g_Config.dSuperMedicaUses[6] := DCheckBoxUseSuperMedicaItemName7.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName8 then
        g_Config.dSuperMedicaUses[7] := DCheckBoxUseSuperMedicaItemName8.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName9 then
        g_Config.dSuperMedicaUses[8] := DCheckBoxUseSuperMedicaItemName9.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName10 then
        g_Config.dSuperMedicaUses[9] := DCheckBoxUseSuperMedicaItemName10.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName11 then
        g_Config.dSuperMedicaUses[10] := DCheckBoxUseSuperMedicaItemName11.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName12 then
        g_Config.dSuperMedicaUses[11] := DCheckBoxUseSuperMedicaItemName12.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName13 then
        g_Config.dSuperMedicaUses[12] := DCheckBoxUseSuperMedicaItemName13.Checked
      else if Sender = DCheckBoxUseSuperMedicaItemName14 then
        g_Config.dSuperMedicaUses[13] := DCheckBoxUseSuperMedicaItemName14.Checked
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DBoxsNewCloseClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(aa(CM_OPENNEWBOXS, frmMain.TempCertification), 0, 0, 1, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket(EncodeMessage(msg));
  DBoxS.Visible := False;
end;

procedure TFrmDlg.DCheckAutoOpenBoxsClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if DCheckAutoOpenBoxs.Checked then begin
    if not g_boBoxsShowPosition then begin
      msg := MakeDefaultMsg(aa(CM_ROTATIONBOX, frmMain.TempCertification), 1{表示自动}, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
      FrmMain.SendSocket(EncodeMessage(msg));
    end;
  end;
end;

function Mz_InitInheritedComponent(Instance: TComponent; RootAncestor: TClass; const DfmData: string): Boolean;
  function Mz_InitComponent(ClassType: TClass; const DfmData: string): Boolean;
  begin
    Result := False;
    if (ClassType = TComponent) or (ClassType = RootAncestor) then Exit;
    Result := Mz_InitComponent(ClassType.ClassParent, DfmData);
    Result := Mz_InternalReadComponentData(Instance, DfmData) or Result; // **
  end;
var
  LocalizeLoading: Boolean;
begin
  GlobalNameSpace.BeginWrite;  // hold lock across all ancestor loads (performance)
  try
    LocalizeLoading := (Instance.ComponentState * [csInline, csLoading]) = [];
    if LocalizeLoading then BeginGlobalLoading;       // push new loadlist onto stack
    try
      Result := Mz_InitComponent(Instance.ClassType, DfmData); // **
      if LocalizeLoading then NotifyGlobalLoading;    // call Loaded
    finally
      if LocalizeLoading then EndGlobalLoading;       // pop loadlist off stack
    end;
  finally
    GlobalNameSpace.EndWrite;
  end;
end;
{.$IF GVersion <> 0}
{constructor TFrmDlg.Create(AOwner: TComponent);
begin
  GlobalNameSpace.BeginWrite;
  try
    CreateNew(AOwner);
    if (ClassType <> TForm) and not (csDesigning in ComponentState) then
    begin
      Include(FFormState, fsCreating);
      try
        if (Mz_InitInheritedComponent(Self, TForm, DemoDfm) = False) then // **
          ShowMessage('注意, 初始化界面失败, 请检查DataUnit.DfmData, :~)');
      finally
        Exclude(FFormState, fsCreating);
      end;
      if OldCreateOrder then DoCreate;
    end;
  finally
    GlobalNameSpace.EndWrite;
  end;
end; }
{.$IFEND}
procedure TFrmDlg.DSdoMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  s18: string;
begin
  with DSdoMemo do begin
    ElemCount:= (GHeight - 2) div _MAX(1, LinesHeight);  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for i:= 0 to ElemCount - 1 do begin
      s18 := Lines.Strings[i+TopIndex];
      if s18 <> '' then begin
        if s18[1] = ' ' then
          dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clSilver, clBlack, s18)
        else
          dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clWhite, clBlack, s18);
      end;
    end;
  end;
end;

procedure TFrmDlg.DSdoMemoScrollBarDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   Rc:Trect;
begin
  with Sender as TDMemoScrollBar do begin
    d := g_WMain2Images.Images[574];
    if d <> nil then begin
      Rc := d.ClientRect;
      Rc.Bottom := GHeight;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, True);
      Rc := d.ClientRect;
      Rc.Top := d.Height-GHeight;
      Rc.Bottom := d.Height;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)+1, Rc, d, True);
    end;
  end;
end;

procedure TFrmDlg.m_EdIdKeyPress(Sender: TObject; var Key: Char);
begin
   if Key = #13 then begin
      Key := #0;
      LoginScene.m_sLoginId := LowerCase(m_EdId.Text);
      if LoginScene.m_sLoginId <> '' then begin
         m_EdPasswd.SetFocus;
      end;
   end;
end;

procedure TFrmDlg.m_EdPasswdKeyPress(Sender: TObject; var Key: Char);
begin
   if (Key = '~') or (Key = '''') then Key := '_';
   if Key = #13 then begin
      Key := #0;
      LoginScene.m_sLoginId := LowerCase(m_EdId.Text);
      LoginScene.m_sLoginPasswd := m_EdPasswd.Text;
      if (LoginScene.m_sLoginId <> '') and (LoginScene.m_sLoginPasswd <> '') then begin
         //发送到服务器验证密码
         FrmMain.SendLogin (LoginScene.m_sLoginId, LoginScene.m_sLoginPasswd);
         m_EdId.Text := '';
         m_EdPasswd.Text := '';
         //m_EdId.Visible := FALSE;
         //m_EdPasswd.Visible := FALSE;
      end else
         if (m_EdId.Visible) and (m_EdId.Text = '') then m_EdId.SetFocus;
   end;
end;

procedure TFrmDlg.m_EdIdKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = VK_TAB then begin
     m_EdPasswd.SetFocus;
   end;
end;

procedure TFrmDlg.m_EdPasswdKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
   if Key = VK_TAB then begin
     m_EdId.SetFocus;
   end;
end;

procedure TFrmDlg.DCBBookHPManChange(Sender: TObject);
begin
  if Sender = DCBBookHPMan then
    g_Config.btHp1Man := DCBBookHPMan.ItemIndex
  else if Sender = DCBBookMPMan then
    g_Config.btMp1Man := DCBBookMPMan.ItemIndex;
  
end;

procedure TFrmDlg.DCBBookHPManDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   FontColor: Tcolor;
begin
  with Sender as TDComboBox do begin
    {if TDComboBox(Sender).Moveed then begin
      Color := $00387B9C;
      FontColor := clYellow;
    end else begin
      Color := $00498394;
      FontColor := clWhite;
    end;    }
    {with dsurface.Canvas do begin
      pen.Color := Color;
      Brush.Color := clBlack;
               //左                               //上                            //右
      Rectangle(SurfaceX(GLeft),SurfaceY(GTop),SurfaceX(GLeft)+TDButton(Sender).GWidth,SurfaceY(GTop)+TDButton(Sender).GHeight);
      Brush.Color := Color;
      if TDButton(Sender).Downed then
        Polygon([Point(SurfaceX(GLeft)+73+3,   SurfaceY(GTop)+12),   Point(SurfaceX(GLeft)+73,   SurfaceY(GTop)+9),   Point(SurfaceX(GLeft)+73+6,   SurfaceY(GTop)+9)])   //画三角形
      else
        Polygon([Point(SurfaceX(GLeft)+73+3,   SurfaceY(GTop)+11),   Point(SurfaceX(GLeft)+73,   SurfaceY(GTop)+8),   Point(SurfaceX(GLeft)+73+6,   SurfaceY(GTop)+8)]);   //画三角形
      //Release;
       dsurface.BoldTextOut (SurfaceX(GLeft) + 2, SurfaceY(GTop) + 4, FontColor, clBlack, DComSdoRandomName.Text);     
    end;}  
  end;
end;

procedure TFrmDlg.DCBBookHPManInitialize(Sender: TObject);
begin
  with Sender as TDCombobox do begin
    ItemIndex := 0;
  end;
end;

procedure TFrmDlg.DAdjustAbilOkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
   with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
   end;
end;

procedure TFrmDlg.DGDWarClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  DMessageDlg ('请输入对方行会的名称', [mbOk, mbAbort]);
  if DlgEditText <> '' then begin
    msg := MakeDefaultMsg(aa(CM_REQUESTGUILDWAR, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg)+EncodeString(DlgEditText));
  end;
end;

procedure TFrmDlg.DWNQStateMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
   al, at: integer;
begin
  if ssLeft in Shift then begin
      if (DWNQState.SpotX <> X) or (DWNQState.SpotY <> Y) then begin
         al := DWNQState.GLeft + (X - DWNQState.SpotX);
         at := DWNQState.GTop + (Y - DWNQState.SpotY);
         if al+DWNQState.GWidth < DWNQState.GWidth then al := 0;
         if al > SCREENWIDTH-DWNQState.GWidth then al := SCREENWIDTH-DWNQState.GWidth;
         if at+DWNQState.GHeight < DWNQState.GHeight then at := 0;
         if at+DWNQState.GHeight > BOTTOMEDGE-200 then at := BOTTOMEDGE-DWNQState.GHeight-200;
         DWNQState.GLeft := al;
         DWNQState.GTop := at;
         DWNQState.SpotX := X;
         DWNQState.SpotY := Y;
      end;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DNQBoxsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  if Sender = DNQBoxs then begin
    DScreen.ShowHint(DWNQState.SurfaceX(DWNQState.GLeft) - 18, DWNQState.SurfaceY(DWNQState.GTop)+40,
       '每满一个节点槽，可开启宝箱一次\每亮起一颗灯，宝箱中的奖励就更好'
       , clWhite, FALSE);
  end else begin
    DScreen.ShowHint(DWNQState.SurfaceX(DWNQState.GLeft)+18, DWNQState.SurfaceY(DWNQState.GTop)+40,
       format('牛气值：%d/%d',[g_dwNQExp,g_dwNQMaxExp])
       , clWhite, FALSE);
  end;
end;

procedure TFrmDlg.DNQExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc:Trect;
begin
  with DNQExp do begin
    if WLib <> nil then begin //20080701
      if boShowNQExpFalsh then begin
        if GetTickCount - ShowNQExpTimeTick > 300 then begin
          ShowNQExpTimeTick := GetTickCount;
          Inc(ShowNQExpInc);
          Inc(ShowNQExpInc1);
          if ShowNQExpInc > 1 then ShowNQExpInc := 0;
          if ShowNQExpInc1 > 9 then boShowNQExpFalsh := False;
        end;
        if ShowNQExpInc <> 0 then
          d := WLib.Images[FaceIndex]
        else d := nil;
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
    case g_btNQLevel-1 of
      0: d := g_WMainImages.Images[565];
      1: d := g_WMainImages.Images[571];
      2: d := g_WMainImages.Images[577];
      3: d := g_WMainImages.Images[583];
      else d := nil;
    end;
    if d <> nil then begin
      rc := d.ClientRect;
      if g_dwNQMaxExp > 0 then begin
        rc.Right := Round((rc.Right-rc.Left) / g_dwNQMaxExp * g_dwNQExp);
        dsurface.Draw (SurfaceX(DNQExp.GLeft) + rc.Left, SurfaceY(DNQExp.GTop)+rc.Top, rc, d, FALSE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWNQStateDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DWNQState do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if GetTickCount - ExpNQTimeTick > 500 then begin
     ExpNQTimeTick := GetTickCount;
     Inc(ExpNQImginsex);
     if ExpNQImginsex > 1 then ExpNQImginsex := 0;
    end;
    if g_dwNQMaxExp > 0 then begin
      case g_btNQLevel-1 of
        0: begin
          d := g_WMainImages.Images[587+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+90, SurfaceY(GTop)+7, d.ClientRect, d, true);
        end;
        1: begin
          d := g_WMainImages.Images[587];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+130, SurfaceY(GTop)+7, d.ClientRect, d, true);
          d := g_WMainImages.Images[589+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+130, SurfaceY(GTop)+15, d.ClientRect, d, true);
        end;
        2: begin
          d := g_WMainImages.Images[587];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+190, SurfaceY(GTop)+7, d.ClientRect, d, true);
          d := g_WMainImages.Images[589];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+190, SurfaceY(GTop)+15, d.ClientRect, d, true);
          d := g_WMainImages.Images[591+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+190, SurfaceY(GTop)+23, d.ClientRect, d, true);
        end;
        3: begin
          d := g_WMainImages.Images[587];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+7, d.ClientRect, d, true);
          d := g_WMainImages.Images[589];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+15, d.ClientRect, d, true);
          d := g_WMainImages.Images[591];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+23, d.ClientRect, d, true);
          d := g_WMainImages.Images[593+ExpNQImginsex];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+266, SurfaceY(GTop)+31, d.ClientRect, d, true);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKimNeedleHelpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d{,dd}: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if not DStartKimNeedle.ShowHint then begin
        if TDButton(Sender).Downed then
          d := WLib.Images[FaceIndex+1]
        else
          d := WLib.Images[FaceIndex];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
          g_ImgMixSurface.SetSize(d.Width, d.Height);
          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
          DrawEffect(0, 0, g_ImgMixSurface, d, ceGrayScale);
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWKimNeedleDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  {$IF M2Version = 1}
  with DWKimNeedle do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    d := g_WMainImages.Images[750];
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+12, SurfaceY(GTop)+18, d.ClientRect, d, TRUE);
    d := g_WMainImages.Images[753];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+95, SurfaceY(GTop)+187, d.ClientRect, d, TRUE);
    dsurface.TextOut (SurfaceX(GLeft+19), SurfaceY(GTop+125), clWhite, '金针锻造师');
  end;
  {$IFEND}
end;

procedure TFrmDlg.DKimNeedleLogoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  procedure PomiTextOut (dsurface: TDirectDrawSurface; x, y: integer; str: string);
  var
     i, n, J: integer;
     d: TDirectDrawSurface;
  begin
     if Length(str)<=0 then Exit;    //20080629
     J := Length(str);
     for i:=1 to Length(str) do begin
        n := byte(str[i]) - byte('0');
        if (n >= 0) and (n <= 9) then begin
           d := g_WMainImages.Images[970 + n];
           if d <> nil then
              dsurface.Draw (x + i*20 - J*20, y, d.ClientRect, d, TRUE);
        end;
     end;
  end;
var
  d: TDirectDrawSurface;
  I, nImg: Integer;
  J: Byte;
begin
  with DKimNeedleLogo do begin
    if DKimNeedleHelp.ShowHint then begin
      d := g_WMainImages.Images[754];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      d := g_WMain2Images.Images[148];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+268, SurfaceY(GTop)-16, d.ClientRect, d, TRUE);
    end else
    if DKimNeedleMemo.ShowHint then begin
      d := g_WMainImages.Images[755];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      d := g_WMain2Images.Images[148];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+268, SurfaceY(GTop)-16, d.ClientRect, d, TRUE);
    end else begin
      if WLib <> nil then begin //20080701
        if GetTickCount - KimNeedleLogoTimeTick > 200 then begin
         KimNeedleLogoTimeTick := GetTickCount;
         Inc(KimNeedleLogoImginsex);
         if KimNeedleLogoImginsex > 29 then KimNeedleLogoImginsex := 0;
        end;
        d := WLib.Images[1000+KimNeedleLogoImginsex];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if g_btKimNeedleSuccess = 0 then begin
        PomiTextOut(dsurface,SurfaceX(GLeft)+178, SurfaceY(GTop)+115, IntToStr(g_nKimSuccessRate));
        d := g_WMainImages.Images[991];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+30, SurfaceY(GTop)+110, d.ClientRect, d, TRUE);
        d := g_WMainImages.Images[990];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+198, SurfaceY(GTop)+115, d.ClientRect, d, TRUE);
        J:= 0;
        for I:=0 to 4 do begin
          if g_KimNeedleItem[I].S.Name <> '' then begin
            Inc(J);
            d := g_WMainImages.Images[760 + g_KimNeedleItem[I].S.Shape - 1];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft)+ J * 50 - 108, SurfaceY(GTop)-53, d.ClientRect, d, TRUE);
            if DStartKimNeedle.ShowHint then begin
              if GetTickCount - KimNeedleStartFlameTimeTick > 200 then begin
               KimNeedleStartFlameTimeTick := GetTickCount;
               Inc(KimNeedleStartFlameImginsex);
               if KimNeedleStartFlameImginsex > 8 then KimNeedleStartFlameImginsex := 0;
              end;
              d := WLib.Images[1030+KimNeedleStartFlameImginsex];
              if d <> nil then
              DrawBlend(dsurface, SurfaceX(GLeft)+ J * 50 - 108, SurfaceY(GTop)-53, d, 255);
            end;
          end;
        end;
      end else begin
        if g_btKimNeedleSuccessShape in [2..6] then begin //显示锻造成功后logo上的针动画
          if g_btKimNeedleSuccessExplImginsex > 3 then begin
            d := g_WMainImages.Images[759+g_btKimNeedleSuccessShape];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft) + 30, SurfaceY(GTop) - 49, d.ClientRect, d, TRUE);  //针的图
            if GetTickCount - g_dwKimNeedleSuccessStarsTimeTick > 120 then begin
              g_dwKimNeedleSuccessStarsTimeTick := GetTickCount();
              Inc(g_btKimNeedleSuccessStarsImginsex);
            end;
            if g_btKimNeedleSuccessStarsImginsex > 13 then g_btKimNeedleSuccessStarsImginsex := 0;
            d := g_WMainImages.Images[1050+g_btKimNeedleSuccessStarsImginsex];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(GLeft)- 8, SurfaceY(GTop), d, 255);  //星星
          end else begin
            if GetTickCount - g_dwKimNeedleSuccessExplTimeTick > 120 then begin
              g_dwKimNeedleSuccessExplTimeTick := GetTickCount();
              Inc(g_btKimNeedleSuccessExplImginsex);
            end;
            d := g_WMainImages.Images[1040+g_btKimNeedleSuccessExplImginsex];
            if d <> nil then
              DrawBlend(dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 255);   //为爆炸的那个图
          end;
        end;
        if g_btKimNeedleSuccess = 1 then nImg := 1073
        else nImg := 1103;
        d := g_WMainImages.Images[nImg];
        if d <> nil then begin
          if g_btKimNeedleSuccess = 1 then
            dsurface.Draw (SurfaceX(GLeft)-8, SurfaceY(GTop)+2, d.ClientRect, d, TRUE)
          else dsurface.Draw (SurfaceX(GLeft)-8, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKimNeedle1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, dTemp: TDirectDrawSurface;
  idx: Integer;
  Butt:TDButton;
begin
  Butt:=TDButton(Sender);
  if Butt.Tag in [0..4] then begin
    with Butt do begin
      if g_KimNeedleItem[Butt.Tag].S.Name <> '' then begin
        idx := g_KimNeedleItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_btKimItemOneLevel > 1) and ((g_btKimItemOneLevel <= 5)) then d := g_WMainImages.Images[780 + g_btKimItemOneLevel -2]
        else d := g_WMainImages.Images[790];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if DStartKimNeedle.ShowHint then begin
          d := g_WMainImages.Images[758];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
          if (g_MovingItem.Item.S.StdMode = 17) and (g_MovingItem.Item.S.Shape in [1..5]) and (g_MovingItem.Item.Dura = 1) and g_boItemMoving then begin
            if (g_MovingItem.Item.S.Shape = g_btKimItemOneLevel) or (g_btKimItemOneLevel = 0) then begin
              d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
              if d<>nil then begin
                DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
              end;
            end else begin
              dTemp := TDirectDrawSurface.Create(frmMain.DXDraw.DDraw);
              try
                dTemp.SystemMemory := TRUE;
                dTemp.SetSize(33, 31);
                dTemp.Fill(56);
                DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), dTemp, 0, 0, dTemp.Width, dTemp.Height, 150);
              finally
                dTemp.Free;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DKimNeedle6DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d, dTemp: TDirectDrawSurface;
  idx: Integer;
  Butt:TDButton;
begin
  Butt:=TDButton(Sender);
  if Butt.Tag in [5..7] then begin
    with Butt do begin
      if g_KimNeedleItem[Butt.Tag].S.Name <> '' then begin
        idx := g_KimNeedleItem[Butt.Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else begin
        if (g_btKimItemOneLevel > 1) and (g_btKimItemOneLevel <= 5) then d := g_WMainImages.Images[785 + g_btKimItemOneLevel - 2]
        else d := g_WMainImages.Images[791];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if DStartKimNeedle.ShowHint then begin
          d := g_WMainImages.Images[758];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
          if (g_MovingItem.Item.S.StdMode = 18) and g_boItemMoving then begin
            if (g_MovingItem.Item.S.Shape = g_btKimItemOneLevel) or (g_btKimItemOneLevel = 0) then begin
              d:=FrmMain.UiDXImageList.Items.Find('MakeWineSel').PatternSurfaces[0];
              if d<>nil then
                DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 0, 0, d.Width, d.Height, 150);
            end else begin
              dTemp := TDirectDrawSurface.Create(frmMain.DXDraw.DDraw);
              try
                dTemp.SystemMemory := TRUE;
                dTemp.SetSize(33, 31);
                dTemp.Fill(56);
                DrawBlendEx (dsurface, SurfaceX(GLeft), SurfaceY(GTop), dTemp, 0, 0, dTemp.Width, dTemp.Height, 150);
              finally
                dTemp.Free;
              end;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWKimNeedleMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DKimNeedle1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ShowHint(TDButton(Sender).SurfaceX(TDButton(Sender).GLeft), TDButton(Sender).SurfaceY(TDButton(Sender).GTop)-19, '金针' , clWhite, FALSE);
end;

procedure TFrmDlg.DKimNeedle6MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ShowHint(TDButton(Sender).SurfaceX(TDButton(Sender).GLeft)-2, TDButton(Sender).SurfaceY(TDButton(Sender).GTop)-19, '幸运符' , clWhite, FALSE);
end;

procedure TFrmDlg.ShowKimNeedle(Bool: Boolean);
begin
  DKimNeedle1.Visible := Bool;
  DKimNeedle2.Visible := Bool;
  DKimNeedle3.Visible := Bool;
  DKimNeedle4.Visible := Bool;
  DKimNeedle5.Visible := Bool;
  DKimNeedle6.Visible := Bool;
  DKimNeedle7.Visible := Bool;
  DKimNeedle8.Visible := Bool;
end;

procedure TFrmDlg.DKimNeedleHelpClick(Sender: TObject; X, Y: Integer);
begin
  if DStartKimNeedle.ShowHint then Exit;
  DKimNeedleMemo.ShowHint := False;
  DKimNeedleHelp.ShowHint := True;
  ShowKimNeedle(False);
  DKimNeedleBar.Visible := False;
end;

procedure TFrmDlg.DKimNeedleMemoClick(Sender: TObject; X, Y: Integer);
begin
  if DStartKimNeedle.ShowHint then Exit;
  DKimNeedleHelp.ShowHint := False;
  DKimNeedleMemo.ShowHint := True;
  ShowKimNeedle(True);
  DKimNeedleBar.Visible := False;
end;

procedure TFrmDlg.DStartKimNeedleClick(Sender: TObject; X, Y: Integer);
var
  I, nItemMakeIdx: Integer;
  sStr: string;
begin
  if DStartKimNeedle.ShowHint then Exit;
  DKimNeedleHelp.ShowHint := False;
  DKimNeedleMemo.ShowHint := False;
  ShowKimNeedle(True);
  DKimNeedleBar.Visible := True;
  sStr := '';
  nItemMakeIdx:= 0;
  for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
    if g_KimNeedleItem[I].S.Name <> '' then begin
      if (g_KimNeedleItem[I].S.StdMode = 17) and (nItemMakeIdx = 0) then nItemMakeIdx:= g_KimNeedleItem[I].MakeIndex
      else if g_KimNeedleItem[I].MakeIndex > 0 then sStr := sStr + IntToStr(g_KimNeedleItem[I].MakeIndex) + '/';
    end;
  end;
  if nItemMakeIdx >0 then begin
    DStartKimNeedle.ShowHint := True;
    DKimNeedleBar.ShowHint := True;
    boKimShowBarSend := True;
    KimShowBarImginsex := g_nKimSuccessRate;
  end;
end;

procedure TFrmDlg.DKimNeedleCloseClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
begin
  if DStartKimNeedle.ShowHint then Exit;
  DWKimNeedle.Visible := False;
  DItemBag.Visible := FALSE;
  for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
    if g_KimNeedleItem[I].S.Name <> '' then begin
      AddItemBag(g_KimNeedleItem[I]);
      g_KimNeedleItem[I].S.Name := '';
    end;
  end;
end;

{-97..-98是金币
-45..-46是请酒里的烧酒物品
-47..-53是酿酒物品
-54..63是挑战物品
-64..71是金针物品}
procedure TFrmDlg.DKimNeedle1Click(Sender: TObject; X, Y: Integer);
var
   temp: TClientItem;
   butt: TDButton;
   I: Integer;
begin
   if DStartKimNeedle.ShowHint then Exit;
   butt := TDButton(Sender);
   if not g_boItemMoving then begin
      if g_KimNeedleItem[butt.Tag].S.Name <> '' then begin
         ItemClickSound (g_KimNeedleItem[butt.Tag].s);
         if g_MovingItem.Item.S.Name <> '' then exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Index := -(butt.Tag + 64);
         g_MovingItem.Item := g_KimNeedleItem[butt.Tag];
         if g_nKimSuccessRate >= g_KimNeedleItem[butt.Tag].S.AniCount then begin
           Dec(g_nKimSuccessRate, g_KimNeedleItem[butt.Tag].S.AniCount);
         end else g_nKimSuccessRate := 0;
         g_KimNeedleItem[butt.Tag].S.Name := '';
         if g_btKimItemNum > 0 then Dec(g_btKimItemNum);
         if (g_btKimNeedleNum > 0) and (g_MovingItem.Item.S.StdMode = 17) then Dec(g_btKimNeedleNum);
         if g_btKimItemNum = 0 then begin
           g_btKimItemOneLevel:= 0;
           g_nKimSuccessRate := 0;
           g_btKimNeedleNum:= 0;
         end;
      end;
   end else begin
      if (g_MovingItem.Index >= 0) or (g_MovingItem.Index = -64) or (g_MovingItem.Index = -65) or (g_MovingItem.Index = -66)
         or (g_MovingItem.Index = -67) or (g_MovingItem.Index = -68) or (g_MovingItem.Index = -69) or (g_MovingItem.Index = -70) or (g_MovingItem.Index = -71) then begin
           case butt.Tag of
             0..4: begin
               if (g_MovingItem.Item.S.StdMode <> 17) or (not (g_MovingItem.Item.S.Shape in [1..5])) or (g_MovingItem.Item.Dura <> 1) then Exit;
               if (g_MovingItem.Item.S.Shape = g_btKimItemOneLevel) and (g_btKimNeedleNum > 1) then begin
                 case g_btKimItemOneLevel of
                   2: if g_btKimNeedleNum >= 3 then Exit;
                   3..5: if g_btKimNeedleNum >= 2 then Exit;
                 end;
               end;
             end;
             5..7: if (g_MovingItem.Item.S.StdMode <> 18) then Exit;
           end;
           if (g_btKimItemNum <> 0) then begin
             if (g_MovingItem.Item.S.Shape <> g_btKimItemOneLevel) then begin
               for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
                 if g_KimNeedleItem[I].S.Name <> '' then begin
                   AddItemBag(g_KimNeedleItem[I]);
                   g_KimNeedleItem[I].S.Name := '';
                 end;
               end;
               g_btKimItemNum:= 0;
               g_btKimNeedleNum := 0;
               g_nKimSuccessRate := 0;
             end;
           end;
           if (g_btKimItemNum = 0) then g_nKimSuccessRate := 0;
           ItemClickSound (g_MovingItem.Item.S);
           if g_KimNeedleItem[butt.Tag].S.Name <> '' then begin
              temp := g_KimNeedleItem[butt.Tag];
              g_KimNeedleItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Index := -(butt.Tag + 64);
              g_MovingItem.Item := temp
           end else begin
              g_KimNeedleItem[butt.Tag] := g_MovingItem.Item;
              g_MovingItem.Item.S.name := '';
              g_boItemMoving := FALSE;
              Inc(g_nKimSuccessRate, g_KimNeedleItem[butt.Tag].S.AniCount);
              if g_nKimSuccessRate >= 100 then  g_nKimSuccessRate := 100;
           end;
          if g_btKimItemNum < 9 then begin
            if (g_btKimNeedleNum < 5) and (g_KimNeedleItem[butt.Tag].S.StdMode = 17) then Inc(g_btKimNeedleNum);
            Inc(g_btKimItemNum);
            if g_btKimItemNum = 1 then begin
              g_btKimItemOneLevel := g_KimNeedleItem[butt.Tag].S.Shape;
              FrmDlg.DKimNeedleBar.ShowHint := False;
              g_btKimNeedleSuccessShape := 0;
              g_btKimNeedleSuccess := 0;
            end;
          end;
      end;
   end;
end;

procedure TFrmDlg.DKimNeedleBarDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I, nItemMakeIdx: Integer;
  sStr: string;
  d: TDirectDrawSurface;
  Rc: TRect;
begin
  with DKimNeedleBar do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_nKimSuccessRate > 0 then begin
      if not DKimNeedleBar.ShowHint{not g_boShowKimBar} then begin
        d := g_WMainImages.Images[759];
        if d <> nil then begin
           rc := d.ClientRect;
           rc.Right := Round((rc.Right-rc.Left) / 100 * g_nKimSuccessRate);
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end else begin
        if KimShowBarImginsex < 100 then begin
          if GetTickCount - KimShowBarTimeTick > 70 then begin
            KimShowBarTimeTick := GetTickCount();
            Inc(KimShowBarImginsex);
          end;
        end;
        if KimShowBarImginsex >= 100 then begin
          if boKimShowBarSend then begin
            sStr := '';
            nItemMakeIdx:= 0;
            for I:=Low(g_KimNeedleItem) to High(g_KimNeedleItem) do begin
              if g_KimNeedleItem[I].S.Name <> '' then begin
                if (g_KimNeedleItem[I].S.StdMode = 17) and (nItemMakeIdx = 0) then nItemMakeIdx:= g_KimNeedleItem[I].MakeIndex
                else if g_KimNeedleItem[I].MakeIndex > 0 then sStr := sStr + IntToStr(g_KimNeedleItem[I].MakeIndex) + '/';
              end;
            end;
            if nItemMakeIdx >0 then begin
              frmMain.SendKimItems(nItemMakeIdx, sStr);
            end else begin //显示锻造失败
              g_btKimNeedleSuccess := 2;
              FillChar (g_KimNeedleItem, sizeof(TClientItem)*8, #0);
              DStartKimNeedle.ShowHint := False;
              g_btKimItemNum := 0;
              g_btKimNeedleNum := 0;
              g_nKimSuccessRate := 0;
              g_btKimItemOneLevel := 0;
              g_btKimNeedleSuccessShape := 0;
            end;
            boKimShowBarSend := False;
          end;
        end;
        d := g_WMainImages.Images[757];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Right := Round((rc.Right-rc.Left) / 100 * KimShowBarImginsex);
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DStateSsasDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  {$IF M2Version <> 2} //不能去掉
  {$IFEND}
end;

procedure TFrmDlg.DStateSsasClick(Sender: TObject; X, Y: Integer);
var
  ly: Integer;
begin
  ly := Y - DStateSsas.GTop;
  if (ly >= 13) and (ly <= 55) then begin
    if StateTab = 0 then begin
      StatePage := 0;
      PageChanged;
    end else begin
      InternalForcePage := 0;
      InternalForcePageChanged;
    end;
  end else
  if (ly >= 56) and (ly <= 100) then begin
    if StateTab = 0 then begin
      StatePage := 1;
      PageChanged;
    end else begin
      InternalForcePage := 1;
      InternalForcePageChanged;
    end;
  end else
  if (ly >= 101) and (ly <= 144) then begin
    if StateTab = 0 then begin
      StatePage := 2;
      PageChanged;
    end else begin
      InternalForcePage := 2;
      InternalForcePageChanged;
    end;
  end else
  if (ly >= 145) and (ly <= 188) then begin
    if StateTab = 0 then begin
      StatePage := 3;
      PageChanged;
    end else begin
      InternalForcePage := 3;
      InternalForcePageChanged;
    end;
  end;
  if (ly >= 189) and (ly <= 233) then begin
    if StateTab = 0 then begin
      StatePage := 4;
      PageChanged;
    end;
  end;
end;

procedure TFrmDlg.DStateWinPulseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  hcolor: integer;
  btX, btY: Byte;
  sStr: string;
begin
  {$IF M2Version = 1}
  if g_MySelf = nil then exit;
  with DStateWinPulse do begin
    if WLib <> nil then begin //20080701
      if g_MySelf.m_btSex = 1 then begin //女
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 3]
        else if StatePulsePage = 4 then //奇经
          d := WLib.Images[1188]
        else d := WLib.Images[FaceIndex + 2];
      end else begin
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 1]
        else if StatePulsePage = 4 then //奇经
          d := WLib.Images[1186]
        else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1171]
    else d := g_WMainImages.Images[830+StatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft) + 92, SurfaceY(GTop) + 6, d.ClientRect, d, TRUE);
    if StatePulsePage = 4 then begin//奇经
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        hcolor := 1180
      else hcolor := 1181+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[hcolor];
    end else begin
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        hcolor := 860
      else hcolor := 861+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[hcolor+StatePulsePage * 10];
    end;
    if d <> nil then
    DrawBlend(dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 255);
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1172]
    else d := g_WMainImages.Images[840+StatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    
    if ((g_btPulseOriginPage = StatePulsePage) or (StatePulsePage = 4){奇经}) and (g_btPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;
    //-----------------穴位位置---------------------
    case StatePulsePage of
      0: begin
        btX := 37;
        btY := 30;
      end;
      1: begin
        btX := 48;
        btY := 24;
      end;
      2: begin
        btX := 47;
        btY := 38;
      end;
      3: begin
        btX := 48;
        btY := 20;
      end;
      4: begin
        btX := 47;
        btY := 16;
      end;
      else begin
        btX := 0;
        btY := 0;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then
      d := g_WMainImages.Images[851]
    else if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1)) or (StatePulsePage = 4){奇经} then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1)) or ((StatePulsePage = 4) and (g_HumanPulseArr[StatePulsePage].nPulsePoint = 0)){奇经} then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
      end;
    end;
    case StatePulsePage of
      0: begin
        btX := 36;
        btY := 59;
      end;
      1: begin
        btX := 48;
        btY := 64;
      end;
      2: begin
        btX := 41;
        btY := 68;
      end;
      3: begin
        btX := 48;
        btY := 40;
      end;
      4: begin
        btX := 92;
        btY := 102;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (StatePulsePage <> 4{奇经}) and (g_btPulsePoint = 2) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if ((g_btPulseOriginPage = StatePulsePage) and (StatePulsePage <> 4{奇经})) and (g_btPulsePoint = 2) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
      end;
    end;

    case StatePulsePage of
      0: begin
        btX := 38;
        btY := 84;
      end;
      1: begin
        btX := 54;
        btY := 104;
      end;
      2: begin
        btX := 41;
        btY := 106;
      end;
      3: begin
        btX := 48;
        btY := 61;
      end;
      4: begin
        btX := 3;
        btY := 101;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
      end;
    end;
    case StatePulsePage of
      0: begin
        btX := 45;
        btY := 106;
      end;
      1: begin
        btX := 61;
        btY := 143;
      end;
      2: begin
        btX := 36;
        btY := 139;
      end;
      3: begin
        btX := 48;
        btY := 85;
      end;
      4: begin
        btX := 65;
        btY := 185;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
      end;
    end;
    case StatePulsePage of
      0: begin
        btX := 52;
        btY := 88;
      end;
      1: begin
        btX := 64;
        btY := 184;
      end;
      2: begin
        btX := 33;
        btY := 175;
      end;
      3: begin
        btX := 48;
        btY := 109;
      end;
      4: begin
        btX := 29;
        btY := 186;
      end;
    end;
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then
      d := g_WMainImages.Images[851]
    else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
    if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
      end;
    end;
    //------------------导航显示----------------------
    if StatePulsePage = 0 then
      d := g_WMainImages.Images[812]
    else d := g_WMainImages.Images[813];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+23, d.ClientRect, d, TRUE);
    if g_HumanPulseArr[0].boOpenPulse then begin
      if StatePulsePage = 1 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+47, d.ClientRect, d, TRUE);
    end;
    if g_HumanPulseArr[1].boOpenPulse then begin
      if StatePulsePage = 2 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+71, d.ClientRect, d, TRUE);
    end;
    if g_HumanPulseArr[2].boOpenPulse then begin
      if StatePulsePage = 3 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+95, d.ClientRect, d, TRUE);
    end;
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[812]
    else d := g_WMainImages.Images[813];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop), d.ClientRect, d, TRUE);
    //----------------鼠标移过导航--------------------
    btX := 140;
    btY := 28;
    if g_btStateWinPulseMoving = 1 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $008BC4ED;
        btX := 141;
        btY := 29;
      end else if StatePulsePage = 0 then hcolor := $008BC4ED
      else hcolor := $006C849A;
    end else if StatePulsePage = 0 then hcolor := $008BC4ED
    else hcolor := $006C849A;
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '冲脉');
    if g_HumanPulseArr[0].boOpenPulse then begin
      btX := 140;
      btY := 52;
      if g_btStateWinPulseMoving = 2 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 53;
        end else if StatePulsePage = 1 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if StatePulsePage = 1 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴跷');
    end;
    if g_HumanPulseArr[1].boOpenPulse then begin
      btX := 140;
      btY := 75;
      if g_btStateWinPulseMoving = 3 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 76;
        end else if StatePulsePage = 2 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if StatePulsePage = 2 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴维');
    end;
    if g_HumanPulseArr[2].boOpenPulse then begin
      btX := 140;
      btY := 99;
      if g_btStateWinPulseMoving = 4 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 100;
        end else if StatePulsePage = 3 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if StatePulsePage = 3 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '任脉');
    end;
    btX := 140;
    btY := 5;
    if g_btStateWinPulseMoving = 11 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $008BC4ED;
        btX := 141;
        btY := 6;
      end else if StatePulsePage = 4 then hcolor := $008BC4ED
      else hcolor := $006C849A;
    end else if StatePulsePage = 4 then hcolor := $008BC4ED
    else hcolor := $006C849A;
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '奇经');
    //-----------------------------------
    case StatePulsePage of
      0: begin
        btX := 81;
        btY := 35;
      end;
      1: begin
        btX := 4;
        btY := 29;
      end;
      2: begin
        btX := 2;
        btY := 41;
      end;
      3: begin
        btX := 2;
        btY := 25;
      end;
      4: begin
        btX := 4;
        btY := 22;
      end;
    end;
    if g_btStateWinPulseMoving = 5 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,0));
    case StatePulsePage of
      0: begin
        btX := 80;
        btY := 64;
      end;
      1: begin
        btX := 4;
        btY := 68;
      end;
      2: begin
        btX := 82;
        btY := 73;
      end;
      3: begin
        btX := 93;
        btY := 45;
      end;
      4: begin
        btX := 68;
        btY := 94;
      end;
    end;
    if g_btStateWinPulseMoving = 6 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,1));
    case StatePulsePage of
      0: begin
        btX := 2;
        btY := 89;
      end;
      1: begin
        btX := 92;
        btY := 108;
      end;
      2: begin
        btX := 1;
        btY := 110;
      end;
      3: begin
        btX := 3;
        btY := 67;
      end;
      4: begin
        btX := 26;
        btY := 116;
      end;
    end;
    if g_btStateWinPulseMoving = 7 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,2));
    case StatePulsePage of
      0: begin
        btX := 6;
        btY := 111;
      end;
      1: begin
        btX := 24;
        btY := 146;
      end;
      2: begin
        btX := 70;
        btY := 144;
      end;
      3: begin
        btX := 93;
        btY := 90;
      end;
      4: begin
        btX := 42;
        btY := 178;
      end;
    end;
    if g_btStateWinPulseMoving = 8 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,3));
    case StatePulsePage of
      0: begin
        btX := 86;
        btY := 92;
      end;
      1: begin
        btX := 29;
        btY := 189;
      end;
      2: begin
        btX := 66;
        btY := 180;
      end;
      3: begin
        btX := 4;
        btY := 114;
      end;
      4: begin
        btX := 3;
        btY := 190;
      end;
    end;
    if g_btStateWinPulseMoving = 9 then begin
      if g_boStateWinPulseDowning then begin
        hcolor := $0048A4E8;
        btX := btX + 1;
        btY := btY + 1;
      end else hcolor := $00A8D4E8;
    end else hcolor := $0088C4E8;  //普通颜色
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(StatePulsePage,4));

    if StatePulsePage <> 4 then begin
      if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
        case g_HumanPulseArr[StatePulsePage].nPulseLevel of
          0: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
          end;
          1: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          2: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          3: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          4: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          5: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
        end;
      end else begin
        dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
        dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
        dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
        dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
      end;
    end;

    if g_btStateWinPulseMoving = 10 then begin
      if g_boStateWinPulseDowning then
        d := g_WMainImages.Images[815]
      else d := g_WMainImages.Images[814];
    end else d := g_WMainImages.Images[814];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+7, SurfaceY(GTop)+210, d.ClientRect, d, TRUE);
    case StatePulsePage of
      0: sStr := '修炼冲脉';
      1: sStr := '修炼阴跷';
      2: sStr := '修炼阴维';
      3: sStr := '修炼任脉';
      4: sStr := '修炼奇经';
    end;
    btX := 13;
    btY := 214;
    if (g_HumanPulseArr[StatePulsePage].nPulseLevel >= 5) or ((g_HumanPulseArr[StatePulsePage].nPulsePoint = 0) and (StatePulsePage = 4)) then begin
      hcolor := clGray{00777C7B};
    end else begin
      if g_btStateWinPulseMoving = 10 then begin
        if g_boStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
    end;
    dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, sStr);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStateWinPulseMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwInternalForceLevel >= nlevel then Result := '~y';
  end;
var
  lx, ly: Integer;
  str: string;
begin
  {$IF M2Version = 1}
  DScreen.ClearHint;

  g_boStateWinPulseDowning := False;
  g_btStateWinPulseMoving := 0;
  lx := X - DStateWinPulse.GLeft;
  ly := Y - DStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    g_btStateWinPulseMoving := 1;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[0].boOpenPulse then begin
      if g_HumanPulseArr[0].nPulseLevel = 1 then begin
        str := GetPulsDesc(Format('冲脉%d-%d',[g_HumanPulseArr[0].nPulseLevel,g_MySelf.m_btJob]));
      end else begin
        if g_HumanPulseArr[0].nPulseLevel = 0 then str := GetPulsDesc('冲脉已通')
        else str := GetPulsDesc(Format('冲脉%d',[g_HumanPulseArr[0].nPulseLevel]));
      end;
      if str <> '' then begin
        with g_BatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end else begin
      str := GetPulsDesc('冲脉未通');
      if str <> '' then begin
        with g_BatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    g_btStateWinPulseMoving := 2;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[0].boOpenPulse then begin
      if g_HumanPulseArr[1].boOpenPulse then begin
        if g_HumanPulseArr[1].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('阴跷%d-%d',[g_HumanPulseArr[1].nPulseLevel,g_MySelf.m_btJob]));
        end else begin
          if g_HumanPulseArr[1].nPulseLevel = 0 then str := GetPulsDesc('阴跷已通')
          else str := GetPulsDesc(Format('阴跷%d',[g_HumanPulseArr[1].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴跷未通');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    g_btStateWinPulseMoving := 3;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[1].boOpenPulse then begin
      if g_HumanPulseArr[2].boOpenPulse then begin
        if g_HumanPulseArr[2].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('阴维%d-%d',[g_HumanPulseArr[2].nPulseLevel,g_MySelf.m_btJob]));
        end else begin
          if g_HumanPulseArr[2].nPulseLevel = 0 then str := GetPulsDesc('阴维已通')
          else str := GetPulsDesc(Format('阴维%d',[g_HumanPulseArr[2].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴维未通');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    g_btStateWinPulseMoving := 4;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    if g_HumanPulseArr[2].boOpenPulse then begin
      if g_HumanPulseArr[3].boOpenPulse then begin
        if g_HumanPulseArr[3].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('任脉%d-%d',[g_HumanPulseArr[3].nPulseLevel,g_MySelf.m_btJob]));
        end else begin
          if g_HumanPulseArr[3].nPulseLevel = 0 then str := GetPulsDesc('任脉已通')
          else str := GetPulsDesc(Format('任脉%d',[g_HumanPulseArr[3].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('任脉未通');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if  (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24)  then begin //奇经
    g_btStateWinPulseMoving := 11;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    str := GetPulsDesc('奇经');
    {if g_HumanPulseArr[4].nPulseLevel = 0 then str := GetPulsDesc('奇经已通')
    else str := GetPulsDesc(Format('奇经%d',[g_HumanPulseArr[3].nPulseLevel]));  }
    if str <> '' then begin
      with g_BatterDesc do begin
        sName := GetPulsePageName(4);
        str := GetValidStr3 (str, sLine1, ['\']);
        str := GetValidStr3 (str, sLine2, ['\']);
        str := GetValidStr3 (str, sLine3, ['\']);
      end;
    end;
  end else
  if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
    g_btStateWinPulseMoving := 10;
    if ssLeft in Shift then  g_boStateWinPulseDowning := True;
    with g_BatterDesc do begin
      sName := ' ';
      sLine1 := '欲练连击，必练内功；打通五穴';
      sLine2 := '，经络自通。欲强连击，锻造金';
      sLine3 := '针；修炼经络，威力提升。';
    end;
  end;
  case StatePulsePage of
    0: begin
      //1
      if (lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47){字} then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 106, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+34, format('%s穴:已打通',[GetPulseName(StatePulsePage,0)]) , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 106, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+34,
                      format('%s穴:待打通',[GetPulseName(StatePulsePage,0)])+'~y\'+format('需要内功等级：%d',[g_btPulseLevel])+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 106, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+34,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 62, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+29, '幽门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 62, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+29,
                      '幽门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 62, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+29,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);;//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76){字} then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 105, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 105, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 105, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+58, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+58,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+58,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      // x 24 y 12
      if (lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+88, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+88,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+88,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 63, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+83, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 63, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+83,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 63, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+83,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 31, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+110, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 31, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+110,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 31, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+110,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 70, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 70, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 70, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 111, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+91, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 111, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+91,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 111, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+91,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 77, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+87, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 77, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+87,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 77, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+87,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    1: begin
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+28, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+28,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+28,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+23, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+23,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+23,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+63,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+107, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+107,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+107,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 79, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+103, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 79, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+103,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
           DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 79, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+103,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 49, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+145, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 49, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+145,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 49, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+145,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 87, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+142, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 87, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+142,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 87, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+142,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+188, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+188,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+188,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 89, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+183, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 89, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+183,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 89, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+183,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    2: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+40, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+40,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+40,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+37, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+37,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+37,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 107, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+72, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 107, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+72,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 107, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+72,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+67,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 26, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+109, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 26, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+109,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 26, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+109,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 66, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+105,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 95, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+143, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 95, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+143,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 95, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+143,
                  '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+138, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+138,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 61, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+138,
                      '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 91, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+179, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 91, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+179,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 91, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+179,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 58, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+174, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 58, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+174,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 58, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+174,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    3: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+24, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+24,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 27, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+24,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+19, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+19,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+19,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+44, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+44,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+44,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+39, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+39,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+39,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+66, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+66,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+66,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+60, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+60,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+60,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+89, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+89,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 118, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+89,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+84, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+84,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+84,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+113, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+113,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+113,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+108, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+108,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 73, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+108,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
    end;
    4: begin //奇经
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34) then begin
        g_btStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+21, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin//if {(g_btPulseOriginPage = StatePulsePage) and }(g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+21,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel)}, FALSE, FALSE, 0);
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 29, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+21,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end; }
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+15, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin//if {(g_btPulseOriginPage = StatePulsePage) and }(g_btPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+15,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel)}, FALSE, FALSE, 0);
          {str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 72, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+15,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;}
      end;
      //2
      if (lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106) then begin
        g_btStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 93, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+93, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 93, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+93,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 93, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+93,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;   }
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'夹脊穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+101, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+101,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 117, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+101,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,1)]);//'天突穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //3
      if (lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128) then begin
        g_btStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 51, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+115, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 51, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+115,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 51, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+115,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+100, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+100,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+100,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //4
      if (lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190) then begin
        g_btStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 67, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+177, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 67, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+177,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 67, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+177,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end;
        str := GetPulsDesc('八风');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 90, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+184, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 90, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+184,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 90, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+184,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('八风');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //5
      if (lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202) then begin
        g_btStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boStateWinPulseDowning := True;
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+189, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+189,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 28, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+189,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+185, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+185,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btPulseLevel)+GetRGB(g_btPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin
          DScreen.ShowTzHint (DStateWinPulse.SurfaceX(DStateWinPulse.GLeft)+ 54, DStateWinPulse.SurfaceY(DStateWinPulse.GTop)+185,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_BatterDesc do begin
              sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_BatterDesc do begin
            sName := format('%s穴:',[GetPulseName(StatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStateWinPulseClick(Sender: TObject; X, Y: Integer);
var
  lx, ly: Integer;
begin
  {$IF M2Version = 1}
  lx := X - DStateWinPulse.GLeft;
  ly := Y - DStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    StatePulsePage := 0;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    if g_HumanPulseArr[0].boOpenPulse then StatePulsePage := 1;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    if g_HumanPulseArr[1].boOpenPulse then StatePulsePage := 2;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    if g_HumanPulseArr[2].boOpenPulse then StatePulsePage := 3;
  end;
  if (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24) then begin
    StatePulsePage := 4;
  end;
  case StatePulsePage of
    0: begin
      //1
      //x24 y23
      if ((lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47)){字} or ((lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      // x 24 y 12
      if ((lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101)){字} or ((lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123)){字} or ((lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104)){字} or ((lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    1: begin
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120)){字} or ((lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158)){字} or ((lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201)){字} or ((lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    2: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192)){字} or ((lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    3: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then frmMain.SendOpenPulsePoint(StatePulsePage, 1);
      end;
      //2
      if ((lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 1 then frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 2 then frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 3 then frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 4 then frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;
    end;
    4: begin //奇经
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39)){图} then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenPulsePoint(StatePulsePage, 1);
        end else begin
          ShowQJPractice(False);
        end;
      end;
      //2
      (*if ((lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106)){字} or ((lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 2);
      end;
      //3
      if ((lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128)){字} or ((lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 3);
      end;
      //4
      if ((lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190)){字} or ((lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 4);
      end;
      //5
      if ((lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202)){字} or ((lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209)){图} then begin
        frmMain.SendOpenPulsePoint(StatePulsePage, 5);
      end;      *)
    end;
  end;
  if ((lx >= 7) and (lx <= 67) and (ly >= 210) and (ly <= 231)) then begin
    if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
      if g_HumanPulseArr[StatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendPracticePulse(StatePulsePage);
      end;
    end else begin
      case StatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HumanPulseArr[StatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(False);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  icon: Integer;
begin
  {$IF M2Version = 1}
  with Sender as TDButton do begin
    if Sender = DWinBatterTopMag4 then begin
      if not g_boOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(TDButton(Sender).GLeft-4), SurfaceY(TDButton(Sender).GTop-4), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;

    if g_WinBatterMagicList.Count > 0 then begin
      if g_WinBatterTopMagic[TDButton(Sender).Tag].Def.sMagicName <> '' then begin
        case g_WinBatterTopMagic[TDButton(Sender).Tag].Def.btEffect of
         102:icon := 952;//三绝杀
         103:icon := 944;//双龙破
         104:icon := 934;//虎啸诀
         105:icon := 950;//追心刺
         106:icon := 942;//凤舞祭
         107:icon := 936;//八卦掌
         108:icon := 956;//断岳斩
         109:icon := 946;//惊雷爆
         110:icon := 932;//三焰咒
         111:icon := 954;//横扫千军
         112:icon := 940;//冰天雪地
         113:icon := 930;//万剑归宗
        else icon := -1;
        end;
        if TDButton(Sender).Downed then
          d := g_WMainImages.Images[icon+1]
        else d := g_WMainImages.Images[icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
      end else begin
        if TDButton(Sender).Downed then begin
          if g_WinBatterTopMagic[TDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TDButton(Sender).Tag*2+1];
          end;
        end else begin
          if g_WinBatterTopMagic[TDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TDButton(Sender).Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
        if (g_WinBatterTopMagic[0].Def.sMagicName = '') and (g_WinBatterTopMagic[1].Def.sMagicName = '') and (g_WinBatterTopMagic[2].Def.sMagicName = '') and (g_WinBatterTopMagic[3].Def.sMagicName = '')
           and (g_WinBatterTopMagic[0].CurTrain <> 1) and (g_WinBatterTopMagic[1].CurTrain <> 1) and (g_WinBatterTopMagic[2].CurTrain <> 1) and (g_WinBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DWinBatterTopMag1 then begin
            if (not TDButton(Sender).Downed) and (not DWinBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TDButton(Sender).GLeft)+10, SurfaceY(TDButton(Sender).GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DStateWinBatterDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  bbx, bby, I, icon, trainlv: Integer;
  magtop, magline, m: Byte;
  pm: PTClientMagic;
begin
  {$IF M2Version = 1}
  with DStateWinBatter do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

        d := g_WMainImages.Images[912];
        if d <> nil then
         dsurface.Draw (SurfaceX(GLeft)+118, SurfaceY(GTop)+6, d.ClientRect, d, TRUE);

        bbx := SurfaceX(GLeft) - 2;
        bby := SurfaceY(GTop) + 81;

        magtop := 0;//InternalForceMagicPage * 6;
        magline := _MIN(4, g_WinBatterMagicList.count);//_MIN(InternalForceMagicPage*6+6, g_InternalForceMagicList.Count);
        for i:=magtop to magline-1 do begin
           pm := PTClientMagic (g_WinBatterMagicList[i]);
           m := i - magtop;
           case pm.Def.btEffect of
             102:icon := 952;//三绝杀
             103:icon := 944;//双龙破
             104:icon := 934;//虎啸诀
             105:icon := 950;//追心刺
             106:icon := 942;//凤舞祭
             107:icon := 936;//八卦掌
             108:icon := 956;//断岳斩
             109:icon := 946;//惊雷爆
             110:icon := 932;//三焰咒
             111:icon := 954;//横扫千军
             112:icon := 940;//冰天雪地
             113:icon := 930;//万剑归宗
             else icon := -1;
           end;
           d := g_WMainImages.Images[icon];
           if d <> nil then
              dsurface.Draw (bbx + 9, bby+7+m*38, d.ClientRect, d, TRUE);
                      
           d := g_WMainImages.Images[112]; //lv
           if d <> nil then
              dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);

           d := g_WMainImages.Images[111]; //exp
           if d <> nil then begin
              dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
           end;
        end;
           for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_WinBatterMagicList[i]);
              m := i - magtop;
              if not (pm.Level in [0..5]) then pm.Level := 0;
              case pm.Def.btEffect of
                102..104: begin
                  case Ord(pm.Key) of
                    1:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+15%暴击');
                    end;
                    3: begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+25%暴击');
                    end;
                    4: begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%+30%暴击');
                    end;
                    else
                    dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[0].nStormsHit)+'%暴击');
                  end;
                end;
                105..107: begin
                  case Ord(pm.Key) of
                     1:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+10%暴击');
                     end;
                     2:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+15%暴击');
                     end;
                     3:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+25%暴击');
                     end;
                     4:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%+30%暴击');
                     end;
                     else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[1].nStormsHit)+'%暴击');
                  end;
                end;
                108..110: begin
                  case Ord(pm.Key) of
                    1:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+15%暴击');
                    end;
                    3:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+25%暴击');
                    end;
                    4:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%+30%暴击');
                    end;
                    else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[2].nStormsHit)+'%暴击');
                  end;
                end;
                111..113: begin
                  case Ord(pm.Key) of
                    1:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+15%暴击');
                    end;
                    3:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+25%暴击');
                    end;
                    4:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%+30%暴击');
                    end;
                    else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HumanPulseArr[3].nStormsHit)+'%暴击');
                  end;
                end;
              end;
              if pm.Level in [0..3,5] then trainlv := pm.Level
              else if pm.Level = 4 then trainlv := 3
              else trainlv := 0;
              dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                 if trainlv < 5 then
                    dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                 else dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
              end;
           end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterComDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  I: Integer;
  btLine: Byte;
  sStr: string;
begin
  with DWinBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if WinBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+WinBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+WinBatterComIndex*15+19), clNavy);
    end;
    btLine := _MIN(4, g_WinBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_WinBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_WinBatterMagicList.Items[I]).Def.sMagicName;
        if I = WinBatterComIndex then
          dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if WinBatterComIndex = btLine then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if WinBatterComIndex = btLine +1 then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
end;

procedure TFrmDlg.DHeroSpleenDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{var
  d: TDirectDrawSurface;}
begin
{  with DHeroSpleen do begin
    if g_WinBatterMagicList.Count > 0 then begin
      d := g_WMainImages.Images[1127];
      if d = nil then d := g_WMain3Images.Images[410];
    end else d := g_WMain3Images.Images[410];
    if d <> nil then
      dsurface.Draw (SurfaceX(Left), SurfaceY(Top), d.ClientRect, d, TRUE);
  end;  }
end;

procedure TFrmDlg.DBatterShowImgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DBatterShowImg do begin
    if WLib <> nil then begin
      if {(not DHeroSpleen.Visible) and} (g_WinBatterMagicList.Count > 0)then begin
        d := g_WMainImages.Images[1120];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          if g_boCanUseBatter then begin
            if GetTickCount - BatterShowTimeTick > 200 then begin
              BatterShowTimeTick := GetTickCount;
              Inc(BatterShowImginsex);
              if BatterShowImginsex > 1 then BatterShowImginsex := 0;
            end;
            d := g_WMainImages.Images[1121+BatterShowImginsex];
            if d<>nil then
             dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWinBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  btLine: Byte;
  ss: Integer;
begin
  with DWinBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_WinBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    WinBatterComIndex := ss;
  end;
end;

procedure TFrmDlg.DWinBatterComMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
begin
  if WinBatterComIndex <> - 1 then begin
    if g_WinBatterMagicList.Count - WinBatterComIndex > 0 then begin
      for I:=Low(g_WinBatterTopMagic) to High(g_WinBatterTopMagic) do begin
        if g_WinBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_WinBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_WinBatterTopMagic[BatterTopMagIndex] := pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^;
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 0;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_WinBatterMagicList[WinBatterComIndex]);
      pm.Key := Chr(BatterTopMagIndex + 1);
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, Chr(BatterTopMagIndex + 1), str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = 0 then begin//空
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = -1 then begin//随机
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 1;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end;
    DWinBatterCom.Visible := False;
  end;
end;

procedure TFrmDlg.DWinBatterRandomDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  {$IF M2Version = 1}
  with Sender as TDButton do begin
    if not TDButton(Sender).Downed then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + GWidth div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $008CC6EF, clBlack, TDButton(Sender).Hint);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + GWidth div 2 + 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 6, $0040BBF1, clBlack, TDButton(Sender).Hint);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterRandomClick(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  I: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  FillChar (g_WinBatterTopMagic, sizeof(TClientMagic)*4, #0);
  if g_WinBatterMagicList.Count > 0 then begin
    for i:=0 to g_WinBatterMagicList.Count-1 do begin
      pm := PTClientMagic (g_WinBatterMagicList[i]);
      if (Ord(pm.Key) = 1) or (Ord(pm.Key) = 2) or (Ord(pm.Key) = 3) or (Ord(pm.Key) = 4) then begin
        pm.Key := #0;
        FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
      end;
    end;
  end;
  g_WinBatterTopMagic[0].CurTrain := 1;
  g_WinBatterTopMagic[1].CurTrain := 1;
  g_WinBatterTopMagic[2].CurTrain := 1;
  g_WinBatterTopMagic[3].CurTrain := 1;
  FrmMain.SendMagicKeyChange (-1, #0, '1/1/1/1');
{$IFEND}
end;

procedure TFrmDlg.DWinBatterSetKeyClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  g_btSdoAssistantPage := 5;
  NewSdoAssistantPageChanged();
  frmMain.OpenSdoAssistant();
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DWinBatterTopMag1 then begin
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterTopMag2 then begin
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterTopMag3 then begin
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterTopMag4 then begin
    if not g_boOpen4BatterSkill then Exit;
    DScreen.ShowHint(DWinBatterTopMag1.SurfaceX(DWinBatterTopMag1.GLeft) - 137, DWinBatterTopMag1.SurfaceY(DWinBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterRandom then begin
    DScreen.ShowHint(DWinBatterRandom.SurfaceX(DWinBatterRandom.GLeft), DWinBatterRandom.SurfaceY(DWinBatterRandom.GTop+DWinBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DWinBatterSetKey then begin
    DScreen.ShowHint(DWinBatterSetKey.SurfaceX(DWinBatterSetKey.GLeft) - 60, DWinBatterSetKey.SurfaceY(DWinBatterSetKey.GTop+DWinBatterSetKey.GHeight),
       '设置施展连击的快捷键'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWinBatterTopMag1MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Button = mbLeft then begin
    if Sender = DWinBatterTopMag4 then begin
      if not g_boOpen4BatterSkill then Exit;
    end;
    if g_WinBatterMagicList.Count > 0 then begin
      DWinBatterCom.GLeft := TDButton(Sender).GLeft-2;
      DWinBatterCom.GTop := TDButton(Sender).GTop+TDButton(Sender).GHeight+1;
      BatterTopMagIndex := TDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
      WinBatterComIndex := -1;
      DWinBatterCom.Visible := True;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBigMerchantDlgClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  msg: TDefaultMessage;
  sData: string;
begin
   if GetTickCount < LastestClickTime then exit;
   L := DBigMerchantDlg.GLeft;
   T := DBigMerchantDlg.GTop;
   with DBigMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            PlaySound (s_glass_button_click);
            if DMerchantDlgSelect(p.RStr, p.TStr, sData) then
              FrmMain.SendMerchantDlgSelect(g_nCurMerchant, sData);
            LastestClickTime := GetTickCount + 2000; //20080803修改 以前为5000
            break;
         end;
      end;

end;

procedure TFrmDlg.DBigMerchantDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
  CloseMDlg;
  CloseMBigDlg;
end;

procedure TFrmDlg.DBigMerchantDlgCloseInitialize(Sender: TObject);
begin
  DBigMerchantDlgClose.SetImgIndex (g_WMainImages, 64);
end;

procedure TFrmDlg.DBigMerchantDlgInitialize(Sender: TObject);
begin
  DBigMerchantDlg.SetImgIndex (g_WMainImages, 402);
end;

procedure TFrmDlg.DBigMerchantDlgMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
   if GetTickCount < LastestClickTime then exit;
   SelectMenuStr := '';
   L := DBigMerchantDlg.GLeft;
   T := DBigMerchantDlg.GTop;
   with DBigMerchantDlg do
      if MDlgPoints.Count > 0 then //20080629
      for i:=0 to MDlgPoints.Count-1 do begin
         p := PTClickPoint (MDlgPoints[i]);
         if (X >= SurfaceX(L + p.rc.Left)) and (X <= SurfaceX(L + p.rc.Right)) and
            (Y >= SurfaceY(T + p.rc.Top)) and (Y <= SurfaceY(T + p.rc.Bottom)) then begin
            SelectMenuStr := p.RStr;
            break;
         end;
      end;
   if DHeroIcon.Visible then DHeroIcon.Visible := False;  //20080521
end;

procedure TFrmDlg.DBigMerchantDlgMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  SelectMenuStr := '';
end;

procedure TFrmDlg.DWinBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  pm: PTClientMagic;
begin
  if g_WinBatterMagicList.Count - 1 >= TDButton(Sender).Tag then begin
    pm := PTClientMagic (g_WinBatterMagicList[TDButton(Sender).Tag]);
    case pm.Def.btEffect of
      102: begin  //三绝杀
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      111: begin //横扫千军
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以自身为';
          sLine2 := '中心，对5*5范围内的目标造成';
          sLine3 := '伤害';
        end;
      end;
      105: begin //追心刺
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，冲撞单体';
          sLine2 := '目标，在迫使其后退的同时，造';
          sLine3 := '成伤害';
        end;
      end;
      108: begin //断岳斩
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对三步内';
          sLine2 := '的单体目标造成伤害';
          sLine3 := '';
        end;
      end;
      112, 113: begin //冰天雪地 万剑归宗
        with g_BatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以目标为';
          sLine2 := '中心，对5*5范围内造成持续伤 ';
          sLine3 := '害';
        end;
      end;
      else g_BatterDesc.sName := '';
    end;
  end;
end;

procedure TFrmDlg.DStateWinBatterMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
   DScreen.ClearHint;
end;

procedure TFrmDlg.DHeroStateSsasClick(Sender: TObject; X, Y: Integer);
var
  ly: Integer;
begin
  ly := Y - DHeroStateSsas.GTop;
  if (ly >= 13) and (ly <= 55) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 0;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 0;
      HeroInternalForcePageChanged;
    end;
  end else
  if (ly >= 56) and (ly <= 100) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 1;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 1;
      HeroInternalForcePageChanged;
    end;
  end else
  if (ly >= 101) and (ly <= 144) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 2;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 2;
      HeroInternalForcePageChanged;
    end;
  end else
  if (ly >= 145) and (ly <= 188) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 3;
      HeroPageChanged;
    end else begin
      HeroInternalForcePage := 3;
      HeroInternalForcePageChanged;
    end;
  end;
  if (ly >= 189) and (ly <= 233) then begin
    if HeroStateTab = 0 then begin
      HeroStatePage := 4;
      HeroPageChanged;
    end;
  end;
end;

procedure TFrmDlg.DHeroStateSsasDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
{$IF M2Version <> 2} //不能去掉
{$IFEND}
end;

procedure TFrmDlg.DMemoWhisperListDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  pcp: pTClickSLPoint;
  data: string;
begin
  with DMemoWhisperList do begin
    with dsurface.Canvas do begin
        Brush.Color := clWindowText;//FSelCol;
        FillRect(Rect(SurfaceX(GLeft),  //左边
                      SurfaceY(GTop),      //上边
                      SurfaceX(GLeft)+GWidth,   //右边
                      SurfaceY(GTop)+GHeight));//下边
        //=================================================
        pen.Color := $00638494;    //画边界线
        if TDEdit(Sender).Focused then pen.Color := $005993BD;
        MoveTo(SurfaceX(GLeft),   SurfaceY(GTop));
        LineTo(SurfaceX(GLeft)+GWidth,   SurfaceY(GTop));
        LineTo(SurfaceX(GLeft)+GWidth,   SurfaceY(GTop)+GHeight);
        LineTo(SurfaceX(GLeft),   SurfaceY(GTop)+GHeight);
        LineTo(SurfaceX(GLeft),   SurfaceY(GTop));
        //==================================================
      Release;
    end;                      //防止除0错误By TasNat at: 2012-10-19 09:22:28
    ElemCount:= (GHeight - 2) div _MAX(1, LinesHeight);  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for I:= 0 to ElemCount - 1 do begin
      data := Lines.Strings[I+TopIndex];
      if data <> '' then begin
        if WhisperAddPoints then begin
           new (pcp);
           pcp.rc := Rect (4, I*LinesHeight+4, 336, I*LinesHeight + 14);
           pcp.RStr := data+inttostr(I+TopIndex);
           pcp.SStr := data;
           WhisperPoints.Add (pcp);
        end;
        if WhisperSelectStr = data+inttostr(I+TopIndex) then
          dsurface.BoldTextOut (SurfaceX(GLeft+3), SurfaceY(GTop+I*LinesHeight+3), clRed, clBlack, data)
        else
        if WhisperMoveedStr = data+inttostr(I+TopIndex) then
          dsurface.BoldTextOut (SurfaceX(GLeft+3), SurfaceY(GTop+I*LinesHeight+3), clYellow, clBlack, data)
        else dsurface.BoldTextOut (SurfaceX(GLeft+3), SurfaceY(GTop+I*LinesHeight+3), clWhite, clBlack, data);
      end;
    end;
    WhisperAddPoints := False;
  end;
end;

procedure TFrmDlg.AddWhisper(str: string);
var
   i, len, aline: integer;
   temp: string;
const
   BOXWIDTH = 260; //41 聊天框文字宽度
begin
   //str:= FormatDateTime('hh:mm:ss',Now)+ ' ' + str;
   len := Length (str);
   temp := '';
   i := 1;
   while TRUE do begin
      if i > len then break;
      if byte (str[i]) >= 128 then begin
         temp := temp + str[i];
         Inc (i);
         if i <= len then temp := temp + str[i]
         else break;
      end else
         temp := temp + str[i];

      aline := FrmMain.Canvas.TextWidth (temp);
      if aline > BOXWIDTH then begin
         DMemoWhisperList.Lines.Add (temp);
         str := Copy (str, i+1, Len-i);
         temp := '';
         break;
      end;
      Inc (i);
   end;
   if temp <> '' then begin
      DMemoWhisperList.Lines.Add ({FormatDateTime('hh:mm:ss',Now)+ ' ' +}temp);
      str := '';
   end;
   {if ChatStrs.Count > 200 then begin
      ChatStrs.Delete (0);
      ChatBks.Delete (0);
      if ChatStrs.Count - ChatBoardTop < VIEWCHATLINE then Dec(ChatBoardTop);
   end else if (ChatStrs.Count-ChatBoardTop) > VIEWCHATLINE then begin
      Inc (ChatBoardTop);
   end;    }
   if WhisperPoints.Count > 0 then
    for i:=0 to FrmDlg.WhisperPoints.Count-1 do
      Dispose (pTClickSLPoint (FrmDlg.WhisperPoints[i]));
    FrmDlg.WhisperPoints.Clear;
   WhisperAddPoints := True;
   if str <> '' then
      AddWhisper ('         ' + str);

end;

procedure TFrmDlg.DMemoWhisperListMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: pTClickSLPoint;
begin
  WhisperMoveedStr := '';
  with DMemoWhisperList do begin
    L := GLeft;
    T := GTop;
    if WhisperPoints.Count > 0 then  begin//20080629
      for i:=0 to WhisperPoints.Count-1 do begin
        p := pTClickSLPoint (WhisperPoints[i]);
        if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          WhisperMoveedStr := p.RStr;
          break;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DMemoWhisperListClick(Sender: TObject; X, Y: Integer);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      line := Copy(line, 10, Length(line)-1);
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':', '[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
var
  i, L, T: integer;
  p: pTClickSLPoint;
begin
  L := DMemoWhisperList.GLeft;
  T := DMemoWhisperList.GTop;
  with DMemoWhisperList do begin
    if WhisperPoints.Count > 0 then //20080629
    for i:=0 to WhisperPoints.Count-1 do begin
       p := pTClickSLPoint (WhisperPoints[i]);
       if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          WhisperSelectStr := p.RStr;
          if not PlayScene.EdChat.Visible then begin
            PlayScene.EdChat.Visible := TRUE;
            PlayScene.EdChat.SetFocus;
          end;
          PlayScene.EdChat.Text := '/' + ExtractUserName (p.SStr) + ' ';
          PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
          PlayScene.EdChat.SelLength := 0;
          //FrmMain.SendMissionSelect (p.RStr);
          break;
       end;
    end;
  end;
end;

procedure TFrmDlg.DMemoWhisperListScrollBarChange(Sender: TObject);
var
  I: Integer;
begin
  if WhisperPoints.Count > 0 then //20080629
  for i:=0 to WhisperPoints.Count-1 do
    Dispose (pTClickSLPoint (WhisperPoints[i]));
  WhisperPoints.Clear;
  WhisperAddPoints := True;
end;

procedure TFrmDlg.DWhisperCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWWhisper.Visible := False;
end;

procedure TFrmDlg.DBWhisperClick(Sender: TObject; X, Y: Integer);
begin
  DWWhisper.Visible := not DWWhisper.Visible;
  //PlayScene.EdChat.Visible := False;
end;

procedure TFrmDlg.AutoWhisper(str: string);
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
begin
  FrmMain.SendSay ('/' + ExtractUserName (str) + ' '+FrmDlg.DEdtWhisper.Text);
end;

procedure TFrmDlg.DStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  idx: integer;
  pm: PTClientMagic;
{$IF M2Version <> 2}
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
  DScreen.ClearHint;
  with Sender as TDButton do begin
    pm := nil;
    {$IF M2Version = 2} //1.76
      if not g_boShowNewItem then         
        idx := _Max(Tag + MagicPage * 5, 0)
      else
        idx := _Max(Tag + MagicPage * 6, 0);
      if idx < g_MagicList.Count then begin
        pm := PTClientMagic (g_MagicList[idx]);
        if pm <> nil then begin
          DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y\(点击技能按钮设置快捷键)', FALSE, True, 40);
        end;
      end;
    {$ELSE}
    if (StateTab = 1) and (InternalForcePage = 1) then begin
      idx := _Max(Tag + InternalForceMagicPage * 6, 0);
      if idx < g_InternalForceMagicList.Count then begin
         pm := PTClientMagic (g_InternalForceMagicList[idx]);
        if pm <> nil then begin
        	if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          	DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                	Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
          else
          	DScreen.ShowTzHint (SurfaceX(GLeft)-120, SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);

        end;
      end;
    end else begin
      idx := _Max(Tag + MagicPage * 6, 0);
      if idx < g_MagicList.Count then begin
        pm := PTClientMagic (g_MagicList[idx]);
        if pm <> nil then begin
          DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y\(点击技能按钮设置快捷键)', FALSE, True, 40);
        end;
      end;
    end;
    {$IFEND}
  end;
end;

procedure TFrmDlg.DStMagHero1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  idx: integer;
  pm: PTClientMagic;
{$IF M2Version <> 2}
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    pm := nil;
    if (HeroStateTab = 1) and (HeroInternalForcePage = 1) then begin
      idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
      if idx < g_HeroInternalForceMagicList.Count then begin
         pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        if pm <> nil then begin
        	if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
	          DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
          else
						DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);

        end;
      end;
    end else begin
      idx := _Max(Tag + HeroMagicPage * 6, 0);
      if idx < g_HeroMagicList.Count then begin
        pm := PTClientMagic (g_HeroMagicList[idx]);
        if pm <> nil then begin
          DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                        SurfaceY(GTop),
                        pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y', FALSE, True, 40);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DKeySelDlgMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

//参数4为触发QM里的[@Help] 作用
procedure TFrmDlg.DBHelpClick(Sender: TObject; X, Y: Integer);
var
  msg : TDefaultMessage;
begin
  if GetTickCount - g_dwHelpQMTick > 500 then begin
    g_dwHelpQMTick := GetTickCount();
    msg := MakeDefaultMsg (aa(CM_CLICKSIGHICON, frmMain.TempCertification), 0, 4, 0, 0, frmMain.m_nSendMsgCount);
    frmMain.SendSocket (EncodeMessage (msg)+ EncodeString('?'));
  end;
end;

procedure TFrmDlg.DHeroStateWinPulseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  hcolor: integer;
  btX, btY: Byte;
  sStr: string;
begin
  {$IF M2Version = 1}
  if g_HeroSelf = nil then exit;
  with DHeroStateWinPulse do begin
    if g_boHeroPulseOpen then begin //英雄是否开通了经脉
      if WLib <> nil then begin //20080701
        if g_HeroSelf.m_btSex = 1 then begin //女
          if HeroStatePulsePage = 0 then
            d := WLib.Images[FaceIndex + 3]
          else if HeroStatePulsePage = 4 then  //奇经
            d := WLib.Images[1188]
          else d := WLib.Images[FaceIndex + 2];
        end else begin
          if HeroStatePulsePage = 0 then
            d := WLib.Images[FaceIndex + 1]
          else if HeroStatePulsePage = 4 then //奇经
            d := WLib.Images[1186]
          else d := WLib.Images[FaceIndex];
        end;
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      if HeroStatePulsePage = 4 then //奇经
        d := g_WMainImages.Images[1171]
      else d := g_WMainImages.Images[830+HeroStatePulsePage];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft) + 92, SurfaceY(GTop) + 6, d.ClientRect, d, TRUE);

      if HeroStatePulsePage = 4 then begin//奇经
        if not g_HumanPulseArr[HeroStatePulsePage].boOpenPulse then
          hcolor := 1180
        else hcolor := 1181+g_HumanPulseArr[HeroStatePulsePage].nPulseLevel;
        d := g_WMainImages.Images[hcolor];
      end else begin
        if not g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse then
          hcolor := 860
        else hcolor := 861+g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel;
        d := g_WMainImages.Images[hcolor+HeroStatePulsePage * 10];
      end;
      if d <> nil then
      DrawBlend(dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 255);

      if HeroStatePulsePage = 4 then //奇经
        d := g_WMainImages.Images[1172]
      else d := g_WMainImages.Images[840+HeroStatePulsePage];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+20, SurfaceY(GTop)+270, clWhite, clBlack, '请到NPC处开启英雄经络');
    end;
    if ((g_btHeroPulseOriginPage = HeroStatePulsePage) or (HeroStatePulsePage = 4){奇经}) and (g_btHeroPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;
    //-----------------穴位位置---------------------
    if g_boHeroPulseOpen then begin //英雄是否开通了经脉
      case HeroStatePulsePage of
        0: begin
          btX := 37;
          btY := 30;
        end;
        1: begin
          btX := 48;
          btY := 24;
        end;
        2: begin
          btX := 47;
          btY := 38;
        end;
        3: begin
          btX := 48;
          btY := 20;
        end;
        4: begin
          btX := 47;
          btY := 16;
        end;
        else begin
          btX := 0;
          btY := 0;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then
        d := g_WMainImages.Images[851]
      else if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1)) or (HeroStatePulsePage = 4{奇经}) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);

      if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1)) or ((HeroStatePulsePage = 4) and (g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0)){奇经} then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 36;
          btY := 59;
        end;
        1: begin
          btX := 48;
          btY := 64;
        end;
        2: begin
          btX := 41;
          btY := 68;
        end;
        3: begin
          btX := 48;
          btY := 40;
        end;
        4: begin
          btX := 92;
          btY := 102;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (HeroStatePulsePage <> 4{奇经}) and (g_btHeroPulsePoint = 2) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (HeroStatePulsePage <> 4{奇经})) and (g_btHeroPulsePoint = 2) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 38;
          btY := 84;
        end;
        1: begin
          btX := 54;
          btY := 104;
        end;
        2: begin
          btX := 41;
          btY := 106;
        end;
        3: begin
          btX := 48;
          btY := 61;
        end;
        4: begin
          btX := 3;
          btY := 101;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 45;
          btY := 106;
        end;
        1: begin
          btX := 61;
          btY := 143;
        end;
        2: begin
          btX := 36;
          btY := 139;
        end;
        3: begin
          btX := 48;
          btY := 85;
        end;
        4: begin
          btX := 65;
          btY := 185;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
        end;
      end;
  //    d := nil;
      case HeroStatePulsePage of
        0: begin
          btX := 52;
          btY := 88;
        end;
        1: begin
          btX := 64;
          btY := 184;
        end;
        2: begin
          btX := 33;
          btY := 175;
        end;
        3: begin
          btX := 48;
          btY := 109;
        end;
        4: begin
          btX := 29;
          btY := 186;
        end;
      end;
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then
        d := g_WMainImages.Images[851]
      else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin
        d := g_WMainImages.Images[852];
      end else d := g_WMainImages.Images[850];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d.ClientRect, d, TRUE);
      if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin
        if PulseOriginImginsex = 1 then begin
          d := g_WMainImages.Images[853];
          if d <> nil then
          DrawBlend(dsurface, SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, d, 255);
        end;
      end;

      //------------------导航显示----------------------
      if HeroStatePulsePage = 0 then
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+23, d.ClientRect, d, TRUE);
      if g_HeroHumanPulseArr[0].boOpenPulse then begin
        if HeroStatePulsePage = 1 then
          d := g_WMainImages.Images[812]
        else d := g_WMainImages.Images[813];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+47, d.ClientRect, d, TRUE);
      end;
      if g_HeroHumanPulseArr[1].boOpenPulse then begin
        if HeroStatePulsePage = 2 then
          d := g_WMainImages.Images[812]
        else d := g_WMainImages.Images[813];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+71, d.ClientRect, d, TRUE);
      end;
      if g_HeroHumanPulseArr[2].boOpenPulse then begin
        if HeroStatePulsePage = 3 then
          d := g_WMainImages.Images[812]
        else d := g_WMainImages.Images[813];
        if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop)+95, d.ClientRect, d, TRUE);
      end;
      if HeroStatePulsePage = 4 then //奇经
        d := g_WMainImages.Images[812]
      else d := g_WMainImages.Images[813];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+136, SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_boHeroPulseOpen then begin //英雄是否开通了经脉
      btX := 140;
      btY := 28;
      if g_btHeroStateWinPulseMoving = 1 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 29;
        end else if HeroStatePulsePage = 0 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if HeroStatePulsePage = 0 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '冲脉');

      if g_HeroHumanPulseArr[0].boOpenPulse then begin
        btX := 140;
        btY := 51;
        if g_btHeroStateWinPulseMoving = 2 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $008BC4ED;
            btX := 141;
            btY := 52;
          end else if HeroStatePulsePage = 1 then hcolor := $008BC4ED
          else hcolor := $006C849A;
        end else if HeroStatePulsePage = 1 then hcolor := $008BC4ED
        else hcolor := $006C849A;
        dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴跷');
      end;
      if g_HeroHumanPulseArr[1].boOpenPulse then begin
        btX := 140;
        btY := 75;
        if g_btHeroStateWinPulseMoving = 3 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $008BC4ED;
            btX := 141;
            btY := 76;
          end else if HeroStatePulsePage = 2 then hcolor := $008BC4ED
          else hcolor := $006C849A;
        end else if HeroStatePulsePage = 2 then hcolor := $008BC4ED
        else hcolor := $006C849A;
        dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '阴维');
      end;
      if g_HeroHumanPulseArr[2].boOpenPulse then begin
        btX := 140;
        btY := 99;
        if g_btHeroStateWinPulseMoving = 4 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $008BC4ED;
            btX := 141;
            btY := 100;
          end else if HeroStatePulsePage = 3 then hcolor := $008BC4ED
          else hcolor := $006C849A;
        end else if HeroStatePulsePage = 3 then hcolor := $008BC4ED
        else hcolor := $006C849A;
        dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '任脉');
      end;
      btX := 140;
      btY := 5;
      if g_btHeroStateWinPulseMoving = 11 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $008BC4ED;
          btX := 141;
          btY := 6;
        end else if HeroStatePulsePage = 4 then hcolor := $008BC4ED
        else hcolor := $006C849A;
      end else if HeroStatePulsePage = 4 then hcolor := $008BC4ED
      else hcolor := $006C849A;
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, '奇经');
      //------------------------------------------------
      case HeroStatePulsePage of
        0: begin
          btX := 81;
          btY := 35;
          //sStr := '幽门';
        end;
        1: begin
          btX := 4;
          btY := 29;
          //sStr := '晴明';
        end;
        2: begin
          btX := 2;
          btY := 41;
          //sStr := '廉泉';
        end;
        3: begin
          btX := 2;
          btY := 25;
          //sStr := '承浆';
        end;
        4: begin
          btX := 4;
          btY := 22;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 5 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,0));
      case HeroStatePulsePage of
        0: begin
          btX := 80;
          btY := 64;
          //sStr := '通谷';
        end;
        1: begin
          btX := 4;
          btY := 68;
          //sStr := '盘缺';
        end;
        2: begin
          btX := 82;
          btY := 73;
          //sStr := '期门';
        end;
        3: begin
          btX := 93;
          btY := 45;
          //sStr := '天突';
        end;
        4: begin
          btX := 68;
          btY := 94;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 6 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,1));
      case HeroStatePulsePage of
        0: begin
          btX := 2;
          btY := 89;
          //sStr := '商曲';
        end;
        1: begin
          btX := 92;
          btY := 108;
          //sStr := '交信';
        end;
        2: begin
          btX := 1;
          btY := 110;
          //sStr := '府舍';
        end;
        3: begin
          btX := 3;
          btY := 67;
          //sStr := '鸠尾';
        end;
        4: begin
          btX := 26;
          btY := 116;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 7 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,2));
      case HeroStatePulsePage of
        0: begin
          btX := 6;
          btY := 111;
          //sStr := '四满';
        end;
        1: begin
          btX := 24;
          btY := 146;
          //sStr := '照海';
        end;
        2: begin
          btX := 70;
          btY := 144;
          //sStr := '冲门';
        end;
        3: begin
          btX := 93;
          btY := 90;
          //sStr := '气海';
        end;
        4: begin
          btX := 42;
          btY := 178;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 8 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,3));
      case HeroStatePulsePage of
        0: begin
          btX := 86;
          btY := 92;
          //sStr := '横骨';
        end;
        1: begin
          btX := 29;
          btY := 189;
          //sStr := '然谷';
        end;
        2: begin
          btX := 66;
          btY := 180;
          //sStr := '筑宾';
        end;
        3: begin
          btX := 4;
          btY := 114;
          //sStr := '曲骨';
        end;
        4: begin
          btX := 3;
          btY := 190;
        end;
      end;
      if g_btHeroStateWinPulseMoving = 9 then begin
        if g_boHeroStateWinPulseDowning then begin
          hcolor := $0048A4E8;
          btX := btX + 1;
          btY := btY + 1;
        end else hcolor := $00A8D4E8;
      end else hcolor := $0088C4E8;  //普通颜色
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, GetPulseName(HeroStatePulsePage,4));

      if HeroStatePulsePage <> 4 then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: begin
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
            end;
            1: begin
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            2: begin
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            3: begin
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            4: begin
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
            5: begin
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
              dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
            end;
          end;
        end else begin
          dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
          dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
          dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
          dsurface.BoldTextOut (SurfaceX(GLeft)+108, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
        end;
      end;
      //{$IFEND}

      if g_btHeroStateWinPulseMoving = 10 then begin
        if g_boHeroStateWinPulseDowning then
          d := g_WMainImages.Images[815]
        else d := g_WMainImages.Images[814];
      end else d := g_WMainImages.Images[814];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+7, SurfaceY(GTop)+210, d.ClientRect, d, TRUE);
      case HeroStatePulsePage of
        0: sStr := '修炼冲脉';
        1: sStr := '修炼阴跷';
        2: sStr := '修炼阴维';
        3: sStr := '修炼任脉';
        4: sStr := '修炼奇经';
      end;
      btX := 13;
      btY := 214;
      if (g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel >= 5) or ((HeroStatePulsePage = 4) and (g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0)) then begin
        hcolor := clGray;
      end else begin
        if g_btHeroStateWinPulseMoving = 10 then begin
          if g_boHeroStateWinPulseDowning then begin
            hcolor := $0048A4E8;
            btX := btX + 1;
            btY := btY + 1;
          end else hcolor := $00A8D4E8;
        end else hcolor := $0088C4E8;  //普通颜色
      end;
      dsurface.BoldTextOut (SurfaceX(GLeft)+btX, SurfaceY(GTop)+btY, hcolor, clBlack, sStr);
    //{$IFEND}
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroStateWinPulseClick(Sender: TObject; X, Y: Integer);
var
  lx, ly: Integer;
begin
  {$IF M2Version = 1}
  if (g_HeroSelf = nil) or (not g_boHeroPulseOpen) then Exit;
  lx := X - DHeroStateWinPulse.GLeft;
  ly := Y - DHeroStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    HeroStatePulsePage := 0;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    if g_HeroHumanPulseArr[0].boOpenPulse then HeroStatePulsePage := 1;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    if g_HeroHumanPulseArr[1].boOpenPulse then HeroStatePulsePage := 2;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    if g_HeroHumanPulseArr[2].boOpenPulse then HeroStatePulsePage := 3;
  end;
  if (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24) then begin
    HeroStatePulsePage := 4;
  end;
  case HeroStatePulsePage of
    0: begin
      //1
      //x24 y23
      if ((lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47)){字} or ((lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      // x 24 y 12
      if ((lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101)){字} or ((lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123)){字} or ((lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104)){字} or ((lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    1: begin
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120)){字} or ((lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158)){字} or ((lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201)){字} or ((lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    2: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122)){字} or ((lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156)){字} or ((lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192)){字} or ((lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    3: begin
      //1
      if ((lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
      end;
      //2
      if ((lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 1 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 2 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 3 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126)){字} or ((lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 4 then frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;
    end;
    4: begin //奇经
      //1
      if ((lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34)){字} or ((lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39)){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
        end else begin
          ShowQJPractice(True);
        end;
      end;
      //2
      (*if ((lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106)){字} or ((lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 2);
      end;
      //3
      if ((lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128)){字} or ((lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 3);
      end;
      //4
      if ((lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190)){字} or ((lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 4);
      end;
      //5
      if ((lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202)){字} or ((lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209)){图} then begin
        frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 5);
      end;   *)
    end;
  end;
  if ((lx >= 7) and (lx <= 67) and (ly >= 210) and (ly <= 231)) then begin
    if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendHeroPracticePulse(HeroStatePulsePage);
      end;
    end else begin
      case HeroStatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(True);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroStateWinPulseMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwHeroInternalForceLevel >= nlevel then Result := '~y';
  end;
var
  lx, ly: Integer;
  str: string;
begin
  {$IF M2Version = 1}
  if not g_boHeroPulseOpen then Exit; //英雄是否开通了经脉
  DScreen.ClearHint;
  g_boHeroStateWinPulseDowning := False;
  g_btHeroStateWinPulseMoving := 0;
  lx := X - DHeroStateWinPulse.GLeft;
  ly := Y - DHeroStateWinPulse.GTop;
  if (lx >= 136) and (lx <= 168) and (ly >= 23) and (ly <= 45) then begin
    g_btHeroStateWinPulseMoving := 1;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[0].boOpenPulse then begin
      if g_HeroHumanPulseArr[0].nPulseLevel = 1 then begin
        str := GetPulsDesc(Format('H冲脉%d-%d',[g_HeroHumanPulseArr[0].nPulseLevel,g_HeroSelf.m_btJob]));
      end else begin
        if g_HeroHumanPulseArr[0].nPulseLevel = 0 then str := GetPulsDesc('冲脉已通')
        else str := GetPulsDesc(Format('H冲脉%d',[g_HeroHumanPulseArr[0].nPulseLevel]));
      end;
      if str <> '' then begin
        with g_HeroBatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end else begin
      str := GetPulsDesc('冲脉未通');
      if str <> '' then begin
        with g_HeroBatterDesc do begin
          sName := GetPulsePageName(0);
          str := GetValidStr3 (str, sLine1, ['\']);
          str := GetValidStr3 (str, sLine2, ['\']);
          str := GetValidStr3 (str, sLine3, ['\']);
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 47) and (ly <= 69) then begin
    g_btHeroStateWinPulseMoving := 2;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[0].boOpenPulse then begin
      if g_HeroHumanPulseArr[1].boOpenPulse then begin
        if g_HeroHumanPulseArr[1].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('H阴跷%d-%d',[g_HeroHumanPulseArr[1].nPulseLevel,g_HeroSelf.m_btJob]));
        end else begin
          if g_HeroHumanPulseArr[1].nPulseLevel = 0 then str := GetPulsDesc('阴跷已通')
          else str := GetPulsDesc(Format('H阴跷%d',[g_HeroHumanPulseArr[1].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴跷未通');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(1);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 71) and (ly <= 93) then begin
    g_btHeroStateWinPulseMoving := 3;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[1].boOpenPulse then begin
      if g_HeroHumanPulseArr[2].boOpenPulse then begin
        if g_HeroHumanPulseArr[2].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('H阴维%d-%d',[g_HeroHumanPulseArr[2].nPulseLevel,g_HeroSelf.m_btJob]));
        end else begin
          if g_HeroHumanPulseArr[2].nPulseLevel = 0 then str := GetPulsDesc('阴维已通')
          else str := GetPulsDesc(Format('H阴维%d',[g_HeroHumanPulseArr[2].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('阴维未通');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(2);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 95) and (ly <= 117) then begin
    g_btHeroStateWinPulseMoving := 4;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    if g_HeroHumanPulseArr[2].boOpenPulse then begin
      if g_HeroHumanPulseArr[3].boOpenPulse then begin
        if g_HeroHumanPulseArr[3].nPulseLevel = 1 then begin
          str := GetPulsDesc(Format('H任脉%d-%d',[g_HeroHumanPulseArr[3].nPulseLevel,g_HeroSelf.m_btJob]));
        end else begin
          if g_HeroHumanPulseArr[3].nPulseLevel = 0 then str := GetPulsDesc('任脉已通')
          else str := GetPulsDesc(Format('H任脉%d',[g_HeroHumanPulseArr[3].nPulseLevel]));
        end;
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end else begin
        str := GetPulsDesc('任脉未通');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := GetPulsePageName(3);
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end else
  if (lx >= 136) and (lx <= 168) and (ly >= 0) and (ly <= 24) then begin
    g_btHeroStateWinPulseMoving := 11;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    str := GetPulsDesc('奇经');
    {if g_HeroHumanPulseArr[4].nPulseLevel = 0 then str := GetPulsDesc('奇经已通')
    else str := GetPulsDesc(Format('H奇经%d',[g_HeroHumanPulseArr[3].nPulseLevel])); }
    if str <> '' then begin
      with g_HeroBatterDesc do begin
        sName := GetPulsePageName(4);
        str := GetValidStr3 (str, sLine1, ['\']);
        str := GetValidStr3 (str, sLine2, ['\']);
        str := GetValidStr3 (str, sLine3, ['\']);
      end;
    end;
  end else
  if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
    g_btHeroStateWinPulseMoving := 10;
    if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
    with g_HeroBatterDesc do begin
      sName := ' ';
      sLine1 := '欲练连击，必练内功；打通五穴';
      sLine2 := '，经络自通。欲强连击，锻造金';
      sLine3 := '针；修炼经络，威力提升。';
    end;
  end;
  case HeroStatePulsePage of
    0: begin
      //1
      if (lx >= 81) and (lx <= 105) and (ly >= 35) and (ly <= 47){字} then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 106, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+34, format('%s穴:已打通',[GetPulseName(HeroStatePulsePage,0)]) , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 106, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+34,
                      format('%s穴:待打通',[GetPulseName(HeroStatePulsePage,0)])+'~y\'+format('需要内功等级：%d',[g_btHeroPulseLevel])+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 106, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+34,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 37) and (lx <= 61) and (ly >= 30) and (ly <= 53){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 62, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+29, '幽门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('幽门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 62, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+29,
                      '幽门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 62, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+29,
                      '幽门穴:目前不可打通'+'~r', FALSE, FALSE, 0);;//未打通
          str := GetPulsDesc('幽门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'幽门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 80) and (lx <= 104) and (ly >= 64) and (ly <= 76){字} then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 105, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 105, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 105, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 59) and (ly <= 82){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+58, '通谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('通谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+58,
                      '通谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+58,
                      '通谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('通谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'通谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      // x 24 y 12
      if (lx >= 2) and (lx <= 26) and (ly >= 89) and (ly <= 101) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+88, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+88,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+88,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 38) and (lx <= 62) and (ly >= 84) and (ly <= 107){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 63, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+83, '商曲穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('商曲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 63, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+83,
                      '商曲穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 63, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+83,
                      '商曲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('商曲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'商曲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 6) and (lx <= 30) and (ly >= 111) and (ly <= 123) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 31, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+110, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 31, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+110,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 31, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+110,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 45) and (lx <= 69) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 70, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105, '四满穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('四满已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 70, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '四满穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 70, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '四满穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('四满未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'四满穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 86) and (lx <= 110) and (ly >= 92) and (ly <= 104) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 111, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+91, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 111, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+91,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 111, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+91,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 52) and (lx <= 76) and (ly >= 88) and (ly <= 111){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 77, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+87, '横骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('横骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 77, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+87,
                      '横骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 77, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+87,
                      '横骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('横骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'横骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP冲脉已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP冲脉1');
            2: str := GetPulsDesc('HP冲脉2');
            3: str := GetPulsDesc('HP冲脉3');
            4: str := GetPulsDesc('HP冲脉4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP冲脉未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    1: begin
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 29) and (ly <= 41) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+28, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+28,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+28,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 24) and (ly <= 47){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+23, '晴明穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('晴明已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+23,
                      '晴明穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+23,
                      '晴明穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('晴明未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'晴明穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 4) and (lx <= 28) and (ly >= 68) and (ly <= 80) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 64) and (ly <= 87){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63, '盘缺穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('盘缺已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '盘缺穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+63,
                      '盘缺穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('盘缺未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'盘缺穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 92) and (lx <= 116) and (ly >= 108) and (ly <= 120) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+107, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+107,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+107,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 54) and (lx <= 78) and (ly >= 104) and (ly <= 127){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 79, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+103, '交信穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('交信已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 79, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+103,
                      '交信穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
           DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 79, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+103,
                      '交信穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('交信未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'交信穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 24) and (lx <= 48) and (ly >= 146) and (ly <= 158) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 49, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+145, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 49, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+145,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 49, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+145,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 61) and (lx <= 86) and (ly >= 143) and (ly <= 166){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 87, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+142, '照海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('照海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 87, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+142,
                      '照海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 87, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+142,
                      '照海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('照海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'照海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 29) and (lx <= 53) and (ly >= 189) and (ly <= 201) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+188, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+188,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+188,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 64) and (lx <= 88) and (ly >= 184) and (ly <= 207){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 89, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+183, '然谷穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('然谷已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 89, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+183,
                      '然谷穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 89, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+183,
                      '然谷穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('然谷未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'然谷穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP阴跷已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP阴跷1');
            2: str := GetPulsDesc('HP阴跷2');
            3: str := GetPulsDesc('HP阴跷3');
            4: str := GetPulsDesc('HP阴跷4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP阴跷未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    2: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 41) and (ly <= 53) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+40, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+40,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+40,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 38) and (ly <= 61){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+37, '廉泉穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('廉泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+37,
                      '廉泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+37,
                      '廉泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('廉泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'廉泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 82) and (lx <= 106) and (ly >= 73) and (ly <= 85) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 107, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+72, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 107, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+72,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 107, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+72,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 68) and (ly <= 91){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67, '期门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('期门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '期门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+67,
                      '期门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('期门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'期门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 1) and (lx <= 25) and (ly >= 110) and (ly <= 122) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 26, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+109, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 26, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+109,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 26, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+109,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 41) and (lx <= 65) and (ly >= 106) and (ly <= 129){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105, '府舍穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('府舍已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '府舍穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 66, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+105,
                      '府舍穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('府舍未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'府舍穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 70) and (lx <= 94) and (ly >= 144) and (ly <= 156) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 95, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+143, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 95, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+143,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 95, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+143,
                  '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 36) and (lx <= 60) and (ly >= 139) and (ly <= 162){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+138, '冲门穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('冲门已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+138,
                      '冲门穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 61, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+138,
                      '冲门穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('冲门未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'冲门穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 66) and (lx <= 90) and (ly >= 180) and (ly <= 192) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 91, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+179, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 91, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+179,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 91, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+179,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 33) and (lx <= 57) and (ly >= 175) and (ly <= 198){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 58, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+174, '筑宾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('筑宾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 58, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+174,
                      '筑宾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 58, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+174,
                      '筑宾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('筑宾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'筑宾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP阴维已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP阴维1');
            2: str := GetPulsDesc('HP阴维2');
            3: str := GetPulsDesc('HP阴维3');
            4: str := GetPulsDesc('HP阴维4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP阴维未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    3: begin
      //1
      if (lx >= 2) and (lx <= 26) and (ly >= 25) and (ly <= 37) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+24, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+24,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 27, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+24,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 20) and (ly <= 43){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+19, '承浆穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('承浆已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+19,
                      '承浆穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+19,
                      '承浆穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('承浆未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'承浆穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //2
      if (lx >= 93) and (lx <= 117) and (ly >= 45) and (ly <= 57) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+44, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+44,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+44,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 40) and (ly <= 63){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+39, '天突穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('天突已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+39,
                      '天突穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+39,
                      '天突穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('天突未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //3
      if (lx >= 3) and (lx <= 27) and (ly >= 67) and (ly <= 79) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+66, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+66,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+66,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 61) and (ly <= 84){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+60, '鸠尾穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('鸠尾已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+60,
                      '鸠尾穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+60,
                      '鸠尾穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('鸠尾未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'鸠尾穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //4
      if (lx >= 93) and (lx <= 117) and (ly >= 90) and (ly <= 102) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+89, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+89,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 118, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+89,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 85) and (ly <= 108){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+84, '气海穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('气海已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+84,
                      '气海穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+84,
                      '气海穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'气海穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      //5
      if (lx >= 4) and (lx <= 28) and (ly >= 114) and (ly <= 126) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+113, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+113,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+113,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 48) and (lx <= 72) and (ly >= 109) and (ly <= 132){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+108, '曲骨穴:已打通' , clWhite, FALSE);
          str := GetPulsDesc('曲骨已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+108,
                      '曲骨穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 73, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+108,
                      '曲骨穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('曲骨未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'曲骨穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;
      end;
      if (lx >= 6) and (lx <= 58) and (ly >= 209) and (ly <= 230) then begin
        if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
          case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
            0: str := GetPulsDesc(format('HP任脉已通-%d',[g_HeroSelf.m_btJob]));
            1: str := GetPulsDesc('HP任脉1');
            2: str := GetPulsDesc('HP任脉2');
            3: str := GetPulsDesc('HP任脉3');
            4: str := GetPulsDesc('HP任脉4');
          end;
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
          DScreen.ShowSpecialHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)- 144, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+140,
                        format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
        end else begin
          str := GetPulsDesc('HP任脉未通');
          if str <> '' then
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft) - 270,DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+200,
                                 str, clWhite, FALSE);
        end;
      end;
    end;
    4: begin //奇经
      //1
      if (lx >= 4) and (lx <= 28) and (ly >= 22) and (ly <= 34) then begin
        g_btHeroStateWinPulseMoving := 5;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+21, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin//if {(g_btHeroPulseOriginPage = HeroStatePulsePage) and }(g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+21,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel)}, FALSE, FALSE, 0);
          {str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 29, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+21,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;  }
      end;
      if (lx >= 47) and (lx <= 71) and (ly >= 16) and (ly <= 39){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 1 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+15, '神冲穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('神冲已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin//if {(g_btHeroPulseOriginPage = HeroStatePulsePage) and }(g_btHeroPulsePoint = 1) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+15,
                      '神冲穴:待打通'+'~y\'{+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel)}, FALSE, FALSE, 0);
          {str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end;
        str := GetPulsDesc('神冲');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
        {end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 72, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+15,
                      '神冲穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          str := GetPulsDesc('神冲未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,0)]);//'神冲穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;
        end;}
      end;
      //2
      if (lx >= 68) and (lx <= 92) and (ly >= 94) and (ly <= 106) then begin
        g_btHeroStateWinPulseMoving := 6;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 93, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+93, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 93, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+93,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'夹脊穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 93, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+93,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 92) and (lx <= 116) and (ly >= 102) and (ly <= 125){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 2 then begin  //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+101, '夹脊穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('夹脊已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 2) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+101,
                      '夹脊穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 117, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+101,
                      '夹脊穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('夹脊未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('夹脊');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,1)]);//'天突穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //3
      if (lx >= 26) and (lx <= 50) and (ly >= 116) and (ly <= 128) then begin
        g_btHeroStateWinPulseMoving := 7;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 51, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+115, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 51, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+115,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 51, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+115,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 3) and (lx <= 27) and (ly >= 101) and (ly <= 124){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 3 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+100, '二百穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('二百已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 3) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+100,
                      '二百穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+100,
                      '二百穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('二百未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('二百');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,2)]);//'二百穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //4
      if (lx >= 42) and (lx <= 66) and (ly >= 178) and (ly <= 190) then begin
        g_btHeroStateWinPulseMoving := 8;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 67, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+177, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 67, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+177,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 67, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+177,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('八风');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 65) and (lx <= 89) and (ly >= 185) and (ly <= 208){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 4 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 90, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+184, '八风穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('八风已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;  }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 4) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 90, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+184,
                      '八风穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('八风未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 90, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+184,
                      '八风穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('气海未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end;}
        end;
        str := GetPulsDesc('气海');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,3)]);//'八风穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      //5
      if (lx >= 3) and (lx <= 27) and (ly >= 190) and (ly <= 202) then begin
        g_btHeroStateWinPulseMoving := 9;
        if ssLeft in Shift then  g_boHeroStateWinPulseDowning := True;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+189, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+189,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 28, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+189,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
      if (lx >= 29) and (lx <= 53) and (ly >= 186) and (ly <= 209){图} then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= 5 then begin //已打通
          DScreen.ShowHint(DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+185, '涌泉穴:已打通' , clWhite, FALSE);
          {str := GetPulsDesc('涌泉已通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = 5) then begin //待打通
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+185,
                      '涌泉穴:待打通'+'~y\'+'需要内功等级：'+IntToStr(g_btHeroPulseLevel)+GetRGB(g_btHeroPulseLevel), FALSE, FALSE, 0);
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end else begin
          DScreen.ShowTzHint (DHeroStateWinPulse.SurfaceX(DHeroStateWinPulse.GLeft)+ 54, DHeroStateWinPulse.SurfaceY(DHeroStateWinPulse.GTop)+185,
                      '涌泉穴:目前不可打通'+'~r', FALSE, FALSE, 0);//未打通
          {str := GetPulsDesc('涌泉未通');
          if str <> '' then begin
            with g_HeroBatterDesc do begin
              sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
              str := GetValidStr3 (str, sLine1, ['\']);
              str := GetValidStr3 (str, sLine2, ['\']);
              str := GetValidStr3 (str, sLine3, ['\']);
            end;
          end; }
        end;
        str := GetPulsDesc('涌泉');
        if str <> '' then begin
          with g_HeroBatterDesc do begin
            sName := format('%s穴:',[GetPulseName(HeroStatePulsePage,4)]);//'涌泉穴:';
            str := GetValidStr3 (str, sLine1, ['\']);
            str := GetValidStr3 (str, sLine2, ['\']);
            str := GetValidStr3 (str, sLine3, ['\']);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroStateWinBatterDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  bbx, bby, I, icon, trainlv: Integer;
  magtop, magline, m: Byte;
  pm: PTClientMagic;
begin
  {$IF M2Version = 1}
  with DHeroStateWinBatter do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

        d := g_WMainImages.Images[912];
        if d <> nil then
         dsurface.Draw (SurfaceX(GLeft)+118, SurfaceY(GTop)+6, d.ClientRect, d, TRUE);

        bbx := SurfaceX(GLeft) - 2;
        bby := SurfaceY(GTop) + 81;

        //虐 钎矫, lv, exp
        magtop := 0;//InternalForceMagicPage * 6;
        magline := _MIN(4, g_HeroBatterMagicList.count);//_MIN(InternalForceMagicPage*6+6, g_InternalForceMagicList.Count);
        for i:=magtop to magline-1 do begin
           pm := PTClientMagic (g_HeroBatterMagicList[i]);
           m := i - magtop;
           case pm.Def.btEffect of
             102:icon := 952;//三绝杀
             103:icon := 944;//双龙破
             104:icon := 934;//虎啸诀
             105:icon := 950;//追心刺
             106:icon := 942;//凤舞祭
             107:icon := 936;//八卦掌
             108:icon := 956;//断岳斩
             109:icon := 946;//惊雷爆
             110:icon := 932;//三焰咒
             111:icon := 954;//横扫千军
             112:icon := 940;//冰天雪地
             113:icon := 930;//万剑归宗
             else icon := -1;
           end;
           d := g_WMainImages.Images[icon];
           if d <> nil then
              dsurface.Draw (bbx + 9, bby+7+m*38, d.ClientRect, d, TRUE);
                      
           d := g_WMainImages.Images[112]; //lv
           if d <> nil then
              dsurface.Draw (bbx + 48, bby+8+15+m*37, d.ClientRect, d, TRUE);

           d := g_WMainImages.Images[111]; //exp
           if d <> nil then begin
              dsurface.Draw (bbx + 48 + 26, bby+8+15+m*37, d.ClientRect, d, TRUE);
           end;
        end;
        with dsurface.Canvas do begin
           for i:=magtop to magline-1 do begin
              pm := PTClientMagic (g_HeroBatterMagicList[i]);
              m := i - magtop;
              if not (pm.Level in [0..5]) then pm.Level := 0;
              case pm.Def.btEffect of
                102..104: begin
                  case Ord(pm.Key) of
                    1:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+15%暴击');
                    end;
                    3: begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+25%暴击');
                    end;
                    4: begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%+30%暴击');
                    end;
                    else
                    dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[0].nStormsHit)+'%暴击');
                  end;
                end;
                105..107: begin
                  case Ord(pm.Key) of
                     1:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+10%暴击');
                     end;
                     2:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+15%暴击');
                     end;
                     3:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+25%暴击');
                     end;
                     4:begin
                        dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%+30%暴击');
                     end;
                     else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[1].nStormsHit)+'%暴击');
                  end;
                end;
                108..110: begin
                  case Ord(pm.Key) of
                    1:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+15%暴击');
                    end;
                    3:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+25%暴击');
                    end;
                    4:begin
                       dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%+30%暴击');
                    end;
                    else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                          clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[2].nStormsHit)+'%暴击');
                  end;
                end;
                111..113: begin
                  case Ord(pm.Key) of
                    1:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+10%暴击');
                    end;
                    2:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+15%暴击');
                    end;
                    3:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+25%暴击');
                    end;
                    4:begin
                      dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%+30%暴击');
                    end;
                    else dsurface.BoldTextOut (bbx + 48, bby + 8 + m*37,
                            clSilver, clBlack, pm.Def.sMagicName+':'+inttostr(g_HeroHumanPulseArr[3].nStormsHit)+'%暴击');
                  end;
                end;
              end;
              if pm.Level in [0..3,5] then trainlv := pm.Level
              else if pm.Level = 4 then trainlv := 3
              else trainlv := 0;
              dsurface.BoldTextOut (bbx + 48 + 16, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Def.MaxTrain[trainlv] > 0 then begin
                 if trainlv < 5 then
                    dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
                 else dsurface.BoldTextOut (bbx + 48 + 46, bby + 8 + 15 + m*37, clSilver, clBlack, '-');
              end;
           end;
           //Release;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  icon: Integer;
begin
  {$IF M2Version = 1}
  with Sender as TDButton do begin
    if Sender = DHeroBatterTopMag4 then begin
      if not g_boHeroOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(TDButton(Sender).GLeft-4), SurfaceY(TDButton(Sender).GTop-4), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;
    if g_HeroBatterMagicList.Count > 0 then begin
      if g_HeroBatterTopMagic[TDButton(Sender).Tag].Def.sMagicName <> '' then begin
        case g_HeroBatterTopMagic[TDButton(Sender).Tag].Def.btEffect of
         102:icon := 952;//三绝杀
         103:icon := 944;//双龙破
         104:icon := 934;//虎啸诀
         105:icon := 950;//追心刺
         106:icon := 942;//凤舞祭
         107:icon := 936;//八卦掌
         108:icon := 956;//断岳斩
         109:icon := 946;//惊雷爆
         110:icon := 932;//三焰咒
         111:icon := 954;//横扫千军
         112:icon := 940;//冰天雪地
         113:icon := 930;//万剑归宗
        else icon := -1;
        end;
        if TDButton(Sender).Downed then
          d := g_WMainImages.Images[icon+1]
        else d := g_WMainImages.Images[icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
      end else begin
        if TDButton(Sender).Downed then begin
          if g_HeroBatterTopMagic[TDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DHeroBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TDButton(Sender).Tag*2+1];
          end;
        end else begin
          if g_HeroBatterTopMagic[TDButton(Sender).Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DHeroBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + TDButton(Sender).Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
        if (g_HeroBatterTopMagic[0].Def.sMagicName = '') and (g_HeroBatterTopMagic[1].Def.sMagicName = '') and (g_HeroBatterTopMagic[2].Def.sMagicName = '') and (g_HeroBatterTopMagic[3].Def.sMagicName = '')
           and (g_HeroBatterTopMagic[0].CurTrain <> 1) and (g_HeroBatterTopMagic[1].CurTrain <> 1) and (g_HeroBatterTopMagic[2].CurTrain <> 1) and (g_HeroBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DHeroBatterTopMag1 then begin
            if (not TDButton(Sender).Downed) and (not DWinBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(TDButton(Sender).GLeft)+10, SurfaceY(TDButton(Sender).GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(TDButton(Sender).GLeft), SurfaceY(TDButton(Sender).GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DHeroBatterTopMag1 then begin
    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterTopMag2 then begin
    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterTopMag3 then begin
    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterTopMag4 then begin


    DScreen.ShowHint(DHeroBatterTopMag1.SurfaceX(DHeroBatterTopMag1.GLeft) - 137, DHeroBatterTopMag1.SurfaceY(DHeroBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DHeroBatterRandom then begin
    DScreen.ShowHint(DHeroBatterRandom.SurfaceX(DHeroBatterRandom.GLeft), DHeroBatterRandom.SurfaceY(DHeroBatterRandom.GTop+DHeroBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterTopMag1MouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Button = mbLeft then begin
    if Sender = DHeroBatterTopMag4 then begin
      if not g_boHeroOpen4BatterSkill then Exit;
    end;
    if g_HeroBatterMagicList.Count > 0 then begin
      DHeroBatterCom.GLeft := TDButton(Sender).GLeft-2;
      DHeroBatterCom.GTop := TDButton(Sender).GTop+TDButton(Sender).GHeight+1;
      HeroBatterTopMagIndex := TDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
      HeroBatterComIndex := -1;
      DHeroBatterCom.Visible := True;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
var
  pm: PTClientMagic;
  I: Integer;
begin
  {$IF M2Version = 1}
  FillChar (g_HeroBatterTopMagic, sizeof(TClientMagic)*4, #0);
  if g_HeroBatterMagicList.Count > 0 then begin
    for i:=0 to g_HeroBatterMagicList.Count-1 do begin
      pm := PTClientMagic (g_HeroBatterMagicList[i]);
      if (Ord(pm.Key) = 1) or (Ord(pm.Key) = 2) or (Ord(pm.Key) = 3) or (Ord(pm.Key) = 4) then begin
        pm.Key := #0;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
      end;
    end;
  end;
  g_HeroBatterTopMagic[0].CurTrain := 1;
  g_HeroBatterTopMagic[1].CurTrain := 1;
  g_HeroBatterTopMagic[2].CurTrain := 1;
  g_HeroBatterTopMagic[3].CurTrain := 1;
  FrmMain.SendHeroMagicKeyChange (-1, #0, '1/1/1/1');
  {$IFEND}
end;

procedure TFrmDlg.DHeroBatterComDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  I: Integer;
  btLine: Byte;
  sStr: string;
begin
  with DHeroBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if HeroBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+HeroBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+HeroBatterComIndex*15+19), clNavy);
    end;
    btLine := _MIN(4, g_HeroBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_HeroBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_HeroBatterMagicList.Items[I]).Def.sMagicName;
        if I = HeroBatterComIndex then
          dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if HeroBatterComIndex = btLine then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if HeroBatterComIndex = btLine +1 then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
end;

procedure TFrmDlg.DHeroBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  btLine: Byte;
  ss: Integer;
begin
  with DHeroBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_HeroBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    HeroBatterComIndex := ss;
  end;
end;

procedure TFrmDlg.DHeroBatterComMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
begin
  if HeroBatterComIndex <> - 1 then begin
    if g_HeroBatterMagicList.Count - HeroBatterComIndex > 0 then begin
      for I:=Low(g_HeroBatterTopMagic) to High(g_HeroBatterTopMagic) do begin
        if g_HeroBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_HeroBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex] := pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 0;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_HeroBatterMagicList[HeroBatterComIndex]);
      pm.Key := Chr(HeroBatterTopMagIndex + 1);
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, Chr(HeroBatterTopMagIndex + 1), str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = 0 then begin//空
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = -1 then begin//随机
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 1;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end;
    DHeroBatterCom.Visible := False;
  end;
end;

procedure TFrmDlg.DHeroBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  pm: PTClientMagic;
begin
  if g_HeroBatterMagicList.Count - 1 >= TDButton(Sender).Tag then begin
    pm := PTClientMagic (g_HeroBatterMagicList[TDButton(Sender).Tag]);
    case pm.Def.btEffect of
      102: begin  //三绝杀
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对单体目';
          sLine2 := '标造成伤害';
          sLine3 := '';
        end;
      end;
      111: begin //横扫千军
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以自身为';
          sLine2 := '中心，对5*5范围内的目标造成';
          sLine3 := '伤害';
        end;
      end;
      105: begin //追心刺
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '近身攻击，冲撞单体';
          sLine2 := '目标，在迫使其后退的同时，造';
          sLine3 := '成伤害';
        end;
      end;
      108: begin //断岳斩
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '远程攻击，对三步内';
          sLine2 := '的单体目标造成伤害';
          sLine3 := '';
        end;
      end;
      112, 113: begin //冰天雪地 万剑归宗
        with g_HeroBatterDesc do begin
          sName := pm.Def.sMagicName+'：';
          sLine1 := '范围攻击，以目标为';
          sLine2 := '中心，对5*5范围内造成持续伤 ';
          sLine3 := '害';
        end;
      end;
      else g_HeroBatterDesc.sName := '';
    end;
  end;
end;

procedure TFrmDlg.HBExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*6+6, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 71) and (pm.Level < 100) then begin
            rc := d.ClientRect;
            if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
              rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.HBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
begin
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*6+6, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 71) and (pm.Level < 100) then begin
      sMsg := '当前经验:%d/%d';
      with HBExp do
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), clWhite, FALSE);
      Break;
    end;
  end;
end;

procedure TFrmDlg.JQExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*6+6, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 68) then begin
            if (pm.Level < 100) then begin
              rc := d.ClientRect;
              if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
                rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
              end;
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.JQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
begin
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*6+6, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 68) and (pm.Level < 100) then begin
      sMsg := '当前经验:%d/%d';
      with JQExp do
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      Break;
    end;
  end;
end;

procedure TFrmDlg.DWHeroAssessDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  function GetHeroIcon(Job,Sex: Byte): Integer;
  var
    Icon: Integer;
  begin
    case Job of
      0:Icon := 502;
      1:Icon := 506;
      2:Icon := 504;
      else Icon := 502;
    end;
    if Sex = 1 then Result := Icon +1
    else Result := Icon;
  end;
var
  d: TDirectDrawSurface;
  Icon: Integer;
begin
  with DWHeroAssess do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if not DHeroAssessSign.ShowHint then begin //评定界面
      dsurface.TextOut (SurfaceX(GLeft)+113, SurfaceY(GTop)+28, clWhite, '请确保酒馆中寄存两位未经评定的英雄，否');
      dsurface.TextOut (SurfaceX(GLeft)+113, SurfaceY(GTop)+28+14, clWhite, '则资质评定无法进行。等级较高者将成为主');
      dsurface.TextOut (SurfaceX(GLeft)+113, SurfaceY(GTop)+28+28, clWhite, '将英雄，等级较低者将成为副将英雄。');
      dsurface.BoldTextOut (SurfaceX(GLeft) + 21, SurfaceY(GTop) + 124, $0088C4E8, clBlack, '试炼场长老');
      if g_GetDeputyHeroData[0].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[0].btJob, g_GetDeputyHeroData[0].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 118, SurfaceY(GTop) + 108, d.ClientRect, d, TRUE);
        dsurface.TextOut(SurfaceX(GLeft) + 160 - FrmMain.Canvas.TextWidth(g_GetDeputyHeroData[0].sChrName) div 2 , SurfaceY(GTop) + 89, $0088C4E8, g_GetDeputyHeroData[0].sChrName);
        dsurface.TextOut(SurfaceX(GLeft) + 160 - FrmMain.Canvas.TextWidth(ForMat('等级：%d',[g_GetDeputyHeroData[0].Level])) div 2 , SurfaceY(GTop) + 203, $0088C4E8, ForMat('等级：%d',[g_GetDeputyHeroData[0].Level]));
      end;
      if g_GetDeputyHeroData[1].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[1].btJob, g_GetDeputyHeroData[1].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 267, SurfaceY(GTop) + 108, d.ClientRect, d, TRUE);
        dsurface.TextOut(SurfaceX(GLeft) + 310 - FrmMain.Canvas.TextWidth(g_GetDeputyHeroData[1].sChrName) div 2 , SurfaceY(GTop) + 89, $0088C4E8, g_GetDeputyHeroData[1].sChrName);
        dsurface.TextOut(SurfaceX(GLeft) + 310 - FrmMain.Canvas.TextWidth(ForMat('等级：%d',[g_GetDeputyHeroData[1].Level])) div 2 , SurfaceY(GTop) + 203, $0088C4E8, ForMat('等级：%d',[g_GetDeputyHeroData[1].Level]));
      end;
    end else begin //出战界面
      dsurface.BoldTextOut (SurfaceX(GLeft) + 21, SurfaceY(GTop) + 106, $0088C4E8, clBlack, '试炼场长老');
      if g_GetDeputyHeroData[0].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[0].btJob, g_GetDeputyHeroData[0].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 13, SurfaceY(GTop) + 157, d.ClientRect, d, TRUE);
        dsurface.TextOut(SurfaceX(GLeft) + 55 - FrmMain.Canvas.TextWidth(g_GetDeputyHeroData[0].sChrName) div 2 , SurfaceY(GTop) + 140, $0088C4E8, g_GetDeputyHeroData[0].sChrName);
        if g_GetDeputyHeroData[0].Level > g_GetDeputyHeroData[1].Level then begin
          dsurface.TextOut(SurfaceX(GLeft) + 55 - FrmMain.Canvas.TextWidth(ForMat('主将%d级',[g_GetDeputyHeroData[0].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('主将%d级',[g_GetDeputyHeroData[0].Level]));
        end else begin
          dsurface.TextOut(SurfaceX(GLeft) + 55 - FrmMain.Canvas.TextWidth(ForMat('副将%d级',[g_GetDeputyHeroData[0].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('副将%d级',[g_GetDeputyHeroData[0].Level]));
        end;
      end;
      if g_GetDeputyHeroData[1].sChrName <> '' then begin
        Icon := GetHeroIcon(g_GetDeputyHeroData[1].btJob, g_GetDeputyHeroData[1].btSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 283, SurfaceY(GTop) + 157, d.ClientRect, d, TRUE);
        dsurface.TextOut(SurfaceX(GLeft) + 326 - FrmMain.Canvas.TextWidth(g_GetDeputyHeroData[1].sChrName) div 2 , SurfaceY(GTop) + 140, $0088C4E8, g_GetDeputyHeroData[1].sChrName);
        if g_GetDeputyHeroData[0].Level < g_GetDeputyHeroData[1].Level then begin
          dsurface.TextOut(SurfaceX(GLeft) + 326 - FrmMain.Canvas.TextWidth(ForMat('主将%d级',[g_GetDeputyHeroData[1].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('主将%d级',[g_GetDeputyHeroData[1].Level]));
        end else begin
          dsurface.TextOut(SurfaceX(GLeft) + 326 - FrmMain.Canvas.TextWidth(ForMat('副将%d级',[g_GetDeputyHeroData[1].Level])) div 2 , SurfaceY(GTop) + 254, $0088C4E8, ForMat('副将%d级',[g_GetDeputyHeroData[1].Level]));
        end;
      end;
      case g_btHeroAssessMenuIndex of
        0: begin
          if g_GetDeputyHeroData[0].Level > g_GetDeputyHeroData[1].Level then begin
            dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, g_GetDeputyHeroData[0].sChrName+'为主将英雄');
            dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, g_GetDeputyHeroData[1].sChrName+'为副将英雄');
          end else begin
            dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, g_GetDeputyHeroData[0].sChrName+'为副将英雄');
            dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, g_GetDeputyHeroData[1].sChrName+'为主将英雄');
          end;
        end;
        1: begin
          //上
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '评定主将、副将后，我二人虽不');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '可同时出战，但可轮番参与战斗');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '。');
          //下
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '界面右下角英雄包裹按钮旁的副');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '将英雄召唤键可收回英雄和召唤');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '副将英雄。');
        end;
        2: begin
          //上
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '主将英雄获得经验、内功经验后');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '，召唤副将英雄。主将英雄将自');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '动为副将英雄传输双倍经验。');
          //下
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '副将英雄能够以战士、道士、法');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '师三种不同的职业状态出战。合');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '理利用将对战局产生重大影响。');
        end;
        3: begin
          //上
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '主将英雄收回后再次召出的时间');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '间隔为1分钟。副将英雄收回后再');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '次召出时间间隔为5分钟。');
          //下
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '主将英雄与副将英雄之间的召唤');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '，没有特殊限制。合理利用召唤');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '时间，将成为战斗的重要角色。');
        end;
        4: begin
          //上
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153, clWhite, '主将英雄死亡后，在1分钟内召唤');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14, clWhite, '副将英雄，副将英雄将获得复仇');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 153+14+14, clWhite, '状态，其属性将大幅提高。');
          //下
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217, clWhite, '副将英雄的复仇状态效果只能维');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14, clWhite, '持3分钟。当把握时机，奋勇杀敌');
          dsurface.TextOut(SurfaceX(GLeft) + 105 , SurfaceY(GTop) + 217+14+14, clWhite, '，英雄同心，其利断金。');
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroAssessSign1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   bby: Byte;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if DHeroAssessSign.ShowHint or (Sender = DStartHeroAutoPra) then bby:=5 else bby:=0; //界面变量区分
      if not TDButton(Sender).ShowHint then begin
        if TDButton(Sender).Downed then begin
          d := WLib.Images[FaceIndex + 1];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + 38 - bby - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 6, $0048A4E8, clBlack, TDButton(Sender).Hint);
        end else begin
          if TDButton(Sender).MouseMoveing then begin
            d := WLib.Images[FaceIndex];
            if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
            dsurface.BoldTextOut (SurfaceX(GLeft) + 36 - bby - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $00A8D4E8, clBlack, TDButton(Sender).Hint);
          end else begin
            d := WLib.Images[FaceIndex];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            dsurface.BoldTextOut (SurfaceX(GLeft) + 36 - bby - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0088C4E8, clBlack, TDButton(Sender).Hint);
          end;
        end;
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
          g_ImgMixSurface.SetSize(d.Width, d.Height);
          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
          DrawEffect(0, 0, g_ImgMixSurface, d, ceGrayScale);
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
        end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 36 - 5 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0099A8AC, clBlack, TDButton(Sender).Hint);
      end;
      if DHeroAssessSign.ShowHint then begin //界面变量区分
        if Sender = DHeroAssessSign1 then begin
          if GetTickCount - HeroAssessSignTimeTick > 300 then begin
           HeroAssessSignTimeTick := GetTickCount;
           Inc(HeroAssessSignImginsex);
           if HeroAssessSignImginsex > 7 then HeroAssessSignImginsex := 0;
          end;
          d := WLib.Images[1580+HeroAssessSignImginsex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)-4, d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBCallDeputyHeroClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  if GetTickCount - g_CallHeroTick > 1000 then begin
    if g_HeroSelf = nil then begin
      g_CallHeroTick := GetTickCount();
      //召唤副将英雄
      msg := MakeDefaultMsg (aa(CM_RECALLHERO, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
      frmMain.SendSocket(EncodeMessage (msg));
    end;
  end;
end;

procedure TFrmDlg.DCheckDeputyHeroWarrClick(Sender: TObject; X,
  Y: Integer);
var
 msg: TDefaultMessage;
begin
  if Sender = DCheckDeputyHeroWarr then begin
    DCheckDeputyHeroWarr.Checked := True;
    DCheckDeputyHeroWiz.Checked := False;
    DCheckDeputyHeroTaos.Checked := False;
  end else if Sender = DCheckDeputyHeroWiz then begin
    DCheckDeputyHeroWarr.Checked := False;
    DCheckDeputyHeroWiz.Checked := True;
    DCheckDeputyHeroTaos.Checked := False;
  end else begin
    DCheckDeputyHeroWarr.Checked := False;
    DCheckDeputyHeroWiz.Checked := False;
    DCheckDeputyHeroTaos.Checked := True;
  end;
  m_btDeputyHeroJob := TDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_CHOOSEHEROJOB, frmMain.TempCertification), m_btDeputyHeroJob, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket(EncodeMessage (msg));
end;

procedure TFrmDlg.DCheckHeroDeputyHeroWarrClick(Sender: TObject; X,
  Y: Integer);
var
 msg: TDefaultMessage;
begin
  if Sender = DCheckHeroDeputyHeroWarr then begin
    DCheckHeroDeputyHeroWarr.Checked := True;
    DCheckHeroDeputyHeroWiz.Checked := False;
    DCheckHeroDeputyHeroTaos.Checked := False;
  end else if Sender = DCheckHeroDeputyHeroWiz then begin
    DCheckHeroDeputyHeroWarr.Checked := False;
    DCheckHeroDeputyHeroWiz.Checked := True;
    DCheckHeroDeputyHeroTaos.Checked := False;
  end else begin
    DCheckHeroDeputyHeroWarr.Checked := False;
    DCheckHeroDeputyHeroWiz.Checked := False;
    DCheckHeroDeputyHeroTaos.Checked := True;
  end;
  m_btDeputyHeroJob := TDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_CHOOSEHEROJOB, frmMain.TempCertification), m_btDeputyHeroJob, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket(EncodeMessage (msg));
end;

procedure TFrmDlg.DHeroAssessSignClick(Sender: TObject; X, Y: Integer);
var
  str: string;
begin
  if DHeroAssessSign1.ShowHint then Exit;   //按钮变黑
  if not DHeroAssessSign.ShowHint then begin  
    if (g_GetDeputyHeroData[0].sChrName = '') or (g_GetDeputyHeroData[1].sChrName = '') then begin
      DMessageDlg ('您需要在酒馆寄存白日门英雄和卧龙英雄，才能进行评定。\（苍月岛仓库内的神秘人处领取白日门英雄，盟重酒馆外翔天等人处领取\卧龙英雄）', [mbOk]);
    end else begin
      if g_GetDeputyHeroData[0].Level = g_GetDeputyHeroData[1].Level then begin
        DMessageDlg ('您的英雄现在不满足成为副将英雄的条件！\可能原因：两位英雄等级相同无法进行评定', [mbOk]);
      end else begin
        DHeroAssessSign.ShowHint := True; //进入出战界面
        DWHeroAssess.SetImgIndex(g_WMainImages, 1541);
        DHeroAssessSign.Visible := False;
        DHeroAssessSign1.SetImgIndex(g_WMainImages, 1548);
        DHeroAssessSign1.Hint := '确定出战';
        DHeroAssessSign1.GLeft := 302;
        DHeroAssessSign1.GTop := 44;
        DHeroAssessClose1.SetImgIndex(g_WMainImages, 1548);
        DHeroAssessClose1.Hint := '暂不出战';
        DHeroAssessClose1.GLeft := 302;
        DHeroAssessClose1.GTop := 85;
        DWHeroAssess.GLeft := 400-DWHeroAssess.GWidth div 2;
        DWHeroAssess.GTop := 300-DWHeroAssess.GHeight div 2;
        DHeroAssessMenu.Visible := True;
      end;
    end;
  end else begin
    if g_GetDeputyHeroData[0].Level > g_GetDeputyHeroData[1].Level then begin
      str := ForMat('评定结果：%s为主将英雄。%s为副将英雄。你同\意该结果吗？\ \注意：一旦同意，将再无法更改结果，且英雄不能被删除。慎重！', [g_GetDeputyHeroData[0].sChrName, g_GetDeputyHeroData[1].sChrName]);
    end else begin
      str := ForMat('评定结果：%s为副将英雄。%s为主将英雄。你同\意该结果吗？\ \注意：一旦同意，将再无法更改结果，且英雄不能被删除。慎重！', [g_GetDeputyHeroData[0].sChrName, g_GetDeputyHeroData[1].sChrName]);
    end;
    if mrOk = FrmDlg.DMessageDlg (str, [mbOk, mbCancel]) then begin
      DHeroAssessSign1.ShowHint := True;
      DHeroAssessClose1.ShowHint := True;
      frmMain.SendAssessmentMainHero(ForMat('%s/%s',[g_GetDeputyHeroData[0].sChrName, g_GetDeputyHeroData[1].sChrName]), g_GetDeputyHeroData[0].Level, g_GetDeputyHeroData[1].Level);
    end;
  end;
end;

procedure TFrmDlg.DHeroAssessMenuDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  hcolor: Integer;
begin
  with DHeroAssessMenu do begin
    dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop), {clMaroon}clRed, '选择出战，结果不可更改！请详查');
    frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
    if g_btHeroAssessMenuMoving = 1 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+16, hcolor, '评定作用');
    if g_btHeroAssessMenuMoving = 2 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+30, hcolor, '副将特色');
    if g_btHeroAssessMenuMoving = 3 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+44, hcolor, '协同作战');
    if g_btHeroAssessMenuMoving = 4 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+58, hcolor, '复仇模式');
    if g_btHeroAssessMenuMoving = 5 then begin
      if g_boHeroAssessMenuDowning then begin
        hcolor := clRed;
      end else hcolor := $0048A4E8;
    end else hcolor := clYellow;
    dsurface.TextOut (SurfaceX(GLeft), SurfaceY(GTop)+72, hcolor, '宣布人选（最终结果）');
    frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];  //字体下划线
  end;
end;

procedure TFrmDlg.DHeroAssessMenuMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  lx, ly: Integer;
begin
  g_boHeroAssessMenuDowning := False;
  g_btHeroAssessMenuMoving := 0;
  lx := X - DHeroAssessMenu.GLeft;
  ly := Y - DHeroAssessMenu.GTop;
  if (lx >= 0) and (lx <= 46) and (ly >= 16) and (ly <= 27) then begin
    g_btHeroAssessMenuMoving := 1;
    if ssLeft in Shift then g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 46) and (ly >= 29) and (ly <= 41) then begin
    g_btHeroAssessMenuMoving := 2;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 46) and (ly >= 43) and (ly <= 55) then begin
    g_btHeroAssessMenuMoving := 3;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 46) and (ly >= 57) and (ly <= 69) then begin
    g_btHeroAssessMenuMoving := 4;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end else
  if (lx >= 0) and (lx <= 118) and (ly >= 71) and (ly <= 83) then begin
    g_btHeroAssessMenuMoving := 5;
    if ssLeft in Shift then  g_boHeroAssessMenuDowning := True;
  end;
end;

procedure TFrmDlg.DHeroAssessMenuMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  lx, ly: Integer;
begin
  lx := X - DHeroAssessMenu.GLeft;
  ly := Y - DHeroAssessMenu.GTop;
  if Button = mbLeft then begin
    if (lx >= 0) and (lx <= 46) and (ly >= 16) and (ly <= 27) then begin
      g_btHeroAssessMenuIndex := 1;
    end else
    if (lx >= 0) and (lx <= 46) and (ly >= 29) and (ly <= 41) then begin
      g_btHeroAssessMenuIndex := 2;
    end else
    if (lx >= 0) and (lx <= 46) and (ly >= 43) and (ly <= 55) then begin
      g_btHeroAssessMenuIndex := 3;
    end else
    if (lx >= 0) and (lx <= 46) and (ly >= 57) and (ly <= 69) then begin
      g_btHeroAssessMenuIndex := 4;
    end else
    if (lx >= 0) and (lx <= 118) and (ly >= 71) and (ly <= 83) then begin
      g_btHeroAssessMenuIndex := 0;
    end;
  end;
end;

procedure TFrmDlg.DHeroAssessCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWHeroAssess.Visible := False;
end;

procedure TFrmDlg.DWHeroAutoPracticeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  function GetHeroIcon(Job,Sex: Byte): Integer;
  var
    Icon: Integer;
  begin
    case Job of
      0:Icon := 502;
      1:Icon := 506;
      2:Icon := 504;
      else Icon := 502;
    end;
    if Sex = 1 then Result := Icon +1
    else Result := Icon;
  end;
var
  d: TDirectDrawSurface;
  Icon: Integer;
  str, str1: string;
begin
  with DWHeroAutoPractice do begin
    if WLib <> nil then begin //20080701

      case g_btHeroAutoPracticePlace of
        0: begin
          d := WLib.Images[1571];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          str := '封魔谷';
          str1 := '获得经验内功经验';
        end;
        1: begin
          d := WLib.Images[1570];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          str := '雷炎洞穴';
          str1 := '获得大量经验';
        end;
        2: begin
          d := WLib.Images[1572];
          if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          str := '雪域地图';
          str1 := '获得大量内功经验';
        end;
      end;
      dsurface.TextOut(SurfaceX(GLeft)+316 - FrmMain.Canvas.TextWidth(str) div 2, SurfaceY(GTop)+73, $0088C4E8, str);
      dsurface.TextOut(SurfaceX(GLeft)+316 - FrmMain.Canvas.TextWidth(str1) div 2, SurfaceY(GTop)+96, $0088C4E8, str1);
      case g_btHeroAutoPracticeStrength of
        0: dsurface.TextOut(SurfaceX(GLeft)+298 , SurfaceY(GTop)+154, $0088C4E8, '低强度');
        1: dsurface.TextOut(SurfaceX(GLeft)+298 , SurfaceY(GTop)+154, $0088C4E8, '中强度');
        2: dsurface.TextOut(SurfaceX(GLeft)+298 , SurfaceY(GTop)+154, $0088C4E8, '高强度');
      end;
      if g_sHeroAutoPracticeChrName <> '' then begin
        dsurface.TextOut(SurfaceX(GLeft) + 62 - FrmMain.Canvas.TextWidth(g_sHeroAutoPracticeChrName) div 2 , SurfaceY(GTop) + 124, $0088C4E8, g_sHeroAutoPracticeChrName);
        Icon := GetHeroIcon(g_btHeroAutoPracticeJob, g_btHeroAutoPracticeSex);
        d := g_WMain2Images.Images[Icon];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft) + 19, SurfaceY(GTop) + 144, d.ClientRect, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroAutoPracticeMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  with DHeroAutoPracticeMemo do begin
    //dsurface.FillRect(Rect(SurfaceX(GLeft), SurfaceY(Top), SurfaceX(GLeft+GWidth), SurfaceY(Top+GHeight)), clred);
    case g_btHeroAutoPracticeStrength of
      0: begin
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop), clWhite, '低强度：获得较低经验和');
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14, clWhite, '内功经验，使用金币辅助');
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14+14, clWhite, '修炼');
      end;
      1: begin
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop), clWhite, '中强度：获得较多经验和');
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14, clWhite, '内功经验，每10秒需要金');
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14+14, clWhite, '币和'+IntToStr(g_btHeroAutoPracticeGameGird1)+'个灵符辅助修炼');
      end;
      2: begin
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop), clWhite, '高强度：获得极多经验和');
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14, clWhite, '内功经验，每10秒需要金');
        dsurface.TextOut(SurfaceX(GLeft) , SurfaceY(GTop)+14+14, clWhite, '币和'+IntToStr(g_btHeroAutoPracticeGameGird2)+'个灵符辅助修炼');
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroAutoPraMapPrevClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DHeroAutoPraMapNext then begin
    Inc (g_btHeroAutoPracticePlace);
    if g_btHeroAutoPracticePlace > 2 then g_btHeroAutoPracticePlace := 0;
  end else begin
    Dec (g_btHeroAutoPracticePlace);
    if g_btHeroAutoPracticePlace < 0 then
      g_btHeroAutoPracticePlace := 2;
  end;
end;

procedure TFrmDlg.DHeroAutoPraYDSPrevClick(Sender: TObject; X, Y: Integer);
begin
  if Sender = DHeroAutoPraYDSNext then begin
    Inc (g_btHeroAutoPracticeStrength);
    if g_btHeroAutoPracticeStrength > 2 then g_btHeroAutoPracticeStrength := 0;
  end else begin
    Dec (g_btHeroAutoPracticeStrength);
    if g_btHeroAutoPracticeStrength < 0 then
      g_btHeroAutoPracticeStrength := 2;
  end;
end;

procedure TFrmDlg.DHeroAutoPraCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWHeroAutoPractice.Visible := False;
end;

procedure TFrmDlg.DStartHeroAutoPraClick(Sender: TObject; X, Y: Integer);
begin
  if DStartHeroAutoPra.ShowHint then Exit;
  DStartHeroAutoPra.ShowHint := True;
  frmMain.SendHeroAutoPractice(g_btHeroAutoPracticePlace, g_btHeroAutoPracticeStrength);
end;

procedure TFrmDlg.DCheckHeroLevelHintClick(Sender: TObject; X, Y: Integer);
var
   msg: TDefaultMessage;
begin
  if not DCheckHeroLevelHint.Checked then
    msg := MakeDefaultMsg (aa(CM_SHOWHEROLEVEL, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount)
  else msg := MakeDefaultMsg (aa(CM_SHOWHEROLEVEL, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DHeroJQExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(HeroMagicPage*6+6, g_HeroMagicList.Count);
        for i:=HeroMagTop to magline-1 do begin
          pm := PTClientMagic (g_HeroMagicList[i]);
          if (pm.Def.wMagicId = 68) then begin
            if (pm.Level < 100) then begin
              rc := d.ClientRect;
              if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
                rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
              end;
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DHeroJQExpMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
begin
  if g_HeroSelf = nil then Exit;
  magline := _MIN(HeroMagicPage*6+6, g_HeroMagicList.Count);
  for i:=Heromagtop to magline-1 do begin
    pm := PTClientMagic (g_HeroMagicList[i]);
    if (pm.Def.wMagicId = 68) then begin
      if (pm.Level < 100) then begin
        sMsg := '当前经验:%d/%d';
        with DHeroJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      end;
      Break;
    end;
  end;
end;

procedure TFrmDlg.DWJenniferLongBoxDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  BackImages, I: Integer; //宝箱背景图
begin
  with DWJenniferLongBox do begin
    if g_boNewBoxs =2 then begin
      BackImages := 660;
      if FaceIndex = BackImages then begin
        if WLib <> nil then begin //20080701
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
        if g_BoxsIsFill = 3 then begin  //开始选择动画
            if GetTickCount - g_dwBoxsFlashTick > 100 then begin
            g_dwBoxsFlashTick := GetTickCount;
            Inc(g_BoxsFlashImg);
            if g_BoxsFlashImg > 9 then begin
              g_BoxsFlashImg := 0;
              g_BoxsIsFill := 8;
              ShowBoxsGird(True,g_boNewBoxs); //显示宝箱格
              g_boBoxsMiddleItems := True;
            end;
          end;
          if g_BoxsIsFill = 3 then begin
            d := g_WMainImages.Images[670+g_BoxsFlashImg];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)+32, d.ClientRect, d, True);
          end;
        end;
        if g_nFilledGetItmesID = 0 then begin
          dsurface.TextOut(SurfaceX(GLeft) + 304 , SurfaceY(GTop) + 106, clYellow, '您将获得开启免费奖励机会');
        end else begin
          dsurface.TextOut(SurfaceX(GLeft) + 340 , SurfaceY(GTop) + 106, clYellow, Format('还剩余%d张开启',[g_nFilledGetItmesID]));
        end;
        if g_boBoxsMiddleItems then begin
          dsurface.TextOut(SurfaceX(GLeft) + 55 , SurfaceY(GTop) + 106, clYellow, '双击上方暗格选择');
        end;
      end;
      if g_boPutBoxsKey then begin
        if GetTickCount - g_dwBoxsTick > 200 then begin
          g_dwBoxsTick := GetTickCount;
          Inc(g_nBoxsImg);
          if g_nBoxsImg > 6 then begin
            g_nBoxsImg := 0;
            g_boPutBoxsKey := False;
            SetImgIndex(g_WMainImages, BackImages);
            GLeft := 148;
            GTop  := 250;
            d := g_WMainImages.Images[BackImages];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
            ShowBoxsGird(True, g_boNewBoxs); //显示宝箱格
            MyPlaySound(BoxonCeagain_ground);
            DJenniferLongBoxClose.Visible := True;
            DJLChangeItem.Visible := True;
            DJLBoxFlash.Visible := True;
            DJLStartItem.Visible := True;
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 2;
            g_boJLBoxSelToTime := True;
            g_nBoxsImg := 20;
          end;
        end;
      end;
      if DJenniferLongBoxClose.Visible then Exit;
      //SetImgIndex(g_WMainImages, 720);
      d := g_WMainImages.Images[720+g_nBoxsImg];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, true);
      d := g_WMainImages.Images[720+7+g_nBoxsImg];
      if d <> nil then
        DrawBlend(dsurface,SurfaceX(GLeft), SurfaceY(GTop), d, 255);
    end else if g_boNewBoxs = 3 then begin
      if WLib <> nil then begin //20080701
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if g_boBoxsMiddleItems then begin
          dsurface.TextOut(SurfaceX(GLeft) + 53 , SurfaceY(GTop) + 250, clYellow, '点击上方暗格选择');
        end else if g_BoxsIsFill = 254 then begin
          dsurface.TextOut(SurfaceX(GLeft) + 53 , SurfaceY(GTop) + 250, clYellow, '天赐开启结束');
        end;
        if g_BoxsIsFill = 7 then  begin //覆盖前动画
          if GetTickCount - g_dwBoxsFlashTick > 200 then begin
            g_dwBoxsFlashTick := GetTickCount;
            Inc(g_BoxsFlashImg);
            if g_BoxsFlashImg > 7 then begin
              g_BoxsFlashImg := 0;
              for I:=Low(g_JLBoxFreeItems) to High(g_JLBoxFreeItems) do begin
                g_JLBoxFreeItems[I].boCloak := True;
              end;
              g_boBoxsLockGetItems := True;
              g_BoxsIsFill := 0;
              DGJLBoxFreeItem.Visible := True;
              g_BoxsMoveDegree := 20;
              g_boBoxsMiddleItems := True;
            end;
          end;
          if g_BoxsIsFill = 7 then begin
            d := g_WMainImages.Images[690+g_BoxsFlashImg];
            if d <> nil then
              dsurface.Draw (SurfaceX(GLeft+42), SurfaceY(GTop+40), d.ClientRect, d, TRUE);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DJLChangeItemMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  if g_BoxsFirstMove then Exit;
  DScreen.ShowHint(DJLChangeItem.SurfaceX(DJLChangeItem.GLeft)+DJLChangeItem.GWidth, DJLChangeItem.SurfaceY(DJLChangeItem.GTop),
       '换取奖励按钮\只有在第一次\选择前有效。'
       , clWhite, FALSE);
end;

procedure TFrmDlg.DJLBoxBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  JLBoxRunning(dsurface);
  with Sender as TDButton do begin
    if not g_boBoxsLockGetItems or ((g_BoxsMoveDegree = Tag) and (g_nPlayGetItmesID = 1)) then begin //显示双击上方暗格选择   显示选中物品
      if ShowHint then begin
          d := WLib.Images[662];
          if d <> nil then
             dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        JLBoxItemBelt(Sender, dsurface);
      end;
    end else begin
      if g_BoxsMoveDegree = Tag then begin
        d := WLib.Images[669];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end else begin
        if g_JLBoxItems[Tag].StdItem.MakeIndex <> 0 then begin
          d := WLib.Images[662];
          if d <> nil then
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
          JLBoxItemBelt(Sender, dsurface);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DJLBoxBelt1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  iname: string;
begin
  DScreen.ClearHint;
  with Sender as TDButton do begin
    iname := g_JLBoxItems[Tag].StdItem.S.Name + '\' + '数量: '+IntToStr(g_JLBoxItems[Tag].nItemNum);
    if g_boBoxsLockGetItems then begin
      if g_JLBoxItems[Tag].StdItem.MakeIndex = 0 then begin
        DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname+'\(已经领取)', clRed, FALSE);
      end else begin
        if g_BoxsFirstMove then Exit;
        if (g_BoxsMoveDegree = Tag) and (g_nPlayGetItmesID = 1) then begin
          DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname+'\(双击获得)', clYellow, FALSE);
        end else begin
          DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), '双击领取', clWhite, FALSE);
        end;
      end;
    end else begin
      if g_BoxsFirstMove then Exit;
      if g_JLBoxItems[Tag].StdItem.MakeIndex = 0 then begin
        DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname+'\(已经领取)', clRed, FALSE);
      end else begin
        DScreen.ShowHint(SurfaceX(GLeft + GWidth), SurfaceY(GTop), iname, clWhite, FALSE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWJenniferLongBoxMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWJenniferLongBoxClick(Sender: TObject; X, Y: Integer);
begin
  if (not g_boItemMoving) and (g_MovingItem.Item.S.Name = '') and (not g_boPutBoxsKey) and (not DJenniferLongBoxClose.Visible) then  begin
    AddItemBag (g_EatingItem);
    DWJenniferLongBox.Visible := False;
    ShowBoxsGird(False, g_boNewBoxs); //显示宝箱格
  end;
end;

procedure TFrmDlg.DJenniferLongBoxCloseClick(Sender: TObject; X,
  Y: Integer);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg(aa(CM_OPEN9YEARSBOXS, frmMain.TempCertification), 0, 0, 1, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket(EncodeMessage(msg));
  DWJenniferLongBox.Visible := False;
end;

procedure TFrmDlg.DJLChangeItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   btn:TDButton;
begin
  if Sender = DJLStartItem then begin
    if g_boJLBoxSelToTime and (not DJLStartItem.ShowHint) then begin //开始到记时
      if GetTickCount - g_dwBoxsTick > 999 then begin
        g_dwBoxsTick := GetTickCount;
        Dec(g_nBoxsImg);
        if g_nBoxsImg < 1 then begin
          g_nBoxsImg := 0;
          g_boJLBoxSelToTime := False;
          DJLStartItemClick(DJLStartItem, 0, 0);
        end;
        DJLStartItem.Hint := Format('开始选择(%d)',[g_nBoxsImg]);
      end;
    end;
  end;
  with Sender as TDButton do begin
    {btn:=TDButton(Sender);   remark by liuzhigang on 2011.12.29
    if ShowHint then begin
      if btn.WLib <> nil then begin //20080701
       d := WLib.Images[668];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
      dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 5, $0099A8AC, clBlack, Hint);
      Exit;
    end;}
    if WLib <> nil then begin
      if TDButton(Sender).Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 6, $0048A4E8, clBlack, Hint);
      end else begin
        if MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $00A8D4E8, clBlack, TDButton(Sender).Hint);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0088C4E8, clBlack, TDButton(Sender).Hint);
        end;
      end;
    end;
  end;
end;

//珍珑宝箱更换奖励
procedure TFrmDlg.JLBoxRunning(dsurface: TDirectDrawSurface);
var
  msg: TDefaultMessage;
begin
  if g_boBoxsShowPosition then begin
    if GetTickCount - g_BoxsShowPositionTick > 220 then begin
     g_BoxsShowPositionTick := GetTickCount;
     Inc(g_BoxsShowPosition);
      if g_BoxsShowPosition > 7 then begin
        g_BoxsShowPosition := -1;
        g_boBoxsShowPosition := False;
        g_BoxsFirstMove := False;
      end;
      if not g_boBoxsShowPosition then Exit;
      if g_nPlayGetItmesID = 2 then begin
        while True do begin
          if (g_BoxsShowPosition < 0) or (g_BoxsShowPosition > 7) then break;
          if g_JLBoxItems[g_BoxsShowPosition].StdItem.MakeIndex = 0 then begin
            Inc(g_BoxsShowPosition);
          end else break;
        end;
        if g_BoxsShowPosition < 8 then g_JLBoxAllItemTag := g_BoxsShowPosition;
      end;
      case g_BoxsShowPosition of
        0: DJLBoxBelt1.ShowHint := g_nPlayGetItmesID <> 2;
        1: DJLBoxBelt2.ShowHint := g_nPlayGetItmesID <> 2;
        2: DJLBoxBelt3.ShowHint := g_nPlayGetItmesID <> 2;
        3: DJLBoxBelt4.ShowHint := g_nPlayGetItmesID <> 2;
        4: DJLBoxBelt5.ShowHint := g_nPlayGetItmesID <> 2;
        5: DJLBoxBelt6.ShowHint := g_nPlayGetItmesID <> 2;
        6: DJLBoxBelt7.ShowHint := g_nPlayGetItmesID <> 2;
        7: begin
          DJLBoxBelt8.ShowHint := g_nPlayGetItmesID <> 2;
          if g_nPlayGetItmesID <> 2 then begin
            msg := MakeDefaultMsg (aa(CM_UPDATA9YEARSBOXSITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
            FrmMain.SendSocket(EncodeMessage(msg));
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DJLChangeItemClick(Sender: TObject; X, Y: Integer);
begin
  if DJLChangeItem.ShowHint then Exit;
  g_BoxsFirstMove := True;
  DJLChangeItem.ShowHint := True;
  DJLStartItem.ShowHint := True;
  g_boBoxsShowPosition := True;
end;

procedure TFrmDlg.DJLStartItemClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  if DJLStartItem.ShowHint then Exit;
  g_boJLBoxSelToTime := False;
  if g_nPlayGetItmesID = 3 then begin
    msg := MakeDefaultMsg (aa(CM_OPENNEW9YEARSBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  end else begin
    if g_nFilledGetItmesID = 0 then begin
      msg := MakeDefaultMsg (aa(CM_OPENFREE9YEARSBOXS, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    end else begin
      msg := MakeDefaultMsg (aa(CM_CHECK9YEARSBOXSKEY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    end;
  end;
  FrmMain.SendSocket(EncodeMessage(msg));
end;

procedure TFrmDlg.DJLBoxBelt1Click(Sender: TObject; X, Y: Integer);
begin
  if not g_boBoxsMiddleItems then Exit;
  if g_JLBoxItems[TDButton(Sender).Tag].StdItem.MakeIndex > 0 then g_BoxsMoveDegree := TDButton(Sender).Tag;
end;

procedure TFrmDlg.DJLBoxBelt1DblClick(Sender: TObject);
var
  I: Integer;
  temp:TBoxsInfo;
begin
  if not g_boBoxsMiddleItems then Exit;
  if g_JLBoxItems[TDButton(Sender).Tag].StdItem.MakeIndex = 0 then Exit;
  if g_JLBoxItems[TDButton(Sender).Tag].StdItem.MakeIndex > 0 then g_BoxsMoveDegree := TDButton(Sender).Tag;
  g_boBoxsMiddleItems := False;
  g_BoxsFirstMove := True;
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if g_BoxsMakeIndex > 0 then begin
      for I:=0 to 7 do begin
        if g_JLBoxItems[I].StdItem.MakeIndex = g_BoxsMakeIndex then begin  //制造ID为M2定好的
          temp := g_JLBoxItems[I];
          g_JLBoxItems[I] := g_JLBoxItems[Tag];
          g_JLBoxItems[Tag] := temp;
          break;
        end;
      end;
      g_BoxsFilleFlashImg := 0;
      g_BoxsIsFill := 4;  //显示选择完动画
    end;
  end;
end;

procedure TFrmDlg.DJLBoxFlashDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  bbx: Integer;
  d: TDirectDrawSurface;
  msg: TDefaultMessage;
begin
  if g_BoxsIsFill = 4 then begin
    with DJLBoxFlash do begin
      case g_BoxsMoveDegree of
        0: bbx := DJLBoxBelt1.GLeft;
        1: bbx := DJLBoxBelt2.GLeft;
        2: bbx := DJLBoxBelt3.GLeft;
        3: bbx := DJLBoxBelt4.GLeft;
        4: bbx := DJLBoxBelt5.GLeft;
        5: bbx := DJLBoxBelt6.GLeft;
        6: bbx := DJLBoxBelt7.GLeft;
        7: bbx := DJLBoxBelt8.GLeft;
      end;
      if GetTickCount - g_dwBoxsFilleFlashTick > 200 then begin
        g_dwBoxsFilleFlashTick := GetTickCount;
        Inc(g_BoxsFilleFlashImg);
        if g_BoxsFilleFlashImg = 8 then begin
          g_nPlayGetItmesID := 1;
          g_BoxsFirstMove := False;
        end;
        if g_BoxsFilleFlashImg > 9 then begin
          g_BoxsFilleFlashImg := 0;
          g_BoxsIsFill := 5;
          msg := MakeDefaultMsg (aa(CM_GET9YEARSBOXSITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
          FrmMain.SendSocket(EncodeMessage(msg));
        end;
      end;
      if g_BoxsIsFill = 5 then Exit;
      d := g_WMainImages.Images[700+g_BoxsFilleFlashImg];
      if d <> nil then
        DrawBlend(dsurface,SurfaceX(bbx-26),SurfaceY(DJLBoxBelt1.GTop-26), d, 255);
    end;
  end;
end;

procedure TFrmDlg.JLBoxItemBelt(Sender: TObject; dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  idx: Integer;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_JLBoxItems[Tag].StdItem.S.Name <> '' then begin
      idx := g_JLBoxItems[Tag].StdItem.S.Looks;
      if idx >= 0 then begin
        d := frmMain.GetBagItemImg(idx);
        if g_JLBoxItems[Tag].StdItem.MakeIndex <> 0 then begin
          if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                       SurfaceY(GTop + (GHeight - d.Height) div 2),
                       d.ClientRect, d, TRUE)
          end;
        end else begin
          if d <> nil then begin
            dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2),d.Width, d.Height ),Rect(0,0,d.Width, d.Height),d);
          end;
          d := g_WMainImages.Images[666];
          if d <> nil then begin
            dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft + (GWidth - d.Width) div 2), SurfaceY(GTop + (GHeight - d.Height) div 2),d.Width, d.Height ),Rect(0,0,d.Width, d.Height),d);
          end;
        end;
      end;
      if (g_BoxsIsFill = 8) and (g_JLBoxItems[Tag].StdItem.MakeIndex <> 0) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 4 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill = 0 then Exit;
        d := g_WMain2Images.Images[250+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(GLeft-14),SurfaceY(GTop-14), d, 255);
      end;
      if (g_BoxsIsFill = 7) and (g_nPlayGetItmesID = 2) and (g_JLBoxAllItemTag = Tag) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 9 then begin
            if g_nFilledGetItmesID  <> 0 then DJLStartItem.Hint := '再开一张';
            DJLStartItem.ShowHint := False;
            g_BoxsFilleFlashImg := 0;
            g_nPlayGetItmesID := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill = 0 then Exit;
        d := g_WMain2Images.Images[240+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(GLeft-14),SurfaceY(GTop-14), d, 255);
      end;
      if (g_BoxsIsFill = 6) and (g_BoxsMoveDegree = Tag) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 5 then begin
            g_boBoxsLockGetItems := False;
            DJLBoxBelt1.ShowHint := g_JLBoxItems[0].StdItem.MakeIndex <> 0;
            DJLBoxBelt2.ShowHint := g_JLBoxItems[1].StdItem.MakeIndex <> 0;
            DJLBoxBelt3.ShowHint := g_JLBoxItems[2].StdItem.MakeIndex <> 0;
            DJLBoxBelt4.ShowHint := g_JLBoxItems[3].StdItem.MakeIndex <> 0;
            DJLBoxBelt5.ShowHint := g_JLBoxItems[4].StdItem.MakeIndex <> 0;
            DJLBoxBelt6.ShowHint := g_JLBoxItems[5].StdItem.MakeIndex <> 0;
            DJLBoxBelt7.ShowHint := g_JLBoxItems[6].StdItem.MakeIndex <> 0;
            DJLBoxBelt8.ShowHint := g_JLBoxItems[7].StdItem.MakeIndex <> 0;
            g_nPlayGetItmesID := 2;
            g_boBoxsShowPosition := True;
            g_BoxsFirstMove := True;
            g_boBoxsMiddleItems := False;
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 7;
          end;
        end;
        if g_BoxsIsFill = 7 then Exit;
        d := g_WMain2Images.Images[231+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(GLeft-14),SurfaceY(GTop-14), d, 255);
      end;
      if (g_BoxsIsFill = 5) and (g_BoxsMoveDegree = Tag) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 5 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill = 0 then Exit;
        d := g_WMain2Images.Images[260+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(GLeft-14),SurfaceY(GTop-14), d, 255);
      end;
      if not (g_BoxsIsFill in [0,4,5,6,7]) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 7 then begin
            g_BoxsFilleFlashImg := 0;
            g_BoxsIsFill := 0;
          end;
        end;
        if g_BoxsIsFill in [0,4,5,6,7] then Exit;
        d := g_WMain2Images.Images[250+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(GLeft-14),SurfaceY(GTop-14), d, 255);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGJLBoxFreeItemGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
   idx, looks: integer;
   d: TDirectDrawSurface;
   msg: TDefaultMessage;
begin
  JLBoxFreeRunning(dsurface);
  idx := ACol + ARow * DGJLBoxFreeItem.ColCount;
  with DGJLBoxFreeItem do  begin
    d := g_WMainImages.Images[661];
    dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                    SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                    d.ClientRect,
                    d, TRUE);
    if idx in [0..19] then begin
      if g_JLBoxFreeItems[idx].Item.StdItem.S.Name <> '' then begin
        looks := g_JLBoxFreeItems[idx].Item.StdItem.S.Looks;
        if looks >= 0 then begin
          if g_JLBoxFreeItems[idx].boCloak then begin
            if {g_boBoxsMiddleItems and} (idx = g_BoxsMoveDegree) then begin
              d := g_WMainImages.Images[669];
            end else d := g_WMainImages.Images[662];
          end else d := frmMain.GetBagItemImg(looks);
          if g_JLBoxFreeItems[idx].Item.StdItem.MakeIndex <> 0 then begin
            if d <> nil then begin
              dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                    SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                    d.ClientRect,
                    d, TRUE)
            end;
          end else begin
            if d <> nil then begin
              dsurface.FastDrawAlpha(Bounds(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1), d.Width, d.Height),Classes.Rect(0,0,d.Width, d.Height),d);
            end;
            d := g_WMainImages.Images[666];
            if d <> nil then begin
              dsurface.FastDrawAlpha(Bounds(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2), SurfaceY(Rect.Top + (RowHeight - d.Height) div 2),d.Width, d.Height ),Classes.Rect(0,0,d.Width, d.Height),d);
            end;
          end;
        end;
      end;
      if g_BoxsIsFill = 3 then begin //换物品动画
        if GetTickCount - g_dwBoxsFlashTick > 130 then begin
          g_dwBoxsFlashTick := GetTickCount;
          Inc(g_BoxsFlashImg);
          if g_BoxsFlashImg > 15 then begin
            g_BoxsFlashImg := 0;
            Visible := False;
            g_boBoxsMiddleItems := False;
            g_BoxsIsFill := 7;
          end;
        end;
        if g_BoxsFlashImg < 6 then begin
          d := g_WMain2Images.Images[250+g_BoxsFlashImg];
          if d <> nil then
            DrawBlend(dsurface,SurfaceX(Rect.Left-16),SurfaceY(Rect.Top-16), d, 255);
        end;
      end;
      if g_BoxsIsFill = 4 then begin
        if idx = g_BoxsMoveDegree then begin
          if GetTickCount - g_dwBoxsFilleFlashTick > 200 then begin
            g_dwBoxsFilleFlashTick := GetTickCount;
            Inc(g_BoxsFilleFlashImg);
            if g_BoxsFilleFlashImg = 8 then begin
              g_JLBoxFreeItems[idx].boCloak := False;
            end;
            if g_BoxsFilleFlashImg > 9 then begin
              g_BoxsFilleFlashImg := 0;                      
              g_BoxsIsFill := 5;
              msg := MakeDefaultMsg (aa(CM_GETFREE9YEARSBOXSITEM, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
              FrmMain.SendSocket(EncodeMessage(msg));
            end;
          end;
          if g_BoxsIsFill = 5 then Exit;
          d := g_WMainImages.Images[700+g_BoxsFilleFlashImg];
          if d <> nil then
            DrawBlend(dsurface,SurfaceX(Rect.Left-26),SurfaceY(Rect.Top-26), d, 255);
        end;
      end;
      if g_BoxsIsFill = 5 then begin
        if g_BoxsMoveDegree = Idx then begin
          if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
            g_dwBoxsFilleFlashTick := GetTickCount;
            Inc(g_BoxsFilleFlashImg);
            if g_BoxsFilleFlashImg > 5 then begin
              g_BoxsFilleFlashImg := 0;
              g_BoxsIsFill := 0;
            end;
          end;
          if g_BoxsIsFill = 0 then Exit;
          d := g_WMain2Images.Images[260+g_BoxsFilleFlashImg];
          if d <> nil then
            DrawBlend(dsurface,SurfaceX(Rect.Left-14),SurfaceY(Rect.Top-14), d, 255);
        end;
      end;
      if (g_BoxsIsFill = 6) and (g_BoxsMoveDegree = idx) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          if g_BoxsFilleFlashImg > 5 then begin
            g_BoxsFilleFlashImg := 0;
            g_boBoxsLockGetItems := False;
            g_boBoxsShowPosition := True;
            g_BoxsFirstMove := True;
            g_nPlayGetItmesID := 2;
            g_BoxsIsFill := 8;
          end;
        end;
        if g_BoxsIsFill = 8 then Exit;
        d := g_WMain2Images.Images[231+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(Rect.Left-14),SurfaceY(Rect.Top-14), d, 255);
      end;
      if (g_BoxsIsFill = 8) and (g_nPlayGetItmesID = 2) and (g_JLBoxAllItemTag = idx) then begin
        if GetTickCount - g_dwBoxsFilleFlashTick > 230 then begin
          g_dwBoxsFilleFlashTick := GetTickCount;
          Inc(g_BoxsFilleFlashImg);
          Inc(g_nFilledGetItmesID);
          if g_BoxsFilleFlashImg > 9 then begin
            g_BoxsFilleFlashImg := 0;
          end;
          if g_nFilledGetItmesID > 19 then begin
            DJLStartItem.Hint := '开启新天赐';
            DJLStartItem.GLeft := 137;
            DJLStartItem.GTop := 258;
            DJLStartItem.Visible := True;
            g_BoxsFirstMove := False;
            g_nPlayGetItmesID := 3;
            g_nFilledGetItmesID := 0;
            g_BoxsIsFill := 254;
          end;
        end;
        if g_BoxsIsFill = 254 then Exit;
        d := g_WMain2Images.Images[240+g_BoxsFilleFlashImg];
        if d <> nil then
          DrawBlend(dsurface,SurfaceX(Rect.Left-14),SurfaceY(Rect.Top-14), d, 255);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGJLBoxFreeItemGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  iname: string;
  idx: Byte;
begin
  DScreen.ClearHint;
  idx := ACol + ARow * DGJLBoxFreeItem.ColCount;
  with DGJLBoxFreeItem do begin
    if idx in [0..19] then begin
      iname := g_JLBoxFreeItems[idx].Item.StdItem.S.Name + '\' + '数量: '+IntToStr(g_JLBoxFreeItems[idx].Item.nItemNum);
      if g_boBoxsLockGetItems then begin
        if g_BoxsFirstMove then Exit;
        if (g_BoxsMoveDegree = idx) and (not g_JLBoxFreeItems[idx].boCloak) then begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), iname+'\(双击获得)', clYellow, FALSE);
        end else begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), '双击选择奖励', clWhite, FALSE);
        end;
      end else begin
        if g_BoxsFirstMove then Exit;
        if g_JLBoxFreeItems[idx].Item.StdItem.MakeIndex = 0 then begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), iname+'\(已经领取)', clRed, FALSE);
        end else begin
          DScreen.ShowHint(SurfaceX(GLeft+(ACol+1)*ColWidth), SurfaceY(GTop+ARow*RowHeight), iname, clWhite, FALSE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGJLBoxFreeItemGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Byte;
begin
  if not g_boBoxsMiddleItems then Exit;
  idx := ACol + ARow * DGJLBoxFreeItem.ColCount;
  if idx in [0..19] then g_BoxsMoveDegree := idx;
end;

procedure TFrmDlg.DGJLBoxFreeItemDblClick(Sender: TObject);
var
  I, idx: Integer;
  temp:TJLBoxFreeItem;
begin
  if not g_boBoxsMiddleItems then Exit;
  idx := DGJLBoxFreeItem.Col + DGJLBoxFreeItem.Row * DGJLBoxFreeItem.ColCount;
  if idx in [0..19] then g_BoxsMoveDegree := idx;
  g_boBoxsMiddleItems := False;
  g_BoxsFirstMove := True;
  with DGJLBoxFreeItem do begin
    if idx in [0..19] then begin
      if (g_JLBoxFreeItems[idx].Item.StdItem.MakeIndex > 0) and (g_BoxsMakeIndex > 0)then begin
        for I:=0 to 19 do begin
          if g_JLBoxFreeItems[I].Item.StdItem.MakeIndex = g_BoxsMakeIndex then begin  //制造ID为M2定好的
            temp := g_JLBoxFreeItems[I];
            g_JLBoxFreeItems[I] := g_JLBoxFreeItems[idx];
            g_JLBoxFreeItems[idx] := temp;
            break;
          end;
        end;
        g_BoxsFilleFlashImg := 0;
        g_BoxsIsFill := 4;  //显示选择完动画
      end;
    end;
  end;
end;
//珍珑免费宝箱翻牌
procedure TFrmDlg.JLBoxFreeRunning(dsurface: TDirectDrawSurface);
begin
  if g_boBoxsShowPosition then begin
    if GetTickCount - g_BoxsShowPositionTick > 220 then begin
     g_BoxsShowPositionTick := GetTickCount;
     Inc(g_BoxsShowPosition);
      if g_BoxsShowPosition > 19 then begin
        g_BoxsShowPosition := -1;
        g_boBoxsShowPosition := False;
      end;
      if not g_boBoxsShowPosition then Exit;
      if g_nPlayGetItmesID = 2 then begin
        while True do begin
          if (g_BoxsShowPosition < 0) or (g_BoxsShowPosition > 19) then break;
          if g_JLBoxFreeItems[g_BoxsShowPosition].Item.StdItem.MakeIndex = 0 then begin
            Inc(g_BoxsShowPosition);
          end else break;
        end;
        if g_BoxsShowPosition < 20 then g_JLBoxAllItemTag := g_BoxsShowPosition;
      end;
      if g_BoxsShowPosition in [0..19] then begin
        g_JLBoxFreeItems[g_BoxsShowPosition].boCloak := False;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBCommandFrameDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  I: Integer;
begin
  d := g_WMainImages.Images[403];
  if d <> nil then begin
    with DBCommandFrame do begin
      dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft), SurfaceY(GTop), GWidth, GHeight ),Rect(0,0, GWidth, GHeight),d);
      if g_CommandList.Count > 0 then begin
        with dsurface.Canvas do begin
          if g_ComMandIndex <> -1 then begin
            Brush.Color := $00400000;
            Pen.Color := $00400000;
            Rectangle(SurfaceX(GLeft)+2, SurfaceY(GTop)+g_ComMandIndex*20+2 ,SurfaceX(GLeft)+GWidth-2,SurfaceY(GTop)+g_ComMandIndex*20+20+2);
            Release;
          end;
          for I:=0 to g_CommandList.Count - 1 do begin
            dsurface.TextOut(SurfaceX(GLeft) + 12, SurfaceY(GTop)+I*20+6, clWhite, g_CommandList[i]);
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBCommandMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  g_ComMandIndex := -1;
  DBCommandFrame.GTop := DBCommand.GTop - DBCommandFrame.GHeight; 
  DBCommandFrame.Visible := True;
end;

procedure TFrmDlg.DBCommandFrameMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
  ss: Integer;
begin
  with DBCommandFrame do begin
    if g_CommandList.Count >0 then begin
      ss := ((Y - GTop) - 1) div 20;
      if ss >= g_CommandList.Count then ss := g_CommandList.Count - 1;
      if ss <= 0 then ss := 0;
      g_ComMandIndex := ss;
    end else g_ComMandIndex := -1;
  end;
end;

procedure TFrmDlg.DBCommandFrameMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
var
  Str: string;
begin
  Str := '';
  case g_ComMandIndex of
    2,5,8,11: Str := '-';
    0: Str := '@加入门派';
    1: Str := '@退出门派';
    3: Str := '@允许收徒';
    4: Str := '@拒绝收徒';
    6: Str := '@拒绝求婚';
    7: Str := '@允许求婚';
    9: Str := '@天地合一';
    10: Str := '@允许天地合一';
    13: Str := '!';
    14: Str := '!~';
    15: Str := '!!';
    16: Str := '/ ';
    17: Str := '@传 ';
    18: Str := '!#';
  end;
  if Str <> '-' then begin
    if not PlayScene.EdChat.Visible then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
    end;
    PlayScene.EdChat.Text := Str;
    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
    PlayScene.EdChat.SelLength := 0;
  end;
end;

procedure TFrmDlg.DCBFilterItemStdModeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  I, X1, Y1, X2, Y2: Integer;
   FontColor: Tcolor;
begin
  with Sender as TDComboBox do begin
    X1 := SurfaceX(GLeft) + (GWidth - 16) + 5;
    Y1 := SurfaceY(GTop) + (GHeight - 5) div 2;

    if Downed then Y1 := Y1 + 1;
    X2 := X1 + 3;
    Y2 := Y1 + 4;

    for I := X1 to X1 + 6 do begin
      dsurface.FastLine(I, Y1, X2, Y2, $00488184);
    end;
    {with dsurface.Canvas do begin
      Brush.Color := Color;
      if TDComboBox(Sender).Downed then
        Polygon([Point(SurfaceX(GLeft)+63+3,   SurfaceY(GTop)+12),   Point(SurfaceX(GLeft)+63,   SurfaceY(GTop)+9),   Point(SurfaceX(GLeft)+63+6,   SurfaceY(GTop)+9)])   //画三角形
      else
        Polygon([Point(SurfaceX(GLeft)+63+3,   SurfaceY(GTop)+11),   Point(SurfaceX(GLeft)+63,   SurfaceY(GTop)+8),   Point(SurfaceX(GLeft)+63+6,   SurfaceY(GTop)+8)]);   //画三角形
      Release;
    end; }
  end;
end;

procedure TFrmDlg.DEdtFilterItemStdModeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  with Sender as TDEdit do begin
    with dsurface.Canvas do begin
      //=================================================
      if TDEdit(Sender).Moveed then
      pen.Color := $00387B9C    //画边界线
      else
      pen.Color := $00638494;    //画边界线
      if TDEdit(Sender).Focused then pen.Color := $005993BD;
      MoveTo(SurfaceX(GLeft),   SurfaceY(GTop));
      LineTo(SurfaceX(GLeft)+GWidth,   SurfaceY(GTop));
      LineTo(SurfaceX(GLeft)+GWidth,   SurfaceY(GTop)+GHeight);
      LineTo(SurfaceX(GLeft),   SurfaceY(GTop)+GHeight);
      LineTo(SurfaceX(GLeft),   SurfaceY(GTop));
      //==================================================
      Release;
      if TDEdit(Sender).Text = '' then  dsurface.TextOut(SurfaceX(GLeft)+2, SurfaceY(GTop)+4, $00808080, '[输入物品关键字查找]');
    end;
  end;
end;

procedure TFrmDlg.DBtnDefaultFilterItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  with Sender as TDButton do begin
    frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];
    if not TDButton(Sender).Downed then begin
      dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop) + 5, clYellow, TDButton(Sender).Hint);
    end else begin
      dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop) + 6, clRed, TDButton(Sender).Hint);
    end;
    frmMain.Canvas.Font.Style := [];
  end;
end;

procedure TFrmDlg.DEdtBookHPProChange(Sender: TObject);
begin
  if TDEdit(Sender).Text <> '' then begin
    case m_btProPage of
      0: begin
        if Sender = DEdtBookHPPro then begin
          g_Config.wHp1Hp := Str_ToInt(DEdtBookHPPro.Text, 0);
        end else if Sender = DEdtBookMPPro then begin
          g_Config.wMp1Mp := Str_ToInt(DEdtBookMPPro.Text, 0);
        end else if Sender = DEdtRenewHP then begin
          g_Config.wRenewHPPercent := Str_ToInt(DEdtRenewHP.Text, g_Config.wRenewHPPercent);
        end else if Sender = DEdtRenewMP then begin
          g_Config.wRenewMPPercent := Str_ToInt(DEdtRenewMP.Text, g_Config.wRenewMPPercent);
        end else if Sender = DEdtRenewHPTime then begin
          g_Config.wRenewHPTime := Str_ToInt(DEdtRenewHPTime.Text, g_Config.wRenewHPTime);
        end else if Sender = DEdtRenewMpTime then begin
          g_Config.wRenewMpTime := Str_ToInt(DEdtRenewMpTime.Text, g_Config.wRenewMpTime);
        end else if Sender = DEdtRenewHPSpecial then begin
          g_Config.wRenewSpecialHPPercent := Str_ToInt(DEdtRenewHPSpecial.Text, g_Config.wRenewSpecialHPPercent);
        end else if Sender = DEdtRenewMpSpecial then begin
          g_Config.wRenewSpecialMpPercent := Str_ToInt(DEdtRenewMpSpecial.Text, g_Config.wRenewSpecialMpPercent);
        end else if Sender = DEdtRenewHPSpecialTime then begin
          g_Config.wRenewSpecialHPTime := Str_ToInt(DEdtRenewHPSpecialTime.Text, g_Config.wRenewSpecialHPTime);
        end else if Sender = DEdtRenewMpSpecialTime then begin
          g_Config.wRenewSpecialMpTime := Str_ToInt(DEdtRenewMpSpecialTime.Text, g_Config.wRenewSpecialMpTime);
        end else if Sender = DEditSuperMedicaHP1 then begin
          g_Config.SuperMedicaHPs[0] := Str_ToInt(DEditSuperMedicaHP1.Text, g_Config.SuperMedicaHPs[0]);
        end else if Sender = DEditSuperMedicaHP2 then begin
          g_Config.SuperMedicaHPs[1] := Str_ToInt(DEditSuperMedicaHP2.Text, g_Config.SuperMedicaHPs[1]);
        end else if Sender = DEditSuperMedicaHP3 then begin
          g_Config.SuperMedicaHPs[2] := Str_ToInt(DEditSuperMedicaHP3.Text, g_Config.SuperMedicaHPs[2]);
        end else if Sender = DEditSuperMedicaHP4 then begin
          g_Config.SuperMedicaHPs[3] := Str_ToInt(DEditSuperMedicaHP4.Text, g_Config.SuperMedicaHPs[3]);
        end else if Sender = DEditSuperMedicaHP5 then begin
          g_Config.SuperMedicaHPs[4] := Str_ToInt(DEditSuperMedicaHP5.Text, g_Config.SuperMedicaHPs[4]);
        end else if Sender = DEditSuperMedicaHP6 then begin
          g_Config.SuperMedicaHPs[5] := Str_ToInt(DEditSuperMedicaHP6.Text, g_Config.SuperMedicaHPs[5]);
        end else if Sender = DEditSuperMedicaHP7 then begin
          g_Config.SuperMedicaHPs[6] := Str_ToInt(DEditSuperMedicaHP7.Text, g_Config.SuperMedicaHPs[6]);
        end else if Sender = DEditSuperMedicaHP8 then begin
          g_Config.SuperMedicaHPs[7] := Str_ToInt(DEditSuperMedicaHP8.Text, g_Config.SuperMedicaHPs[7]);
        end else if Sender = DEditSuperMedicaHP9 then begin
          g_Config.SuperMedicaHPs[8] := Str_ToInt(DEditSuperMedicaHP9.Text, g_Config.SuperMedicaHPs[8]);
        end else if Sender = DEditSuperMedicaHP10 then begin
          g_Config.SuperMedicaHPs[9] := Str_ToInt(DEditSuperMedicaHP10.Text, g_Config.SuperMedicaHPs[9]);
        end else if Sender = DEditSuperMedicaHP11 then begin
          g_Config.SuperMedicaHPs[10] := Str_ToInt(DEditSuperMedicaHP11.Text, g_Config.SuperMedicaHPs[10]);
        end else if Sender = DEditSuperMedicaHP12 then begin
          g_Config.SuperMedicaHPs[11] := Str_ToInt(DEditSuperMedicaHP12.Text, g_Config.SuperMedicaHPs[11]);
        end else if Sender = DEditSuperMedicaHP13 then begin
          g_Config.SuperMedicaHPs[12] := Str_ToInt(DEditSuperMedicaHP13.Text, g_Config.SuperMedicaHPs[12]);
        end else if Sender = DEditSuperMedicaHP14 then begin
          g_Config.SuperMedicaHPs[13] := Str_ToInt(DEditSuperMedicaHP14.Text, g_Config.SuperMedicaHPs[13]);
        end else if Sender = DEditSuperMedicaMP1 then begin
          g_Config.SuperMedicaMPs[0] := Str_ToInt(DEditSuperMedicaMP1.Text, g_Config.SuperMedicaMPs[0]);
        end else if Sender = DEditSuperMedicaMP2 then begin
          g_Config.SuperMedicaMPs[1] := Str_ToInt(DEditSuperMedicaMP2.Text, g_Config.SuperMedicaMPs[1]);
        end else if Sender = DEditSuperMedicaMP3 then begin
          g_Config.SuperMedicaMPs[2] := Str_ToInt(DEditSuperMedicaMP3.Text, g_Config.SuperMedicaMPs[2]);
        end else if Sender = DEditSuperMedicaMP4 then begin
          g_Config.SuperMedicaMPs[3] := Str_ToInt(DEditSuperMedicaMP4.Text, g_Config.SuperMedicaMPs[3]);
        end else if Sender = DEditSuperMedicaMP5 then begin
          g_Config.SuperMedicaMPs[4] := Str_ToInt(DEditSuperMedicaMP5.Text, g_Config.SuperMedicaMPs[4]);
        end else if Sender = DEditSuperMedicaMP6 then begin
          g_Config.SuperMedicaMPs[5] := Str_ToInt(DEditSuperMedicaMP6.Text, g_Config.SuperMedicaMPs[5]);
        end else if Sender = DEditSuperMedicaMP7 then begin
          g_Config.SuperMedicaMPs[6] := Str_ToInt(DEditSuperMedicaMP7.Text, g_Config.SuperMedicaMPs[6]);
        end else if Sender = DEditSuperMedicaMP8 then begin
          g_Config.SuperMedicaMPs[7] := Str_ToInt(DEditSuperMedicaMP8.Text, g_Config.SuperMedicaMPs[7]);
        end else if Sender = DEditSuperMedicaMP9 then begin
          g_Config.SuperMedicaMPs[8] := Str_ToInt(DEditSuperMedicaMP9.Text, g_Config.SuperMedicaMPs[8]);
        end else if Sender = DEditSuperMedicaMP10 then begin
          g_Config.SuperMedicaMPs[9] := Str_ToInt(DEditSuperMedicaMP10.Text, g_Config.SuperMedicaMPs[9]);
        end else if Sender = DEditSuperMedicaMP11 then begin
          g_Config.SuperMedicaMPs[10] := Str_ToInt(DEditSuperMedicaMP11.Text, g_Config.SuperMedicaMPs[10]);
        end else if Sender = DEditSuperMedicaMP12 then begin
          g_Config.SuperMedicaMPs[11] := Str_ToInt(DEditSuperMedicaMP12.Text, g_Config.SuperMedicaMPs[11]);
        end else if Sender = DEditSuperMedicaMP13 then begin
          g_Config.SuperMedicaMPs[12] := Str_ToInt(DEditSuperMedicaMP13.Text, g_Config.SuperMedicaMPs[12]);
        end else if Sender = DEditSuperMedicaMP14 then begin
          g_Config.SuperMedicaMPs[13] := Str_ToInt(DEditSuperMedicaMP14.Text, g_Config.SuperMedicaMPs[13]);
        end else if Sender = DEditSuperMedicaHPTime1 then begin
          g_Config.SuperMedicaHPTimes[0] := Str_ToInt(DEditSuperMedicaHPTime1.Text, g_Config.SuperMedicaHPTimes[0]);
        end else if Sender = DEditSuperMedicaHPTime2 then begin
          g_Config.SuperMedicaHPTimes[1] := Str_ToInt(DEditSuperMedicaHPTime2.Text, g_Config.SuperMedicaHPTimes[1]);
        end else if Sender = DEditSuperMedicaHPTime3 then begin
          g_Config.SuperMedicaHPTimes[2] := Str_ToInt(DEditSuperMedicaHPTime3.Text, g_Config.SuperMedicaHPTimes[2]);
        end else if Sender = DEditSuperMedicaHPTime4 then begin
          g_Config.SuperMedicaHPTimes[3] := Str_ToInt(DEditSuperMedicaHPTime4.Text, g_Config.SuperMedicaHPTimes[3]);
        end else if Sender = DEditSuperMedicaHPTime5 then begin
          g_Config.SuperMedicaHPTimes[4] := Str_ToInt(DEditSuperMedicaHPTime5.Text, g_Config.SuperMedicaHPTimes[4]);
        end else if Sender = DEditSuperMedicaHPTime6 then begin
          g_Config.SuperMedicaHPTimes[5] := Str_ToInt(DEditSuperMedicaHPTime6.Text, g_Config.SuperMedicaHPTimes[5]);
        end else if Sender = DEditSuperMedicaHPTime7 then begin
          g_Config.SuperMedicaHPTimes[6] := Str_ToInt(DEditSuperMedicaHPTime7.Text, g_Config.SuperMedicaHPTimes[6]);
        end else if Sender = DEditSuperMedicaHPTime8 then begin
          g_Config.SuperMedicaHPTimes[7] := Str_ToInt(DEditSuperMedicaHPTime8.Text, g_Config.SuperMedicaHPTimes[7]);
        end else if Sender = DEditSuperMedicaHPTime9 then begin
          g_Config.SuperMedicaHPTimes[8] := Str_ToInt(DEditSuperMedicaHPTime9.Text, g_Config.SuperMedicaHPTimes[8]);
        end else if Sender = DEditSuperMedicaHPTime10 then begin
          g_Config.SuperMedicaHPTimes[9] := Str_ToInt(DEditSuperMedicaHPTime10.Text, g_Config.SuperMedicaHPTimes[9]);
        end else if Sender = DEditSuperMedicaHPTime11 then begin
          g_Config.SuperMedicaHPTimes[10] := Str_ToInt(DEditSuperMedicaHPTime11.Text, g_Config.SuperMedicaHPTimes[10]);
        end else if Sender = DEditSuperMedicaHPTime12 then begin
          g_Config.SuperMedicaHPTimes[11] := Str_ToInt(DEditSuperMedicaHPTime12.Text, g_Config.SuperMedicaHPTimes[11]);
        end else if Sender = DEditSuperMedicaHPTime13 then begin
          g_Config.SuperMedicaHPTimes[12] := Str_ToInt(DEditSuperMedicaHPTime13.Text, g_Config.SuperMedicaHPTimes[12]);
        end else if Sender = DEditSuperMedicaHPTime14 then begin
          g_Config.SuperMedicaHPTimes[13] := Str_ToInt(DEditSuperMedicaHPTime14.Text, g_Config.SuperMedicaHPTimes[13]);
        end else if Sender = DEditSuperMedicaMPTime1 then begin
          g_Config.SuperMedicaMPTimes[0] := Str_ToInt(DEditSuperMedicaMPTime1.Text, g_Config.SuperMedicaMPTimes[0]);
        end else if Sender = DEditSuperMedicaMPTime2 then begin
          g_Config.SuperMedicaMPTimes[1] := Str_ToInt(DEditSuperMedicaMPTime2.Text, g_Config.SuperMedicaMPTimes[1]);
        end else if Sender = DEditSuperMedicaMPTime3 then begin
          g_Config.SuperMedicaMPTimes[2] := Str_ToInt(DEditSuperMedicaMPTime3.Text, g_Config.SuperMedicaMPTimes[2]);
        end else if Sender = DEditSuperMedicaMPTime4 then begin
          g_Config.SuperMedicaMPTimes[3] := Str_ToInt(DEditSuperMedicaMPTime4.Text, g_Config.SuperMedicaMPTimes[3]);
        end else if Sender = DEditSuperMedicaMPTime5 then begin
          g_Config.SuperMedicaMPTimes[4] := Str_ToInt(DEditSuperMedicaMPTime5.Text, g_Config.SuperMedicaMPTimes[4]);
        end else if Sender = DEditSuperMedicaMPTime6 then begin
          g_Config.SuperMedicaMPTimes[5] := Str_ToInt(DEditSuperMedicaMPTime6.Text, g_Config.SuperMedicaMPTimes[5]);
        end else if Sender = DEditSuperMedicaMPTime7 then begin
          g_Config.SuperMedicaMPTimes[6] := Str_ToInt(DEditSuperMedicaMPTime7.Text, g_Config.SuperMedicaMPTimes[6]);
        end else if Sender = DEditSuperMedicaMPTime8 then begin
          g_Config.SuperMedicaMPTimes[7] := Str_ToInt(DEditSuperMedicaMPTime8.Text, g_Config.SuperMedicaMPTimes[7]);
        end else if Sender = DEditSuperMedicaMPTime9 then begin
          g_Config.SuperMedicaMPTimes[8] := Str_ToInt(DEditSuperMedicaMPTime9.Text, g_Config.SuperMedicaMPTimes[8]);
        end else if Sender = DEditSuperMedicaMPTime10 then begin
          g_Config.SuperMedicaMPTimes[9] := Str_ToInt(DEditSuperMedicaMPTime10.Text, g_Config.SuperMedicaMPTimes[9]);
        end else if Sender = DEditSuperMedicaMPTime11 then begin
          g_Config.SuperMedicaMPTimes[10] := Str_ToInt(DEditSuperMedicaMPTime11.Text, g_Config.SuperMedicaMPTimes[10]);
        end else if Sender = DEditSuperMedicaMPTime12 then begin
          g_Config.SuperMedicaMPTimes[11] := Str_ToInt(DEditSuperMedicaMPTime12.Text, g_Config.SuperMedicaMPTimes[11]);
        end else if Sender = DEditSuperMedicaMPTime13 then begin
          g_Config.SuperMedicaMPTimes[12] := Str_ToInt(DEditSuperMedicaMPTime13.Text, g_Config.SuperMedicaMPTimes[12]);
        end else if Sender = DEditSuperMedicaMPTime14 then begin
          g_Config.SuperMedicaMPTimes[13] := Str_ToInt(DEditSuperMedicaMPTime14.Text, g_Config.SuperMedicaMPTimes[13]);
        end;
      end;
      {$IF M2Version <> 2}
      1: begin
        if Sender = DEdtBookHPPro then begin
          g_Config.wHp2Hp := Str_ToInt(DEdtBookHPPro.Text, 0);
        end else if Sender = DEdtBookMPPro then begin
          g_Config.wMp2Mp := Str_ToInt(DEdtBookMPPro.Text, 0);
        end else if Sender = DEdtRenewHP then begin
          g_Config.wRenewHeroNormalHpPercent := Str_ToInt(DEdtRenewHP.Text, g_Config.wRenewHeroNormalHpPercent);
        end else if Sender = DEdtRenewMP then begin
          g_Config.wRenewHeroNormalMpPercent := Str_ToInt(DEdtRenewMP.Text, g_Config.wRenewHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPTime then begin
          g_Config.wRenewHeroNormalHpTime := Str_ToInt(DEdtRenewHPTime.Text, g_Config.wRenewHeroNormalHpTime);
        end else if Sender = DEdtRenewMpTime then begin
          g_Config.wRenewHeroNormalMpTime := Str_ToInt(DEdtRenewMpTime.Text, g_Config.wRenewHeroNormalMpTime);
        end else if Sender = DEdtRenewHPSpecial then begin
          g_Config.wRenewSpecialHeroNormalHpPercent := Str_ToInt(DEdtRenewHPSpecial.Text, g_Config.wRenewSpecialHeroNormalHpPercent);
        end else if Sender = DEdtRenewMpSpecial then begin
          g_Config.wRenewSpecialHeroNormalMpPercent := Str_ToInt(DEdtRenewMpSpecial.Text, g_Config.wRenewSpecialHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPSpecialTime then begin
          g_Config.wRenewSpecialHeroNormalHpTime := Str_ToInt(DEdtRenewHPSpecialTime.Text, g_Config.wRenewSpecialHeroNormalHpTime);
        end else if Sender = DEdtRenewMpSpecialTime then begin
          g_Config.wRenewSpecialHeroNormalMpTime := Str_ToInt(DEdtRenewMpSpecialTime.Text, g_Config.wRenewSpecialHeroNormalMpTime);
        end else if Sender = DEditSuperMedicaHP1 then begin
          g_Config.hSuperMedicaHPs[0] := Str_ToInt(DEditSuperMedicaHP1.Text, g_Config.hSuperMedicaHPs[0]);
        end else if Sender = DEditSuperMedicaHP2 then begin
          g_Config.hSuperMedicaHPs[1] := Str_ToInt(DEditSuperMedicaHP2.Text, g_Config.hSuperMedicaHPs[1]);
        end else if Sender = DEditSuperMedicaHP3 then begin
          g_Config.hSuperMedicaHPs[2] := Str_ToInt(DEditSuperMedicaHP3.Text, g_Config.hSuperMedicaHPs[2]);
        end else if Sender = DEditSuperMedicaHP4 then begin
          g_Config.hSuperMedicaHPs[3] := Str_ToInt(DEditSuperMedicaHP4.Text, g_Config.hSuperMedicaHPs[3]);
        end else if Sender = DEditSuperMedicaHP5 then begin
          g_Config.hSuperMedicaHPs[4] := Str_ToInt(DEditSuperMedicaHP5.Text, g_Config.hSuperMedicaHPs[4]);
        end else if Sender = DEditSuperMedicaHP6 then begin
          g_Config.hSuperMedicaHPs[5] := Str_ToInt(DEditSuperMedicaHP6.Text, g_Config.hSuperMedicaHPs[5]);
        end else if Sender = DEditSuperMedicaHP7 then begin
          g_Config.hSuperMedicaHPs[6] := Str_ToInt(DEditSuperMedicaHP7.Text, g_Config.hSuperMedicaHPs[6]);
        end else if Sender = DEditSuperMedicaHP8 then begin
          g_Config.hSuperMedicaHPs[7] := Str_ToInt(DEditSuperMedicaHP8.Text, g_Config.hSuperMedicaHPs[7]);
        end else if Sender = DEditSuperMedicaHP9 then begin
          g_Config.hSuperMedicaHPs[8] := Str_ToInt(DEditSuperMedicaHP9.Text, g_Config.hSuperMedicaHPs[8]);
        end else if Sender = DEditSuperMedicaHP10 then begin
          g_Config.hSuperMedicaHPs[9] := Str_ToInt(DEditSuperMedicaHP10.Text, g_Config.hSuperMedicaHPs[9]);
        end else if Sender = DEditSuperMedicaHP11 then begin
          g_Config.hSuperMedicaHPs[10] := Str_ToInt(DEditSuperMedicaHP11.Text, g_Config.hSuperMedicaHPs[10]);
        end else if Sender = DEditSuperMedicaHP12 then begin
          g_Config.hSuperMedicaHPs[11] := Str_ToInt(DEditSuperMedicaHP12.Text, g_Config.hSuperMedicaHPs[11]);
        end else if Sender = DEditSuperMedicaHP13 then begin
          g_Config.hSuperMedicaHPs[12] := Str_ToInt(DEditSuperMedicaHP13.Text, g_Config.hSuperMedicaHPs[12]);
        end else if Sender = DEditSuperMedicaHP14 then begin
          g_Config.hSuperMedicaHPs[13] := Str_ToInt(DEditSuperMedicaHP14.Text, g_Config.hSuperMedicaHPs[13]);
        end else if Sender = DEditSuperMedicaMP1 then begin
          g_Config.hSuperMedicaMPs[0] := Str_ToInt(DEditSuperMedicaMP1.Text, g_Config.hSuperMedicaMPs[0]);
        end else if Sender = DEditSuperMedicaMP2 then begin
          g_Config.hSuperMedicaMPs[1] := Str_ToInt(DEditSuperMedicaMP2.Text, g_Config.hSuperMedicaMPs[1]);
        end else if Sender = DEditSuperMedicaMP3 then begin
          g_Config.hSuperMedicaMPs[2] := Str_ToInt(DEditSuperMedicaMP3.Text, g_Config.hSuperMedicaMPs[2]);
        end else if Sender = DEditSuperMedicaMP4 then begin
          g_Config.hSuperMedicaMPs[3] := Str_ToInt(DEditSuperMedicaMP4.Text, g_Config.hSuperMedicaMPs[3]);
        end else if Sender = DEditSuperMedicaMP5 then begin
          g_Config.hSuperMedicaMPs[4] := Str_ToInt(DEditSuperMedicaMP5.Text, g_Config.hSuperMedicaMPs[4]);
        end else if Sender = DEditSuperMedicaMP6 then begin
          g_Config.hSuperMedicaMPs[5] := Str_ToInt(DEditSuperMedicaMP6.Text, g_Config.hSuperMedicaMPs[5]);
        end else if Sender = DEditSuperMedicaMP7 then begin
          g_Config.hSuperMedicaMPs[6] := Str_ToInt(DEditSuperMedicaMP7.Text, g_Config.hSuperMedicaMPs[6]);
        end else if Sender = DEditSuperMedicaMP8 then begin
          g_Config.hSuperMedicaMPs[7] := Str_ToInt(DEditSuperMedicaMP8.Text, g_Config.hSuperMedicaMPs[7]);
        end else if Sender = DEditSuperMedicaMP9 then begin
          g_Config.hSuperMedicaMPs[8] := Str_ToInt(DEditSuperMedicaMP9.Text, g_Config.hSuperMedicaMPs[8]);
        end else if Sender = DEditSuperMedicaMP10 then begin
          g_Config.hSuperMedicaMPs[9] := Str_ToInt(DEditSuperMedicaMP10.Text, g_Config.hSuperMedicaMPs[9]);
        end else if Sender = DEditSuperMedicaMP11 then begin
          g_Config.hSuperMedicaMPs[10] := Str_ToInt(DEditSuperMedicaMP11.Text, g_Config.hSuperMedicaMPs[10]);
        end else if Sender = DEditSuperMedicaMP12 then begin
          g_Config.hSuperMedicaMPs[11] := Str_ToInt(DEditSuperMedicaMP12.Text, g_Config.hSuperMedicaMPs[11]);
        end else if Sender = DEditSuperMedicaMP13 then begin
          g_Config.hSuperMedicaMPs[12] := Str_ToInt(DEditSuperMedicaMP13.Text, g_Config.hSuperMedicaMPs[12]);
        end else if Sender = DEditSuperMedicaMP14 then begin
          g_Config.hSuperMedicaMPs[13] := Str_ToInt(DEditSuperMedicaMP14.Text, g_Config.hSuperMedicaMPs[13]);
        end else if Sender = DEditSuperMedicaHPTime1 then begin
          g_Config.hSuperMedicaHPTimes[0] := Str_ToInt(DEditSuperMedicaHPTime1.Text, g_Config.hSuperMedicaHPTimes[0]);
        end else if Sender = DEditSuperMedicaHPTime2 then begin
          g_Config.hSuperMedicaHPTimes[1] := Str_ToInt(DEditSuperMedicaHPTime2.Text, g_Config.hSuperMedicaHPTimes[1]);
        end else if Sender = DEditSuperMedicaHPTime3 then begin
          g_Config.hSuperMedicaHPTimes[2] := Str_ToInt(DEditSuperMedicaHPTime3.Text, g_Config.hSuperMedicaHPTimes[2]);
        end else if Sender = DEditSuperMedicaHPTime4 then begin
          g_Config.hSuperMedicaHPTimes[3] := Str_ToInt(DEditSuperMedicaHPTime4.Text, g_Config.hSuperMedicaHPTimes[3]);
        end else if Sender = DEditSuperMedicaHPTime5 then begin
          g_Config.hSuperMedicaHPTimes[4] := Str_ToInt(DEditSuperMedicaHPTime5.Text, g_Config.hSuperMedicaHPTimes[4]);
        end else if Sender = DEditSuperMedicaHPTime6 then begin
          g_Config.hSuperMedicaHPTimes[5] := Str_ToInt(DEditSuperMedicaHPTime6.Text, g_Config.hSuperMedicaHPTimes[5]);
        end else if Sender = DEditSuperMedicaHPTime7 then begin
          g_Config.hSuperMedicaHPTimes[6] := Str_ToInt(DEditSuperMedicaHPTime7.Text, g_Config.hSuperMedicaHPTimes[6]);
        end else if Sender = DEditSuperMedicaHPTime8 then begin
          g_Config.hSuperMedicaHPTimes[7] := Str_ToInt(DEditSuperMedicaHPTime8.Text, g_Config.hSuperMedicaHPTimes[7]);
        end else if Sender = DEditSuperMedicaHPTime9 then begin
          g_Config.hSuperMedicaHPTimes[8] := Str_ToInt(DEditSuperMedicaHPTime9.Text, g_Config.hSuperMedicaHPTimes[8]);
        end else if Sender = DEditSuperMedicaHPTime10 then begin
          g_Config.hSuperMedicaHPTimes[9] := Str_ToInt(DEditSuperMedicaHPTime10.Text, g_Config.hSuperMedicaHPTimes[9]);
        end else if Sender = DEditSuperMedicaHPTime11 then begin
          g_Config.hSuperMedicaHPTimes[10] := Str_ToInt(DEditSuperMedicaHPTime11.Text, g_Config.hSuperMedicaHPTimes[10]);
        end else if Sender = DEditSuperMedicaHPTime12 then begin
          g_Config.hSuperMedicaHPTimes[11] := Str_ToInt(DEditSuperMedicaHPTime12.Text, g_Config.hSuperMedicaHPTimes[11]);
        end else if Sender = DEditSuperMedicaHPTime13 then begin
          g_Config.hSuperMedicaHPTimes[12] := Str_ToInt(DEditSuperMedicaHPTime13.Text, g_Config.hSuperMedicaHPTimes[12]);
        end else if Sender = DEditSuperMedicaHPTime14 then begin
          g_Config.hSuperMedicaHPTimes[13] := Str_ToInt(DEditSuperMedicaHPTime14.Text, g_Config.hSuperMedicaHPTimes[13]);
        end else if Sender = DEditSuperMedicaMPTime1 then begin
          g_Config.hSuperMedicaMPTimes[0] := Str_ToInt(DEditSuperMedicaMPTime1.Text, g_Config.hSuperMedicaMPTimes[0]);
        end else if Sender = DEditSuperMedicaMPTime2 then begin
          g_Config.hSuperMedicaMPTimes[1] := Str_ToInt(DEditSuperMedicaMPTime2.Text, g_Config.hSuperMedicaMPTimes[1]);
        end else if Sender = DEditSuperMedicaMPTime3 then begin
          g_Config.hSuperMedicaMPTimes[2] := Str_ToInt(DEditSuperMedicaMPTime3.Text, g_Config.hSuperMedicaMPTimes[2]);
        end else if Sender = DEditSuperMedicaMPTime4 then begin
          g_Config.hSuperMedicaMPTimes[3] := Str_ToInt(DEditSuperMedicaMPTime4.Text, g_Config.hSuperMedicaMPTimes[3]);
        end else if Sender = DEditSuperMedicaMPTime5 then begin
          g_Config.hSuperMedicaMPTimes[4] := Str_ToInt(DEditSuperMedicaMPTime5.Text, g_Config.hSuperMedicaMPTimes[4]);
        end else if Sender = DEditSuperMedicaMPTime6 then begin
          g_Config.hSuperMedicaMPTimes[5] := Str_ToInt(DEditSuperMedicaMPTime6.Text, g_Config.hSuperMedicaMPTimes[5]);
        end else if Sender = DEditSuperMedicaMPTime7 then begin
          g_Config.hSuperMedicaMPTimes[6] := Str_ToInt(DEditSuperMedicaMPTime7.Text, g_Config.hSuperMedicaMPTimes[6]);
        end else if Sender = DEditSuperMedicaMPTime8 then begin
          g_Config.hSuperMedicaMPTimes[7] := Str_ToInt(DEditSuperMedicaMPTime8.Text, g_Config.hSuperMedicaMPTimes[7]);
        end else if Sender = DEditSuperMedicaMPTime9 then begin
          g_Config.hSuperMedicaMPTimes[8] := Str_ToInt(DEditSuperMedicaMPTime9.Text, g_Config.hSuperMedicaMPTimes[8]);
        end else if Sender = DEditSuperMedicaMPTime10 then begin
          g_Config.hSuperMedicaMPTimes[9] := Str_ToInt(DEditSuperMedicaMPTime10.Text, g_Config.hSuperMedicaMPTimes[9]);
        end else if Sender = DEditSuperMedicaMPTime11 then begin
          g_Config.hSuperMedicaMPTimes[10] := Str_ToInt(DEditSuperMedicaMPTime11.Text, g_Config.hSuperMedicaMPTimes[10]);
        end else if Sender = DEditSuperMedicaMPTime12 then begin
          g_Config.hSuperMedicaMPTimes[11] := Str_ToInt(DEditSuperMedicaMPTime12.Text, g_Config.hSuperMedicaMPTimes[11]);
        end else if Sender = DEditSuperMedicaMPTime13 then begin
          g_Config.hSuperMedicaMPTimes[12] := Str_ToInt(DEditSuperMedicaMPTime13.Text, g_Config.hSuperMedicaMPTimes[12]);
        end else if Sender = DEditSuperMedicaMPTime14 then begin
          g_Config.hSuperMedicaMPTimes[13] := Str_ToInt(DEditSuperMedicaMPTime14.Text, g_Config.hSuperMedicaMPTimes[13]);
        end;
      end;
      2: begin
        if Sender = DEdtBookHPPro then begin
          g_Config.wHp3Hp := Str_ToInt(DEdtBookHPPro.Text, 0);
        end else if Sender = DEdtBookMPPro then begin
          g_Config.wMp3Mp := Str_ToInt(DEdtBookMPPro.Text, 0);
        end else if Sender = DEdtRenewHP then begin
          g_Config.wRenewzHeroNormalHpPercent := Str_ToInt(DEdtRenewHP.Text, g_Config.wRenewzHeroNormalHpPercent);
        end else if Sender = DEdtRenewMp then begin
          g_Config.wRenewzHeroNormalMpPercent := Str_ToInt(DEdtRenewMp.Text, g_Config.wRenewzHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPTime then begin
          g_Config.wRenewzHeroNormalHpTime := Str_ToInt(DEdtRenewHPTime.Text, g_Config.wRenewzHeroNormalHpTime);
        end else if Sender = DEdtRenewMpTime then begin
          g_Config.wRenewzHeroNormalMpTime := Str_ToInt(DEdtRenewMpTime.Text, g_Config.wRenewzHeroNormalMpTime);
        end else if Sender = DEdtRenewHPSpecial then begin
          g_Config.wRenewSpecialzHeroNormalHpPercent := Str_ToInt(DEdtRenewHPSpecial.Text, g_Config.wRenewSpecialzHeroNormalHpPercent);
        end else if Sender = DEdtRenewMpSpecial then begin
          g_Config.wRenewSpecialzHeroNormalMpPercent := Str_ToInt(DEdtRenewMpSpecial.Text, g_Config.wRenewSpecialzHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPSpecialTime then begin
          g_Config.wRenewSpecialzHeroNormalHpTime := Str_ToInt(DEdtRenewHPSpecialTime.Text, g_Config.wRenewSpecialzHeroNormalHpTime);
        end else if Sender = DEdtRenewMpSpecialTime then begin
          g_Config.wRenewSpecialzHeroNormalMpTime := Str_ToInt(DEdtRenewMpSpecialTime.Text, g_Config.wRenewSpecialzHeroNormalMpTime);
        end else if Sender = DEditSuperMedicaHP1 then begin
          g_Config.zSuperMedicaHPs[0] := Str_ToInt(DEditSuperMedicaHP1.Text, g_Config.zSuperMedicaHPs[0]);
        end else if Sender = DEditSuperMedicaHP2 then begin
          g_Config.zSuperMedicaHPs[1] := Str_ToInt(DEditSuperMedicaHP2.Text, g_Config.zSuperMedicaHPs[1]);
        end else if Sender = DEditSuperMedicaHP3 then begin
          g_Config.zSuperMedicaHPs[2] := Str_ToInt(DEditSuperMedicaHP3.Text, g_Config.zSuperMedicaHPs[2]);
        end else if Sender = DEditSuperMedicaHP4 then begin
          g_Config.zSuperMedicaHPs[3] := Str_ToInt(DEditSuperMedicaHP4.Text, g_Config.zSuperMedicaHPs[3]);
        end else if Sender = DEditSuperMedicaHP5 then begin
          g_Config.zSuperMedicaHPs[4] := Str_ToInt(DEditSuperMedicaHP5.Text, g_Config.zSuperMedicaHPs[4]);
        end else if Sender = DEditSuperMedicaHP6 then begin
          g_Config.zSuperMedicaHPs[5] := Str_ToInt(DEditSuperMedicaHP6.Text, g_Config.zSuperMedicaHPs[5]);
        end else if Sender = DEditSuperMedicaHP7 then begin
          g_Config.zSuperMedicaHPs[6] := Str_ToInt(DEditSuperMedicaHP7.Text, g_Config.zSuperMedicaHPs[6]);
        end else if Sender = DEditSuperMedicaHP8 then begin
          g_Config.zSuperMedicaHPs[7] := Str_ToInt(DEditSuperMedicaHP8.Text, g_Config.zSuperMedicaHPs[7]);
        end else if Sender = DEditSuperMedicaHP9 then begin
          g_Config.zSuperMedicaHPs[8] := Str_ToInt(DEditSuperMedicaHP9.Text, g_Config.zSuperMedicaHPs[8]);
        end else if Sender = DEditSuperMedicaHP10 then begin
          g_Config.zSuperMedicaHPs[9] := Str_ToInt(DEditSuperMedicaHP10.Text, g_Config.zSuperMedicaHPs[9]);
        end else if Sender = DEditSuperMedicaHP11 then begin
          g_Config.zSuperMedicaHPs[10] := Str_ToInt(DEditSuperMedicaHP11.Text, g_Config.zSuperMedicaHPs[10]);
        end else if Sender = DEditSuperMedicaHP12 then begin
          g_Config.zSuperMedicaHPs[11] := Str_ToInt(DEditSuperMedicaHP12.Text, g_Config.zSuperMedicaHPs[11]);
        end else if Sender = DEditSuperMedicaHP13 then begin
          g_Config.zSuperMedicaHPs[12] := Str_ToInt(DEditSuperMedicaHP13.Text, g_Config.zSuperMedicaHPs[12]);
        end else if Sender = DEditSuperMedicaHP14 then begin
          g_Config.zSuperMedicaHPs[13] := Str_ToInt(DEditSuperMedicaHP14.Text, g_Config.zSuperMedicaHPs[13]);
        end else if Sender = DEditSuperMedicaMP1 then begin
          g_Config.zSuperMedicaMPs[0] := Str_ToInt(DEditSuperMedicaMP1.Text, g_Config.zSuperMedicaMPs[0]);
        end else if Sender = DEditSuperMedicaMP2 then begin
          g_Config.zSuperMedicaMPs[1] := Str_ToInt(DEditSuperMedicaMP2.Text, g_Config.zSuperMedicaMPs[1]);
        end else if Sender = DEditSuperMedicaMP3 then begin
          g_Config.zSuperMedicaMPs[2] := Str_ToInt(DEditSuperMedicaMP3.Text, g_Config.zSuperMedicaMPs[2]);
        end else if Sender = DEditSuperMedicaMP4 then begin
          g_Config.zSuperMedicaMPs[3] := Str_ToInt(DEditSuperMedicaMP4.Text, g_Config.zSuperMedicaMPs[3]);
        end else if Sender = DEditSuperMedicaMP5 then begin
          g_Config.zSuperMedicaMPs[4] := Str_ToInt(DEditSuperMedicaMP5.Text, g_Config.zSuperMedicaMPs[4]);
        end else if Sender = DEditSuperMedicaMP6 then begin
          g_Config.zSuperMedicaMPs[5] := Str_ToInt(DEditSuperMedicaMP6.Text, g_Config.zSuperMedicaMPs[5]);
        end else if Sender = DEditSuperMedicaMP7 then begin
          g_Config.zSuperMedicaMPs[6] := Str_ToInt(DEditSuperMedicaMP7.Text, g_Config.zSuperMedicaMPs[6]);
        end else if Sender = DEditSuperMedicaMP8 then begin
          g_Config.zSuperMedicaMPs[7] := Str_ToInt(DEditSuperMedicaMP8.Text, g_Config.zSuperMedicaMPs[7]);
        end else if Sender = DEditSuperMedicaMP9 then begin
          g_Config.zSuperMedicaMPs[8] := Str_ToInt(DEditSuperMedicaMP9.Text, g_Config.zSuperMedicaMPs[8]);
        end else if Sender = DEditSuperMedicaMP10 then begin
          g_Config.zSuperMedicaMPs[9] := Str_ToInt(DEditSuperMedicaMP10.Text, g_Config.zSuperMedicaMPs[9]);
        end else if Sender = DEditSuperMedicaMP11 then begin
          g_Config.zSuperMedicaMPs[10] := Str_ToInt(DEditSuperMedicaMP11.Text, g_Config.zSuperMedicaMPs[10]);
        end else if Sender = DEditSuperMedicaMP12 then begin
          g_Config.zSuperMedicaMPs[11] := Str_ToInt(DEditSuperMedicaMP12.Text, g_Config.zSuperMedicaMPs[11]);
        end else if Sender = DEditSuperMedicaMP13 then begin
          g_Config.zSuperMedicaMPs[12] := Str_ToInt(DEditSuperMedicaMP13.Text, g_Config.zSuperMedicaMPs[12]);
        end else if Sender = DEditSuperMedicaMP14 then begin
          g_Config.zSuperMedicaMPs[13] := Str_ToInt(DEditSuperMedicaMP14.Text, g_Config.zSuperMedicaMPs[13]);
        end else if Sender = DEditSuperMedicaHPTime1 then begin
          g_Config.zSuperMedicaHPTimes[0] := Str_ToInt(DEditSuperMedicaHPTime1.Text, g_Config.zSuperMedicaHPTimes[0]);
        end else if Sender = DEditSuperMedicaHPTime2 then begin
          g_Config.zSuperMedicaHPTimes[1] := Str_ToInt(DEditSuperMedicaHPTime2.Text, g_Config.zSuperMedicaHPTimes[1]);
        end else if Sender = DEditSuperMedicaHPTime3 then begin
          g_Config.zSuperMedicaHPTimes[2] := Str_ToInt(DEditSuperMedicaHPTime3.Text, g_Config.zSuperMedicaHPTimes[2]);
        end else if Sender = DEditSuperMedicaHPTime4 then begin
          g_Config.zSuperMedicaHPTimes[3] := Str_ToInt(DEditSuperMedicaHPTime4.Text, g_Config.zSuperMedicaHPTimes[3]);
        end else if Sender = DEditSuperMedicaHPTime5 then begin
          g_Config.zSuperMedicaHPTimes[4] := Str_ToInt(DEditSuperMedicaHPTime5.Text, g_Config.zSuperMedicaHPTimes[4]);
        end else if Sender = DEditSuperMedicaHPTime6 then begin
          g_Config.zSuperMedicaHPTimes[5] := Str_ToInt(DEditSuperMedicaHPTime6.Text, g_Config.zSuperMedicaHPTimes[5]);
        end else if Sender = DEditSuperMedicaHPTime7 then begin
          g_Config.zSuperMedicaHPTimes[6] := Str_ToInt(DEditSuperMedicaHPTime7.Text, g_Config.zSuperMedicaHPTimes[6]);
        end else if Sender = DEditSuperMedicaHPTime8 then begin
          g_Config.zSuperMedicaHPTimes[7] := Str_ToInt(DEditSuperMedicaHPTime8.Text, g_Config.zSuperMedicaHPTimes[7]);
        end else if Sender = DEditSuperMedicaHPTime9 then begin
          g_Config.zSuperMedicaHPTimes[8] := Str_ToInt(DEditSuperMedicaHPTime9.Text, g_Config.zSuperMedicaHPTimes[8]);
        end else if Sender = DEditSuperMedicaHPTime10 then begin
          g_Config.zSuperMedicaHPTimes[9] := Str_ToInt(DEditSuperMedicaHPTime10.Text, g_Config.zSuperMedicaHPTimes[9]);
        end else if Sender = DEditSuperMedicaHPTime11 then begin
          g_Config.zSuperMedicaHPTimes[10] := Str_ToInt(DEditSuperMedicaHPTime11.Text, g_Config.zSuperMedicaHPTimes[10]);
        end else if Sender = DEditSuperMedicaHPTime12 then begin
          g_Config.zSuperMedicaHPTimes[11] := Str_ToInt(DEditSuperMedicaHPTime12.Text, g_Config.zSuperMedicaHPTimes[11]);
        end else if Sender = DEditSuperMedicaHPTime13 then begin
          g_Config.zSuperMedicaHPTimes[12] := Str_ToInt(DEditSuperMedicaHPTime13.Text, g_Config.zSuperMedicaHPTimes[12]);
        end else if Sender = DEditSuperMedicaHPTime14 then begin
          g_Config.zSuperMedicaHPTimes[13] := Str_ToInt(DEditSuperMedicaHPTime14.Text, g_Config.zSuperMedicaHPTimes[13]);
        end else if Sender = DEditSuperMedicaMPTime1 then begin
          g_Config.zSuperMedicaMPTimes[0] := Str_ToInt(DEditSuperMedicaMPTime1.Text, g_Config.zSuperMedicaMPTimes[0]);
        end else if Sender = DEditSuperMedicaMPTime2 then begin
          g_Config.zSuperMedicaMPTimes[1] := Str_ToInt(DEditSuperMedicaMPTime2.Text, g_Config.zSuperMedicaMPTimes[1]);
        end else if Sender = DEditSuperMedicaMPTime3 then begin
          g_Config.zSuperMedicaMPTimes[2] := Str_ToInt(DEditSuperMedicaMPTime3.Text, g_Config.zSuperMedicaMPTimes[2]);
        end else if Sender = DEditSuperMedicaMPTime4 then begin
          g_Config.zSuperMedicaMPTimes[3] := Str_ToInt(DEditSuperMedicaMPTime4.Text, g_Config.zSuperMedicaMPTimes[3]);
        end else if Sender = DEditSuperMedicaMPTime5 then begin
          g_Config.zSuperMedicaMPTimes[4] := Str_ToInt(DEditSuperMedicaMPTime5.Text, g_Config.zSuperMedicaMPTimes[4]);
        end else if Sender = DEditSuperMedicaMPTime6 then begin
          g_Config.zSuperMedicaMPTimes[5] := Str_ToInt(DEditSuperMedicaMPTime6.Text, g_Config.zSuperMedicaMPTimes[5]);
        end else if Sender = DEditSuperMedicaMPTime7 then begin
          g_Config.zSuperMedicaMPTimes[6] := Str_ToInt(DEditSuperMedicaMPTime7.Text, g_Config.zSuperMedicaMPTimes[6]);
        end else if Sender = DEditSuperMedicaMPTime8 then begin
          g_Config.zSuperMedicaMPTimes[7] := Str_ToInt(DEditSuperMedicaMPTime8.Text, g_Config.zSuperMedicaMPTimes[7]);
        end else if Sender = DEditSuperMedicaMPTime9 then begin
          g_Config.zSuperMedicaMPTimes[8] := Str_ToInt(DEditSuperMedicaMPTime9.Text, g_Config.zSuperMedicaMPTimes[8]);
        end else if Sender = DEditSuperMedicaMPTime10 then begin
          g_Config.zSuperMedicaMPTimes[9] := Str_ToInt(DEditSuperMedicaMPTime10.Text, g_Config.zSuperMedicaMPTimes[9]);
        end else if Sender = DEditSuperMedicaMPTime11 then begin
          g_Config.zSuperMedicaMPTimes[10] := Str_ToInt(DEditSuperMedicaMPTime11.Text, g_Config.zSuperMedicaMPTimes[10]);
        end else if Sender = DEditSuperMedicaMPTime12 then begin
          g_Config.zSuperMedicaMPTimes[11] := Str_ToInt(DEditSuperMedicaMPTime12.Text, g_Config.zSuperMedicaMPTimes[11]);
        end else if Sender = DEditSuperMedicaMPTime13 then begin
          g_Config.zSuperMedicaMPTimes[12] := Str_ToInt(DEditSuperMedicaMPTime13.Text, g_Config.zSuperMedicaMPTimes[12]);
        end else if Sender = DEditSuperMedicaMPTime14 then begin
          g_Config.zSuperMedicaMPTimes[13] := Str_ToInt(DEditSuperMedicaMPTime14.Text, g_Config.zSuperMedicaMPTimes[13]);
        end;
      end;
      3: begin
        if Sender = DEdtBookHPPro then begin
          g_Config.wHp4Hp := Str_ToInt(DEdtBookHPPro.Text, 0);
        end else if Sender = DEdtBookMpPro then begin
          g_Config.wMp4Mp := Str_ToInt(DEdtBookMpPro.Text, 0);
        end else if Sender = DEdtRenewHP then begin
          g_Config.wRenewfHeroNormalHpPercent := Str_ToInt(DEdtRenewHP.Text, g_Config.wRenewfHeroNormalHpPercent);
        end else if Sender = DEdtRenewMp then begin
          g_Config.wRenewfHeroNormalMpPercent := Str_ToInt(DEdtRenewMp.Text, g_Config.wRenewfHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPTime then begin
          g_Config.wRenewfHeroNormalHpTime := Str_ToInt(DEdtRenewHPTime.Text, g_Config.wRenewfHeroNormalHpTime);
        end else if Sender = DEdtRenewMpTime then begin
          g_Config.wRenewfHeroNormalMpTime := Str_ToInt(DEdtRenewMpTime.Text, g_Config.wRenewfHeroNormalMpTime);
        end else if Sender = DEdtRenewHPSpecial then begin
          g_Config.wRenewSpecialfHeroNormalHpPercent := Str_ToInt(DEdtRenewHPSpecial.Text, g_Config.wRenewSpecialfHeroNormalHpPercent);
        end else if Sender = DEdtRenewMpSpecial then begin
          g_Config.wRenewSpecialfHeroNormalMpPercent := Str_ToInt(DEdtRenewMpSpecial.Text, g_Config.wRenewSpecialfHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPSpecialTime then begin
          g_Config.wRenewSpecialfHeroNormalHpTime := Str_ToInt(DEdtRenewHPSpecialTime.Text, g_Config.wRenewSpecialfHeroNormalHpTime);
        end else if Sender = DEdtRenewMpSpecialTime then begin
          g_Config.wRenewSpecialfHeroNormalMpTime := Str_ToInt(DEdtRenewMpSpecialTime.Text, g_Config.wRenewSpecialfHeroNormalMpTime);
        end else if Sender = DEditSuperMedicaHP1 then begin
          g_Config.fSuperMedicaHPs[0] := Str_ToInt(DEditSuperMedicaHP1.Text, g_Config.fSuperMedicaHPs[0]);
        end else if Sender = DEditSuperMedicaHP2 then begin
          g_Config.fSuperMedicaHPs[1] := Str_ToInt(DEditSuperMedicaHP2.Text, g_Config.fSuperMedicaHPs[1]);
        end else if Sender = DEditSuperMedicaHP3 then begin
          g_Config.fSuperMedicaHPs[2] := Str_ToInt(DEditSuperMedicaHP3.Text, g_Config.fSuperMedicaHPs[2]);
        end else if Sender = DEditSuperMedicaHP4 then begin
          g_Config.fSuperMedicaHPs[3] := Str_ToInt(DEditSuperMedicaHP4.Text, g_Config.fSuperMedicaHPs[3]);
        end else if Sender = DEditSuperMedicaHP5 then begin
          g_Config.fSuperMedicaHPs[4] := Str_ToInt(DEditSuperMedicaHP5.Text, g_Config.fSuperMedicaHPs[4]);
        end else if Sender = DEditSuperMedicaHP6 then begin
          g_Config.fSuperMedicaHPs[5] := Str_ToInt(DEditSuperMedicaHP6.Text, g_Config.fSuperMedicaHPs[5]);
        end else if Sender = DEditSuperMedicaHP7 then begin
          g_Config.fSuperMedicaHPs[6] := Str_ToInt(DEditSuperMedicaHP7.Text, g_Config.fSuperMedicaHPs[6]);
        end else if Sender = DEditSuperMedicaHP8 then begin
          g_Config.fSuperMedicaHPs[7] := Str_ToInt(DEditSuperMedicaHP8.Text, g_Config.fSuperMedicaHPs[7]);
        end else if Sender = DEditSuperMedicaHP9 then begin
          g_Config.fSuperMedicaHPs[8] := Str_ToInt(DEditSuperMedicaHP9.Text, g_Config.fSuperMedicaHPs[8]);
        end else if Sender = DEditSuperMedicaHP10 then begin
          g_Config.fSuperMedicaHPs[9] := Str_ToInt(DEditSuperMedicaHP10.Text, g_Config.fSuperMedicaHPs[9]);
        end else if Sender = DEditSuperMedicaHP11 then begin
          g_Config.fSuperMedicaHPs[10] := Str_ToInt(DEditSuperMedicaHP11.Text, g_Config.fSuperMedicaHPs[10]);
        end else if Sender = DEditSuperMedicaHP12 then begin
          g_Config.fSuperMedicaHPs[11] := Str_ToInt(DEditSuperMedicaHP12.Text, g_Config.fSuperMedicaHPs[11]);
        end else if Sender = DEditSuperMedicaHP13 then begin
          g_Config.fSuperMedicaHPs[12] := Str_ToInt(DEditSuperMedicaHP13.Text, g_Config.fSuperMedicaHPs[12]);
        end else if Sender = DEditSuperMedicaHP14 then begin
          g_Config.fSuperMedicaHPs[13] := Str_ToInt(DEditSuperMedicaHP14.Text, g_Config.fSuperMedicaHPs[13]);
        end else if Sender = DEditSuperMedicaMP1 then begin
          g_Config.fSuperMedicaMPs[0] := Str_ToInt(DEditSuperMedicaMP1.Text, g_Config.fSuperMedicaMPs[0]);
        end else if Sender = DEditSuperMedicaMP2 then begin
          g_Config.fSuperMedicaMPs[1] := Str_ToInt(DEditSuperMedicaMP2.Text, g_Config.fSuperMedicaMPs[1]);
        end else if Sender = DEditSuperMedicaMP3 then begin
          g_Config.fSuperMedicaMPs[2] := Str_ToInt(DEditSuperMedicaMP3.Text, g_Config.fSuperMedicaMPs[2]);
        end else if Sender = DEditSuperMedicaMP4 then begin
          g_Config.fSuperMedicaMPs[3] := Str_ToInt(DEditSuperMedicaMP4.Text, g_Config.fSuperMedicaMPs[3]);
        end else if Sender = DEditSuperMedicaMP5 then begin
          g_Config.fSuperMedicaMPs[4] := Str_ToInt(DEditSuperMedicaMP5.Text, g_Config.fSuperMedicaMPs[4]);
        end else if Sender = DEditSuperMedicaMP6 then begin
          g_Config.fSuperMedicaMPs[5] := Str_ToInt(DEditSuperMedicaMP6.Text, g_Config.fSuperMedicaMPs[5]);
        end else if Sender = DEditSuperMedicaMP7 then begin
          g_Config.fSuperMedicaMPs[6] := Str_ToInt(DEditSuperMedicaMP7.Text, g_Config.fSuperMedicaMPs[6]);
        end else if Sender = DEditSuperMedicaMP8 then begin
          g_Config.fSuperMedicaMPs[7] := Str_ToInt(DEditSuperMedicaMP8.Text, g_Config.fSuperMedicaMPs[7]);
        end else if Sender = DEditSuperMedicaMP9 then begin
          g_Config.fSuperMedicaMPs[8] := Str_ToInt(DEditSuperMedicaMP9.Text, g_Config.fSuperMedicaMPs[8]);
        end else if Sender = DEditSuperMedicaMP10 then begin
          g_Config.fSuperMedicaMPs[9] := Str_ToInt(DEditSuperMedicaMP10.Text, g_Config.fSuperMedicaMPs[9]);
        end else if Sender = DEditSuperMedicaMP11 then begin
          g_Config.fSuperMedicaMPs[10] := Str_ToInt(DEditSuperMedicaMP11.Text, g_Config.fSuperMedicaMPs[10]);
        end else if Sender = DEditSuperMedicaMP12 then begin
          g_Config.fSuperMedicaMPs[11] := Str_ToInt(DEditSuperMedicaMP12.Text, g_Config.fSuperMedicaMPs[11]);
        end else if Sender = DEditSuperMedicaMP13 then begin
          g_Config.fSuperMedicaMPs[12] := Str_ToInt(DEditSuperMedicaMP13.Text, g_Config.fSuperMedicaMPs[12]);
        end else if Sender = DEditSuperMedicaMP14 then begin
          g_Config.fSuperMedicaMPs[13] := Str_ToInt(DEditSuperMedicaMP14.Text, g_Config.fSuperMedicaMPs[13]);
        end else if Sender = DEditSuperMedicaHPTime1 then begin
          g_Config.fSuperMedicaHPTimes[0] := Str_ToInt(DEditSuperMedicaHPTime1.Text, g_Config.fSuperMedicaHPTimes[0]);
        end else if Sender = DEditSuperMedicaHPTime2 then begin
          g_Config.fSuperMedicaHPTimes[1] := Str_ToInt(DEditSuperMedicaHPTime2.Text, g_Config.fSuperMedicaHPTimes[1]);
        end else if Sender = DEditSuperMedicaHPTime3 then begin
          g_Config.fSuperMedicaHPTimes[2] := Str_ToInt(DEditSuperMedicaHPTime3.Text, g_Config.fSuperMedicaHPTimes[2]);
        end else if Sender = DEditSuperMedicaHPTime4 then begin
          g_Config.fSuperMedicaHPTimes[3] := Str_ToInt(DEditSuperMedicaHPTime4.Text, g_Config.fSuperMedicaHPTimes[3]);
        end else if Sender = DEditSuperMedicaHPTime5 then begin
          g_Config.fSuperMedicaHPTimes[4] := Str_ToInt(DEditSuperMedicaHPTime5.Text, g_Config.fSuperMedicaHPTimes[4]);
        end else if Sender = DEditSuperMedicaHPTime6 then begin
          g_Config.fSuperMedicaHPTimes[5] := Str_ToInt(DEditSuperMedicaHPTime6.Text, g_Config.fSuperMedicaHPTimes[5]);
        end else if Sender = DEditSuperMedicaHPTime7 then begin
          g_Config.fSuperMedicaHPTimes[6] := Str_ToInt(DEditSuperMedicaHPTime7.Text, g_Config.fSuperMedicaHPTimes[6]);
        end else if Sender = DEditSuperMedicaHPTime8 then begin
          g_Config.fSuperMedicaHPTimes[7] := Str_ToInt(DEditSuperMedicaHPTime8.Text, g_Config.fSuperMedicaHPTimes[7]);
        end else if Sender = DEditSuperMedicaHPTime9 then begin
          g_Config.fSuperMedicaHPTimes[8] := Str_ToInt(DEditSuperMedicaHPTime9.Text, g_Config.fSuperMedicaHPTimes[8]);
        end else if Sender = DEditSuperMedicaHPTime10 then begin
          g_Config.fSuperMedicaHPTimes[9] := Str_ToInt(DEditSuperMedicaHPTime10.Text, g_Config.fSuperMedicaHPTimes[9]);
        end else if Sender = DEditSuperMedicaHPTime11 then begin
          g_Config.fSuperMedicaHPTimes[10] := Str_ToInt(DEditSuperMedicaHPTime11.Text, g_Config.fSuperMedicaHPTimes[10]);
        end else if Sender = DEditSuperMedicaHPTime12 then begin
          g_Config.fSuperMedicaHPTimes[11] := Str_ToInt(DEditSuperMedicaHPTime12.Text, g_Config.fSuperMedicaHPTimes[11]);
        end else if Sender = DEditSuperMedicaHPTime13 then begin
          g_Config.fSuperMedicaHPTimes[12] := Str_ToInt(DEditSuperMedicaHPTime13.Text, g_Config.fSuperMedicaHPTimes[12]);
        end else if Sender = DEditSuperMedicaHPTime14 then begin
          g_Config.fSuperMedicaHPTimes[13] := Str_ToInt(DEditSuperMedicaHPTime14.Text, g_Config.fSuperMedicaHPTimes[13]);
        end else if Sender = DEditSuperMedicaMPTime1 then begin
          g_Config.fSuperMedicaMPTimes[0] := Str_ToInt(DEditSuperMedicaMPTime1.Text, g_Config.fSuperMedicaMPTimes[0]);
        end else if Sender = DEditSuperMedicaMPTime2 then begin
          g_Config.fSuperMedicaMPTimes[1] := Str_ToInt(DEditSuperMedicaMPTime2.Text, g_Config.fSuperMedicaMPTimes[1]);
        end else if Sender = DEditSuperMedicaMPTime3 then begin
          g_Config.fSuperMedicaMPTimes[2] := Str_ToInt(DEditSuperMedicaMPTime3.Text, g_Config.fSuperMedicaMPTimes[2]);
        end else if Sender = DEditSuperMedicaMPTime4 then begin
          g_Config.fSuperMedicaMPTimes[3] := Str_ToInt(DEditSuperMedicaMPTime4.Text, g_Config.fSuperMedicaMPTimes[3]);
        end else if Sender = DEditSuperMedicaMPTime5 then begin
          g_Config.fSuperMedicaMPTimes[4] := Str_ToInt(DEditSuperMedicaMPTime5.Text, g_Config.fSuperMedicaMPTimes[4]);
        end else if Sender = DEditSuperMedicaMPTime6 then begin
          g_Config.fSuperMedicaMPTimes[5] := Str_ToInt(DEditSuperMedicaMPTime6.Text, g_Config.fSuperMedicaMPTimes[5]);
        end else if Sender = DEditSuperMedicaMPTime7 then begin
          g_Config.fSuperMedicaMPTimes[6] := Str_ToInt(DEditSuperMedicaMPTime7.Text, g_Config.fSuperMedicaMPTimes[6]);
        end else if Sender = DEditSuperMedicaMPTime8 then begin
          g_Config.fSuperMedicaMPTimes[7] := Str_ToInt(DEditSuperMedicaMPTime8.Text, g_Config.fSuperMedicaMPTimes[7]);
        end else if Sender = DEditSuperMedicaMPTime9 then begin
          g_Config.fSuperMedicaMPTimes[8] := Str_ToInt(DEditSuperMedicaMPTime9.Text, g_Config.fSuperMedicaMPTimes[8]);
        end else if Sender = DEditSuperMedicaMPTime10 then begin
          g_Config.fSuperMedicaMPTimes[9] := Str_ToInt(DEditSuperMedicaMPTime10.Text, g_Config.fSuperMedicaMPTimes[9]);
        end else if Sender = DEditSuperMedicaMPTime11 then begin
          g_Config.fSuperMedicaMPTimes[10] := Str_ToInt(DEditSuperMedicaMPTime11.Text, g_Config.fSuperMedicaMPTimes[10]);
        end else if Sender = DEditSuperMedicaMPTime12 then begin
          g_Config.fSuperMedicaMPTimes[11] := Str_ToInt(DEditSuperMedicaMPTime12.Text, g_Config.fSuperMedicaMPTimes[11]);
        end else if Sender = DEditSuperMedicaMPTime13 then begin
          g_Config.fSuperMedicaMPTimes[12] := Str_ToInt(DEditSuperMedicaMPTime13.Text, g_Config.fSuperMedicaMPTimes[12]);
        end else if Sender = DEditSuperMedicaMPTime14 then begin
          g_Config.fSuperMedicaMPTimes[13] := Str_ToInt(DEditSuperMedicaMPTime14.Text, g_Config.fSuperMedicaMPTimes[13]);
        end;
      end;
      4: begin
        if Sender = DEdtBookHPPro then begin
          g_Config.wHp5Hp := Str_ToInt(DEdtBookHPPro.Text, 0);
        end else if Sender = DEdtBookMpPro then begin
          g_Config.wMp5Mp := Str_ToInt(DEdtBookMpPro.Text, 0);
        end else if Sender = DEdtRenewHP then begin
          g_Config.wRenewdHeroNormalHpPercent := Str_ToInt(DEdtRenewHP.Text, g_Config.wRenewdHeroNormalHpPercent);
        end else if Sender = DEdtRenewMp then begin
          g_Config.wRenewdHeroNormalMpPercent := Str_ToInt(DEdtRenewMp.Text, g_Config.wRenewdHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPTime then begin
          g_Config.wRenewdHeroNormalHpTime := Str_ToInt(DEdtRenewHPTime.Text, g_Config.wRenewdHeroNormalHpTime);
        end else if Sender = DEdtRenewMpTime then begin
          g_Config.wRenewdHeroNormalMpTime := Str_ToInt(DEdtRenewMpTime.Text, g_Config.wRenewdHeroNormalMpTime);
        end else if Sender = DEdtRenewHPSpecial then begin
          g_Config.wRenewSpecialdHeroNormalHpPercent := Str_ToInt(DEdtRenewHPSpecial.Text, g_Config.wRenewSpecialdHeroNormalHpPercent);
        end else if Sender = DEdtRenewMpSpecial then begin
          g_Config.wRenewSpecialdHeroNormalMpPercent := Str_ToInt(DEdtRenewMpSpecial.Text, g_Config.wRenewSpecialdHeroNormalMpPercent);
        end else if Sender = DEdtRenewHPSpecialTime then begin
          g_Config.wRenewSpecialdHeroNormalHpTime := Str_ToInt(DEdtRenewHPSpecialTime.Text, g_Config.wRenewSpecialdHeroNormalHpTime);
        end else if Sender = DEdtRenewMpSpecialTime then begin
          g_Config.wRenewSpecialdHeroNormalMpTime := Str_ToInt(DEdtRenewMpSpecialTime.Text, g_Config.wRenewSpecialdHeroNormalMpTime);
        end else if Sender = DEditSuperMedicaHP1 then begin
          g_Config.dSuperMedicaHPs[0] := Str_ToInt(DEditSuperMedicaHP1.Text, g_Config.dSuperMedicaHPs[0]);
        end else if Sender = DEditSuperMedicaHP2 then begin
          g_Config.dSuperMedicaHPs[1] := Str_ToInt(DEditSuperMedicaHP2.Text, g_Config.dSuperMedicaHPs[1]);
        end else if Sender = DEditSuperMedicaHP3 then begin
          g_Config.dSuperMedicaHPs[2] := Str_ToInt(DEditSuperMedicaHP3.Text, g_Config.dSuperMedicaHPs[2]);
        end else if Sender = DEditSuperMedicaHP4 then begin
          g_Config.dSuperMedicaHPs[3] := Str_ToInt(DEditSuperMedicaHP4.Text, g_Config.dSuperMedicaHPs[3]);
        end else if Sender = DEditSuperMedicaHP5 then begin
          g_Config.dSuperMedicaHPs[4] := Str_ToInt(DEditSuperMedicaHP5.Text, g_Config.dSuperMedicaHPs[4]);
        end else if Sender = DEditSuperMedicaHP6 then begin
          g_Config.dSuperMedicaHPs[5] := Str_ToInt(DEditSuperMedicaHP6.Text, g_Config.dSuperMedicaHPs[5]);
        end else if Sender = DEditSuperMedicaHP7 then begin
          g_Config.dSuperMedicaHPs[6] := Str_ToInt(DEditSuperMedicaHP7.Text, g_Config.dSuperMedicaHPs[6]);
        end else if Sender = DEditSuperMedicaHP8 then begin
          g_Config.dSuperMedicaHPs[7] := Str_ToInt(DEditSuperMedicaHP8.Text, g_Config.dSuperMedicaHPs[7]);
        end else if Sender = DEditSuperMedicaHP9 then begin
          g_Config.dSuperMedicaHPs[8] := Str_ToInt(DEditSuperMedicaHP9.Text, g_Config.dSuperMedicaHPs[8]);
        end else if Sender = DEditSuperMedicaHP10 then begin
          g_Config.dSuperMedicaHPs[9] := Str_ToInt(DEditSuperMedicaHP10.Text, g_Config.dSuperMedicaHPs[9]);
        end else if Sender = DEditSuperMedicaHP11 then begin
          g_Config.dSuperMedicaHPs[10] := Str_ToInt(DEditSuperMedicaHP11.Text, g_Config.dSuperMedicaHPs[10]);
        end else if Sender = DEditSuperMedicaHP12 then begin
          g_Config.dSuperMedicaHPs[11] := Str_ToInt(DEditSuperMedicaHP12.Text, g_Config.dSuperMedicaHPs[11]);
        end else if Sender = DEditSuperMedicaHP13 then begin
          g_Config.dSuperMedicaHPs[12] := Str_ToInt(DEditSuperMedicaHP13.Text, g_Config.dSuperMedicaHPs[12]);
        end else if Sender = DEditSuperMedicaHP14 then begin
          g_Config.dSuperMedicaHPs[13] := Str_ToInt(DEditSuperMedicaHP14.Text, g_Config.dSuperMedicaHPs[13]);
        end else if Sender = DEditSuperMedicaMP1 then begin
          g_Config.dSuperMedicaMPs[0] := Str_ToInt(DEditSuperMedicaMP1.Text, g_Config.dSuperMedicaMPs[0]);
        end else if Sender = DEditSuperMedicaMP2 then begin
          g_Config.dSuperMedicaMPs[1] := Str_ToInt(DEditSuperMedicaMP2.Text, g_Config.dSuperMedicaMPs[1]);
        end else if Sender = DEditSuperMedicaMP3 then begin
          g_Config.dSuperMedicaMPs[2] := Str_ToInt(DEditSuperMedicaMP3.Text, g_Config.dSuperMedicaMPs[2]);
        end else if Sender = DEditSuperMedicaMP4 then begin
          g_Config.dSuperMedicaMPs[3] := Str_ToInt(DEditSuperMedicaMP4.Text, g_Config.dSuperMedicaMPs[3]);
        end else if Sender = DEditSuperMedicaMP5 then begin
          g_Config.dSuperMedicaMPs[4] := Str_ToInt(DEditSuperMedicaMP5.Text, g_Config.dSuperMedicaMPs[4]);
        end else if Sender = DEditSuperMedicaMP6 then begin
          g_Config.dSuperMedicaMPs[5] := Str_ToInt(DEditSuperMedicaMP6.Text, g_Config.dSuperMedicaMPs[5]);
        end else if Sender = DEditSuperMedicaMP7 then begin
          g_Config.dSuperMedicaMPs[6] := Str_ToInt(DEditSuperMedicaMP7.Text, g_Config.dSuperMedicaMPs[6]);
        end else if Sender = DEditSuperMedicaMP8 then begin
          g_Config.dSuperMedicaMPs[7] := Str_ToInt(DEditSuperMedicaMP8.Text, g_Config.dSuperMedicaMPs[7]);
        end else if Sender = DEditSuperMedicaMP9 then begin
          g_Config.dSuperMedicaMPs[8] := Str_ToInt(DEditSuperMedicaMP9.Text, g_Config.dSuperMedicaMPs[8]);
        end else if Sender = DEditSuperMedicaMP10 then begin
          g_Config.dSuperMedicaMPs[9] := Str_ToInt(DEditSuperMedicaMP10.Text, g_Config.dSuperMedicaMPs[9]);
        end else if Sender = DEditSuperMedicaMP11 then begin
          g_Config.dSuperMedicaMPs[10] := Str_ToInt(DEditSuperMedicaMP11.Text, g_Config.dSuperMedicaMPs[10]);
        end else if Sender = DEditSuperMedicaMP12 then begin
          g_Config.dSuperMedicaMPs[11] := Str_ToInt(DEditSuperMedicaMP12.Text, g_Config.dSuperMedicaMPs[11]);
        end else if Sender = DEditSuperMedicaMP13 then begin
          g_Config.dSuperMedicaMPs[12] := Str_ToInt(DEditSuperMedicaMP13.Text, g_Config.dSuperMedicaMPs[12]);
        end else if Sender = DEditSuperMedicaMP14 then begin
          g_Config.dSuperMedicaMPs[13] := Str_ToInt(DEditSuperMedicaMP14.Text, g_Config.dSuperMedicaMPs[13]);
        end else if Sender = DEditSuperMedicaHPTime1 then begin
          g_Config.dSuperMedicaHPTimes[0] := Str_ToInt(DEditSuperMedicaHPTime1.Text, g_Config.dSuperMedicaHPTimes[0]);
        end else if Sender = DEditSuperMedicaHPTime2 then begin
          g_Config.dSuperMedicaHPTimes[1] := Str_ToInt(DEditSuperMedicaHPTime2.Text, g_Config.dSuperMedicaHPTimes[1]);
        end else if Sender = DEditSuperMedicaHPTime3 then begin
          g_Config.dSuperMedicaHPTimes[2] := Str_ToInt(DEditSuperMedicaHPTime3.Text, g_Config.dSuperMedicaHPTimes[2]);
        end else if Sender = DEditSuperMedicaHPTime4 then begin
          g_Config.dSuperMedicaHPTimes[3] := Str_ToInt(DEditSuperMedicaHPTime4.Text, g_Config.dSuperMedicaHPTimes[3]);
        end else if Sender = DEditSuperMedicaHPTime5 then begin
          g_Config.dSuperMedicaHPTimes[4] := Str_ToInt(DEditSuperMedicaHPTime5.Text, g_Config.dSuperMedicaHPTimes[4]);
        end else if Sender = DEditSuperMedicaHPTime6 then begin
          g_Config.dSuperMedicaHPTimes[5] := Str_ToInt(DEditSuperMedicaHPTime6.Text, g_Config.dSuperMedicaHPTimes[5]);
        end else if Sender = DEditSuperMedicaHPTime7 then begin
          g_Config.dSuperMedicaHPTimes[6] := Str_ToInt(DEditSuperMedicaHPTime7.Text, g_Config.dSuperMedicaHPTimes[6]);
        end else if Sender = DEditSuperMedicaHPTime8 then begin
          g_Config.dSuperMedicaHPTimes[7] := Str_ToInt(DEditSuperMedicaHPTime8.Text, g_Config.dSuperMedicaHPTimes[7]);
        end else if Sender = DEditSuperMedicaHPTime9 then begin
          g_Config.dSuperMedicaHPTimes[8] := Str_ToInt(DEditSuperMedicaHPTime9.Text, g_Config.dSuperMedicaHPTimes[8]);
        end else if Sender = DEditSuperMedicaHPTime10 then begin
          g_Config.dSuperMedicaHPTimes[9] := Str_ToInt(DEditSuperMedicaHPTime10.Text, g_Config.dSuperMedicaHPTimes[9]);
        end else if Sender = DEditSuperMedicaHPTime11 then begin
          g_Config.dSuperMedicaHPTimes[10] := Str_ToInt(DEditSuperMedicaHPTime11.Text, g_Config.dSuperMedicaHPTimes[10]);
        end else if Sender = DEditSuperMedicaHPTime12 then begin
          g_Config.dSuperMedicaHPTimes[11] := Str_ToInt(DEditSuperMedicaHPTime12.Text, g_Config.dSuperMedicaHPTimes[11]);
        end else if Sender = DEditSuperMedicaHPTime13 then begin
          g_Config.dSuperMedicaHPTimes[12] := Str_ToInt(DEditSuperMedicaHPTime13.Text, g_Config.dSuperMedicaHPTimes[12]);
        end else if Sender = DEditSuperMedicaHPTime14 then begin
          g_Config.dSuperMedicaHPTimes[13] := Str_ToInt(DEditSuperMedicaHPTime14.Text, g_Config.dSuperMedicaHPTimes[13]);
        end else if Sender = DEditSuperMedicaMPTime1 then begin
          g_Config.dSuperMedicaMPTimes[0] := Str_ToInt(DEditSuperMedicaMPTime1.Text, g_Config.dSuperMedicaMPTimes[0]);
        end else if Sender = DEditSuperMedicaMPTime2 then begin
          g_Config.dSuperMedicaMPTimes[1] := Str_ToInt(DEditSuperMedicaMPTime2.Text, g_Config.dSuperMedicaMPTimes[1]);
        end else if Sender = DEditSuperMedicaMPTime3 then begin
          g_Config.dSuperMedicaMPTimes[2] := Str_ToInt(DEditSuperMedicaMPTime3.Text, g_Config.dSuperMedicaMPTimes[2]);
        end else if Sender = DEditSuperMedicaMPTime4 then begin
          g_Config.dSuperMedicaMPTimes[3] := Str_ToInt(DEditSuperMedicaMPTime4.Text, g_Config.dSuperMedicaMPTimes[3]);
        end else if Sender = DEditSuperMedicaMPTime5 then begin
          g_Config.dSuperMedicaMPTimes[4] := Str_ToInt(DEditSuperMedicaMPTime5.Text, g_Config.dSuperMedicaMPTimes[4]);
        end else if Sender = DEditSuperMedicaMPTime6 then begin
          g_Config.dSuperMedicaMPTimes[5] := Str_ToInt(DEditSuperMedicaMPTime6.Text, g_Config.dSuperMedicaMPTimes[5]);
        end else if Sender = DEditSuperMedicaMPTime7 then begin
          g_Config.dSuperMedicaMPTimes[6] := Str_ToInt(DEditSuperMedicaMPTime7.Text, g_Config.dSuperMedicaMPTimes[6]);
        end else if Sender = DEditSuperMedicaMPTime8 then begin
          g_Config.dSuperMedicaMPTimes[7] := Str_ToInt(DEditSuperMedicaMPTime8.Text, g_Config.dSuperMedicaMPTimes[7]);
        end else if Sender = DEditSuperMedicaMPTime9 then begin
          g_Config.dSuperMedicaMPTimes[8] := Str_ToInt(DEditSuperMedicaMPTime9.Text, g_Config.dSuperMedicaMPTimes[8]);
        end else if Sender = DEditSuperMedicaMPTime10 then begin
          g_Config.dSuperMedicaMPTimes[9] := Str_ToInt(DEditSuperMedicaMPTime10.Text, g_Config.dSuperMedicaMPTimes[9]);
        end else if Sender = DEditSuperMedicaMPTime11 then begin
          g_Config.dSuperMedicaMPTimes[10] := Str_ToInt(DEditSuperMedicaMPTime11.Text, g_Config.dSuperMedicaMPTimes[10]);
        end else if Sender = DEditSuperMedicaMPTime12 then begin
          g_Config.dSuperMedicaMPTimes[11] := Str_ToInt(DEditSuperMedicaMPTime12.Text, g_Config.dSuperMedicaMPTimes[11]);
        end else if Sender = DEditSuperMedicaMPTime13 then begin
          g_Config.dSuperMedicaMPTimes[12] := Str_ToInt(DEditSuperMedicaMPTime13.Text, g_Config.dSuperMedicaMPTimes[12]);
        end else if Sender = DEditSuperMedicaMPTime14 then begin
          g_Config.dSuperMedicaMPTimes[13] := Str_ToInt(DEditSuperMedicaMPTime14.Text, g_Config.dSuperMedicaMPTimes[13]);
        end;
      end;
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DEdtFilterItemStdModeChange(Sender: TObject);
var
  I: Integer;
  List: TList;

  ShowItem: pTShowItem1;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
  sText: string;
begin
  if DEdtFilterItemStdMode.Text = '' then begin
    DCBFilterItemStdModeChange(Sender);
  end else begin
    sText := DEdtFilterItemStdMode.Text;
    List := TList.Create;
    try
      g_ShowItemList.Get(TItemType(DCBFilterItemStdMode.ItemIndex), List);
      DListViewFilterItem.Clear;
      DListViewFilterItem.ColCount := 4;
      DListViewFilterItem.HScrollBar.MaxValue := 0;
      for I := 0 to List.Count - 1 do begin
        ShowItem := List.Items[I];
        if AnsiContainsText(sText, ShowItem.SItemName) or AnsiContainsText(ShowItem.SItemName, sText) then begin
          ListItem := DListViewFilterItem.Add;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Caption := ShowItem.SItemName;
          ViewItem.Data := ShowItem;
          ViewItem.Style := bsButton; //bsRadio;
          ViewItem.Color.Up.Color := clWhite;
          ViewItem.Color.Hot.Color := clRed; //clWhite;
          ViewItem.Color.Down.Color := clRed;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Style := bsCheckBox;
          ViewItem.ImageIndex.Up := 228;
          ViewItem.ImageIndex.Down := 229;
          ViewItem.Checked := ShowItem.boHintMsg;
          ViewItem.WLib := g_WMain2Images;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Style := bsCheckBox;
          ViewItem.ImageIndex.Up := 228;
          ViewItem.ImageIndex.Down := 229;
          ViewItem.Checked := ShowItem.boPickup;
          ViewItem.WLib := g_WMain2Images;

          ViewItem := ListItem.AddItem('', nil);
          ViewItem.Style := bsCheckBox;
          ViewItem.ImageIndex.Up := 228;
          ViewItem.ImageIndex.Down := 229;
          ViewItem.Checked := ShowItem.boShowName;
          ViewItem.WLib := g_WMain2Images;
        end;
      end;
      DListViewFilterItem.HScrollBar.RemoveSize := DListViewFilterItem.HScrollBar.ItemHeight * 8;
      DListViewFilterItem.HScrollBar.MaxValue := DListViewFilterItem.Count * DListViewFilterItem.HScrollBar.ItemHeight;
    finally
      List.Free;
    end;
  end;
end;

procedure TFrmDlg.DCBFilterItemStdModeChange(Sender: TObject);
var
  I: Integer;
  List: TList;

  ShowItem: pTShowItem1;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
begin
  List := TList.Create;
  try
    g_ShowItemList.Get(TItemType(DCBFilterItemStdMode.ItemIndex), List);
    DListViewFilterItem.Clear;
    DListViewFilterItem.ColCount := 4;
    DListViewFilterItem.HScrollBar.MaxValue := 0;
    for I := 0 to List.Count - 1 do begin
      ShowItem := List.Items[I];
      ListItem := DListViewFilterItem.Add;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Caption := ShowItem.SItemName;
      ViewItem.Data := ShowItem;
      ViewItem.Style := bsButton; //bsRadio;
      ViewItem.Color.Up.Color := clWhite;
      ViewItem.Color.Hot.Color := clRed; //clWhite;
      ViewItem.Color.Down.Color := clRed;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Style := bsCheckBox;
      ViewItem.ImageIndex.Up := 228;
      ViewItem.ImageIndex.Down := 229;
      ViewItem.Checked := ShowItem.boHintMsg;
      ViewItem.WLib := g_WMain2Images;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Style := bsCheckBox;
      ViewItem.ImageIndex.Up := 228;
      ViewItem.ImageIndex.Down := 229;
      ViewItem.Checked := ShowItem.boPickup;
      ViewItem.WLib := g_WMain2Images;

      ViewItem := ListItem.AddItem('', nil);
      ViewItem.Style := bsCheckBox;
      ViewItem.ImageIndex.Up := 228;
      ViewItem.ImageIndex.Down := 229;
      ViewItem.Checked := ShowItem.boShowName;
      ViewItem.WLib := g_WMain2Images;
    end;
    DListViewFilterItem.HScrollBar.RemoveSize := DListViewFilterItem.HScrollBar.ItemHeight * 8;
    DListViewFilterItem.HScrollBar.MaxValue := DListViewFilterItem.Count * DListViewFilterItem.HScrollBar.ItemHeight;
  finally
    List.Free;
  end;
end;

procedure TFrmDlg.DBtnDefaultFilterItemClick(Sender: TObject; X,
  Y: Integer);
var
  I: Integer;
  List: TList;
  ListItem: TDListItem;
  ViewItem: pTViewItem;
  ShowItem: pTShowItem1;
begin
  if mrOk = DMessageDlg('你想恢复成系统默认设置吗 ?', [mbOk, mbCancel]) then begin
    g_ShowItemList.BackUp;
    List := TList.Create;
    try
      g_ShowItemList.Get(TItemType(DCBFilterItemStdMode.ItemIndex), List);
      DListViewFilterItem.Clear;
      DListViewFilterItem.ColCount := 4;
      DListViewFilterItem.HScrollBar.MaxValue := 0;
      for I := 0 to List.Count - 1 do begin
        ShowItem := List.Items[I];
        ListItem := DListViewFilterItem.Add;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Caption := ShowItem.SItemName;
        ViewItem.Data := ShowItem;
        ViewItem.Style := bsButton; //bsRadio;
        ViewItem.Color.Up.Color := clWhite;
        ViewItem.Color.Hot.Color := clRed; //clWhite;
        ViewItem.Color.Down.Color := clRed;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Style := bsCheckBox;
        ViewItem.ImageIndex.Up := 228;
        ViewItem.ImageIndex.Down := 229;
        ViewItem.Checked := ShowItem.boHintMsg;
        ViewItem.WLib := g_WMain2Images;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Style := bsCheckBox;
        ViewItem.ImageIndex.Up := 228;
        ViewItem.ImageIndex.Down := 229;
        ViewItem.Checked := ShowItem.boPickup;
        ViewItem.WLib := g_WMain2Images;

        ViewItem := ListItem.AddItem('', nil);
        ViewItem.Style := bsCheckBox;
        ViewItem.ImageIndex.Up := 228;
        ViewItem.ImageIndex.Down := 229;
        ViewItem.Checked := ShowItem.boShowName;
        ViewItem.WLib := g_WMain2Images;
      end;
      DListViewFilterItem.HScrollBar.MaxValue := List.Count * DListViewFilterItem.HScrollBar.ItemHeight;
    finally
      List.Free;
    end;
    g_ShowItemList.SaveToFile;
    DListViewFilterItem.HScrollBar.First;
  end;
end;

procedure TFrmDlg.DListViewFilterItemListItemClick(Sender: TObject; ARow,
  ACol: Integer; ListItem: TDListItem; ViewItem: pTViewItem);
var
  ShowItem: pTShowItem1;
begin
  ShowItem := ListItem.Items[0].Data;
  case ACol of
    0: ;
    1: ShowItem.boHintMsg := ViewItem.Checked;
    2: ShowItem.boPickup := ViewItem.Checked;
    3: ShowItem.boShowName := ViewItem.Checked;
  end;
  g_ShowItemList.SaveToFile;
end;

procedure TFrmDlg.DBotMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  {$IF M2Version = 2}//1.76
  if FrmDlg.DBotMemo.Visible then begin
    with Sender as TDButton do begin
      if WLib <> nil then begin //20080701
        if TDButton(Sender).Downed then begin
           d := WLib.Images[FaceIndex];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end else begin
           d := WLib.Images[307];
           if d <> nil then
              dsurface.Draw (SurfaceX(GLeft-4), SurfaceY(GTop-2), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
  {$ELSE}
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if TDButton(Sender).Downed then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWWStallPriceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  str: string;
begin
  with DWWStallPrice do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    dsurface.TextOut(SurfaceX(GLeft)+35, SurfaceY(GTop)+59, clLime, g_UseShopItem.Item.S.Name);
    dsurface.TextOut(SurfaceX(GLeft)+123, SurfaceY(GTop)+59, $008CC7EF, '金额范围');
    if DBWStallPriceTab2.Tag = 0 then begin
      str := Format(' 150,000,000 %s',[g_sGoldName]);
    end else begin
      str := Format(' 8,000,000 %s',[g_sGameGoldName]);
    end;
    dsurface.TextOut(SurfaceX(GLeft)+177, SurfaceY(GTop)+59, $008CC7EF, str);
    dsurface.TextOut(SurfaceX(GLeft)+35, SurfaceY(GTop)+79, $008CC7EF, '输入物品价格：');
  end;
end;

procedure TFrmDlg.DBWStallPriceTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if TDButton(Sender).Tag = 0 then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop) - 2, d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 50 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 1, $008CC7EF, clBlack, TDButton(Sender).Hint);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 50 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $007396B5, clBlack, TDButton(Sender).Hint);
    end;
  end;
end;

procedure TFrmDlg.DBWStallPriceTab1Click(Sender: TObject; X, Y: Integer);
begin
  if Sender = DBWStallPriceTab1 then begin
    DBWStallPriceTab1.Tag := 0;
    DBWStallPriceTab2.Tag := 1;
    DEdtWStallPrice.MaxLength := 7;
  end else begin
    DBWStallPriceTab1.Tag := 1;
    DBWStallPriceTab2.Tag := 0;
    DEdtWStallPrice.MaxLength := 9;
  end;
  DEdtWStallPrice.Text := '';
end;

procedure TFrmDlg.DBotStallClick(Sender: TObject; X, Y: Integer);
begin
  if DWStall.Visible then begin
    DItemBag.Visible := False;
  end else begin
    if not g_MySelf.m_boIsShop then begin
      DItemBag.GLeft := 380;
      DItemBag.GTop := 90;
      DItemBag.Visible := True;
    end;
    DEdtStallName.Text := Format('[%s]的商店',[g_MySelf.m_sUserName]);
  end;
  DWStall.Visible := not DWStall.Visible;
end;

procedure TFrmDlg.DGStallGridPaint(Sender: TObject; ACol, ARow: Integer;
  Rect: TRect; State: TDGridDrawState; dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DGStall.ColCount;
  if idx in [0..9] then begin
    if g_ShopItems[idx].Item.S.Name <> '' then begin
      d := FrmMain.GetBagItemImg(g_ShopItems[idx].Item.S.Looks);
      if d <> nil then begin
        with DGStall do begin
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2),
            d.ClientRect,
            d, TRUE);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGStallGridSelect(Sender: TObject; ACol, ARow: Integer;
  Shift: TShiftState);
var
  idx, mi: integer;
begin
  if g_MySelf.m_boIsShop then Exit;
  if DBotStall.Visible then begin
    idx := ACol + ARow * DGStall.ColCount;
    if idx in [0..9] then begin
      if not g_boItemMoving then begin
        if g_ShopItems[idx].Item.S.Name <> '' then begin
          g_boItemMoving := TRUE;
          g_MovingItem.Index := -(72+idx);
          g_MovingItem.Item := g_ShopItems[idx].Item;
          //g_MovingItem.Hero := False;
          g_ShopItems[idx].Item.S.Name := '';
          ItemClickSound(g_ShopItems[idx].Item.S);
        end;
      end else begin
        mi := g_MovingItem.Index;
        if (mi = -97) or (mi = -98) then Exit; //金币...
        if (mi <= -72) and (mi > -81) then begin
          g_UseShopItem.Item := g_MovingItem.Item;
          AddShopItem(g_UseShopItem);
          CancelItemMoving;
        end else begin
          if GetShopItemRoom then begin
            g_UseShopItem.Item := g_MovingItem.Item;
            CancelItemMoving;
            if DBWStallPriceTab2.Tag = 0 then begin //元宝
              DEdtWStallPrice.MaxLength := 7;
            end else begin
              DEdtWStallPrice.MaxLength := 9;
            end;
            DEdtWStallPrice.Text := '';
            DEdtWStallPrice.SetFocus;
            DWWStallPrice.Show;
          end else begin
            DMessageDlg ('摊位物品已满，无法继续添加物品！', [mbOk]);
          end;
        end;
      end;
    end;
  end;
  //ArrangeItemBag;
end;

procedure TFrmDlg.DBStallCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWStall.Visible := False;
end;

procedure TFrmDlg.DBWStallPriceCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWWStallPrice.Visible := False;
end;

procedure TFrmDlg.DBWStallPriceOKClick(Sender: TObject; X, Y: Integer);
var
  nPic: Integer;
begin
  if DEdtWStallPrice.Text <> '' then begin
    nPic := Str_ToInt(DEdtWStallPrice.Text, 0);
    if DBWStallPriceTab1.Tag = 0 then begin //元宝
      if (nPic > 8000000) or (nPic < 1) then begin
        DMessageDlg ('输入'+g_sGameGoldName+'价格错误，请输入一个在 1~8,000,000 之间的数字！', [mbOk]);
        DEdtWStallPrice.Text := '8000000';
        Exit;
      end;
    end else begin  //金币
      if (nPic > 150000000) or (nPic < 1) then begin
        DMessageDlg ('输入'+g_sGoldName+'价格错误，请输入一个在 1~150,000,000 之间的数字！', [mbOk]);
        DEdtWStallPrice.Text := '150000000';
        Exit;
      end;
    end;
    g_UseShopItem.nPic := Str_ToInt(DEdtWStallPrice.Text, 0);
    g_UseShopItem.boCls := DBWStallPriceTab1.Tag = 0;
    AddShopItem(g_UseShopItem);
    AddItemBagLock(g_UseShopItem.Item);
    DWWStallPrice.Visible := False;
    FillChar (g_UseShopItem, SizeOf(TClientItem), #0);
  end;
end;

procedure TFrmDlg.DBtnStallStartClick(Sender: TObject; X, Y: Integer);
  function ShopItemExists(): Boolean;
  var
    I: Integer;
  begin
    Result := False;
    for I:= Low(g_ShopItems) to High(g_ShopItems) do begin
      if g_ShopItems[I].Item.S.Name <> '' then begin
        Result := True;
        Break;
      end;
    end;
  end;
var
  btDir: Byte;
begin
  if g_MySelf.m_boIsShop then Exit;
  if DBotStall.Visible then begin
    if GetTickCount > DlgShopTime then begin
      if ShopItemExists then begin
        btDir := g_MySelf.m_btDir;
        if (g_MySelf.m_nState and $04000000 = 0){非麻痹}and (g_MySelf.m_nState and $1000000 = 0){非冰冻}and (g_MySelf.m_nState and $00004000 = 0){非定身} then begin
          if btDir in [0, 2, 4, 6] then begin
            Inc(btDir);
            if frmMain.CanNextAction and frmMain.ServerAcceptNextAction then begin
              g_MySelf.SendMsg (CM_TURN, g_MySelf.m_nCurrX, g_MySelf.m_nCurrY, btDir, 0, 0, '', 0, g_nilFeature);
            end;
          end;
          FrmMain.SendShopItems(DEdtStallName.Text);
          DlgShopTime := GetTickCount + 5000;
        end else begin
          DScreen.AddChatBoardString('麻痹中不允许摆摊！',  clWhite, clRed);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBtnStallStopClick(Sender: TObject; X, Y: Integer);
var
  i: integer;
begin
  try //程序自动增加
    for I := Low(g_ShopItems) to High(g_ShopItems) do begin
      if g_ShopItems[i].Item.S.Name <> '' then DelItemBagLock(g_ShopItems[i].Item);
    end;
    ArrangeItemBag;
    FillChar(g_ShopItems, Sizeof(TShopItem) * 10, #0);
    //DSelfShop.Visible := False;
    if g_MySelf.m_boIsShop then FrmMain.SendCloseShopItems;
    DWStall.Visible := False;
  except //程序自动增加
    DebugOutStr('[Exception] TFrmDlg.DShopCloseClick'); //程序自动增加
  end; //程序自动增加
end;

procedure TFrmDlg.DGStallGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  sGold: string;
begin
  DScreen.ClearHint;
  iname := '';
  sGold := '';
  idx := ACol + ARow * DGStall.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_ShopItems[idx].Item;
    GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
    g_MouseItem.S.Name := '';
    if iname <> '' then begin
      with DGStall do begin
        if g_ShopItems[idx].boCls then begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_ShopItems[idx].nPic), g_sGameGoldName]);
        end else begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_ShopItems[idx].nPic), g_sGoldName]);
        end;
        DScreen.ShowSpecialHint(SurfaceX(GLeft+(ACol)*ColWidth),
                                SurfaceY(GTop+(ARow+1)*RowHeight),
                                Format('<%s/c=$000075EA fontsize=12 fontstyle=bold><%s/c=Red fontsize=12 fontstyle=bold>\ \%s\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Lime>',
                                [iname, iname1, d1, d2, d3, d4, d5, d6, d7, sGold]), False);
      end;
    end;
  end;
end;

procedure TFrmDlg.DGUserStallGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
var
  idx: integer;
  d: TDirectDrawSurface;
begin
  idx := ACol + ARow * DGUserStall.ColCount;
  if idx in [0..9] then begin
    if g_UserShopItem[idx].Item.S.Name <> '' then begin
      d := FrmMain.GetBagItemImg(g_UserShopItem[idx].Item.S.Looks);
      if d <> nil then begin
        with DGUserStall do begin
          dsurface.Draw(SurfaceX(Rect.Left + (ColWidth - d.Width) div 2),
            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2),
            d.ClientRect,
            d, TRUE);
          if g_btShopIdx = idx then begin
            if g_dShopSelImage <> nil then begin
              dsurface.FastDrawAlpha(Bounds(SurfaceX(Rect.Left), SurfaceY(Rect.Top),g_dShopSelImage.Width, g_dShopSelImage.Height ),classes.Rect(0,0,g_dShopSelImage.Width, g_dShopSelImage.Height),g_dShopSelImage);
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DGUserStallGridMouseMove(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  sGold: string;
begin
  DScreen.ClearHint;
  iname := '';
  sGold := '';
  idx := ACol + ARow * DGUserStall.ColCount;
  if idx in [0..9] then begin
    g_MouseItem := g_UserShopItem[idx].Item;
    GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
    g_MouseItem.S.Name := '';
    if iname <> '' then begin
      with DGUserStall do begin
        if g_UserShopItem[idx].boCls then begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_UserShopItem[idx].nPic), g_sGameGoldName]);
        end else begin
          sGold := Format('售价：%s%s',[GetGoldStr(g_UserShopItem[idx].nPic), g_sGoldName]);
        end;
        DScreen.ShowSpecialHint(SurfaceX(GLeft+(ACol)*ColWidth),
                                SurfaceY(GTop+(ARow+1)*RowHeight),
                                Format('<%s/c=$000075EA fontsize=12 fontstyle=bold><%s/c=Red fontsize=12 fontstyle=bold>\ \%s\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Lime>',
                                [iname, iname1, d1, d2, d3, d4, d5, d6, d7, sGold]), False);
      end;
    end;
  end;
end;

procedure TFrmDlg.DBUserStallCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWUserStall.Visible := False;
  FreeAndNil(g_dShopSelImage);
end;

procedure TFrmDlg.DWUserStallDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with DWUserStall do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if g_sShopName <> '' then begin
      dsurface.BoldTextOut(SurfaceX(GLeft)+29, SurfaceY(GTop)+35, clWhite, clBlack, g_sShopName);
    end;
  end;
end;

procedure TFrmDlg.DWStallMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWUserStallMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DGUserStallGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
var
  idx: Integer;
begin
  idx := ACol + ARow * DGUserStall.ColCount;
  if idx in [0..9] then begin
    if g_UserShopItem[idx].Item.S.Name <> '' then begin
      g_btShopIdx := idx;
    end;
  end;
end;

procedure TFrmDlg.DBBuyUserStallItemClick(Sender: TObject; X, Y: Integer);
var
  sGold: string;
begin
  if g_btShopIdx in [0..9] then begin
    if g_UserShopItem[g_btShopIdx].Item.S.Name <> '' then begin
      if g_UserShopItem[g_btShopIdx].boCls then begin
        sGold := g_sGameGoldName;
      end else begin
        sGold := g_sGoldName;
      end;
      if mrOk = FrmDlg.DMessageDlg (Format('你将以 %s %s购买 %s，确定吗？',[GetGoldStr(g_UserShopItem[g_btShopIdx].nPic), sGold, g_UserShopItem[g_btShopIdx].Item.S.Name]), [mbOk, mbCancel]) then begin
        if g_SelfShopItem.S.Name = '' then begin
          g_SelfShopItem := g_UserShopItem[g_btShopIdx].Item;
          FrmMain.SendSelfShopBuy(g_nShopActorIdx, g_nShopX, g_nShopY,
            g_UserShopItem[g_btShopIdx].Item.MakeIndex);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DWMiniMapDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  mx, my,nx,ny, i: Integer;
  rc: TRect;
  actor:TActor;
  //{$IF GVersion = 1}
  //x,y:integer;
  //{$IFEND}
  btColor:TColor;
  //{T,} old: PFindNOde;  //自动寻路 20080617
  Automx,Automy: Integer; //自动寻路 20080617
  MapDesc: pMapDesc; //小地图注释格式
//  Surface11: TDirectDrawSurface;
begin
  if GetTickCount > m_dwBlinkTime + 300 then begin  //当前玩家在小地图上的位置，每300毫秒闪一次
    m_dwBlinkTime := GetTickCount;
    m_boViewBlink := not m_boViewBlink;
  end;
  if g_nMiniMapIndex < 0 then exit;
  if GetMiniMapNum(g_nMiniMapIndex) <> nil then  //新小地图
    d:= GetMiniMapNum(g_nMiniMapIndex)
  else
    d := g_WMMapImages.Images[g_nMiniMapIndex];
  if d = nil then Exit;
  mx := (g_MySelf.m_nCurrX*48) div 32;
  my := (g_MySelf.m_nCurrY*32) div 32;
  rc.Left := _MAX(0, mx-60);
  rc.Top := _MAX(0, my-60);
  rc.Right := _MIN(d.ClientRect.Right, rc.Left + 120);
  rc.Bottom := _MIN(d.ClientRect.Bottom, rc.Top + 120);
  if g_nViewMinMapLv = 1 then begin
    if not g_boTransparentMiniMap then
      dsurface.Draw ((SCREENWIDTH-120), 0, rc, d, FALSE)
    else begin
      //DrawBlendEx (dsurface, (SCREENWIDTH-120), 0, d,rc.Left, rc.Top, 120, 120, 150);
      dsurface.FastDrawAlpha(Bounds((SCREENWIDTH-120), 0, 120, 120), rc, d, False);
    end;
    if g_boShowMimiMapDesc or ((g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0)) then begin
      for I:=0 to g_MapDescList.Count -1 do begin
        if pMapDesc(g_MapDescList[I]) <> nil then begin
          MapDesc := pMapDesc(g_MapDescList[I]);
          if (MapDesc.sMapName = g_sMapTitle) and not MapDesc.boMaxMap then begin
            if (680 + (MapDesc.m_nMapX * 48) div 32 - rc.Left >= 680){左} and ((MapDesc.m_nMapY * 32) div 32 - rc.Top >= 0){上} and ((MapDesc.m_nMapY * 32) div 32 - rc.Top <= 120){下} and (680 + (MapDesc.m_nMapX * 48) div 32 - rc.Left <= 800){右} then begin
                dsurface.BoldTextOut ((SCREENWIDTH-121) + (MapDesc.m_nMapX * 48) div 32 - rc.Left - FrmMain.Canvas.TextWidth(MapDesc.sMainMapName) div 2
                  , (MapDesc.m_nMapY * 32) div 32 - rc.Top - 7, MapDesc.btColor, clBlack,MapDesc.sMainMapName);
            end;
          end;
        end;
      end;
    end;
    if (g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0) then
      dsurface.BoldTextOut (DWMiniMap.GLeft + 120 - FrmMain.Canvas.TextWidth(IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY))
        , DWMiniMap.GTop + 108, clWhite, clBlack,IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY));
    //小地图画自动寻路路径 20080617
    if LegendMap.StartFind then begin
      with dsurface.Canvas do begin
        //T := PFindNOde(g_RoadList[0]);
        Pen.Color := clYellow;
        Automx := (SCREENWIDTH-120) + (g_MySelf.m_nCurrX * 48) div 32 - rc.Left;
        AutomY := (g_MySelf.m_nCurrY * 32) div 32 - rc.Top;
        for I := 0 to Length(LegendMap.Path) - 1 do begin
          MoveTo(Automx, Automy);
          Automx := (SCREENWIDTH-120) + (LegendMap.Path[I].X * 48) div 32 - rc.Left;
          AutomY := (LegendMap.Path[I].Y * 32) div 32 - rc.Top;
          LineTo(Automx, Automy);
        end;
        Release;
      end;
    end;  
  //雷达
  if m_boViewBlink then begin
    mx := (SCREENWIDTH-120) + (g_MySelf.m_nCurrX * 48) div 32 - rc.Left;
    my := (g_MySelf.m_nCurrY * 32) div 32 - rc.Top;
    ClFunc.PixelsOut(dsurface,mx, my, GetRGB(255), 3);
  end;
  for nx:=g_MySelf.m_nCurrX - 10  to g_MySelf.m_nCurrX + 10 do begin
    for ny:=g_MySelf.m_nCurrY - 10 to g_MySelf.m_nCurrY + 10 do begin
      actor := PlayScene.FindActorXY(nx,ny);
      if (actor <> nil) and (actor <> g_MySelf) and (not actor.m_boDeath) then begin
        mx := (SCREENWIDTH-120) + (actor.m_nCurrX * 48) div 32 - rc.Left;
        my := (actor.m_nCurrY * 32) div 32 - rc.Top;
        case actor.m_btRace of    //
          50,12: btColor:=215;
          0,150: btColor:=251;
          else btColor:=249;
        end;    // case
        if (actor.m_btRace= 1) then btColor := actor.m_btMiniMapHeroColor;
        ClFunc.PixelsOut(dsurface,mx, my, GetRGB(btColor), 3);
      end;
    end;
  end;
  end else begin
    if (d <> nil) and (d.Width <> 0) and (d.Height <> 0)then begin

      g_MiniMapSurface.StretchDraw(Rect(0, 0, 200, 200), d.ClientRect,d, False);
      if not g_boTransparentMiniMap then
        dsurface.Draw(DWMiniMap.GLeft,0,g_MiniMapSurface.ClientRect,g_MiniMapSurface,False)
      else
        //DrawBlendEx (dsurface, (SCREENWIDTH-200), 0, g_MiniMapSurface, 0, 0, 200, 200, 150);
        dsurface.FastDrawAlpha(Bounds((SCREENWIDTH-200), 0, 200, 200), g_MiniMapSurface.ClientRect, g_MiniMapSurface, False);
      //dsurface.StretchDraw(Rect((SCREENWIDTH - 200), 0, 800, 200), d.ClientRect,d, False);
      rc := d.ClientRect;
      mx := UpInt((295 / d.Width) * g_MySelf.m_nCurrX) + 800 - 200;
      my := UpInt((198 / d.Height) * g_MySelf.m_nCurrY);
    end;
    if g_boShowMimiMapDesc or ((g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0)) then begin
      for I:=0 to g_MapDescList.Count -1 do begin
        if pMapDesc(g_MapDescList[I]) <> nil then begin
          MapDesc := pMapDesc(g_MapDescList[I]);
          if (MapDesc.sMapName = g_sMapTitle) and MapDesc.boMaxMap then begin
              dsurface.BoldTextOut (UpInt((295 / d.Width) * MapDesc.m_nMapX) + 600 - FrmMain.Canvas.TextWidth(MapDesc.sMainMapName) div 2
                , UpInt((198 / d.Height) * MapDesc.m_nMapY), MapDesc.btColor, clBlack,MapDesc.sMainMapName);
          end;
        end;
      end;
    end;
    if (g_nMouseMinMapX <> 0) and (g_nMouseMinMapY <> 0) then
      dsurface.BoldTextOut (DWMiniMap.GLeft + 200 - FrmMain.Canvas.TextWidth(IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY))
        , DWMiniMap.GTop + 188, clWhite, clBlack,IntToStr(g_nMouseMinMapX)+':'+IntToStr(g_nMouseMinMapY));
    //大地图画自动寻路路径 20080617
    if LegendMap.StartFind then begin
      with dsurface.Canvas do begin
        Pen.Color := clYellow;
        Automx := UpInt((295 / d.Width) * g_MySelf.m_nCurrX) + 800 - 200;
        Automy := UpInt((198 / d.Height) * g_MySelf.m_nCurrY);
        for I := 0 to Length(LegendMap.Path) - 1 do begin
          MoveTo(Automx, Automy);
          Automx := UpInt((295 / d.Width) * LegendMap.Path[I].X) + 800 - 200;
          Automy := UpInt((198 / d.Height) * LegendMap.Path[I].Y);
          LineTo(Automx, Automy);
        end;
        Release;
      end;
    end;
    if m_boViewBlink then ClFunc.PixelsOut(dsurface,mx, my, GetRGB(255), 3);
  end;
end;

procedure TFrmDlg.DWMiniMapMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if ssLeft in Shift then begin
    if g_boViewMiniMap then begin
      if g_nViewMinMapLv >= 2 then begin
         g_nViewMinMapLv:=1;
         DWMiniMap.GLeft := SCREENWIDTH - 120; //20080323
         DWMiniMap.GWidth := 120; //20080323
         DWMiniMap.GHeight:= 120; //20080323
      end else begin
        Inc(g_nViewMinMapLv);
        DWMiniMap.GLeft := SCREENWIDTH - 200; //20080323
        DWMiniMap.GWidth := 200; //20080323
        DWMiniMap.GHeight:= 200; //20080323
      end;
    end;
  end;
  if Button = mbRight then begin
    g_boTransparentMiniMap := not g_boTransparentMiniMap;
  end;
end;

procedure TFrmDlg.DWMiniMapMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  d: TDirectDrawSurface;
  rc: TRect;
  nx, ny: Integer;
begin
  try
  if GetMiniMapNum(g_nMiniMapIndex) <> nil then  //新小地图
    d:= GetMiniMapNum(g_nMiniMapIndex)
  else
    d := g_WMMapImages.Images[g_nMiniMapIndex];
    if d <> nil then begin
      rc := d.ClientRect;
      if g_nViewMinMapLv = 1 then begin
        if x < 60 then nx := -(60-x) else nx:= x-60;
        g_nMouseMinMapX := (g_MySelf.m_nCurrX * 32) div 32 - rc.Left + nx - (SCREENWIDTH - 120);
        if y < 60 then ny := -(60-y) else ny:= y-60;
        g_nMouseMinMapY := (g_MySelf.m_nCurrY * 32) div 32 - rc.Top + ny;
      end else
        if g_nViewMinMapLv = 2 then begin
          g_nMouseMinMapX := _MAX(0, Round((X - 600) * d.Width / 295));  //全景 坐标对的
          g_nMouseMinMapY := Round(Y * d.Height / 198);
        end;
    end;
  except
    DebugOutStr ('MiniMapMouseMove');
  end;
end;

procedure TFrmDlg.ClientGetMissionSay(nParam: Integer; Text: string);
var
  I: Integer;
  nPos: Integer;
  DMemo: TDTreeView;
  TextList: TStringList;
  sText, sCmd: string;
  TreeNode: TDTreeNode;
  ChildTreeNode: TDTreeNode;
  function NewNpcLabel(ACaption, ACmd: string; Up, Hot, Down: TColor; Style: TFontStyles): TDTreeNode;
  var
    DLabel: TMissionLabel;
  begin
    DLabel := TMissionLabel.Create;
    DLabel.Caption := ACaption;
    DLabel.CaptionColor.Up.Color := Up;
    DLabel.CaptionColor.Hot.Color := Hot;
    DLabel.CaptionColor.Down.Color := Down;
    DLabel.CaptionColor.Up.Style := Style;
    DLabel.CaptionColor.Hot.Style := Style;
    DLabel.CaptionColor.Down.Style := Style;
    DLabel.m_sCmd := ACmd;
    Result := DLabel;
  end;

begin
//  DScreen.AddChatBoardString(Text, clYellow, clRed);
  if Text <> '' then begin
    if nParam = 0 then begin
      DMemo := DTreeViewMission1;
      DMemo.Clear;

      TextList := TStringList.Create;
      ExtractStrings(['\'], [' '], PChar(Text), TextList);

      for I := TextList.Count - 1 downto 0 do begin
        TextList[I] := Trim(TextList[I]);
        if TextList[I] = '' then begin
          TextList.Delete(I);
        end;
      end;

      TreeNode := nil;
      ChildTreeNode := nil;

      for I := 0 to TextList.Count - 1 do begin
        sText := TextList[I];
        sText := Trim(sText);
        if sText[1] = '<' then sText := Copy(sText, 2, Length(sText) - 1);
        if sText[Length(sText)] = '>' then sText := Copy(sText, 1, Length(sText) - 1);
        sCmd := '';
        nPos := Pos('/@', sText);
        if nPos > 0 then begin
          sCmd := Copy(sText, nPos + 1, Length(sText) - nPos);
          sText := Copy(sText, 1, nPos - 1);
        end;

        if sCmd <> '' then begin
          if TreeNode = nil then begin
            TreeNode := NewNpcLabel('', '', clWhite, clYellow, clRed, []);
            DMemo.Add(TreeNode);
          end;
          ChildTreeNode := NewNpcLabel(sText, sCmd, clWhite, clYellow, clRed, []);
          TreeNode.Add(ChildTreeNode);
        end else begin
          TreeNode := NewNpcLabel(sText, sCmd, clWhite, clYellow, clRed, []);
          DMemo.Add(TreeNode);
        end;
      end;
      if DMemo.Count > 0 then begin
        DMemo.Items[0].Expand := True;
      end;
      TextList.Free;
    end else begin
      sText := Text;
      sCmd := '';
      DMemoMissionBottom.Lines.Clear;
      while TRUE do begin
         if sText = '' then break;   //为空了则退出循环
         sText := GetValidStr3 (sText, sCmd, ['\']); //获取内容
         if sCmd <> '' then DMemoMissionBottom.Lines.Add(sCmd);
      end;

      if MissionBottomPoints.Count > 0 then //20080629
      for i:=0 to MissionBottomPoints.Count-1 do
        Dispose (pTClickPoint (MissionBottomPoints[i]));
      MissionBottomPoints.Clear;
      MissionBottomAddPoints := True;
    end;
  end;
end;

procedure TFrmDlg.DTreeViewMission1Select(Sender: TObject; TreeNode: TDTreeNode);
begin
  PlaySound(s_glass_button_click);
  if CompareText(TMissionLabel(TreeNode).m_sCmd, '@EXIT') = 0 then begin
    DWMission.Visible := False;
  end else begin
    if TMissionLabel(TreeNode).m_sCmd <> '' then
      SendMissionSelect (TMissionLabel(TreeNode).m_sCmd);
  end;
end;

procedure TFrmDlg.DMemoMissionBottomDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  data, fdata, cmdstr, cmdparam: string;
  sx: integer;
  pcp: PTClickPoint;
  Color: TColor;
  sColor, cmdtitle, sTemp: string;
begin
  with DMemoMissionBottom do begin//防止除0错误By TasNat at: 2012-10-19 09:23:22
    ElemCount:= (GHeight - 2) div _MAX(1, LinesHeight);  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for I:= 0 to ElemCount - 1 do begin
      sx := 0;
      fdata := '';
      data := Lines.Strings[I+TopIndex];
      while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin  //如果是连接
        if data[1] <> '<' then begin
          data := '<' + GetValidStr3 (data, fdata, ['<']);
        end;
        data := ArrestStringEx (data, '<', '>', cmdstr);//得到"<"和">" 号之间的字   赋予给 cmdstr
        if cmdstr <> '' then begin
          cmdparam := GetValidStr3 (cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
        end;
        if fdata <> '' then begin
          dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, fdata);
          sx := sx + FrmMain.Canvas.TextWidth(fdata);
        end;
        if (cmdstr <> '') then begin
          if CompareLStr(cmdparam, 'FCOLOR=', length('FCOLOR=')) then begin
            sColor := GetValidStr3(cmdparam, sTemp, ['=']);
            Color := GetRGB(Lobyte(Str_ToInt(sColor, 255)));
            dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), Color, clBlack, cmdstr)  //显示颜色文字
          end else begin
            if MissionBottomAddPoints and (cmdparam <> '') then begin
               new (pcp);
               pcp.rc := Rect (sx, I*LinesHeight, sx + FrmMain.Canvas.TextWidth(cmdstr), I*LinesHeight + 14);
               pcp.RStr := cmdparam;
               MissionBottomPoints.Add (pcp);
            end;
            FrmMain.Canvas.Font.Style := FrmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
            if MissionMoveedBottomStr = cmdparam then begin
               dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), GetRGB(223), clBlack, cmdstr);
            end else dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clYellow, clBlack, cmdstr);
          end;
          FrmMain.Canvas.Font.Style := FrmMain.Canvas.Font.Style - [fsUnderline];
          sx := sx + FrmMain.Canvas.TextWidth(cmdstr);
        end;
      end;
      if data <> '' then
        dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, data);
    end;
    MissionBottomAddPoints := False;
  end;
end;

procedure TFrmDlg.DMemoMissionBottomMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
var
   i, L, T: integer;
   p: PTClickPoint;
begin
  MissionMoveedBottomStr := '1';
  L := DMemoMissionBottom.GLeft;
  T := DMemoMissionBottom.GTop;
  with DMemoMissionBottom do begin
    if MissionBottomPoints.Count > 0 then  begin//20080629
      for i:=0 to MissionBottomPoints.Count-1 do begin
        p := PTClickPoint (MissionBottomPoints[i]);
        if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          MissionMoveedBottomStr := p.RStr;
          break;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DMemoMissionBottomClick(Sender: TObject; X, Y: Integer);
var
  i, L, T: integer;
  p: PTClickPoint;
  sData: string;
begin
  L := DMemoMissionBottom.GLeft;
  T := DMemoMissionBottom.GTop;
  with DMemoMissionBottom do begin
    if MissionBottomPoints.Count > 0 then //20080629
    for i:=0 to MissionBottomPoints.Count-1 do begin
       p := PTClickPoint (MissionBottomPoints[i]);
       if (X >= L + p.rc.Left) and (X <= L + p.rc.Right) and
          (Y >= T + p.rc.Top) and (Y <= T + p.rc.Bottom) then begin
          if DMerchantDlgSelect(p.RStr, p.TStr, sData) then SendMissionSelect(sData);
          //LastestClickTime := GetTickCount + 2000; //20080803修改 以前为5000
          break;
       end;
    end;
  end;
end;

procedure TFrmDlg.SendMissionSelect(rstr: string);
var
  msg: TDefaultMessage;
begin
  msg := MakeDefaultMsg (aa(CM_CLICKMMISSION, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg) + EncodeString (rstr));
end;

procedure TFrmDlg.DMemoMissionBottomScrollBarChange(Sender: TObject);
var
  I: Integer;
begin
  if MissionBottomPoints.Count > 0 then //20080629
  for i:=0 to MissionBottomPoints.Count-1 do
    Dispose (pTClickPoint (MissionBottomPoints[i]));
  MissionBottomPoints.Clear;
  MissionBottomAddPoints := True;
end;

procedure TFrmDlg.DBMissionCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWMission.Visible := False;
end;

procedure TFrmDlg.DBMission1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
begin
  d := nil;
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if TDButton(Sender).Tag <> m_btMissionPage then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    dsurface.BoldTextOut (SurfaceX(GLeft) + 28 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 4, clWhite, clBlack, Hint);
  end;
end;

procedure TFrmDlg.DBMission1Click(Sender: TObject; X, Y: Integer);
begin
  if m_btMissionPage <> TDButton(Sender).Tag then begin
    m_btMissionPage := TDButton(Sender).Tag;
    MissionPageChanged();
  end;
end;

procedure TFrmDlg.MissionPageChanged;
var
  msg: TDefaultMessage;
  StrSel: string;
begin
  case m_btMissionPage of
    0: begin
      {DTreeViewMission1.Visible := True; DScrollBarMission1.Visible := True;
      DTreeViewMission2.Visible := False; DScrollBarMission2.Visible := False;
      DTreeViewMission3.Visible := False; DScrollBarMission3.Visible := False;    }
     // if DTreeViewMission1.Count = 0 then Exit;
      StrSel := '@主线任务';
    end;
    1: begin
      {DTreeViewMission1.Visible := False; DScrollBarMission1.Visible := False;
      DTreeViewMission2.Visible := True; DScrollBarMission2.Visible := True;
      DTreeViewMission3.Visible := False; DScrollBarMission3.Visible := False;    }
     // if DTreeViewMission2.Count = 0 then Exit;
      StrSel := '@支线任务';
    end;
    2: begin
      {DTreeViewMission1.Visible := False; DScrollBarMission1.Visible := False;
      DTreeViewMission2.Visible := False; DScrollBarMission2.Visible := False;
      DTreeViewMission3.Visible := True; DScrollBarMission3.Visible := True;  }
     // if DTreeViewMission3.Count = 0 then Exit;
      StrSel := '@操作指南';
    end;
    else begin
      {DTreeViewMission1.Visible := False; DScrollBarMission1.Visible := False;
      DTreeViewMission2.Visible := False; DScrollBarMission2.Visible := False;
      DTreeViewMission3.Visible := False; DScrollBarMission3.Visible := False;    }
      StrSel := '';
    end;
  end;

  if StrSel <> '' then begin
    msg := MakeDefaultMsg(aa(CM_CLICKMMISSION, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);//20090228
    FrmMain.SendSocket(EncodeMessage(msg) + EncodeString(StrSel));
  end;
end;
procedure TFrmDlg.DBMissionClick(Sender: TObject; X, Y: Integer);
begin
  DWMission.Visible := not DWMission.Visible;
  if DWMission.Visible then begin
    if m_boMissionEff then m_boMissionEff := False;
    MissionPageChanged();
  end;
end;

procedure TFrmDlg.DBMissionDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if TDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;


    if WLib <> nil then begin //20080701
      if TDButton(Sender).MouseMoveing then d := WLib.Images[FaceIndex + 1]
      else if TDButton(Sender).Downed then d := WLib.Images[FaceIndex + 2]
      else begin
        if m_boMissionEff then begin
          if GetTickCount - m_dwMissionEffTick > 180 then begin
            m_dwMissionEffTick := GetTickCount;
            Inc(m_btMissionEffImg);
            if m_btMissionEffImg > 1 then m_btMissionEffImg := 0;
          end;
          d := WLib.Images[FaceIndex+m_btMissionEffImg];
        end else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DBMissionClose1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if Downed then begin
      d := WLib.Images[FaceIndex + 1];
      if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + 4, $0048A4E8, clBlack, Hint);
    end else begin
      if MouseMoveing then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $00A8D4E8, clBlack, TDButton(Sender).Hint);
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $0088C4E8, clBlack, TDButton(Sender).Hint);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWSkillMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  {$IF M2Version <> 2}
  with DWSkillMemo do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    frmMain.Canvas.Font.Size := 15;
    frmMain.Canvas.Font.Style := [fsBold];
    dsurface.BoldTextOut(SurfaceX(GLeft)+64, SurfaceY(GTop)+10, $00A8D4E8, clBlack, SkillMemoName);
    frmMain.Canvas.Font.Style := [];
    frmMain.Canvas.Font.Size := 9;
    if SkillMemoId = 100 then begin //神秘解读
      frmMain.Canvas.Font.Style := [fsBold];
      dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+53, $0088C4E8, clBlack, g_MySelf.m_sUserName);
      frmMain.Canvas.Font.Style := [];
      d := g_WUI1Images.Images[920];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft) + 30, SurfaceY(GTop) + 152, d.ClientRect, d, True);
      end;
      d := g_WUI1Images.Images[921];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft) + 30, SurfaceY(GTop) + 170, d.ClientRect, d, True);
      end;
      frmMain.Canvas.Font.Style := [fsBold];
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 152, $008CC7EF, clBlack, IntToStr(SkillMemoLevel));
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 170, $008CC7EF, clBlack, Format('%d/999', [g_nProficiency]));
      frmMain.Canvas.Font.Style := [];
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 228, clWhite, clBlack, '神秘解读：学习后用来制作相应等');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 243, clWhite, clBlack, '级的神秘卷轴。在寻宝的过程中来');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 258, clWhite, clBlack, '提升技能等级。随着技能提升人物');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 273, clWhite, clBlack, '的血量也将会有一定的提升。');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 289, clWhite, clBlack, '熟练度：制作神秘卷轴可以提升您');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 303, clWhite, clBlack, '的熟练度，熟练度的增加相应解读');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 23, SurfaceY(GTop) + 318, clWhite, clBlack, '卷轴的成功率也会越高。');
    end else begin
      frmMain.Canvas.Font.Style := [fsBold];
      dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+53, $0088C4E8, clBlack, g_MySelf.m_sUserName);
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 131, $0088C4E8, clBlack, SkillMemoName);
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 149, $0088C4E8, clBlack, '0');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 185, $0088C4E8, clBlack, '0/300');
      frmMain.Canvas.Font.Style := [];

      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 131, clSilver, clBlack, '当前技能：');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 149, clSilver, clBlack, '当前等级：');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 167, clSilver, clBlack, '（升级到下一级血量增加）');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 185, clSilver, clBlack, '当前经验：');
      dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 203, clSilver, clBlack, Format('（1 %s = 1 技能经验）', [g_sGameGird]));
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSkillMemoIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  wm: TWMImages;
begin
  {$IF M2Version <> 2}
  with DBSkillMemoIcon do begin
    wm := GetMagicIcon(SkillMemoEffect, 0, SkillMemoId, 0, SkillMemoIcon);
    if wm <> nil then begin
      if not Downed then begin
        d := wm.Images[SkillMemoIcon];
      end else begin
        d := wm.Images[SkillMemoIcon + 1];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSkillMemoCloseClick(Sender: TObject; X, Y: Integer);
begin
  DWSkillMemo.Visible := False;
end;

procedure TFrmDlg.DBHeroSkillMemoCloseClick(Sender: TObject; X,
  Y: Integer);
begin
  DWHeroSkillMemo.Visible := False;
end;

procedure TFrmDlg.DBJDSeeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with TDButton(Sender) do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 2];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2 + 1, SurfaceY(GTop) + 4, $0048A4E8, clBlack, Hint);
      end else begin
        if MouseMoveing then begin
          d := WLib.Images[FaceIndex + 1];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $00A8D4E8, clBlack, TDButton(Sender).Hint);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 3, $0088C4E8, clBlack, TDButton(Sender).Hint);
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBJDSeeClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if g_MagicList.Count > 0 then begin
    for I:=0 to g_MagicList.Count - 1 do begin
      pm := PTClientMagic (g_MagicList[I]);
      if pm.Def.wMagicId = 100 then begin //神秘解读
        SetSkillMemoDlg(100, pm.Level, pm.Def.btEffect, pm.Def.sMagicName, '神秘解读');
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBJDSeeMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  with TDButton(Sender) do begin
    if (Sender = DBJDSee) or ((Sender = DBNewJDSee)) then begin
      DScreen.ShowHint(SurfaceX(GLeft) - 50, SurfaceY(GTop)+ 10, '点击可以查看神秘解\读的熟练度', clYellow, FALSE);
    end else if Sender = DBHeroQSSSee then begin
      DScreen.ShowHint(SurfaceX(GLeft) - 50, SurfaceY(GTop)+ 10, '点击可以修炼强身术', clYellow, FALSE);
    end;
  end;
{$IFEND}
end;
{$IF M2Version <> 2}
procedure TFrmDlg.SetSkillMemoDlg(MagID, MagLevel: Word; Effect: Byte; magname, magTitle: string);
var
  msg: TDefaultMessage;
begin
  if (MagID = 100) and not DWSkillMemo.Visible then begin //神秘解读
    msg := MakeDefaultMsg (aa(CM_OPENQUERYPROFICIENCY, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
    FrmMain.SendSocket(EncodeMessage (msg));
  end;
  SkillMemoID := MagID;
  SkillMemoLevel := MagLevel; 
  SkillMemoEffect := Effect;
  SkillMemoName := magname;
  SkillMemoTitle := magTitle;
  DBSkillMemoLink.Visible := SkillMemoId <> 100;
  DWSkillMemo.Visible := not DWSkillMemo.Visible;
end;

procedure TFrmDlg.SetHeroSkillMemoDlg(MagID: Word; Effect: Byte; magname, magTitle: string);
var
  I: Integer;
  pm: PTClientMagic;
begin
  HeroSkillMemoID := MagID;
  HeroSkillMemoEffect := Effect;
  HeroSkillMemoName := magname;
  HeroSkillMemoTitle := magTitle;
  if g_HeroSelf <> nil then begin
    HeroSkillMemoUserName := g_HeroSelf.m_sUserName;
  end;
  pm := nil;
  if g_HeroMagicList.Count > 0 then begin
    for I:=0 to g_HeroMagicList.Count - 1 do begin
      if pTClientMagic(g_HeroMagicList[i]).Def.wMagicId = HeroSkillMemoId then begin
        pm := g_HeroMagicList[i];
        Break;
      end;
    end;
  end;

  if pm <> nil then begin
    if (pm.Level < 99) then begin
      HeroSkillMemoAddHp := GetHeroSkillMemoAddHp(pm.Level);
    end else HeroSkillMemoAddHp := 0;
  end;
  DWHeroSkillMemo.Visible := not DWHeroSkillMemo.Visible;
end;
{$IFEND}

procedure TFrmDlg.DBHeroQSSSeeClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  SetHeroSkillMemoDlg(99, 92, '白日门强身术', '强身术修炼');
  {$IFEND}
end;

procedure TFrmDlg.DWHeroSkillMemoDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  I: Integer;
  pm: PTClientMagic;
begin
  {$IF M2Version <> 2}
  with DWHeroSkillMemo do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    frmMain.Canvas.Font.Size := 15;
    frmMain.Canvas.Font.Style := [fsBold];
    dsurface.BoldTextOut(SurfaceX(GLeft)+64, SurfaceY(GTop)+10, $00A8D4E8, clBlack, HeroSkillMemoTitle);
    frmMain.Canvas.Font.Size := 9;

    dsurface.BoldTextOut(SurfaceX(GLeft)+80, SurfaceY(GTop)+53, $0088C4E8, clBlack, HeroSkillMemoUserName+'（英雄）');
    frmMain.Canvas.Font.Style := [];
    pm := nil;
    if g_HeroMagicList.Count > 0 then begin
      for I:=0 to g_HeroMagicList.Count - 1 do begin
        if pTClientMagic(g_HeroMagicList[i]).Def.wMagicId = HeroSkillMemoId then begin
          pm := g_HeroMagicList[i];
          Break;
        end;
      end;
    end;

    if pm <> nil then begin
      frmMain.Canvas.Font.Style := [fsBold];
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 131, $0088C4E8, clBlack, pm.Def.sMagicName);
      dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 149, $0088C4E8, clBlack, IntToStr(pm.Level));
      if pm.Level = 99 then begin
        dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 185, $0088C4E8, clBlack, '-');
      end else begin
        dsurface.BoldTextOut(SurfaceX(GLeft) + 100, SurfaceY(GTop) + 185, $0088C4E8, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]){'0/300'});
      end;
      frmMain.Canvas.Font.Style := [];
    end;
    dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 131, clSilver, clBlack, '当前技能：');
    dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 149, clSilver, clBlack, '当前等级：');
    dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 167, clSilver, clBlack, Format('（升级到下一级血量增加%d）',[HeroSkillMemoAddHp]));
    dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 185, clSilver, clBlack, '当前经验：');
    dsurface.BoldTextOut(SurfaceX(GLeft) + 24, SurfaceY(GTop) + 203, clSilver, clBlack, Format('（1 %s = 1 技能经验）', [g_sGameGird]));
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  wm: TWMImages;
begin
  {$IF M2Version <> 2}
  with DBHeroSkillMemoIcon do begin
    wm := GetMagicIcon(HeroSkillMemoEffect, 0, HeroSkillMemoId, 0, HeroSkillMemoIcon);
    if wm <> nil then begin
      if not Downed then begin
        d := wm.Images[HeroSkillMemoIcon];
      end else begin
        d := wm.Images[HeroSkillMemoIcon + 1];
      end;
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoLinkDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
begin
  {$IF M2Version <> 2}
  with DBHeroSkillMemoLink do begin
    frmMain.Canvas.Font.Style := [fsUnderline];
    if HeroSkillMemoLinkIdx = 1 then begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop), clRed, clBlack, Format('使用1800张%s自动修炼180次', [g_sGameGird]));
    end else begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, clBlack, Format('使用1800张%s自动修炼180次', [g_sGameGird]));
    end;
    if HeroSkillMemoLinkIdx = 2 then begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+17, clRed, clBlack, Format('使用3600张%s自动修炼360次', [g_sGameGird]));
    end else begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+17, clYellow, clBlack, Format('使用3600张%s自动修炼360次', [g_sGameGird]));
    end;
    if HeroSkillMemoLinkIdx = 3 then begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+34, clRed, clBlack, Format('使用5400张%s自动修炼180次', [g_sGameGird]));
    end else begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+34, clYellow, clBlack, Format('使用5400张%s自动修炼180次', [g_sGameGird]));
    end;
    if HeroSkillMemoLinkIdx = 4 then begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+51, clRed, clBlack, Format('使用10800张%s自动修炼360次', [g_sGameGird]));
    end else begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+51, clYellow, clBlack, Format('使用10800张%s自动修炼360次', [g_sGameGird]));
    end;
    if HeroSkillMemoLinkIdx = 5 then begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+68, clRed, clBlack, Format('取消自动修炼', [g_sGameGird]));
    end else begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+68, clYellow, clBlack, Format('取消自动修炼', [g_sGameGird]));
    end;
    if HeroSkillMemoLinkIdx = 6 then begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+85, clRed, clBlack, Format('查询剩余修炼次数', [g_sGameGird]));
    end else begin
      dsurface.BoldTextOut(SurfaceX(GLeft), SurfaceY(GTop)+85, clYellow, clBlack, Format('查询剩余修炼次数', [g_sGameGird]));
    end;
    frmMain.Canvas.Font.Style := [];
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoLinkClick(Sender: TObject; X, Y: Integer);
var
  msg: TDefaultMessage;
begin
  with DBHeroSkillMemoLink do begin
    if (X >= GLeft) and (X <= GLeft+GWidth) then begin
      if (Y >= GTop) and (Y <= GTop+13) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 1, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+17) and (Y <= GTop+30) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 2, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+34) and (Y <= GTop+47) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 3, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+51) and (Y <= GTop+64) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_AUTOGAMEGIRDUPSKILL99, frmMain.TempCertification), 4, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+68) and (Y <= GTop+81) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_CLOSEGAMEGIRDUPSKILL99, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
      if (Y >= GTop+85) and (Y <= GTop+98) then begin
        PlaySound (s_glass_button_click);
        msg := MakeDefaultMsg (aa(CM_QUERYGAMEGIRDUPSKILL99, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
        frmMain.SendSocket (EncodeMessage (msg));
      end;
    end;
  end;
end;

procedure TFrmDlg.DBHeroSkillMemoLinkMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  HeroSkillMemoLinkIdx := 0;
  {$IFEND}
end;

procedure TFrmDlg.DBItemLevelBelt1Click(Sender: TObject; X, Y: Integer);
  {$IF M2Version <> 2}
var
  ItemLevelSort: pTItemLevelSort;
  {$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TDButton do begin
    if g_UserItemLevelList.Count >= Tag+1 then begin
      if g_UserItemLevelList[Tag] <> nil then begin
        ItemLevelSort := pTItemLevelSort(g_UserItemLevelList[Tag]);
        g_MouseItem := ItemLevelSort.Item;
        ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                          SurfaceY(GTop) + GHeight, '', 1, False);
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBItemLevelBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  ItemLevelSort: pTItemLevelSort;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TDButton do begin
    if g_UserItemLevelList.Count >= Tag+1 then begin
      if g_UserItemLevelList[Tag] <> nil then begin
        ItemLevelSort := pTItemLevelSort(g_UserItemLevelList[Tag]);
        if ItemLevelSort.Item.S.Name <> '' then begin
          if Downed then begin
            frmMain.Canvas.Font.Style := [fsUnderline];
            dsurface.TextOut (SurfaceX(GLeft) + 46-FrmMain.Canvas.TextWidth(ItemLevelSort.Item.S.Name) div 2, SurfaceY(GTop), clRed, ItemLevelSort.Item.S.Name);
            frmMain.CanVas.Font.Style := [];
          end else if MouseMoveing then begin
            frmMain.Canvas.Font.Style := [fsUnderline];
            dsurface.TextOut (SurfaceX(GLeft) + 46-FrmMain.Canvas.TextWidth(ItemLevelSort.Item.S.Name) div 2, SurfaceY(GTop), $0000E7F7, ItemLevelSort.Item.S.Name);
            frmMain.CanVas.Font.Style := [];
          end else begin
            dsurface.TextOut (SurfaceX(GLeft) + 46-FrmMain.Canvas.TextWidth(ItemLevelSort.Item.S.Name) div 2, SurfaceY(GTop), clYellow, ItemLevelSort.Item.S.Name);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBHeroSkillMemoLinkMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  HeroSkillMemoLinkIdx := 0;
  with DBHeroSkillMemoLink do begin
    if (X >= GLeft) and (X <= SurfaceX(GLeft)+GWidth) then begin
      if (Y >= GTop) and (Y <= GTop+13) then HeroSkillMemoLinkIdx := 1;
      if (Y >= GTop+17) and (Y <= GTop+30) then HeroSkillMemoLinkIdx := 2;
      if (Y >= GTop+34) and (Y <= GTop+47) then HeroSkillMemoLinkIdx := 3;
      if (Y >= GTop+51) and (Y <= GTop+64) then HeroSkillMemoLinkIdx := 4;
      if (Y >= GTop+68) and (Y <= GTop+81) then HeroSkillMemoLinkIdx := 5;
      if (Y >= GTop+85) and (Y <= GTop+98) then HeroSkillMemoLinkIdx := 6;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DWSignedItemsDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with DWSignedItems do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    dsurface.BoldTextOut(SurfaceX(GLeft) + 44, SurfaceY(GTop) + 141, $0088C4E8, clBlack, '鉴宝师');
    case m_btSignedItemsPage of
      1: begin
        if m_btSignedHint = 3 then begin
          dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, Format('我已经给了你一把没鉴定过的%s，跟你原',[g_SignedItem[0].S.Name]));
          dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+56, clWhite, Format('来的%s没鉴定过之前是一模一样的！',[g_SignedItem[0].S.Name]));
        end else if m_btSignedHint = 4 then begin
          dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, '更换失败！');
        end else begin
          if g_SignedItem[0].S.Name <> '' then begin
            dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, Format('这个%s看上去不错，我这里正好有没有',[g_SignedItem[0].S.Name]));
            dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+56, clWhite, Format('鉴定过的各种%s你可以挑一把，要换的',[g_SignedItem[0].S.Name]));
            dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+71, clWhite, '话，你要给我一个幸运符');
          end else begin
            dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+41, clWhite, '如果你不喜欢已经鉴定过了的宝物，你可以把');
            dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+56, clWhite, '他给我，我平素最爱收藏各种宝物，我会给你');
            dsurface.TextOut(SurfaceX(GLeft)+126, SurfaceY(GTop)+71, clWhite, '一个一模一样的没鉴定过的装备作为补偿。');
          end;
          d := g_WUI1Images.Images[892];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+222, SurfaceY(GTop)+145, d.ClientRect, d, True);
            dsurface.Draw(SurfaceX(GLeft)+292, SurfaceY(GTop)+153, d.ClientRect, d, True);
          end;
          if g_SignedItem[0].S.Name <> '' then begin
            d := g_WUI1Images.Images[890];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(GLeft)+237, SurfaceY(GTop)+124, d.ClientRect, d, True);
            end;
          end;
          if g_SignedItem[1].S.Name <> '' then begin
            d := g_WUI1Images.Images[891];
            if d <> nil then begin
              dsurface.Draw(SurfaceX(GLeft)+304, SurfaceY(GTop)+150, d.ClientRect, d, True);
            end;
          end;
        end;
      end;
      2: begin
        dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft)+134, SurfaceY(GTop)+109,g_ImgSignedSurface.Width, g_ImgSignedSurface.Height ),g_ImgSignedSurface.ClientRect ,g_ImgSignedSurface);
        dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '宝物除了能给你带来意外的财富，还能给');
        dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '你的装备附加强效属性。');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+113, clWhite, '1、只有标识可鉴定的物品才能进行鉴定');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+128, clWhite, '2、每件物品最多可以鉴定三次，但是在鉴定过程中有可');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+143, clWhite, '能获得追加的鉴定机会，还有可能获得让庄主帮忙鉴定');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+158, clWhite, '的机会');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+173, clWhite, '3、鉴定出来的宝物一般是带有额外属性加成，宝物等级');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+188, clWhite, '越高，属性越多，属性越好');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+203, clWhite, '4、鉴定失败，鉴定师会返还一定的经验或者荣耀点。');
        dsurface.Canvas.Pen.Color := $00488490;//$98;
        dsurface.Canvas.MoveTo(SurfaceX(GLeft)+134, SurfaceY(GTop)+109);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134+g_ImgSignedSurface.Width, SurfaceY(GTop)+109);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134+g_ImgSignedSurface.Width, SurfaceY(GTop)+109+g_ImgSignedSurface.Height);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134, SurfaceY(GTop)+109+g_ImgSignedSurface.Height);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134, SurfaceY(GTop)+109);
        dsurface.Canvas.Release;
      end;
      3: begin
        dsurface.FastDrawAlpha(Bounds(SurfaceX(GLeft)+134, SurfaceY(GTop)+109,g_ImgSignedSurface.Width, g_ImgSignedSurface.Height ),g_ImgSignedSurface.ClientRect ,g_ImgSignedSurface);
        dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '宝物除了能给你带来意外的财富，还能给');
        dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '你的装备附加强效属性。');

        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+113, clWhite, '1、如果你对鉴定出来的附加属性不满意，你可以和我更');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+128, clWhite, '换，我会挑一件和你鉴定之前一模一样的装备给你的。');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+143, clWhite, '2、更换后装备幸运值和已升级的点数保留，例如你给我');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+158, clWhite, '一个三鉴的幸运+7，攻击12-87，暴击等级+10的传奇战');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+173, clWhite, '刃，我会换给你一个没鉴定过的幸运+7，攻击12-87，暴');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+188, clWhite, '击等级+10的传奇战刃。');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+203, clWhite, '3、和我更换装备需要给我一个幸运符，幸运符可以从商');
        dsurface.TextOut(SurfaceX(GLeft)+136, SurfaceY(GTop)+218, clWhite, '城购买。');

        dsurface.Canvas.Pen.Color := $00488490;//$98;
        dsurface.Canvas.MoveTo(SurfaceX(GLeft)+134, SurfaceY(GTop)+109);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134+g_ImgSignedSurface.Width, SurfaceY(GTop)+109);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134+g_ImgSignedSurface.Width, SurfaceY(GTop)+109+g_ImgSignedSurface.Height);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134, SurfaceY(GTop)+109+g_ImgSignedSurface.Height);
        dsurface.Canvas.LineTo(SurfaceX(GLeft)+134, SurfaceY(GTop)+109);
        dsurface.Canvas.Release;
      end;
      else begin
        if g_SignedItem[0].S.Name <> '' then begin
          if m_btSignedHint = 1 then begin //成功
            dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '借助卷轴的力量，我已经帮你发现了你这');
            dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, Format('%s的潜能。', [g_SignedItem[0].S.Name]));
          end else if m_btSignedHint = 2 then begin //失败
            dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, Format('我并没能从你的这个%s上发现更多的', [g_SignedItem[0].S.Name]));
            dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '潜能。你不要沮丧，我会给你额外的补偿');
            dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+80, clWhite, '。');
          end else begin
            if g_SignedItem[0].btAppraisalLevel in [1..4,11..14,21..24,31..34,41..44,51..54] then begin  //可鉴定
              case g_SignedItem[0].btAppraisalLevel of
                1,11,21,31,41,51: begin
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '第一次鉴定我需要一个一级鉴定卷轴，你');
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '快去收集一个吧！');
                end;
                2,12,22,32,42,52: begin
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '第二次鉴定我需要一个二级鉴定卷轴，你');
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '快去收集一个吧！');
                end;
                3,13,23,33,43,53: begin
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '第三次鉴定我需要一个三级鉴定卷轴，你');
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '快去收集一个吧！');
                end;
                4,14,24,34,44,54: begin
                  dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, Format('你的这件%s已经不能再鉴定了。',[g_SignedItem[0].S.Name]));
                end;
              end;
            end else begin
              dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '标志了不可鉴定的物品我是鉴定不了的，');
              dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '你换一个吧。');
            end;
          end;
        end else begin
          dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+50, clWhite, '我收藏天下的奇珍异宝，走南闯北几十年');
          dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+65, clWhite, '了，各种神器见过不少，把你要鉴定的装');
          dsurface.TextOut(SurfaceX(GLeft)+138, SurfaceY(GTop)+80, clWhite, '备放在桌子上吧！');
        end;
        d := g_WUI1Images.Images[892];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(GLeft)+222, SurfaceY(GTop)+145, d.ClientRect, d, True);
          dsurface.Draw(SurfaceX(GLeft)+292, SurfaceY(GTop)+153, d.ClientRect, d, True);
        end;
        if g_SignedItem[0].S.Name <> '' then begin
          d := g_WUI1Images.Images[890];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+237, SurfaceY(GTop)+124, d.ClientRect, d, True);
          end;
        end;
        if g_SignedItem[1].S.Name <> '' then begin
          d := g_WUI1Images.Images[891];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+304, SurfaceY(GTop)+150, d.ClientRect, d, True);
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSignedItemDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with TDButton(Sender) do begin
    if WLib <> nil then begin
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + 37 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 6, $0048A4E8, clBlack, TDButton(Sender).Hint);
        end;
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
          dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          if MouseMoveing then begin
            dsurface.BoldTextOut (SurfaceX(GLeft) + 36 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $00A8D4E8, clBlack, TDButton(Sender).Hint);
          end else dsurface.BoldTextOut (SurfaceX(GLeft) + 36 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + 5, $0088C4E8, clBlack, TDButton(Sender).Hint);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBSignedItemClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if m_boSignedLock then Exit;
  if m_btSignedItemsPage <> TDButton(Sender).Tag then begin
    m_btSignedItemsPage := TDButton(Sender).Tag;
    case m_btSignedItemsPage of
      1: begin
        DBSignedBelt1.Visible := True;
        DBSignedBelt2.Visible := True;
        DBOrdSigned.Visible := False;
        DBHighSigned.Visible := False;
        DBSignedChange.Visible := True;
        if (g_SignedItem[1].S.Name <> '') and (g_SignedItem[1].S.StdMode <> 18) and (g_SignedItem[1].S.Shape <> 1) then begin
          AddItemBag(g_SignedItem[1]);
          g_SignedItem[1].S.Name := '';
        end;
      end;
      2: begin
        DBSignedBelt1.Visible := False;
        DBSignedBelt2.Visible := False;
        DBOrdSigned.Visible := False;
        DBHighSigned.Visible := False;
        DBSignedChange.Visible := False;
      end;
      3: begin
        DBSignedBelt1.Visible := False;
        DBSignedBelt2.Visible := False;
        DBOrdSigned.Visible := False;
        DBHighSigned.Visible := False;
        DBSignedChange.Visible := False;
      end;
      else begin
        DBSignedBelt1.Visible := True;
        DBSignedBelt2.Visible := True;
        DBOrdSigned.Visible := True;
        DBHighSigned.Visible := True;
        DBSignedChange.Visible := False;
        if g_SignedItem[0].S.Name <> '' then begin
          case g_SignedItem[0].btAppraisalLevel of
            1,11,21,31,41,51: begin
              DBOrdSigned.Hint := '普通一鉴';
              DBHighSigned.Hint := '高级一鉴';
              DBOrdSigned.Enabled := True;
              DBHighSigned.Enabled := True;
              if (g_SignedItem[1].S.Name = '') and not ((g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767))  then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and (g_ItemArr[I].Item.S.Shape = 239) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
            2,12,22,32,42,52: begin
              DBOrdSigned.Hint := '普通二鉴';
              DBHighSigned.Hint := '高级二鉴';
              DBOrdSigned.Enabled := True;
              DBHighSigned.Enabled := True;
              if (g_SignedItem[1].S.Name = '') and not ((g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767))  then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and (g_ItemArr[I].Item.S.Shape = 240) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
            3,13,23,33,43,53: begin
              DBOrdSigned.Hint := '普通三鉴';
              DBHighSigned.Hint := '高级三鉴';
              DBOrdSigned.Enabled := True;
              DBHighSigned.Enabled := True;
              if (g_SignedItem[1].S.Name = '') and not ((g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767))  then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and (g_ItemArr[I].Item.S.Shape = 241) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
            else begin
              DBOrdSigned.Hint := '普通鉴定';
              DBHighSigned.Hint := '高级鉴定';
              DBOrdSigned.Enabled := False;
              DBHighSigned.Enabled := False;
            end;
          end;
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBOrdSignedDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if not Enabled then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2, SurfaceY(GTop) + d.Height div 2 - FrmMain.Canvas.TextHeight(Hint) div 2{+ 5}, $0099A8AC, clBlack, Hint);
        Exit;
      end;
      if TDButton(Sender).Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(Hint) div 2+1, SurfaceY(GTop) + d.Height div 2 - FrmMain.Canvas.TextHeight(Hint) div 2 + 1{SurfaceY(GTop) + 6}, $0048A4E8, clBlack, Hint);
      end else begin
        if TDButton(Sender).MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + d.Height div 2 - FrmMain.Canvas.TextHeight(Hint) div 2, $00A8D4E8, clBlack, TDButton(Sender).Hint);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          dsurface.BoldTextOut (SurfaceX(GLeft) + d.Width div 2 - FrmMain.Canvas.TextWidth(TDButton(Sender).Hint) div 2, SurfaceY(GTop) + d.Height div 2 - FrmMain.Canvas.TextHeight(Hint) div 2, $0088C4E8, clBlack, TDButton(Sender).Hint);
        end;
      end;
    end;
  end;
{$IFEND}  
end;

procedure TFrmDlg.DBSignedBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if m_btSignedItemsPage = 1 then begin
        d := g_WUI1Images.Images[883];
      end else begin
        d := WLib.Images[FaceIndex];
      end;
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      if g_SignedItem[Tag].S.Name <> '' then begin
        idx := g_SignedItem[Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
        g_ImgMixSurface.SetSize(35, 33);
        g_ImgMixSurface.FastFill($00003255);
        if d<>nil then begin
          DrawBlendEx (dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
        end;
      end;
      if Sender = DBSignedBelt1 then begin
        case m_btSignedSuccess of
          1: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[940+m_btSignedImginsex];
            if d <> nil then
              DrawBlend(dsurface, DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d, 255);
          end;
          2: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[970+m_btSignedImginsex];
            if d <> nil then
              DrawBlend(dsurface, DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d, 255);
          end;
          3: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[1000+m_btSignedImginsex];
            if d <> nil then
              DrawBlend(dsurface, DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d, 255);
          end;
          4: begin
            if GetTickCount - m_dwSignedTimeTick > 120 then begin
              m_dwSignedTimeTick := GetTickCount();
              Inc(m_btSignedImginsex);
            end;
            if m_btSignedImginsex > 21 then begin
              m_btSignedImginsex := 0;
              m_btSignedSuccess := 0; //停止动画
              m_boSignedLock := False;
            end;
            d := g_WUI1Images.Images[1030+m_btSignedImginsex];
            if d <> nil then
              DrawBlend(dsurface, DWSignedItems.SurfaceX(DWSignedItems.GLeft), DWSignedItems.SurfaceY(DWSignedItems.GTop), d, 255);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBSignedBelt1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientItem;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boSignedLock then Exit;
    m_btSignedHint := 0;
  with Sender as TDButton do begin
    if not g_boItemMoving then begin
      if g_SignedItem[Tag].S.Name <> '' then begin
         ItemClickSound (g_SignedItem[Tag].S);
         if g_MovingItem.Item.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_SignedItem[Tag];
         g_SignedItem[Tag].S.Name := '';
         if g_SignedItem[0].S.Name = '' then begin
           DBOrdSigned.Hint := '普通鉴定';
           DBHighSigned.Hint := '高级鉴定';
           DBOrdSigned.Enabled := False;
           DBHighSigned.Enabled := False;
           DBSignedChange.Enabled := False;
         end;
      end;
    end else begin
      if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_SignedItem[Tag].S.Name <> '' then begin
          temp := g_SignedItem[Tag];
          g_SignedItem[Tag] := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_SignedItem[Tag] := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
        end;

        if m_btSignedItemsPage = 1 then begin
          if Sender = DBSignedBelt1 then begin
            if not (g_SignedItem[0].btAppraisalLevel in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
              DBSignedChange.Enabled := False;
              AddItemBag(g_SignedItem[0]);
              g_SignedItem[0].S.Name := '';
              Exit;
            end else begin
              if (g_SignedItem[1].S.Name = '') then begin
                for I:=6 to MAXBAGITEMCL-1 do begin
                  if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 18) and (g_ItemArr[I].Item.S.Shape = 1) then begin
                    g_SignedItem[1] := g_ItemArr[I].Item;
                    g_ItemArr[I].Item.S.Name := '';
                    Break;
                  end;
                end;
              end;
            end;
          end else begin
            if (g_SignedItem[1].S.StdMode <> 18) and (g_SignedItem[1].S.Shape <> 1) then begin
              DBSignedChange.Enabled := False;
              AddItemBag(g_SignedItem[1]);
              g_SignedItem[1].S.Name := '';
              Exit;
            end;
          end;
        end else begin
          if Sender = DBSignedBelt1 then begin
            case g_SignedItem[0].btAppraisalLevel of
              1,11,21,31,41,51: begin
                DBOrdSigned.Hint := '普通一鉴';
                DBHighSigned.Hint := '高级一鉴';
                DBOrdSigned.Enabled := True;
                DBHighSigned.Enabled := True;
                if (g_SignedItem[1].S.Name = '') and not ((g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767))  then begin
                  for I:=6 to MAXBAGITEMCL-1 do begin
                    if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and (g_ItemArr[I].Item.S.Shape = 239) then begin
                      g_SignedItem[1] := g_ItemArr[I].Item;
                      g_ItemArr[I].Item.S.Name := '';
                      Break;
                    end;
                  end;
                end;
              end;
              2,12,22,32,42,52: begin
                DBOrdSigned.Hint := '普通二鉴';
                DBHighSigned.Hint := '高级二鉴';
                DBOrdSigned.Enabled := True;
                DBHighSigned.Enabled := True;
                if (g_SignedItem[1].S.Name = '') and not ((g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767))  then begin
                  for I:=6 to MAXBAGITEMCL-1 do begin
                    if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and (g_ItemArr[I].Item.S.Shape = 240) then begin
                      g_SignedItem[1] := g_ItemArr[I].Item;
                      g_ItemArr[I].Item.S.Name := '';
                      Break;
                    end;
                  end;
                end;
              end;
              3,13,23,33,43,53: begin
                DBOrdSigned.Hint := '普通三鉴';
                DBHighSigned.Hint := '高级三鉴';
                DBOrdSigned.Enabled := True;
                DBHighSigned.Enabled := True;
                if (g_SignedItem[1].S.Name = '') and not ((g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767))  then begin
                  for I:=6 to MAXBAGITEMCL-1 do begin
                    if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and (g_ItemArr[I].Item.S.Shape = 241) then begin
                      g_SignedItem[1] := g_ItemArr[I].Item;
                      g_ItemArr[I].Item.S.Name := '';
                      Break;
                    end;
                  end;
                end;
              end;
              else begin
                DBOrdSigned.Hint := '普通鉴定';
                DBHighSigned.Hint := '高级鉴定';
                DBOrdSigned.Enabled := False;
                DBHighSigned.Enabled := False;
              end;
            end;
          end;
        end;
        DBSignedChange.Enabled := g_SignedItem[0].S.Name <> '';
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBSignedItemsCloseClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boSignedLock then Exit;
  for I:=Low(g_SignedItem) to High(g_SignedItem) do begin
    if g_SignedItem[I].S.Name <> '' then begin
      AddItemBag(g_SignedItem[I]);
      g_SignedItem[I].S.Name := '';
    end;
  end;
  DWSignedItems.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DWJudgeItemsDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWJudgeItems do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    case m_btJudjeItemsPage of
      1: begin
        g_ImgMixSurface.SetSize(329, 196);
        g_ImgMixSurface.FastFill(0);
        dsurface.Draw(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, g_ImgMixSurface.ClientRect, g_ImgMixSurface, False);
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+52, clWhite, '1、宝物品评可以让你看到宝物的真实战斗力分数');
        if g_boJudgeUseGold then begin
          dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, Format('2、品评装备一次需要花费%d%s', [g_nJudgePrice, g_sGoldName]));
        end else begin
          dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, Format('2、品评装备一次需要花费%d%s', [g_nJudgePrice, g_sGameGoldName]));
        end;
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+78, clWhite, '3、如果你的宝物足够强大，在我品评后，可以帮你放入排');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+91, clWhite, '   行榜的装备榜，受宗仁瞻仰');
      end;
      else begin
        dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '宝物的基础属性，附加基础属性，附加神秘');
        dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '属性，升级次数，幸运值等都会影响宝物的');
        dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '评分，评分越高，宝物在装备排行榜的排行');
        dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+83, clWhite, '也越高');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWJudgeItemsMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBJudgeBelt1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientItem;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if not g_boItemMoving then begin
      if g_JudgeItems.S.Name <> '' then begin
         ItemClickSound (g_JudgeItems.S);
         if g_MovingItem.Item.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_JudgeItems;
         g_JudgeItems.S.Name := '';
      end;
    end else begin
      if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.btAppraisalLevel in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_JudgeItems.S.Name <> '' then begin
          temp := g_JudgeItems;
          g_JudgeItems := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_JudgeItems := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
        d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      if g_JudgeItems.S.Name <> '' then begin
        idx := g_JudgeItems.S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.btAppraisalLevel in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
        g_ImgMixSurface.SetSize(35, 33);
        g_ImgMixSurface.FastFill($00003255);
        if d<>nil then begin
          DrawBlendEx (dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeBelt1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    g_MouseItem := g_JudgeItems;
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeItemClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if m_btJudjeItemsPage <> Tag then begin
      m_btJudjeItemsPage := Tag;
      DBJudgeBelt1.Visible := m_btJudjeItemsPage = 0;
      DBJudgeStart.Visible := m_btJudjeItemsPage = 0;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeItemsCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_JudgeItems.S.Name <> '' then begin
    AddItemBag(g_JudgeItems);
    g_JudgeItems.S.Name := '';
  end;
  DWJudgeItems.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBJudgeStartClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_boJudgeUseGold then begin
    str := Format('您确定用%d%s品评这个装备吗？', [g_nJudgePrice, g_sGoldName]);
  end else begin
    str := Format('您确定用%d%s品评这个装备吗？', [g_nJudgePrice, g_sGameGoldName]);
  end;

  if mrOk = DMessageDlg (str, [mbOk, mbCancel]) then begin
    FrmMain.SendUserJudge(g_JudgeItems.MakeIndex, g_JudgeItems.S.Name);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWMakeSignedDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWMakeSigned do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    d := g_WUI1Images.Images[893];
    if d <> nil then begin
      dsurface.Draw(SurfaceX(GLeft)+118, SurfaceY(GTop)+14, d.ClientRect, d, True);
    end;
    case m_btMakeSignedPage of
      1: begin
        if m_btMakeSignedHint = 1 then begin //成功
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '神秘卷轴制作成功');
        end else if m_btMakeSignedHint = 2 then begin //失败
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '这次制作不幸的失败了，可能是因为你的神');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '秘解读技能等级还不够高，或者是你制作的');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '卷轴等级太高了');
        end else begin
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '你可以把你对鉴宝的心得还有你的鉴定经验');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '写在神秘卷轴上，这样的话，就可以帮助更');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '多人解读神秘属性');
        end;
      end;
      2: begin
        g_ImgMixSurface.SetSize(329, 196);
        g_ImgMixSurface.FastFill(0);
        dsurface.Draw(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, g_ImgMixSurface.ClientRect, g_ImgMixSurface, False);
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+52, clWhite, '1、神秘属性可以通过使用的神秘卷轴进行解读');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, '2、神秘卷轴的等级决定了可以解读的神秘属性个数，等级');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+78, clWhite, '   一的神秘卷轴可以解读第一个神秘属性，等级二的神秘卷');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+91, clWhite, '   轴可以解读第一个和第二个神秘属性，等级三的神秘卷轴');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+104, clWhite, '   可以解读前三个神秘属性，等级四的神秘卷轴可以解读前');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+117, clWhite, '   四个神秘属性');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+130, clWhite, '3、解读神秘属性有一定的成功率，使用的神秘卷轴等级越高');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+143, clWhite, '   、熟练度越高，解读的成功率也越高');
      end;
      3: begin
        g_ImgMixSurface.SetSize(329, 196);
        g_ImgMixSurface.FastFill(0);
        dsurface.Draw(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, g_ImgMixSurface.ClientRect, g_ImgMixSurface, False);
        dsurface.Draw(SurfaceX(GLeft)+122, SurfaceY(GTop)+40, g_ImgMixSurface.ClientRect, g_ImgMixSurface, False);
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+52, clWhite, '1、制作神秘卷轴需要使用羊皮卷，羊皮卷可以从商城进行购');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+65, clWhite, '   买');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+78, clWhite, '2、制作神秘卷轴有一定的成功率，成功率由幸运值、要制作');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+91, clWhite, '   的卷轴等级和玩家的神秘解读技能的等级相关，制作面页');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+104, clWhite, '   中的红色进度条为玩家的幸运值，每次制作失败都会增加');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+117, clWhite, '   幸运值');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+130, clWhite, '3、每次制作成功都会消耗一定的精力值，精力值不足的时候');
        dsurface.TextOut(SurfaceX(GLeft)+125, SurfaceY(GTop)+143, clWhite, '   不能制作卷轴，精力值会随着在线时间的延长有所增长。');
      end;
      else begin
        if m_btMakeSignedHint = 3 then begin //成功
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '借助神秘卷轴的帮助，已经帮你解读出了一');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '个神秘属性');
        end else if m_btMakeSignedHint = 4 then begin //失败
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '这次解读不幸失败，解读幸运值、神秘卷轴');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '的等级和熟练度过低可能导致解读失败，不');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '要失望，再接再厉吧。');
        end else if g_SignedItem[0].S.Name <> '' then begin
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '等级越高，熟练度越高的神秘卷轴，解读成');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '功的概率越高，放入你要使用的神秘卷轴吧');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+70, clWhite, '。');
        end else begin
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+44, clWhite, '你可以跟别人购买神秘卷轴，也可以自己制');
          dsurface.TextOut(SurfaceX(GLeft)+129, SurfaceY(GTop)+57, clWhite, '作神秘卷轴来解读宝物的神秘属性。');
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedExp1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if Sender = DBMakeSignedExp1 then begin
      DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop) - 3, Format(' 精力值 %d/%d' ,[g_btEnergyValue,100]) , clWhite, FALSE);
    end else begin
      DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop) - 3, Format(' 幸运值 %d/%d' ,[g_btLuckyValue,100]) , clWhite, FALSE);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWMakeSignedMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBMakeSignedReadClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  with Sender as TDButton do begin
    if m_btMakeSignedPage <> Tag then begin
      m_btMakeSignedPage := Tag;
      DBMakeSignedBelt1.Visible := m_btMakeSignedPage = 0;
      DBMakeSignedBelt2.Visible := m_btMakeSignedPage = 0;
      DBMakeSignedReadStart.Visible := m_btMakeSignedPage = 0;
      DBMakeSignedBelt3.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve1.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve2.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve3.Visible := m_btMakeSignedPage = 1;
      DBMakeSignedLeve4.Visible := m_btMakeSignedPage = 1;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLevelOrderClick(Sender: TObject; X, Y: Integer);
var
 msg: TDefaultMessage;
begin
  LevelOrderPage := 6;
  LevelOrderPageChanged;
  nLevelOrderPage := TDButton(Sender).Tag;
  nLevelOrderTypePage := TDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_QUERYUSERLEVELSORT, frmMain.TempCertification), 0{nPage}, nLevelOrderSortTypePage{nSortType}, nLevelOrderPage{nType}, 0, frmMain.m_nSendMsgCount);
  FrmMain.SendSocket (EncodeMessage (msg));
end;

procedure TFrmDlg.DBOrdSignedClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if m_boSignedLock then Exit;
  if not TDButton(Sender).Enabled then Exit;
  if g_SignedItem[1].S.Name = '' then begin
    DMessageDlg ('请放置鉴定卷轴，鉴定卷轴可以在日常活动中获得，包括祝福点活动、灵\符仙子追加奖励、九周年大使处的烟花兑换及5元礼包等各种活动', [mbOK]);
    Exit;
  end;
  case g_SignedItem[0].btAppraisalLevel of
    1,11,21,31,41,51: begin
      if ((g_SignedItem[1].S.StdMode = 17) and (g_SignedItem[1].S.Shape = 239)) or ((g_SignedItem[1].S.StdMode = 44) and (g_SignedItem[1].S.Shape = 249)) then begin
        DBOrdSigned.Enabled := False;
        DBHighSigned.Enabled := False;
        m_boSignedLock := True;
        FrmMain.SendSginedItem(g_SignedItem[0].MakeIndex, g_SignedItem[1].MakeIndex, TDButton(Sender).Tag);
      end else begin
        DMessageDlg ('鉴定的装备与卷轴不匹配！', [mbOK]);
        Exit;
      end;
    end;
    2,12,22,32,42,52: begin
      if ((g_SignedItem[1].S.StdMode = 17) and (g_SignedItem[1].S.Shape = 240)) or ((g_SignedItem[1].S.StdMode = 44) and (g_SignedItem[1].S.Shape = 250)) then begin
        DBOrdSigned.Enabled := False;
        DBHighSigned.Enabled := False;
        m_boSignedLock := True;
        FrmMain.SendSginedItem(g_SignedItem[0].MakeIndex, g_SignedItem[1].MakeIndex, TDButton(Sender).Tag);
      end else begin
        DMessageDlg ('鉴定的装备与卷轴不匹配！', [mbOK]);
        Exit;
      end;
    end;
    3,13,23,33,43,53: begin
      if ((g_SignedItem[1].S.StdMode = 17) and (g_SignedItem[1].S.Shape = 241)) or ((g_SignedItem[1].S.StdMode = 44) or (g_SignedItem[1].S.Shape = 251)) then begin
        DBOrdSigned.Enabled := False;
        DBHighSigned.Enabled := False;
        m_boSignedLock := True;
        FrmMain.SendSginedItem(g_SignedItem[0].MakeIndex, g_SignedItem[1].MakeIndex, TDButton(Sender).Tag);
      end else begin
        DMessageDlg ('鉴定的装备与卷轴不匹配！', [mbOK]);
        Exit;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBSignedBelt1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    g_MouseItem := g_SignedItem[Tag];
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DWSignedItemsMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  DScreen.ClearHint;
end;

procedure TFrmDlg.DBSignedChangeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if not TDButton(Sender).Enabled then Exit;
  if m_boSignedLock then Exit;
  if (g_SignedItem[0].S.StdMode = 5) and (g_SignedItem[0].S.Need = 32767) then begin   //见习
    DMessageDlg ('无法更换这个物品！', [mbOK]);
    AddItemBag(g_SignedItem[0]);
    g_SignedItem[0].S.Name := '';
    DBSignedChange.Enabled := False;
    Exit;
  end;
  if not (g_SignedItem[0].btAppraisalLevel in [2..4,12..14,22..24,32..34,42..44,52..54]) then begin
    DMessageDlg ('你的宝物没有鉴定过，无需更换！', [mbOK]);
    AddItemBag(g_SignedItem[0]);
    g_SignedItem[0].S.Name := '';
    DBSignedChange.Enabled := False;
    Exit;
  end;
  if g_SignedItem[1].S.Name = '' then begin
    DMessageDlg ('缺少幸运符，请从商铺中购买！', [mbOK]);
    AddItemBag(g_SignedItem[1]);
    g_SignedItem[1].S.Name := '';
    Exit;
  end;
  DBSignedChange.Enabled := False;
  m_boSignedLock := True;
  FrmMain.SendChangeSginedItem(g_SignedItem[0].MakeIndex, g_SignedItem[1].MakeIndex);
{$IFEND}
end;

procedure TFrmDlg.DscStartDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  d := nil;
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if MouseMoveing then d := WLib.Images[FaceIndex]
      else if Downed then d := WLib.Images[FaceIndex + 1]
      else d := g_qingqingImages.Images[20];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
    end;
    if not Enabled then begin
      if d <> nil then begin
        if g_boReSelConnect then begin
        
          g_ImgMixSurface.SetSize(d.Width, d.Height);
          g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
          DrawEffect(0, 0, g_ImgMixSurface, d, ceGrayScale);
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);

          dsurface.FillRectAlpha(g_ReSelClientRect, clBlack, 90);
          if GetTickCount - g_dwReSelConnectTick > 100 then begin
            g_dwReSelConnectTick := GetTickCount;
            g_ReSelClientRect.Top := g_ReSelClientRect.Top + 1;
            if g_ReSelClientRect.Top > g_ReSelClientRect.Bottom then begin
              g_boReSelConnect := False;
              Enabled := True;
            end;
          end;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBMakeSignedBelt3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
        d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      if g_MakeSignedBelt3.S.Name <> '' then begin
        idx := g_MakeSignedBelt3.S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.S.StdMode = 44) and
                  (g_MovingItem.Item.S.Shape = 254) then begin
        g_ImgMixSurface.SetSize(35, 33);
        g_ImgMixSurface.FastFill($00003255);
        if d<>nil then begin
          DrawBlendEx (dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
        end;
      end;
      case m_btMakeSignedSuccess of
        1: begin
          if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
            m_dwMakeSignedTimeTick := GetTickCount();
            Inc(m_btMakeSignedImginsex);
          end;
          if m_btMakeSignedImginsex > 21 then begin
            m_btMakeSignedImginsex := 0;
            m_btMakeSignedSuccess := 0; //停止动画
            m_boMakeSignedLock := False;
          end;
          d := g_WUI1Images.Images[1000+m_btMakeSignedImginsex];
          if d <> nil then
            DrawBlend(dsurface, DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d, 255);
        end;
        2: begin
          if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
            m_dwMakeSignedTimeTick := GetTickCount();
            Inc(m_btMakeSignedImginsex);
          end;
          if m_btMakeSignedImginsex > 21 then begin
            m_btMakeSignedImginsex := 0;
            m_btMakeSignedSuccess := 0; //停止动画
            m_boMakeSignedLock := False;
          end;
          d := g_WUI1Images.Images[1030+m_btMakeSignedImginsex];
          if d <> nil then
            DrawBlend(dsurface, DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d, 255);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt3Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientItem;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  with Sender as TDButton do begin
    if not g_boItemMoving then begin
      if g_MakeSignedBelt3.S.Name <> '' then begin
         ItemClickSound (g_MakeSignedBelt3.S);
         if g_MovingItem.Item.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_MakeSignedBelt3;
         g_MakeSignedBelt3.S.Name := '';
      end;
    end else begin
      if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) and (g_MovingItem.Item.S.StdMode = 44) and
         (g_MovingItem.Item.S.Shape = 254) then begin
        ItemClickSound (g_MovingItem.Item.S);
        if g_MakeSignedBelt3.S.Name <> '' then begin
          temp := g_MakeSignedBelt3;
          g_MakeSignedBelt3 := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_MakeSignedBelt3 := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedLeve1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  str := '';
  if not FrmMain.GetMagicByID(100) then str := str + '缺少神秘解读技能\';
  if g_btEnergyValue = 0 then str := str + '缺少精力值\';
  if g_MakeSignedBelt3.S.Name = '' then str := str + '缺少羊皮卷\';
  if str <> '' then begin
    DMessageDlg (str, [mbOK]);
    Exit;
  end;
  m_boMakeSignedLock := True;
  frmMain.SendMakeScroll(g_MakeSignedBelt3.MakeIndex, TDButton(Sender).Tag);
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;

      if g_MakeSignedBelt[Tag].S.Name <> '' then begin
        idx := g_MakeSignedBelt[Tag].S.Looks;
        if idx >= 0 then begin
            d := frmMain.GetBagItemImg(idx);
            if d <> nil then
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                           SurfaceY(GTop + (GHeight - d.Height) div 2),
                           d.ClientRect, d, TRUE);
        end;
      end else if Sender = DBMakeSignedBelt1 then begin  //检测神秘属性装备
        with g_MovingItem.Item do
        if (s.Name <> '') and (g_MovingItem.Index >= 0) and ((btUnKnowValue[6] = 255) or
           (btUnKnowValue[7] = 255) or (btUnKnowValue[8] = 255) or (btUnKnowValue[9] = 255)) then begin
          g_ImgMixSurface.SetSize(35, 33);
          g_ImgMixSurface.FastFill($00003255);
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
          end;
        end;
      end else begin //检测是否为神秘卷轴
        with g_MovingItem.Item do
        if (s.Name <> '') and (g_MovingItem.Index >= 0) and (s.StdMode = 44) and ((s.Shape = 255) and (s.NeedIdentify > 0)) or (s.Shape = 252) then begin
          g_ImgMixSurface.SetSize(35, 33);
          g_ImgMixSurface.FastFill($00003255);
          if d<>nil then begin
            DrawBlendEx (dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
          end;
        end;
      end;
      if Sender = DBMakeSignedBelt1 then begin
        case m_btMakeSignedSuccess of
          3: begin
            if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
              m_dwMakeSignedTimeTick := GetTickCount();
              Inc(m_btMakeSignedImginsex);
            end;
            if m_btMakeSignedImginsex > 21 then begin
              m_btMakeSignedImginsex := 0;
              m_btMakeSignedSuccess := 0; //停止动画
              m_boMakeSignedLock := False;
            end;
            d := g_WUI1Images.Images[1000+m_btMakeSignedImginsex];
            if d <> nil then
              DrawBlend(dsurface, DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d, 255);
          end;
          4: begin
            if GetTickCount - m_dwMakeSignedTimeTick > 120 then begin
              m_dwMakeSignedTimeTick := GetTickCount();
              Inc(m_btMakeSignedImginsex);
            end;
            if m_btMakeSignedImginsex > 21 then begin
              m_btMakeSignedImginsex := 0;
              m_btMakeSignedSuccess := 0; //停止动画
              m_boMakeSignedLock := False;
            end;
            d := g_WUI1Images.Images[1030+m_btMakeSignedImginsex];
            if d <> nil then
              DrawBlend(dsurface, DWMakeSigned.SurfaceX(DWMakeSigned.GLeft), DWMakeSigned.SurfaceY(DWMakeSigned.GTop), d, 255);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedCloseClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  if g_MakeSignedBelt3.S.Name <> '' then begin
    AddItemBag(g_MakeSignedBelt3);
    g_MakeSignedBelt3.S.Name := '';
  end;
  for I:=Low(g_MakeSignedBelt) to High(g_MakeSignedBelt) do begin
    if g_MakeSignedBelt[I].S.Name <> '' then begin
      AddItemBag(g_MakeSignedBelt[I]);
      g_MakeSignedBelt[I].S.Name := '';
    end;
  end;
  DWMakeSigned.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  temp: TClientItem;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
    m_btSignedHint := 0;
  with Sender as TDButton do begin
    if not g_boItemMoving then begin
      if g_MakeSignedBelt[Tag].S.Name <> '' then begin
         ItemClickSound (g_MakeSignedBelt[Tag].S);
         if g_MovingItem.Item.S.Name <> '' then Exit;
         g_boItemMoving := TRUE;
         g_MovingItem.Item := g_MakeSignedBelt[Tag];
         g_MakeSignedBelt[Tag].S.Name := '';
      end;
    end else begin
      if (g_MovingItem.Item.S.Name <> '') and (g_MovingItem.Index >= 0) then begin
        if Sender = DBMakeSignedBelt1 then begin
          with g_MovingItem.Item do
          if (btUnKnowValue[6] <> 255) and (btUnKnowValue[7] <> 255) and
             (btUnKnowValue[8] <> 255) and (btUnKnowValue[9] <> 255) then Exit;
        end else begin
          with g_MovingItem.Item do
          if (s.StdMode <> 44) or (((s.Shape <> 255) or (s.NeedIdentify = 0)) and (s.Shape <> 252)) then Exit;
        end;
        ItemClickSound (g_MovingItem.Item.S);
        if g_MakeSignedBelt[Tag].S.Name <> '' then begin
          temp := g_MakeSignedBelt[Tag];
          g_MakeSignedBelt[Tag] := g_MovingItem.Item;
          g_MovingItem.Item := temp
        end else begin
          g_MakeSignedBelt[Tag] := g_MovingItem.Item;
          g_MovingItem.Item.S.name := '';
          g_boItemMoving := FALSE;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt3MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    g_MouseItem := g_MakeSignedBelt3;
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedBelt1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    g_MouseItem := g_MakeSignedBelt[Tag];
    ShowMouseItemInfo(SurfaceX(GLeft) + GWidth,
                      SurfaceY(GTop) + GHeight, '', 1, False);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedReadStartClick(Sender: TObject; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  str: string;
  n1: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if m_boMakeSignedLock then Exit;
  str := '';
  n1 := 0;
  if g_MakeSignedBelt[1].S.Name = '' then str := '缺少神秘卷轴\';
  if g_MakeSignedBelt[0].S.Name = '' then str := str + '缺少待解读物品\';
  if (g_MakeSignedBelt[0].S.Name <> '') and (g_MakeSignedBelt[1].S.Name <> '') then begin
    if (g_MakeSignedBelt[0].btUnKnowValueCount > 0) and (g_MakeSignedBelt[0].btUnKnowValueCount < 5) then begin//判断是否存在神秘属性
      if g_MakeSignedBelt[0].btUnKnowValue[6]= 255 then n1:= 1
      else if g_MakeSignedBelt[0].btUnKnowValue[7]= 255 then n1:= 2
      else if g_MakeSignedBelt[0].btUnKnowValue[8]= 255 then n1:= 3
      else if g_MakeSignedBelt[0].btUnKnowValue[9]= 255 then n1:= 4;
    end;
    if not n1 in [1..4] then begin
      str := str + '无需解读物品\';
    end else begin
      if not ((g_MakeSignedBelt[1].S.StdMode = 44) and (g_MakeSignedBelt[1].S.Shape = 252)) then begin
        if (n1 > g_MakeSignedBelt[1].S.NeedIdentify) then begin
          str := str + Format('神秘卷轴等级无法解读，需等级%d的神秘卷轴\', [n1]);
        end;
      end;
    end;
  end;

  if str <> '' then begin
    DMessageDlg (str, [mbOK]);
    Exit;
  end;
  m_boMakeSignedLock := True;
  frmMain.SendMakeReadScroll(g_MakeSignedBelt[0].MakeIndex, g_MakeSignedBelt[1].MakeIndex);
{$IFEND}
end;

procedure TFrmDlg.DBMakeSignedExp1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  Rc: TRect;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if Sender = DBMakeSignedExp1 then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
           Rc := d.ClientRect;
           Rc.Right := Round((Rc.Right-Rc.Left) / 100 * g_btEnergyValue);
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end else begin
        d := WLib.Images[FaceIndex];
        if d <> nil then begin
           Rc := d.ClientRect;
           Rc.Right := Round((Rc.Right-Rc.Left) / 100 * g_btLuckyValue);
           dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, TRUE);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltDblClick(Sender: TObject);
begin
{$IF M2Version <> 2}
  UseLingMeiItem();
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  d := nil;
  with Sender as TDButton do begin
    if g_LingMeiBelt.S.Name <> '' then begin
      d := frmMain.GetBagItemImg(g_LingMeiBelt.S.Looks);
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft+(GWidth-d.Width) div 2), SurfaceY(GTop+(GHeight-d.Height) div 2), d.ClientRect, d, TRUE);
    end else begin
      if (g_MovingItem.Item.S.Name <> '') then begin
        g_ImgMixSurface.SetSize(35, 33);
        g_ImgMixSurface.FastFill($00003255);
        DrawBlendEx (dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, g_ImgMixSurface, 0, 0, g_ImgMixSurface.Width, g_ImgMixSurface.Height, 150);
      end;
    end;
    if m_boLingMeiEffect then begin
      if GetTickCount - m_dwLingMeiTimeTick > 120 then begin
        m_dwLingMeiTimeTick := GetTickCount();
        Inc(m_btLingMeiImgFrame);
      end;
      if m_btLingMeiImgFrame > 5 then begin
        m_btLingMeiImgFrame := 0;
        m_boLingMeiEffect := False; //停止动画
      end;
      d := g_wmain2Images.Images[260+m_btLingMeiImgFrame];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)-20, SurfaceY(GTop)-20, d, 255);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  iname, iname1, d1, d2, d3, d4, d5, d6, d7, hcolor: string;
  useable: Boolean;
  nY: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  if m_boLingMeiEffect then Exit;
  if g_LingMeiBelt.S.Name <> '' then begin
    g_MouseItem := g_LingMeiBelt;
    GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
    g_MouseItem.S.Name := '';
    nY := 0;
    if iname <> '' then nY := nY+25;
    if d1 <> '' then nY := nY+25;
    if d2 <> '' then nY := nY+25;
    if d3 <> '' then nY := nY+25;
    if d4 <> '' then nY := nY+25;
    with Sender as TDButton do begin
      DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth,
                              SurfaceY(GTop)-nY-23,
                              Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\<使用灵媒快捷键为/c=Yellow><Ctrl+X/c=Red>',
                              [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
    end;
  end else begin
    with Sender as TDButton do begin
      DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth,
                              SurfaceY(GTop)+6,'<可以放入灵媒，/c=Yellow>\<使用灵媒快捷键为/c=Yellow><Ctrl+X/c=Red>', False);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingMeiBeltClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_boHeroItemMoving then Exit;
  if m_boLingMeiEffect then Exit;
  if g_boItemMoving then begin
    if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
    if ((g_MovingItem.Item.S.StdMode = 44) and (g_MovingItem.Item.S.Shape = 253)) or CheckItemSpiritMedia(g_MovingItem.Item) then begin
      if g_MovingItem.Index >= 0 then begin
        ItemClickSound (g_MovingItem.Item.S);
        g_WaitingUseItem := g_MovingItem;
        g_WaitingUseItem.Index := -255;
        FrmMain.SendTakeOnLingMei (g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
        g_MovingItem.Item.S.Name := '';
        g_boItemMoving := FALSE;
      end else begin
        if g_MovingItem.Index = -255 then begin
          ItemClickSound (g_MovingItem.Item.S);
          g_LingMeiBelt := g_MovingItem.Item;
          g_MovingItem.Item.S.Name := '';
          g_boItemMoving := FALSE;
         end;
      end;
    end else begin
      DMessageDlg ('必须放入灵媒才有效！', [mbOK]);
    end;
  end else begin
    if (g_MovingItem.Item.S.Name <> '') or (g_WaitingUseItem.Item.S.Name <> '') then Exit;
    if g_LingMeiBelt.S.Name <> '' then begin
      ItemClickSound (g_LingMeiBelt.S);
      g_MovingItem.Index := -255;
      g_MovingItem.Item := g_LingMeiBelt;
      g_LingMeiBelt.S.Name := '';
      g_boItemMoving := TRUE;
    end;
  end;
{$IFEND}
end;
{$IF M2Version <> 2}
procedure TFrmDlg.UseLingMeiItem();
begin
  if not m_boLingMeiEffect then m_boLingMeiEffect := True;
  if g_LingMeiBelt.S.Name = '' then begin
    DScreen.AddChatBoardString('[请将灵媒装备在探索位]', clWhite, clBlue);
    Exit;
  end;
  if g_LingMeiBelt.Aura = 0 then begin
    DMessageDlg ('灵媒的灵气值已经不足，请补充灵气后再使用！', [mbOK]);
    Exit;
  end;
  FrmMain.SendUseUserLingMei(g_LingMeiBelt.MakeIndex, g_LingMeiBelt.S.Name);
end;
{$IFEND}
{$IF M2Version = 1}
procedure TFrmDlg.ShowQJPractice(boIsHero: Boolean);
var
  I: Integer;
  function GetMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_MySelf <> nil then begin
      for I:=0 to g_MagicList.Count - 1 do begin
        pm := PTClientMagic(g_MagicList[I]);
        if pm <> nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
  function GetHeroMagicLevel(): Byte;
  var
    pm: PTClientMagic;
    I: Integer;
  begin
    Result := High(Byte);
    if g_HeroSelf <> nil then begin
      for I:=0 to g_HeroMagicList.Count - 1 do begin
        pm := PTClientMagic(g_HeroMagicList[I]);
        if pm <>nil then begin
          if pm.Def.wMagicId = 95 then begin
            Result := pm.Level;
            Break;
          end;
        end;
      end;
    end;
  end;
begin
  m_boQJPracticeHero := boIsHero;
  FillChar(g_QJPracticeItems, SizeOf(TClientItem), #0);
  if m_boQJPracticeHero then begin
    m_sQJPracticeObjectName := g_HeroSelf.m_sUserName+'（英雄）';
    if (GetHeroMagicLevel < 64) or (g_boQJHeroDZXY99 and (GetHeroMagicLevel < 99)) then begin
      for I:=0 to g_HeroBagCount-1 do begin
        if (g_HeroItemArr[I].S.Name <> '') and (g_HeroItemArr[I].S.StdMode = 17) and
          (g_HeroItemArr[I].S.Shape = 238) then begin
          g_QJPracticeItems := g_HeroItemArr[I];
          g_HeroItemArr[I].S.Name := '';
          Break;
        end;
      end;
    end else if (GetHeroMagicLevel = 64) and not g_boQJHeroDZXY99 then begin
      for I:=0 to g_HeroBagCount-1 do begin
        if (g_HeroItemArr[I].S.Name <> '') and (g_HeroItemArr[I].S.StdMode = 44) and
          (g_HeroItemArr[I].S.Shape = 248) then begin
          g_QJPracticeItems := g_HeroItemArr[I];
          g_HeroItemArr[I].S.Name := '';
          Break;
        end;
      end;
    end;
  end else begin
    m_sQJPracticeObjectName := g_MySelf.m_sUserName;
    if (GetMagicLevel < 64) or (g_boQJDZXY99 and (GetMagicLevel < 99)) then begin
      for I:=6 to MAXBAGITEMCL-1 do begin
        if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 17) and
          (g_ItemArr[I].Item.S.Shape = 238) then begin
          g_QJPracticeItems := g_ItemArr[I].Item;
          g_ItemArr[I].Item.S.Name := '';
          Break;
        end;
      end;
    end else if (GetMagicLevel = 64) and not g_boQJHeroDZXY99 then begin
      for I:=6 to MAXBAGITEMCL-1 do begin
        if (g_ItemArr[I].Item.S.Name <> '') and (g_ItemArr[I].Item.S.StdMode = 44) and
          (g_ItemArr[I].Item.S.Shape = 248) then begin
          g_QJPracticeItems := g_ItemArr[I].Item;
          g_ItemArr[I].Item.S.Name := '';
          Break;
        end;
      end;
    end;
  end;
  DWQJPractice.Visible := True;
end;
{$IFEND}

procedure TFrmDlg.DBTitleManDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;
{$IF M2Version <> 2}
function TFrmDlg.GetTitlePageIdx(btMaxPage: Byte): Byte;
begin
  Result := 0;
  if g_ClientHumTitles.nUseTitleIndex > 0 then begin
    if m_btTitlePage > 0 then begin
      if g_ClientHumTitles.nUseTitleIndex > btMaxPage then begin
        Result := g_ClientHumTitles.nUseTitleIndex - btMaxPage;
      end;
    end else begin
      Result := g_ClientHumTitles.nUseTitleIndex;
    end;
  end;
end;

function TFrmDlg.GetUserTitlePageIdx(): Byte;
begin
  Result := 0;
  if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
    if m_btUserTitlePage > 0 then begin
      if UserState1.wHumTitles.nUseTitleIndex > 4 then begin
        Result := UserState1.wHumTitles.nUseTitleIndex - 4;
      end;
    end else begin
      Result := UserState1.wHumTitles.nUseTitleIndex;
    end;
  end;
end;

procedure TFrmDlg.NGUpLevelState(boIsHero: Boolean);
var
	I, idx: Integer;
  pm: PTClientMagic;
  boIsNG: Boolean;
begin
	if boIsHero then begin
  	for I:=0 to 6-1 do begin
     	idx := _Max(I + HeroInternalForceMagicPage * 6, 0);
    	if (idx >= 0) and (idx < g_HeroInternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwHeroInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLHeroNGUpLevel1.Visible := True;
              DLHeroNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLHeroNGUpLevel2.Visible := True;
              DLHeroNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLHeroNGUpLevel3.Visible := True;
              DLHeroNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLHeroNGUpLevel4.Visible := True;
              DLHeroNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLHeroNGUpLevel5.Visible := True;
              DLHeroNGUpLevel5.Enabled := boIsNG;
            end;
            5: begin
              DLHeroNGUpLevel6.Visible := True;
              DLHeroNGUpLevel6.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLHeroNGUpLevel1.Visible := False;
          1: DLHeroNGUpLevel2.Visible := False;
          2: DLHeroNGUpLevel3.Visible := False;
          3: DLHeroNGUpLevel4.Visible := False;
          4: DLHeroNGUpLevel5.Visible := False;
          5: DLHeroNGUpLevel6.Visible := False;
        end;
      end;
    end;   
  end else begin
  	for I:=0 to 6-1 do begin
     	idx := _Max(I + InternalForceMagicPage * 6, 0);
    	if (idx >= 0) and (idx < g_InternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_InternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLNGUpLevel1.Visible := True;
              DLNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLNGUpLevel2.Visible := True;
              DLNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLNGUpLevel3.Visible := True;
              DLNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLNGUpLevel4.Visible := True;
              DLNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLNGUpLevel5.Visible := True;
              DLNGUpLevel5.Enabled := boIsNG;
            end;
            5: begin
              DLNGUpLevel6.Visible := True;
              DLNGUpLevel6.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLNGUpLevel1.Visible := False;
          1: DLNGUpLevel2.Visible := False;
          2: DLNGUpLevel3.Visible := False;
          3: DLNGUpLevel4.Visible := False;
          4: DLNGUpLevel5.Visible := False;
          5: DLNGUpLevel6.Visible := False;
        end;
      end;
    end;
  end;
end;

procedure TFrmDlg.NewNGUpLevelState(boIsHero: Boolean);
var
	I, idx: Integer;
  pm: PTClientMagic;
  boIsNG: Boolean;
begin
	if boIsHero then begin
  	for I:=0 to 5-1 do begin
     	idx := _Max(I + HeroInternalForceMagicPage * 5, 0);
    	if (idx >= 0) and (idx < g_HeroInternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwHeroInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLNewHeroNGUpLevel1.Visible := True;
              DLNewHeroNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLNewHeroNGUpLevel2.Visible := True;
              DLNewHeroNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLNewHeroNGUpLevel3.Visible := True;
              DLNewHeroNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLNewHeroNGUpLevel4.Visible := True;
              DLNewHeroNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLNewHeroNGUpLevel5.Visible := True;
              DLNewHeroNGUpLevel5.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLNewHeroNGUpLevel1.Visible := False;
          1: DLNewHeroNGUpLevel2.Visible := False;
          2: DLNewHeroNGUpLevel3.Visible := False;
          3: DLNewHeroNGUpLevel4.Visible := False;
          4: DLNewHeroNGUpLevel5.Visible := False;
        end;
      end;
    end;   
  end else begin
  	for I:=0 to 5-1 do begin
     	idx := _Max(I + InternalForceMagicPage * 5, 0);
    	if (idx >= 0) and (idx < g_InternalForceMagicList.Count) then begin
      	pm := PTClientMagic (g_InternalForceMagicList[idx]);
        boIsNG := (boISAngerMagic(pm.Def.wMagicId)) and
        					(pm.Level >= 3) and (g_dwInternalForceLevel >= pm.Def.wPower) and (pm.Def.wPower > 0); //怒之
          case I of
            0: begin
              DLNewNGUpLevel1.Visible := True;
              DLNewNGUpLevel1.Enabled := boIsNG;
            end;
            1: begin
              DLNewNGUpLevel2.Visible := True;
              DLNewNGUpLevel2.Enabled := boIsNG;
            end;
            2: begin
              DLNewNGUpLevel3.Visible := True;
              DLNewNGUpLevel3.Enabled := boIsNG;
            end;
            3: begin
              DLNewNGUpLevel4.Visible := True;
              DLNewNGUpLevel4.Enabled := boIsNG;
            end;
            4: begin
              DLNewNGUpLevel5.Visible := True;
              DLNewNGUpLevel5.Enabled := boIsNG;
            end;
          end;
      end else begin
      	case I of
        	0: DLNewNGUpLevel1.Visible := False;
          1: DLNewNGUpLevel2.Visible := False;
          2: DLNewNGUpLevel3.Visible := False;
          3: DLNewNGUpLevel4.Visible := False;
          4: DLNewNGUpLevel5.Visible := False;
        end;
      end;
    end;
  end;
end;
{$IFEND}

procedure TFrmDlg.DBTitle1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TDButton do begin
    if (GetTitlePageIdx(4)-1 = Tag) and (GetTitlePageIdx(4) <> 0) then Exit;
    idx := _Max(Tag + m_btTitlePage * 4, 0);
    if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('你确定要将'+g_ClientHumTitles.ClientHumTitles[idx].sTitleName+'设置为当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[idx].MakeIndex, 1);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBTitleManClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  if g_ClientHumTitles.nUseTitleIndex > 0 then begin
    if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('是否取消当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].MakeIndex, 0);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(g_ClientHumTitles.ClientHumTitles) to High(g_ClientHumTitles.ClientHumTitles) do begin
      if g_ClientHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBPrevTitle then begin
    if m_btTitlePage > 0 then Dec (m_btTitlePage);
  end else begin
    if m_btTitlePage < (GetTitleCount+3) div 4 -1 then
       Inc (m_btTitlePage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBTitle1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      idx := _Max(Tag + m_btTitlePage * 4, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if g_ClientHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetTitlePageIdx(4)-1 = Tag) and (GetTitlePageIdx(4) <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBUserTitle1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface; 
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      idx := _Max(Tag + m_btUserTitlePage * 4, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        if UserState1.wHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if UserState1.wHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetUserTitlePageIdx-1 = Tag) and (GetUserTitlePageIdx <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;


procedure TFrmDlg.DBUserTitleManDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+3];
      if d <> nil then begin
         dsurface.Draw (SurfaceX(GLeft)-2, SurfaceY(GTop)-2, d.ClientRect, d, TRUE);
      end;
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBUserPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(UserState1.wHumTitles.ClientHumTitles) to High(UserState1.wHumTitles.ClientHumTitles) do begin
      if UserState1.wHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBUserPrevTitle then begin
    if m_btUserTitlePage > 0 then Dec (m_btUserTitlePage);
  end else begin
    if m_btUserTitlePage < (GetTitleCount+3) div 4 -1 then
       Inc (m_btUserTitlePage);
  end;
  {$IFEND}
end;

{$IF M2Version <> 2}
function TFrmDlg.GetTitleInfo(TitleItem: TClientHumTitle; var List: TStringList; boNewState: Boolean): string;
var
  str1: string;
  sTime: string;
  sDesc: string;
  nTime: Integer;
begin
  with TitleItem do begin
    if (wDC > 0) and (not (AniCount in [5,10])) then str1 := '攻击上限+'+IntToStr(wDC) + '\';//2011030
    if wMC > 0 then str1 := str1 + '魔法上限+'+IntToStr(wMC) + '\';
    if wSC > 0 then str1 := str1 + '道术上限+'+IntToStr(wSC) + '\';
    if wHP > 0 then str1 := str1 + '生命上限+'+IntToStr(wHP) + '\';


    if nHours <> High(nHours) then begin
      nTime := nHours div 24;
      if nTime > 0 then begin
        sTime := '剩余时间：<'+IntToStr(nTime)+'/c=Yellow>天';
      end else begin
        sTime := '剩余时间：<'+IntToStr(nHours)+'/c=Yellow>小时';
      end;
    end;
    if boNewState then begin
      sDesc := '';
      List.Clear;
      List.Delimiter := '|';
      case TitleItem.Looks of
        1275: List.DelimitedText := '灌注玛法传奇力|量的水晶，可在|水晶特使处赠送|给女性玩家';
        else List.DelimitedText := GetNewStateTitleDesc(sTitleName);
      end;
    end else begin
      case TitleItem.Looks of
        1275: sDesc := '<灌注玛法传奇力量的水晶/c=Yellow>\<，可在水晶特使处赠送给/c=Yellow>\<女性玩家/c=Yellow>';
        else sDesc := '<'+GetTitleDesc(sTitleName)+'/c=Yellow>';
      end;
    end;
    if (wDura > 0) and (AniCount in [1,5]) then str1 := str1 + format('有效次数%d次', [wDura]);
    if sTitleName <> '' then
      Result := ForMat('<%s/c=Lime fontstyle=bold>\%s\%s\%s', [sTitleName, sDesc, str1, sTime]);
  end;
end;
{$IFEND}

procedure TFrmDlg.DBTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if Sender = DBTitleMan then begin
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then str := '\(单击图标取消当前称号)' else str := '';
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1], g_MouseTitleList, False)+str, False);
        end;
      end;
    end else begin
      if (GetTitlePageIdx(4)-1 = Tag) and (GetTitlePageIdx(4) <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btTitlePage * 4, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then str := '\(单击图标设为当前称号)' else str := ''; 
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(g_ClientHumTitles.ClientHumTitles[idx], g_MouseTitleList, False)+str, False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBUserTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if Sender = DBUserTitleMan then begin
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1], g_MouseTitleList, False), False);
        end;
      end;
    end else begin
      if (GetUserTitlePageIdx-1 = Tag) and (GetUserTitlePageIdx <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btUserTitlePage * 4, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[idx], g_MouseTitleList, False), False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWPFLingPaiDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWPFLingPai do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then begin
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        dsurface.TextOut(SurfaceX(GLeft)+50, SurfaceY(GTop)+123, clWhite, '・我任命的护花使者');
        dsurface.TextOut(SurfaceX(GLeft)+194, SurfaceY(GTop)+354, $005894B8, Format('%d/%d', [m_btPJLingPaiPage+1, g_TitleHumNameList.Count div 5 + 1]));
        dsurface.TextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+374, clYellow, '回收护花使者称号:');
        dsurface.TextOut(SurfaceX(GLeft)+224, SurfaceY(GTop)+374, clWhite, m_sSelPJLingPaiName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCloseInitialize(Sender: TObject);
begin
  {$IF M2Version <> 2}
  with Sender as TDButton do
  SetImgIndex(g_WMain2Images, 148);
  {$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiIcon1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if g_WUI1Images <> nil then begin
      idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
      if idx < g_TitleHumNameList.Count then begin
        pm := pTClientHumName (g_TitleHumNameList[idx]);
        if pm <> nil then begin
          if pm.boOnline then begin
            if MouseMoveing then d := g_WUI1Images.Images[1]
            else if Downed then d := g_WUI1Images.Images[2]
            else d := g_WUI1Images.Images[0];
          end else begin
            if MouseMoveing then d := g_WUI1Images.Images[7]
            else if Downed then d := g_WUI1Images.Images[8]
            else d := g_WUI1Images.Images[6];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if pm.boOnline then
          str := '在线'
        else str := '离线';
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, str, clYellow, False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWPFLingPaiMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWPFLingPai.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DLPFLingPaiPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DLPFLingPaiPrev then begin
    if m_btPJLingPaiPage > 0 then
       Dec (m_btPJLingPaiPage);
  end else begin
    if m_btPJLingPaiPage < (g_TitleHumNameList.Count+4) div 5 - 1 then
       Inc (m_btPJLingPaiPage);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiName1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if MouseMoveing then dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, pm.sChrName)
        else if Downed then dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, pm.sChrName)
        else dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clWhite, pm.sChrName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCall1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
      if Downed then dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '召唤')
      else dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '召唤');
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];  //字体下划线
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiMove1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  idx: Integer;
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
      if Downed then dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '传送')
      else dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '传送');
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];  //字体下划线
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiCall1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要召唤“'+pm.sChrName+'"到你身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(0, 0, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiMove1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要传送到“'+pm.sChrName+'"身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(0, 1, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBPFLingPaiName1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btPJLingPaiPage * 5, 0);
    if idx < g_TitleHumNameList.Count then begin
      pm := pTClientHumName (g_TitleHumNameList[idx]);
      if pm <> nil then begin
        if (pm.sChrName <> '') then begin
          m_sSelPJLingPaiName := pm.sChrName;
          DLabel12.Visible := True;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLabel12Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if mrOk = FrmDlg.DMessageDlg ('你确定回收“'+m_sSelPJLingPaiName+'”的称号吗？', [mbOk, mbCancel]) then begin
    frmMain.SendReFenghao(0, m_sSelPJLingPaiName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiTab1Click(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  with Sender as TDButton do
  ChangeZZLingPaiPage(Tag);
  {$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if Tag <> m_btZZLingPaiPage then begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex + 1];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 34 - FrmMain.Canvas.TextWidth(Caption) div 2, SurfaceY(GTop) + 5, clWhite, clBlack, Caption);
    end else begin
      if WLib <> nil then begin //20080701
       d := WLib.Images[FaceIndex];
       if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      end;
        dsurface.BoldTextOut (SurfaceX(GLeft) + 34 - FrmMain.Canvas.TextWidth(Caption) div 2, SurfaceY(GTop) + 5, clWhite, clBlack, Caption);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWZZLingPaiDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWZZLingPai do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
         dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
      case m_btZZLingPaiPage of
        0: begin
          d := WLib.Images[551];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+26, SurfaceY(GTop)+96, d.ClientRect, d, TRUE);
        end;
        2: begin
          dsurface.TextOut(SurfaceX(GLeft)+50, SurfaceY(GTop)+123, clWhite, '・我任命的主宰龙卫');
          dsurface.TextOut(SurfaceX(GLeft)+194, SurfaceY(GTop)+354, $005894B8, Format('%d/%d', [m_btZZHWLingPaiPage+1, g_HuWeiJunList.Count div 5 + 1]));
          dsurface.TextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+374, clYellow, '回收近卫军称号:');
          dsurface.TextOut(SurfaceX(GLeft)+224, SurfaceY(GTop)+374, clWhite, m_sSelHWLingPaiName);
        end;
      end;
    end;
  end;
{$IFEND}
end;
{$IF M2Version <> 2}
procedure TFrmDlg.ChangeZZLingPaiPage(btPage: Byte);
begin
  if m_btZZLingPaiPage <> btPage then begin
    m_btZZLingPaiPage := btPage;
    DBZZLingPaiMapName1.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName2.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName3.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName4.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName5.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName6.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName7.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName8.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName9.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName10.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName11.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName12.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName13.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName14.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName15.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName16.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName17.Visible := m_btZZLingPaiPage = 0;
    DBZZLingPaiMapName18.Visible := m_btZZLingPaiPage = 0;
    DMZZLingPai.Visible := m_btZZLingPaiPage = 1;
    DBZZLingPaiIcon1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiIcon5.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiName5.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiCall5.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove1.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove2.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove3.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove4.Visible := m_btZZLingPaiPage = 2;
    DBZZLingPaiMove5.Visible := m_btZZLingPaiPage = 2;
    DLZZLingPaiPrev.Visible := m_btZZLingPaiPage = 2;
    DLZZLingPaiDown.Visible := m_btZZLingPaiPage = 2;
    if m_btZZLingPaiPage = 2 then
      DLabel15.Visible := m_sSelHWLingPaiName <> ''
    else DLabel15.Visible := False;
  end;
end;
{$IFEND}
procedure TFrmDlg.DBZZLingPaiTab1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do
    SetImgIndex(g_WUI1Images, 555);
{$IFEND}
end;

procedure TFrmDlg.DMZZLingPaiDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  s18: string;
begin
  with DMZZLingPai do begin//防止除0错误By TasNat at: 2012-10-19 09:24:16
    ElemCount:= (GHeight - 2) div _MAX(1, LinesHeight);  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for i:= 0 to ElemCount - 1 do begin
      s18 := Lines.Strings[i+TopIndex];
      if s18 <> '' then begin
        if s18[1] = ' ' then
          dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clSilver, clBlack, s18)
        else
          dsurface.BoldTextOut (SurfaceX(GLeft), SurfaceY(GTop) + i*LinesHeight, clWhite, clBlack, s18);
      end;
    end;
  end;
end;

procedure TFrmDlg.DMZZLingPaiInitialize(Sender: TObject);
begin
  DMZZLingPai.DScroll := DMZZLingPaiScrollBar;
  DMZZLingPai.DScroll.GTop := -19;
  DMZZLingPai.DScroll.GLeft := 322;
  DMZZLingPai.DScroll.GHeight := 304;
  DMZZLingPai.DScroll.GWidth := 16;
  DMZZLingPai.DScroll.Bar.GTop := 17;
  DMZZLingPai.DScroll.BDown.GTop := 287;
  DMZZLingPai.DScroll.BUp.GTop := 2;
  if FileExists(g_ParamDir+'\Data\explain4.dat') then begin
    try
      DMZZLingPai.Lines.LoadFromFile(g_ParamDir+'\Data\explain4.dat');
    except
    end;
  end;
end;

procedure TFrmDlg.DMZZLingPaiScrollBarInitialize(Sender: TObject);
begin
  DMZZLingPaiScrollBar.Bar.SetImgIndex(g_WMain2Images, 581);
  DMZZLingPaiScrollBar.BUp.SetImgIndex(g_WMain2Images, 292);
  DMZZLingPaiScrollBar.BDown.SetImgIndex(g_WMain2Images, 294);
end;

procedure TFrmDlg.DBZZLingPaiIcon1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
  str: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if pm.boOnline then
          str := '在线'
        else str := '离线';
        DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, str, clYellow, False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiIcon1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if g_WUI1Images <> nil then begin
      idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
      if idx < g_HuWeiJunList.Count then begin
        pm := pTClientHumName (g_HuWeiJunList[idx]);
        if pm <> nil then begin
          if pm.boOnline then begin
            if MouseMoveing then d := g_WUI1Images.Images[1]
            else if Downed then d := g_WUI1Images.Images[2]
            else d := g_WUI1Images.Images[0];
          end else begin
            if MouseMoveing then d := g_WUI1Images.Images[7]
            else if Downed then d := g_WUI1Images.Images[8]
            else d := g_WUI1Images.Images[6];
          end;
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiName1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if (pm.sChrName <> '') then begin
          m_sSelHWLingPaiName := pm.sChrName;
          DLabel15.Visible := True;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiName1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if MouseMoveing then dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, pm.sChrName)
        else if Downed then dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, pm.sChrName)
        else dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clWhite, pm.sChrName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiCall1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要召唤“'+pm.sChrName+'"到你身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(1, 0, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiCall1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
      if Downed then dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '召唤')
      else dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '召唤');
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];  //字体下划线
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiCloseClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version <> 2}
  msg := MakeDefaultMsg (aa(CM_CLOSEDOMINATETOKEN, frmMain.TempCertification), 0, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket (EncodeMessage (msg));
  DWZZLingPai.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMove1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
  pm: pTClientHumName;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      pm := pTClientHumName (g_HuWeiJunList[idx]);
      if pm <> nil then begin
        if pm.boOnline and (pm.sChrName <> '') then begin
          if mrOk = FrmDlg.DMessageDlg ('你确定要传送到“'+pm.sChrName+'"身边吗？', [mbOk, mbCancel]) then begin
            frmMain.SendCallFengHao(1, 1, pm.sChrName);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMove1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  idx: Integer;
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    idx := _Max(Tag + m_btZZHWLingPaiPage * 5, 0);
    if idx < g_HuWeiJunList.Count then begin
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style + [fsUnderline];  //字体下划线
      if Downed then dsurface.TextOut(SurfaceX(GLeft)+1, SurfaceY(GTop)+1, clRed, '传送')
      else dsurface.TextOut(SurfaceX(GLeft), SurfaceY(GTop), clYellow, '传送');
      frmMain.Canvas.Font.Style := frmMain.Canvas.Font.Style - [fsUnderline];  //字体下划线
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLabel15Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if mrOk = FrmDlg.DMessageDlg ('你确定回收“'+m_sSelHWLingPaiName+'”的称号吗？', [mbOk, mbCancel]) then begin
    frmMain.SendReFenghao(1, m_sSelHWLingPaiName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLZZLingPaiPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DLZZLingPaiPrev then begin
    if m_btZZHWLingPaiPage > 0 then
       Dec (m_btZZHWLingPaiPage);
  end else begin
    if m_btZZHWLingPaiPage < (g_HuWeiJunList.Count+4) div 5 - 1 then
       Inc (m_btZZHWLingPaiPage);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMapName1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if Caption <> '' then begin
        if Downed then begin
          d := WLib.Images[FaceIndex+1];
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + 30 - FrmMain.Canvas.TextWidth(Caption) div 2 + 1, SurfaceY(GTop) +6, $0048A4E8, clBlack, Caption);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + 30 - FrmMain.Canvas.TextWidth(Caption) div 2, SurfaceY(GTop)+ 5, $0048A4E8, clBlack, Caption);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMapName1Initialize(Sender: TObject);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do
    SetImgIndex(g_WUI1Images, 552);
{$IFEND}
end;

procedure TFrmDlg.DBZZLingPaiMapName1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if Caption <> '' then frmMain.SendSelDominatMap(Caption);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
const
	Lines = '<技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + InternalForceMagicPage * 6, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then
      	DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+10,
        			Format(Lines, [pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 5, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, True);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewHeroNGUpLevel1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version <> 2}
const
	Lines = '<技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+10,
        			Format(Lines, [pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + InternalForceMagicPage * 5, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLNewStateUserGuildNameClick(Sender: TObject; X, Y: Integer);
begin
  PlayScene.EdChat.Visible := TRUE;
  PlayScene.EdChat.Text := '/'+ UserState1.GuildName+' ';
  PlayScene.EdChat.SetFocus;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
end;

procedure TFrmDlg.DLNewStateUserNameClick(Sender: TObject; X, Y: Integer);
begin
  PlayScene.EdChat.Visible := TRUE;
  PlayScene.EdChat.Text := '/'+ UserState1.UserName+' ';
  PlayScene.EdChat.SetFocus;
  SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
  PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
end;

procedure TFrmDlg.DLNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + InternalForceMagicPage * 6, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLHeroNGUpLevel1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
  {$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	frmMain.SendNGUpLevel(pm.Def.wMagicId, True);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DLHeroNGUpLevel1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
const
	Lines = '<技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
var
	idx: Integer;
  pm: PTClientMagic;
{$IFEND}
begin
	{$IF M2Version <> 2}
	with Sender as TDLabel do begin
  	if not Enabled then Exit;
    idx := _Max(Tag + HeroInternalForceMagicPage * 6, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then
      	DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+10,
        			Format(Lines, [pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBPetLogCloseClick(Sender: TObject; X, Y: Integer);
begin
	DWPetLog.Visible := False;
  if g_PetDlg.sLogList <> nil then FreeAndNil(g_PetDlg.sLogList);
end;

procedure TFrmDlg.DWPetLogDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
	d: TDirectDrawSurface;
  I: Integer;
const
	sHapplyLine = '你的宠物的快乐度为:%d';
begin
	with DWPetLog do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    MainForm.Canvas.Font.Size := 14;
    dsurface.TextOut(SurfaceX(GLeft)+160, SurfaceY(GTop)+16, clWhite, '宠物放养');
    MainForm.Canvas.Font.Size := 9;
    if g_PetDlg.sLogList <> nil then
    if g_PetDlg.sLogList.Count > 0 then begin
    	for I:=0 to g_PetDlg.sLogList.Count-1 do begin
      	dsurface.TextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+50+I*17, clWhite, g_PetDlg.sLogList[I]);
      end;
    end;
    dsurface.BoldTextOut(SurfaceX(GLeft)+60, SurfaceY(GTop)+266, clRed, clBlack, Format(sHapplyLine, [g_PetDlg.nHapply]));;
  end;
end;

procedure TFrmDlg.DLPetLogMoveClick(Sender: TObject; X, Y: Integer);
begin
	frmMain.SendPetMove;
end;

procedure TFrmDlg.DLPetLogPagePrvClick(Sender: TObject; X, Y: Integer);
begin
	if Sender = DLPetLogPagePrv then
  	frmMain.SendPetLogPage(0)
  else frmMain.SendPetLogPage(1);
end;
procedure TFrmDlg.DWFactionDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
	d: TDirectDrawSurface;
  bx, by, I: Integer;
const
  AdminNum = '・掌门 (%d人)';
  MemberNum = '・师门弟子 (%d人)';
{$IFEND}
begin
{$IF M2Version <> 2}
	with DWFactionDlg do begin
  	with dsurface do begin
      if WLib <> nil then begin
        d := WLib.Images[FaceIndex];
        if d <> nil then
          Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      TextOut(SurfaceX(GLeft)+250-frmMain.Canvas.TextWidth(g_FactionDlg.sDivisionName) div 2, SurfaceY(GTop)+29, $8CC7EF, g_FactionDlg.sDivisionName);
      frmMain.Canvas.Font.Style := [fsBold];
      BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)+49, $8CC7EF, clBlack, g_FactionDlgHint);
      if m_btFactionPage = 0 then begin
        if not g_FactionDlg.boPublic then begin
          BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+70, clTeal, clBlack, '师门心法：'+g_FactionDlg.sHeartName);
          BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+85, clTeal, clBlack, '师父名称：'+g_FactionDlg.sMasterName);
          BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+70, clTeal, clBlack, '心法属性：'+g_FactionDlg.sHeartTpye);
          BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+85, clTeal, clBlack, '师门人数：'+g_FactionDlg.sMemberCount);
          BoldTextOut(SurfaceX(GLeft)+350, SurfaceY(GTop)+70, clTeal, clBlack, '师门人气：'+IntToStr(g_FactionDlg.nPopularity));
          BoldTextOut(SurfaceX(GLeft)+350, SurfaceY(GTop)+85, clTeal, clBlack, Format('最高传承心法：%d级', [g_FactionDlg.nHeartLeve]));
        end else begin //公共师门
          BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+70, clTeal, clBlack, '师门心法：'+g_FactionDlg.sHeartName);
          BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+85, clTeal, clBlack, Format('最高传承心法：%d级', [g_FactionDlg.nHeartLeve]));
          BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+70, clTeal, clBlack, '心法属性：'+g_FactionDlg.sHeartTpye);
          BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+85, clTeal, clBlack, '师门人数：'+g_FactionDlg.sMemberCount);
        end;
        frmMain.Canvas.Font.Style := [];
        BoldTextOut(SurfaceX(GLeft)+39, SurfaceY(GTop)+101, clSilver, clBlack, '_______________________________师门公告_______________________________');
        bx := SurfaceX(GLeft) + 39;
        by := SurfaceY(GTop) + 115;
        for I := 0 to g_FactionDlg.NoticeList.Count-1 do begin
          if I*14 > 150 then break;
          TextOut (bx, by + I*14, clSilver, g_FactionDlg.NoticeList[I]);
        end;
      end else begin
        frmMain.Canvas.Font.Style := [];
        BoldTextOut(SurfaceX(GLeft)+27, SurfaceY(GTop)+83, clWhite, clBlack, Format(AdminNum, [g_FactionMember.AdminNum]));
        BoldTextOut(SurfaceX(GLeft)+27, SurfaceY(GTop)+123, clWhite, clBlack, Format(MemberNum, [g_FactionMember.MemberNum]));
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWFactionAddDlgDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
	d: TDirectDrawSurface;
  I: Integer;
  FactionAddInfo: pTClientDivisionInfo;
{$IFEND}
begin
{$IF M2Version <> 2}
	with DWFactionAddDlg do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with dsurface do begin
    	frmMain.Canvas.Font.Style := [fsBold];
      TextOut(SurfaceX(GLeft)+24, SurfaceY(GTop)+20, $88C4E8, '师门');
      TextOut(SurfaceX(GLeft)+134, SurfaceY(GTop)+20, $88C4E8, '师父');
      TextOut(SurfaceX(GLeft)+204, SurfaceY(GTop)+20, $88C4E8, '师门人气值');
      frmMain.Canvas.Font.Style := [];
    end;
    for I:=0 to g_FactionAddList.Count-1 do begin
    	if I > 4 then Break;
    	FactionAddInfo := g_FactionAddList[I];
      if FactionAddInfo <> nil then begin
      	dsurface.BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+48+I*20, $8CC7EF, clBlack, FactionAddInfo.sDivisionName);
        dsurface.BoldTextOut(SurfaceX(GLeft)+130, SurfaceY(GTop)+48+I*20, $8CC7EF, clBlack, FactionAddInfo.sChrName);
        dsurface.BoldTextOut(SurfaceX(GLeft)+220, SurfaceY(GTop)+48+I*20, $8CC7EF, clBlack, IntToStr(FactionAddInfo.nPopularity));
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DEditFactionAddQueryDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
	Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
	with DEditFactionAddQuery do begin
  	dsurface.FastFillRect(ClientRect, clBlack);
  	if Moveed then
    	Color := $00387B9C
    else Color := $00638494;
  	if Text = '' then  dsurface.TextOut(SurfaceX(GLeft)+2, SurfaceY(GTop)+4, $00808080, '输入想要查询的宗师名');
		dsurface.FastFrameRect(ClientRect, Color);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionAddPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if Sender = DLFactionAddPrev then begin
      frmMain.SendFactionAddPageChanged(0);
    end else begin
      frmMain.SendFactionAddPageChanged(1);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionAddQueryClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
	if Trim(DEditFactionAddQuery.Text) <> '' then
    frmMain.SendFactionAddQueryListByName(Trim(DEditFactionAddQuery.Text));
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyAdd1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  FactionAddInfo: pTClientDivisionInfo;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDLabel do begin
    if Tag <= g_FactionAddList.Count then begin
      FactionAddInfo := g_FactionAddList[Tag];
      if FactionAddInfo <> nil then begin
        if FactionAddInfo.sDivisionName <> '' then
        frmMain.SendFactionAddApplyAdd(FactionAddInfo.sDivisionName);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBFactionAddDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
	DWFactionAddDlg.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBFactionDlgCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWFactionDlg.Visible := False;
  if g_FactionDlg.NoticeList <> nil then FreeAndNil(g_FactionDlg.NoticeList);
  FactionMemberListFree();
{$IFEND}
end;

procedure TFrmDlg.DBFactionDlgEditNoticeCloseClick(Sender: TObject; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DWFactionDlgEditNotice.Visible := FALSE;
  Memo.Visible := FALSE;
  DMsgDlg.DialogResult := mrCancel;
{$IFEND}
end;

procedure TFrmDlg.DBotFactionClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if DWFactionDlg.Visible then begin
  	DWFactionDlg.Visible := FALSE;
  end else if GetTickCount > g_dwQueryMsgTick then begin
    DWFactionApplyManage.Visible := False;
  	g_dwQueryMsgTick := GetTickCount + 3000;
  	FrmMain.SendFactionDlg;
  end;
{$IFEND}
end;

{$IF M2Version <> 2}
procedure TFrmDlg.ShowFactionDlg;
begin
  //DLFactionDlgExit.Visible := not g_FactionDlg.boIsAdmin;
  if g_FactionDlg.boPublic then
    DLFactionDlgExit.GLeft := DLFactionDlgKick.GLeft
  else DLFactionDlgExit.GLeft := 153;
  DLFactionDlgHome.Visible := not g_FactionDlg.boPublic;
  DLFactionDlgList.Visible := not g_FactionDlg.boPublic;

  DLFactionDlgEditNotice.Visible := g_FactionDlg.boIsAdmin;
  DLFactionDlgManageApply.Visible := g_FactionDlg.boIsAdmin;
  DLFactionDlgGetTitle.Visible := g_FactionDlg.boIsAdmin;
  DLFactionDlgKick.Visible := g_FactionDlg.boIsAdmin;
  FactionMemberListFree();
  g_FactionDlgHint := '师门公告';
  m_btFactionPage := 0;
  DWFactionDlg.Visible := TRUE;
end;

procedure TFrmDlg.DBFactionIconDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
	with Sender as TDButton do begin
    if WLib <> nil then begin
      if MouseMoveing then d := WLib.Images[FaceIndex+1]
      else if Downed then d := WLib.Images[FaceIndex+2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
  end;
end;

procedure TFrmDlg.DBFactionIconMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  with Sender as TDButton do begin
    if FaceIndex = 0 then
      DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, '在线', clYellow, False)
    else DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop)+GHeight, '离线', clYellow, False);
  end;
end;
procedure TFrmDlg.DLFactionNameClick(Sender: TObject; X, Y: Integer);
var
  ShowText: string;
  FactionMember: TFactionMember;
  I: Integer;
  sSex: string[2];
begin
  with Sender as TDLabel do begin
    for I:=0 to g_FactionMeberList.Count-1 do begin
      FactionMember := TFactionMember(g_FactionMeberList.Values[g_FactionMeberList.Keys[i]]);
      if FactionMember <> nil then begin
        FactionMember.m_Name.UpColor := clWhite;
        FactionMember.m_Name.HotColor := clWhite;
      end;
    end;
    FactionMember := TFactionMember(g_FactionMeberList.GetValues(IntToStr(Integer(Sender))));
    if FactionMember <> nil then begin
      with FactionMember.m_DivisionMember.DivisionMember do begin
        if btGender = 0 then
          sSex := '男'
        else sSex := '女';
        if FactionMember.m_DivisionMember.DivisionMember.boStatus then begin
          ShowText := Format('状态        在线\性别        %s\职业        %s\等级        %d\'+
                             '贡献人气值  %d', [sSex, GetJobName(btJob), nLevel, nContribution]);
        end else begin
          ShowText := Format('状态        离线\性别        %s\职业        %s\等级        %d\'+
                             '贡献人气值  %d\上次登陆    %s', [sSex, GetJobName(btJob), nLevel, nContribution, FormatDateTime('yyyy年mm月dd日', dLogonTime)]);
        end;
        DScreen.ShowHint(SurfaceX(GLeft)+20, SurfaceY(GTop), ShowText, clYellow, False);
        g_FactionMember.SelMemberName := FactionMember.m_DivisionMember.sChrName;
        UpColor := clYellow;
        HotColor := clYellow;
        PlayScene.EdChat.Visible := TRUE;
        PlayScene.EdChat.Text := '/'+ FactionMember.m_DivisionMember.sChrName+' ';
        PlayScene.EdChat.SetFocus;
        SetImeMode (PlayScene.EdChat.Handle, LocalLanguage);
        PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
      end;
    end;
  end;
end;

procedure TFrmDlg.FactionMemberListFree();
var
  I: Integer;
  FactionMember: TFactionMember;
begin
  if g_FactionMeberList <> nil then begin
    for I:=0 to g_FactionMeberList.Count-1 do begin
      FactionMember :=  TFactionMember(g_FactionMeberList.Values[g_FactionMeberList.Keys[i]]);
      if FactionMember <> nil then
        FactionMember.Free;
    end;
    FreeAndNil(g_FactionMeberList);
  end;
end;

procedure TFrmDlg.ShowFactionDlgEditNotice();
var
  d: TDirectDrawSurface;
  i: integer;
  data: string;
begin
  with DWFactionDlgEditNotice do begin
    GLeft := 146;
    GTop := 78;
    HideAllControls;
    DWFactionDlgEditNotice.ShowModal;

    Memo.Left := SurfaceX(GLeft+27);
    Memo.Top  := SurfaceY(GTop+56);
    Memo.Width := 424;
    Memo.Height := 202;
    if g_FactionDlg.NoticeList <> nil then
    Memo.Lines.Assign (g_FactionDlg.NoticeList);
    Memo.Visible := TRUE;

    while TRUE do begin
      if not Visible then break;
      FrmMain.ProcOnIdle;
      Application.ProcessMessages;
      if Application.Terminated then exit;
    end;

    DWFactionDlgEditNotice.Visible := FALSE;
    RestoreHideControls;

    if DMsgDlg.DialogResult = mrOk then begin
      data := '';
      if Memo.Lines.Count > 0 then //20080629
      for i:=0 to Memo.Lines.Count-1 do begin
        if Memo.Lines[i] = '' then
          data := data + Memo.Lines[i] + ' '#13
        else data := data + Memo.Lines[i] + #13;
      end;
      if Length(data) > 964 then begin
        data := Copy (data, 1, 964);
        DMessageDlg ('公告内容超过限制大小，公告内容将被截短！', [mbOk]);
      end;
      FrmMain.SendFactionDlgUpdateNotice (data);
    end;
  end;
end;
{$IFEND}
procedure TFrmDlg.DLFactionDlgEditNoticeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  ShowFactionDlgEditNotice();
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgHomeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    frmMain.SendOpenFactionDLgHome();
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgListClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 3000;
    FrmMain.SendGetFactionMemberList;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgEditNoticeOKClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DBFactionDlgEditNoticeCloseClick (self, 0, 0);
  DMsgDlg.DialogResult := mrOk;
{$IFEND}
end;

procedure TFrmDlg.DWFactionDlgMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  DScreen.ClearHint;
end;

{$IF M2Version <> 2}
procedure TFrmDlg.AddFactionMember(DivisionMember: TClientDivisionMember; X, Y: Integer);
var
  FactionMember: TFactionMember;
  I: Integer;
begin
  FactionMember := TFactionMember.Create;
  FactionMember.m_Icon.GLeft := X;
  FactionMember.m_Icon.GTop := Y;
  if DivisionMember.DivisionMember.boStatus then
    FactionMember.m_Icon.SetImgIndex(g_WUI1Images, 0)
  else FactionMember.m_Icon.SetImgIndex(g_WUI1Images, 6);

  FactionMember.m_Name.GLeft := X+FactionMember.m_Icon.GWidth;
  FactionMember.m_Name.GTop := Y-2;
  FactionMember.m_Name.Caption := DivisionMember.sChrName;
  FactionMember.m_DivisionMember := DivisionMember;
  g_FactionMeberList.Add(IntToStr(Integer(FactionMember.m_Name)), FactionMember);
end;
{$IFEND}

procedure TFrmDlg.DLFactionDlgExitClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_FactionDlg.boIsAdmin then begin
    if mrOk = DMessageDlg ('你确定要解散师门？', [mbOk, mbCancel]) then begin
      FrmMain.SendFactionMemberDel(FrmMain.CharName);
    end;
  end else begin
    if mrOk = DMessageDlg ('你确定要退出师门？', [mbOk, mbCancel]) then begin
      FrmMain.SendFactionMemberDel(FrmMain.CharName);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgKickClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_FactionMember.SelMemberName <> '' then begin
    if mrOk = DMessageDlg ('你是否要将“'+g_FactionMember.SelMemberName+'”逐出师门？', [mbOk, mbCancel]) then begin
      FrmMain.SendFactionMemberDel(g_FactionMember.SelMemberName);
    end;
  end else begin
    DMessageDlg('请选择要逐出师门的成员！！！', [mbOk]);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgManageApplyClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    FrmMain.SendGetFactionManageApplyList;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWFactionApplyManageCloseClick(Sender: TObject; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  if g_FactionApplyManageNameList <> nil then
  FreeAndNil(g_FactionApplyManageNameList);
  DWFactionApplyManage.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DWFactionApplyManageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
	with DWFactionApplyManage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.TextOut(SurfaceX(GLeft)+91, SurfaceY(GTop)+27, $8CC7EF, '管理师门申请');
      dsurface.TextOut(SurfaceX(GLeft)+164, SurfaceY(GTop)+79, clWhite, '角色名');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridFactionApplySelGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_qingqingImages <> nil then begin
    idx := ARow;
    if (idx in [0..4]) and (g_FactionApplyManageNameList.Count > idx) then begin
      if ACol = 0 then begin
        if g_FactionApplyManageSel[idx] then
          d := g_qingqingImages.Images[8]
        else d := g_qingqingImages.Images[7];
        if d <> nil then begin
          with DGridFactionApplySel do begin
             dsurface.Draw (SurfaceX(Rect.Left + (ColWidth - d.Width) div 2 - 1),
                            SurfaceY(Rect.Top + (RowHeight - d.Height) div 2 + 1),
                            d.ClientRect,
                            d, TRUE);
          end;
        end;
      end else begin
        with DGridFactionApplySel do
        dsurface.TextOut(SurfaceX(Rect.Left)+ 16, SurfaceY(Rect.Top)+6, clWhite, g_FactionApplyManageNameList.Strings[idx]);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridFactionApplySelGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
{$IF M2Version <> 2}
var
   idx: integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if ACol = 0 then begin
    idx := ARow;
    if (idx in [0..4]) and (g_FactionApplyManageNameList.Count > idx) then begin
      g_FactionApplyManageSel[idx] := not g_FactionApplyManageSel[idx];
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyManageAgreeClick(Sender: TObject; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    Lines := '';
    for I:=Low(g_FactionApplyManageSel) to High(g_FactionApplyManageSel) do begin
      if g_FactionApplyManageNameList.Count > I then begin
        if g_FactionApplyManageSel[I] then
          Lines := Lines + g_FactionApplyManageNameList.Strings[I] + '|';
      end;
    end;
    if Lines <> '' then frmMain.SendFactionManageAgree(Lines);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyManageRefuseClick(Sender: TObject; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  I: Integer;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    Lines := '';
    for I:=Low(g_FactionApplyManageSel) to High(g_FactionApplyManageSel) do begin
      if g_FactionApplyManageNameList.Count > I then begin
        if g_FactionApplyManageSel[I] then
          Lines := Lines + g_FactionApplyManageNameList.Strings[I] + '|';
      end;
    end;
    if Lines <> '' then frmMain.SendFactionManageRefuse(Lines);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLFactionApplyManageAllSelClick(Sender: TObject; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DLFactionApplyManageAllSel then
    FillChar(g_FactionApplyManageSel, SizeOf(g_FactionApplyManageSel), True)
  else FillChar(g_FactionApplyManageSel, SizeOf(g_FactionApplyManageSel), #0);
{$IFEND}
end;

procedure TFrmDlg.DLFactionDlgGetTitleClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    frmMain.SendFactionTitle;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWLingWUXinFaDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  OldFontSize: Byte;
  dStatFrame: Word;
const
  XinFaColor: array[0..4] of TColor = ($FF009C, clWhite, clYellow, $8C6531, clRed);
  XinFaHint: array[0..4, 0..2] of string = (
    ('紫金为帝王之象，紫金心法戾气最重。性格杀伐果断', '，十荡十决的勇气适合修炼紫金心法，紫金心法讲究', '大开大合，包罗万象。'),
    ('乙木为自然循环往生的法则，天生怀一个怜悯之心的', '人，则适合修炼乙木心法，乙木心法运行讲究生生不', '息，气息悠长，最善持久战。'),
    ('大地心法主旨沉稳，不动如山。肉体强横，老成持重', '的人最适合此类心法，大地心法的运行讲究一力降十', '会，以拙破巧，先立于不败之地。'),
    ('抽刀水更流，四两拨千斤。葵水心法讲究以柔克刚，', '劲力阴柔，伤人经脉。修习葵水心法讲究平心静气，', '后发制人，适合心态平和之人。'),
    ('阳炎天火，焚尽万物。习此心法者，功法凶狠毒辣，', '招招搏命。阳炎心法以怒火仇恨为根本，有时伤敌伤', '己，爆发力最是强劲。')
  );
  //0..4   5个对象
  //0..2   0为上面图象  1为小原点图象 2为小原点X坐标
  XinFaImages: array[0..4, 0..2] of Word = ((2151, 2040, 133), (2152, 1920, 186), (2154, 1980, 238), (2153, 2010, 296), (2150, 1950, 348));
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWLingWUXinFa do begin
    if WLib <> nil then begin
      if g_LingWuXinFa.btPage = 0 then
        if g_LingWuXinFa.boChangeXinFa then
          d := WLib.Images[FaceIndex-1]
        else d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex-3];
      if d <> nil then begin
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      end;
      with g_LingWuXinFa do begin
        frmMain.Canvas.Font.Style := [fsBold];
        dsurface.TextOut(SurfaceX(GLeft)+44, SurfaceY(GTop)+155, clSilver, '龙卫信使');
        frmMain.Canvas.Font.Style := [];
        if g_LingWuXinFa.btPage = 0 then begin
          OldFontSize := frmMain.Canvas.Font.Size;
          frmMain.Canvas.Font.Size := 15;
          dsurface.TextOut(SurfaceX(GLeft)+261, SurfaceY(GTop)+141, XinFaColor[btIndex], g_XinFaName[btIndex]+'心法');
          frmMain.Canvas.Font.Size := OldFontSize;
          dsurface.BoldTextOut(SurfaceX(GLeft)+170, SurfaceY(GTop)+161, $88C4E8, clBlack, XinFaHint[btIndex, 0]);
          dsurface.BoldTextOut(SurfaceX(GLeft)+170, SurfaceY(GTop)+176, $88C4E8, clBlack, XinFaHint[btIndex, 1]);
          dsurface.BoldTextOut(SurfaceX(GLeft)+170, SurfaceY(GTop)+191, $88C4E8, clBlack, XinFaHint[btIndex, 2]);
          d := WLib.Images[XinFaImages[btIndex, 0]];
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          end;
          if GetTickCount - dwStartTimeTick > 100 then begin
            dwStartTimeTick := GetTickCount;
            Inc(btCurrentFrame);
            if btCurrentFrame > 19 then btCurrentFrame := 0;
          end;
          d := WLib.Images[XinFaImages[btIndex, 1]+btCurrentFrame];
          if d <> nil then begin
            DrawBlend(dsurface, SurfaceX(GLeft)+XinFaImages[btIndex, 2], SurfaceY(GTop)+80, d, 255);
          end;
          if boChangeXinFa then begin
            dsurface.BoldTextOut(SurfaceX(GLeft)+253, SurfaceY(GTop)+207, clLime, clBlack, '当前心法种类：' + g_XinFaName[btGetM2Type]);
          end else begin
            if sKeySelCaption = '' then
              dsurface.BoldTextOut(SurfaceX(GLeft)+190, SurfaceY(GTop)+229, $88C4E8, clBlack, '心法命名2-6字')
            else dsurface.BoldTextOut(SurfaceX(GLeft)+190, SurfaceY(GTop)+229, $88C4E8, clBlack, sKeySelCaption);
          end;
        end else begin
          case btHelpPage of
            0: begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+64, clWhite, clBlack, '所谓龙卫心法，不过是神龙子嗣修炼到一定程度后，');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+78, clWhite, clBlack, '通过激发神龙血脉，获得的能力的大幅提升。龙卫心');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+92, clWhite, clBlack, '法因人而异，名字也不同，因为能够修炼该心法之人');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+106, clWhite, clBlack, '，均成为神龙帝国龙卫封号，所以统称为龙卫心法。');
            end;
            1: begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+64, clWhite, clBlack, '人法地，地法天，天法道，道法自然。领悟招式也是');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+78, clWhite, clBlack, '如此，无论是在战场搏杀，还是在密室修炼，又或是');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+92, clWhite, clBlack, '在野外冒险，只要心法等级达到一定程度，均有机会');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+106, clWhite, clBlack, '在使用招式时领悟进入下一重境界。普通招式境界共');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+120, clWhite, clBlack, '分九重，每领悟一重都将强大几分。心法跨入三阶龙');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+134, clWhite, clBlack, '卫境界更能激发神龙血脉，施展更强威力。');
            end;
            2: begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+64, clWhite, clBlack, '龙卫心法是驱动一切上乘武工的基础，能够激发神龙');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+78, clWhite, clBlack, '血脉的怒火，瞬间进入龙卫境界。心法等级提升将带');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+92, clWhite, clBlack, '来独特的神圣攻防属性加成，更能帮助你自行领悟强');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+106, clWhite, clBlack, '大的招式。每个人的性格经脉不同，会产生不同的行');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+120, clWhite, clBlack, '气方式，相生相克均是自然规律，心法提升终将带你');
              dsurface.BoldTextOut(SurfaceX(GLeft)+172, SurfaceY(GTop)+134, clWhite, clBlack, '踏入龙卫境界，领悟神龙血脉中隐藏的神技实力。');
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaNamePrevDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
	with Sender as TDButton do begin
    if WLib <> nil then begin
      if MouseMoveing then d := WLib.Images[FaceIndex+1]
      else if Downed then d := WLib.Images[FaceIndex+2]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
      	dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridLingWuXinFaKeyGridPaint(Sender: TObject; ACol,
  ARow: Integer; Rect: TRect; State: TDGridDrawState;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DGridLingWuXinFaKey do begin
    idx := ACol + ARow * ColCount;
    if idx in [0..19] then begin
      d := g_WUI1Images.Images[2326];
      if d <> nil then
        dsurface.Draw(SurfaceX(Rect.Left), SurfaceY(Rect.Top), d.ClientRect, d, True);
      if g_LingWuXinFa.nKeySelIndex-1 = idx then
        d := g_WUI1Images.Images[2341+50*g_LingWuXinFa.btKeyPage+idx*2]
      else d := g_WUI1Images.Images[2340+50*g_LingWuXinFa.btKeyPage+idx*2];
      if d <> nil then
        dsurface.Draw(SurfaceX(Rect.Left)+7, SurfaceY(Rect.Top)+10, d.ClientRect, d, True);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DGridLingWuXinFaKeyGridSelect(Sender: TObject; ACol,
  ARow: Integer; Shift: TShiftState);
{$IF M2Version <> 2}
const
  KeyName: array [0..19, 0..2] of string[2] = (
    ('百', '地', '步'), ('断', '风', '刺'), ('飞', '凤', '刀'),
    ('焚', '光', '赋'), ('幻', '虎', '动'), ('击', '火', '击'),
    ('狂', '间', '剑'), ('裂', '金', '脚'), ('凌', '雷', '诀'),
    ('猛', '麟', '破'), ('千', '龙', '气'), ('神', '木', '拳'),
    ('十', '日', '扫'), ('万', '蛇', '闪'), ('翔', '水', '手'),
    ('玄', '天', '术'), ('一', '烟', '行'), ('御', '岩', '跃'),
    ('斩', '雨', '斩'), ('逐', '月', '纵')
  );
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DGridLingWuXinFaKey do begin
    with g_LingWuXinFa do begin
      nKeySelIndex := ACol + ARow * ColCount+1;
      sKeySelCaption := sKeySelCaption + KeyName[nKeySelIndex-1, btKeyPage];
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLLingWuXinFaKeyChangeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    if sKeySelCaption <> '' then
      sKeySelCaption := Copy(sKeySelCaption, 1, Length(sKeySelCaption)-2);
  end;
{$IFEND}
end;

procedure TFrmDlg.DLLingWuXinFaKeyPrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    if Sender = DLLingWuXinFaKeyPrev then begin
      if btKeyPage > 0 then Dec (btKeyPage);
    end else begin
      if btKeyPage < 2 then
         Inc (btKeyPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaNamePrevClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    if Sender = DBXinFaNamePrev then begin
      if btIndex > 0 then Dec (btIndex);
    end else begin
      if btIndex < 4 then
         Inc (btIndex);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingWuXinFaKeyCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWuXinFaKey.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBLingWuXinFaNameClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with DWLingWuXinFaKey do begin
    if not Visible then begin
      GLeft := 186;
      GTop := 350;
      g_LingWuXinFa.nKeySelIndex := 0;
      g_LingWuXinFa.btKeyPage := 0;
      Visible := True;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLLingWUXinFaClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with g_LingWuXinFa do begin
    btPage := TDLabel(Sender).Tag;
    DLXinFaChangeSelName.Visible := boChangeXinFa and (btPage = 0);
    DBLingWuXinFaName.Visible := not boChangeXinFa and (btPage = 0);
    DLXinFaMakeName.Visible := DBLingWuXinFaName.Visible;
    DBXinFaNameNext.Visible := btPage = 0;
    DBXinFaNamePrev.Visible := btPage = 0;
    DLHelpXinfa.Visible := btPage = 1;
    DLLingwuZhaoshi.Visible := btPage = 1;
    if btPage = 1 then btHelpPage := 0;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLHelpXinfaClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  with TDLabel(Sender) do begin
    g_LingWuXinFa.btHelpPage := Tag;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLXinFaMakeNameClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_LingWuXinFa.sKeySelCaption <> '' then begin
    DWLingWUXinFa.Visible := False;
    DWLingWuXinFaKey.Visible := False;
    if mrOk = DMessageDlg (Format('你确定要修行%s(%s属性)的心法吗？',
          [g_LingWuXinFa.sKeySelCaption, g_XinFaName[g_LingWuXinFa.btIndex]]), [mbOk, mbCancel]) then begin
      frmMain.SendLingWuXinFa(g_LingWuXinFa.btIndex, g_LingWuXinFa.sKeySelCaption);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DLXinFaChangeSelNameClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWUXinFa.Visible := False;
  DWLingWuXinFaKey.Visible := False;
  if mrOk = DMessageDlg (Format('你确定要转换为%s属性的心法吗？',
        [g_XinFaName[g_LingWuXinFa.btIndex]]), [mbOk, mbCancel]) then begin
    frmMain.SendChangeLingWuXinFa(g_LingWuXinFa.btIndex);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBLingWUXinFaCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  DWLingWUXinFa.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  ax, ay, Idx: Integer;
  bbx, bby: Integer;
  wm: TWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWinPageTab1 do begin
    if WLib <> nil then begin
      if g_MySelf.m_btSex = 1 then
        d := WLib.Images[FaceIndex+1]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    bbx := GLeft+31;
    bby := GTop+56;
    if g_UseItems[U_DRESS].S.Name <> '' then begin //衣服
      Idx := g_UseItems[U_DRESS].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        with GetEffecItemList(g_UseItems[U_DRESS].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_DRESS].nIndex);
              if g_DrawUseItems[U_DRESS].nIndex > btShapeCount-1 then g_DrawUseItems[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
    //自己人物发型  2007.10.16 
    Idx := 1799;
    if g_MySelf.m_btSex = 1 then  Idx := 2399;
    if g_MySelf.m_btSex = 0 then begin  //男
      if g_MySelf.m_btHair <> 0 then begin
        if Idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        end;
      end;
    end else if g_MySelf.m_btHair <> 1 then begin
      if Idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
    end;
    if g_UseItems[U_WEAPON].S.Name <> '' then begin
      Idx := g_UseItems[U_WEAPON].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with GetEffecItemList(g_UseItems[U_WEAPON].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_WEAPON].nIndex);
              if g_DrawUseItems[U_WEAPON].nIndex > btShapeCount-1 then g_DrawUseItems[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;  
    end;
    //斗笠 20080417
    if g_UseItems[U_ZHULI].S.Name <> '' then begin
      if g_UseItems[U_ZHULI].S.Shape <> 2  then begin
        Idx := g_UseItems[U_ZHULI].S.Looks;
        if Idx >= 0 then begin
          d := FrmMain.GetWStateImg(Idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (g_UseItems[U_HELMET].S.Looks = 103) or (g_UseItems[U_HELMET].S.Looks = 106) or (g_UseItems[U_HELMET].S.Looks = 344) or (g_UseItems[U_HELMET].S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if g_UseItems[U_HELMET].S.Name <> '' then begin //头盔
            Idx := g_UseItems[U_HELMET].S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          Idx := g_UseItems[U_ZHULI].S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          Idx := g_UseItems[U_ZHULI].S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if g_UseItems[U_HELMET].S.Name <> '' then begin //头盔
            Idx := g_UseItems[U_HELMET].S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
      if g_UseItems[U_HELMET].S.Name <> '' then begin
        with GetEffecItemList(g_UseItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_HELMET].nIndex);
              if g_DrawUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end else
    if g_UseItems[U_HELMET].S.Name <> '' then begin //头盔
      Idx := g_UseItems[U_HELMET].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with GetEffecItemList(g_UseItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems[U_HELMET].nIndex);
              if g_DrawUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
    dsurface.TextOut (SurfaceX(GLeft) + 46, SurfaceY(GTop) + 6, clSilver, g_sGuildName + ' ' + g_sGuildRankName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateWinPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateWinPage.ActivePage = 0 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '装');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '备');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '装');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '备');
    end;
    if DPNewStateWinPage.ActivePage = 1 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '态');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '态');
    end;
    if DPNewStateWinPage.ActivePage = 2 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $00A8D4E8, clBlack, '属');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $00A8D4E8, clBlack, '性');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $00708CA0, clBlack, '属');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $00708CA0, clBlack, '性');
    end;
    if DPNewStateWinPage.ActivePage = 3 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $00A8D4E8, clBlack, '称');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $00A8D4E8, clBlack, '号');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $00708CA0, clBlack, '称');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $00708CA0, clBlack, '号');
    end;
    if DPNewStateWinPage.ActivePage = 4 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+170, $00A8D4E8, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+183, $00A8D4E8, clBlack, '能');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+170, $00708CA0, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+183, $00708CA0, clBlack, '能');
    end;
    if DPNewStateWinPage.ActivePage = 5 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+210, $00A8D4E8, clBlack, '出');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+223, $00A8D4E8, clBlack, '战');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+210, $00708CA0, clBlack, '出');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+223, $00708CA0, clBlack, '战');
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSWBujukDblClick(Sender: TObject);
var
  msg: TDefaultMessage;
begin
  //存放罐物品的扩展   20080315
  if (g_UseItems[U_BUJUK].S.StdMode = 2) and (g_UseItems[U_BUJUK].S.AniCount = 21) then begin
    if Sender = DBNewSWBujuk then begin
      if g_UseItems[U_BUJUK].Dura < g_UseItems[U_BUJUK].DuraMax then begin
         msg := MakeDefaultMsg (aa(CM_DBLREPAIRDRAGON, frmMain.TempCertification),0, 0, 0, 0, frmMain.m_nSendMsgCount);//20071231
         FrmMain.SendSocket (EncodeMessage (msg));//20071231
       end;
    end;
  end;
end;

procedure TFrmDlg.DBNewSWNecklaceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx, nWhere, EffIdx: Integer;
  d: TDirectDrawSurface;
  wm: TWMImages;
  ax, ay: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  nWhere := -1;
  if Sender = DBNewSWNecklace then nWhere := U_NECKLACE;
  if Sender = DBNewSWLight then nWhere := U_RIGHTHAND;
  if Sender = DBNewSWArmRingR then nWhere := U_ARMRINGR;
  if Sender = DBNewSWArmRingL then nWhere := U_ARMRINGL;
  if Sender = DBNewSWRingR then nWhere := U_RINGR;
  if Sender = DBNewSWRingL then nWhere := U_RINGL;
  if Sender = DBNewSWBujuk then nWhere := U_BUJUK;
  if Sender = DBNewSWBelt then nWhere := U_BELT;
  if Sender = DBNewSWBoots then nWhere := U_BOOTS;
  if Sender = DBNewSWCharm then nWhere := U_CHARM;
  if Sender = DBNewSWDRUM then nWhere := U_DRUM;

  if nWhere >= 0 then begin
    if g_UseItems[nWhere].S.Name <> '' then begin
      idx := g_UseItems[nWhere].S.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx);
        if d <> nil then begin
          with TDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft) + (GWidth - d.Width) div 2 + 2,
                          SurfaceY(GTop) + (GHeight - d.Height) div 2 + 1,
                          d.ClientRect, d, TRUE);
            if GetEffecItemList(g_UseItems[nWhere].S.Name).btShapeCount > 0 then begin
              with GetEffecItemList(g_UseItems[nWhere].S.Name) do begin
                if GetTickCount - g_DrawUseItems[nWhere].dwDrawTick >= 150 then begin
                  g_DrawUseItems[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems[nWhere].nIndex);
                  if g_DrawUseItems[nWhere].nIndex > btShapeCount-1 then g_DrawUseItems[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    DrawBlend(dsurface,SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d, 255);
                  end;
                end;
              end;
            end else begin
              if g_UseItems[nWhere].S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  DrawBlend(dsurface,SurfaceX(GLeft-21), SurfaceY(GTop-23), d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSWWeaponClick(Sender: TObject; X, Y: Integer);
var
  where, n, sel: integer;
  flag: Boolean;
  msg: TDefaultMessage;
begin
  if g_MySelf = nil then exit;
  if g_boItemMoving (*or g_boRightItem{右键点物品}*) then begin
    flag := FALSE;
    if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
    if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
    where := GetTakeOnPosition (g_MovingItem.Item.S.StdMode);
    if g_MovingItem.Index >= 0 then begin
      //存放罐物品的扩展   20080315
      if ((g_UseItems[U_BUJUK].S.StdMode = 2) and (g_UseItems[U_BUJUK].S.AniCount = 21) and (Byte(g_UseItems[U_BUJUK].S.Source) = g_MovingItem.Item.S.Shape) and (g_UseItems[U_BUJUK].S.Shape = g_MovingItem.Item.S.StdMode)) and (not (g_MovingItem.Item.S.StdMode in [5,6,10,11])) then begin
        if Sender = DBNewSWBujuk then begin
          g_WaitingUseItem := g_MovingItem;
          g_MovingItem.Item.S.Name := '';
          g_boItemMoving := False;
          msg := MakeDefaultMsg (aa(CM_REPAIRDRAGON, frmMain.TempCertification),g_WaitingUseItem.Item.MakeIndex, 4, 0, 0, frmMain.m_nSendMsgCount);//20071231
          FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.S.Name));//20071231
          //Exit;
        end;
      end;
      //火云石修复
      if (g_UseItems[U_BUJUK].S.StdMode = 25) and (g_UseItems[U_BUJUK].S.Shape = 10) and (g_MovingItem.Item.S.StdMode = 43) and (g_MovingItem.Item.S.Shape = 1) then begin
        if Sender = DBNewSWBujuk then begin
          g_WaitingUseItem := g_MovingItem;
          g_MovingItem.Item.S.Name := '';
          g_boItemMoving := False;
          msg := MakeDefaultMsg (aa(CM_REPAIRFINEITEM, frmMain.TempCertification),g_WaitingUseItem.Item.MakeIndex, 0, 0, 0, frmMain.m_nSendMsgCount);//20080507
          FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_WaitingUseItem.Item.S.Name));//20080507
        end;
      end;
      case where of
        U_DRESS: begin//衣服
          if Sender = DBNewSWDress then begin
            if g_MySelf.m_btSex = 0 then //男的
              if g_MovingItem.Item.S.StdMode <> 10 then //10男式衣服
                Exit;
            if g_MySelf.m_btSex = 1 then //女的
              if g_MovingItem.Item.S.StdMode <> 11 then //11男式衣服
                Exit;
            flag := TRUE;
          end;
        end;
        U_WEAPON: begin//武器
          if Sender = DBNewSWWEAPON then flag := TRUE;
        end;
        U_NECKLACE: begin//项链
          if Sender = DBNewSWNecklace then flag := TRUE;
        end;
        U_RIGHTHAND: begin //蜡烛、火把、圣牌、勋章之类的
          if Sender = DBNewSWLight then flag := TRUE;
        end;
        U_HELMET: begin//头盔
          if Sender = DBNewSWHelmet then flag := TRUE;
        end;
        U_ZHULI: begin//斗笠
          if Sender = DBNewSWHelmet then flag := True;
        end;
        U_RINGR, U_RINGL: begin//戒指（左右都可以）
          if Sender = DBNewSWRingL then begin
            where := U_RINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSWRingR then begin
            where := U_RINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGR: begin//手镯、手套(左右都可以)
          if Sender = DBNewSWArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSWArmRingR then begin
            where := U_ARMRINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGL: begin//护身符、药粉之类的
          if Sender = DBNewSWArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BUJUK: begin //护身符、药粉之类的
          if Sender = DBNewSWBujuk then begin
            case g_MovingItem.Item.S.StdMode of
              2: begin //祝福罐，魔令包
                if (g_MovingItem.Item.S.StdMode = 2) and (g_MovingItem.Item.S.AniCount = 21) then begin
                  where := U_BUJUK;
                  flag := TRUE;
                end;
              end;
              25: begin //符
                where := U_BUJUK;
                flag := TRUE;
              end;
            end;
          end;
          if Sender = DBNewSWArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BELT: begin//腰带
          if Sender = DBNewSWBelt then begin
            where := U_BELT;
            flag := TRUE;
          end;
        end;
        U_BOOTS: begin//鞋子
          if Sender = DBNewSWBoots then begin
            where := U_BOOTS;
            flag := TRUE;
          end;
        end;
        U_CHARM: begin//宝石
          if Sender = DBNewSWCharm then begin
            where := U_CHARM;
            flag := TRUE;
          end;
        end;
        U_DRUM: begin//军鼓
          if Sender = DBNewSWDRUM then begin
            where := U_DRUM;
            flag := TRUE;
          end;
        end;
      end;
      if Sender = DBNewSWCharm then begin
        if (g_UseItems[U_CHARM].S.Shape = 5) and (g_UseItems[U_CHARM].S.StdMode = 7) and (g_UseItems[U_CHARM].S.Name <> '') then begin//20090205
          case g_MovingItem.Item.S.StdMode of
            7: begin
              if g_MovingItem.Item.S.Shape = 3 then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingItem.Item.MakeIndex, 1, 0, 0, frmMain.m_nSendMsgCount);//20071231
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingItem.Item.S.Name));//20071231
                Exit;
              end;
            end;
          end;
        end;
      end;
    end else begin
      n := -(g_MovingItem.Index+1);
      if n in [0..14] then begin
        ItemClickSound (g_MovingItem.Item.S);
        g_UseItems[n] := g_MovingItem.Item;
        g_MovingItem.Item.S.Name := '';
        g_boItemMoving := FALSE;
      end;
    end;
    if flag then begin
      ItemClickSound (g_MovingItem.Item.S);
      g_WaitingUseItem := g_MovingItem;
      g_WaitingUseItem.Index := where;
      FrmMain.SendTakeOnItem (where, g_MovingItem.Item.MakeIndex, g_MovingItem.Item.S.Name);
      g_MovingItem.Item.S.Name := '';
      g_boItemMoving := FALSE;
    end;
  end else begin
    if g_boHeroItemMoving then Exit;
    if (g_MovingItem.Item.S.Name <> '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
    sel := -1;
    if Sender = DBNewSWDress then sel := U_DRESS;
    if Sender = DBNewSWWeapon then sel := U_WEAPON;
    if Sender = DBNewSWHelmet then begin //斗笠
      if g_UseItems[U_ZHULI].S.Name <> '' then
         sel := U_ZHULI
      else sel := U_HELMET;
    end;
    if Sender = DBNewSWNecklace then sel := U_NECKLACE;
    if Sender = DBNewSWLight then sel := U_RIGHTHAND;
    if Sender = DBNewSWRingL then sel := U_RINGL;
    if Sender = DBNewSWRingR then sel := U_RINGR;
    if Sender = DBNewSWArmRingL then sel := U_ARMRINGL;
    if Sender = DBNewSWArmRingR then sel := U_ARMRINGR;
    if Sender = DBNewSWBujuk then sel := U_BUJUK;
    if Sender = DBNewSWBelt then sel := U_BELT;  //
    if Sender = DBNewSWBoots then sel := U_BOOTS;
    if Sender = DBNewSWCharm then sel := U_CHARM;
    if Sender = DBNewSWDRUM then sel := U_DRUM;
    if sel >= 0 then begin
      if g_UseItems[sel].S.Name <> '' then begin
        ItemClickSound (g_UseItems[sel].S);
        g_MovingItem.Index := -(sel+1);
        g_MovingItem.Item := g_UseItems[sel];
        g_UseItems[sel].S.Name := '';
        g_boItemMoving := TRUE;
      end;
    end;
  end;
end;

procedure TFrmDlg.DBNewSWWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  sel := -1;
  Lines := '';
  if Sender = DBNewSWDress then sel := U_DRESS;
  if Sender = DBNewSWWeapon then sel := U_WEAPON;
  if Sender = DBNewSWHelmet then sel := U_HELMET;
  if Sender = DBNewSWNecklace then sel := U_NECKLACE;
  if Sender = DBNewSWLight then sel := U_RIGHTHAND;
  if Sender = DBNewSWRingL then sel := U_RINGL;
  if Sender = DBNewSWRingR then sel := U_RINGR;
  if Sender = DBNewSWArmRingL then sel := U_ARMRINGL;
  if Sender = DBNewSWArmRingR then sel := U_ARMRINGR;

  if Sender = DBNewSWBujuk then sel := U_BUJUK;
  if Sender = DBNewSWBelt then sel := U_BELT;
  if Sender = DBNewSWBoots then sel := U_BOOTS;
  if Sender = DBNewSWCharm then sel := U_CHARM;
  if Sender = DBNewSWDRUM then sel := U_DRUM;
  if sel >= 0 then begin
    g_MouseStateItem := g_UseItems[sel];
    if (g_UseItems[sel].S.Name <> '') or (g_UseItems[U_ZHULI].S.Name <> '') then begin
      if (sel = U_HELMET) and (g_UseItems[U_ZHULI].S.Name <> '') then begin
        g_MouseItem := g_UseItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
        if iname <> '' then begin
          if g_UseItems[U_ZHULI].Dura = 0 then
            hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(g_UseItems[sel].S.Name, 1);
      if DWNewStateWin.GLeft >= 350 then
        nHintX:=DWNewStateWin.SurfaceX(DWNewStateWin.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DWNewStateWin.SurfaceX(DWNewStateWin.GLeft)+DWNewStateWin.GWidth;
      nHintY:=DWNewStateWin.SurfaceY(DWNewStateWin.GTop) +50;
      g_MouseItem := g_UseItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
      if (iname <> '') or (Lines <> '') then begin
        if g_UseItems[sel].Dura = 0 then
          hcolor := 'Red'
        else hcolor := '';
        with Sender as TDButton do begin
          if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintx,
                                    nHinty,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False//'<'+iname+'/c=Yellow>\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + '<'+d4+'/c=Yellow>\'+ d5 + '\' + d6 + '\' + d7, FALSE
                                    );

          end else begin
            DScreen.ShowSpecialHint(nHintx,
                                    nHinty,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,1)]), False
                                    );
          end;
        end;
      end;
      g_MouseItem.S.Name := '';
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  g_MouseStateItem.S.Name := '';
  if g_MouseTitleList.Count > 0 then
    g_MouseTitleList.Clear;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateWinPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateWinPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateWinPage.ActivePage := 1;
  end else
  if (ly >= 91) and (ly <= 130) then begin
    DPNewStateWinPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateWinPage.ActivePage := 3;
  end else
  if (ly >= 171) and (ly <= 210) then begin
    DPNewStateWinPage.ActivePage := 4;
  end else
  if (ly >= 211) and (ly <= 250) then begin
    DPNewStateWinPage.ActivePage := 5;
    DCheckNewDeputyHeroWarr.Checked := False;
    DCheckNewDeputyHeroWiz.Checked := False;
    DCheckNewDeputyHeroTaos.Checked := False;
    case m_btDeputyHeroJob of
      0: DCheckNewDeputyHeroWarr.Checked := True;
      1: DCheckNewDeputyHeroWiz.Checked := True;
      2: DCheckNewDeputyHeroTaos.Checked := True;
      else DCheckNewDeputyHeroWarr.Checked := True;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateTab1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if (Sender = DBNewStateTab1) or (Sender = DBNewStateTab2) or (Sender = DBNewStateTab3) then
    DPNewStateWinTab.ActivePage := TDButton(Sender).Tag
  else DPNewStateHeroTab.ActivePage := TDButton(Sender).Tag
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinCloseClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStateWinClose then
    DWNewStateWin.Visible := False
  else if Sender = DBNewStateHeroClose then
    DWNewStateHero.Visible := False
  else DWNewStateUser.Visible := False;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinCloseDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      if not Downed then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex + 1];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
end;

procedure TFrmDlg.DWNewStateWinPageTab2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if g_MySelf = nil then Exit;
  with DWNewStateWinPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with dsurface do begin
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+16, clSilver, clBlack, '职业      ：' + GetJobName(g_MySelf.m_btJob));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+31, clSilver, clBlack, '等级      ：' + IntToStr(g_MySelf.m_Abil.Level));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+46, clSilver, clBlack, '声望      ：' + IntToStr(g_nCreditPoint));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+61, clSilver, clBlack, '当前经验  ：' + IntToStr(g_MySelf.m_Abil.nExp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+76, clSilver, clBlack, '升级经验  ：' + IntToStr(g_MySelf.m_Abil.nMaxExp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+91, clSilver, clBlack, Format('体力值    ：%d/%d', [g_MySelf.m_Abil.HP, g_MySelf.m_Abil.MaxHP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+106, clSilver, clBlack, Format('魔法值    ：%d/%d', [g_MySelf.m_Abil.MP, g_MySelf.m_Abil.MaxMP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+121, clSilver, clBlack, Format('药力值    ：%d/%d', [g_MySelf.m_Abil.MedicineValue, g_MySelf.m_Abil.MaxMedicineValue]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+136, clSilver, clBlack, '酒量      ：' + IntToStr(g_MySelf.m_Abil.MaxAlcohol));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+151, clSilver, clBlack, g_sGameDiaMond + '数  ：' + IntToStr(g_MySelf.m_nGameDiaMond));

      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+181, clSilver, clBlack, g_sGameGird + '数量  ：' + IntToStr(g_MySelf.m_nGameGird));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+196, clYellow, clBlack, g_sGameGoldName + '数量  ：' + IntToStr(g_MySelf.m_nGameGold));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+211, clSilver, clBlack, g_sGamePointName + '    ：' + IntToStr(g_MySelf.m_nGamePoint));
      if g_dGamePointDate <> 32590 then
       BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+226, clYellow, clBlack, g_sGamePointName+'截止时间'+ FormatDateTime('mm月dd日24时', g_dGamePointDate));
    end;
  end;
end;

procedure TFrmDlg.DWNewStateWinPageTab3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWinPageTab3 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with dsurface do begin
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+35, clSilver, clBlack, Format('防御 %d-%d', [LoWord(g_MySelf.m_Abil.AC), HiWord(g_MySelf.m_Abil.AC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+50, clSilver, clBlack, Format('魔御 %d-%d', [LoWord(g_MySelf.m_Abil.MAC), HiWord(g_MySelf.m_Abil.MAC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+65, clSilver, clBlack, Format('攻击 %d-%d', [LoWord(g_MySelf.m_Abil.DC), HiWord(g_MySelf.m_Abil.DC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+80, clSilver, clBlack, Format('魔法 %d-%d', [LoWord(g_MySelf.m_Abil.MC), HiWord(g_MySelf.m_Abil.MC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+95, clSilver, clBlack, Format('道术 %d-%d', [LoWord(g_MySelf.m_Abil.SC), HiWord(g_MySelf.m_Abil.SC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+110, clSilver, clBlack, '精确度     ' + IntToStr(g_nMyHitPoint));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+125, clSilver, clBlack, '敏捷度     ' + IntToStr(g_nMySpeedPoint));

      if g_MySelf.m_Abil.Weight > g_MySelf.m_Abil.MaxWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clRed, clBlack, Format('背包重量  %d/%d', [g_MySelf.m_Abil.Weight, g_MySelf.m_Abil.MaxWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clSilver, clBlack, Format('背包重量  %d/%d', [g_MySelf.m_Abil.Weight, g_MySelf.m_Abil.MaxWeight]));
      if g_MySelf.m_Abil.WearWeight > g_MySelf.m_Abil.MaxWearWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clRed, clBlack, Format('穿戴重量  %d/%d', [g_MySelf.m_Abil.WearWeight, g_MySelf.m_Abil.MaxWearWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clSilver, clBlack, Format('穿戴重量  %d/%d', [g_MySelf.m_Abil.WearWeight, g_MySelf.m_Abil.MaxWearWeight]));
      if g_MySelf.m_Abil.HandWeight > g_MySelf.m_Abil.MaxHandWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clRed, clBlack, Format('腕力      %d/%d', [g_MySelf.m_Abil.HandWeight, g_MySelf.m_Abil.MaxHandWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clSilver, clBlack, Format('腕力      %d/%d', [g_MySelf.m_Abil.HandWeight, g_MySelf.m_Abil.MaxHandWeight]));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+80, clSilver, clBlack, '魔法防御  ' + IntToStr(g_nMyAntiMagic * 10) + '%');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  rc: Trect;
begin
  if g_MySelf = nil then Exit;
  with DBNewLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;

      if g_MySelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_MySelf.m_Abil.MaxAlcohol * g_MySelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
end;

procedure TFrmDlg.DWNewStateWinDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  nTitleWidth: Integer;
  sTitleName: string;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWin do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      frmMain.Canvas.Font.Style := [fsBold];
      if DBNewStateTab3.Visible then begin //有心法
        d := WLib.Images[2196+DPNewStateWinTab.ActivePage];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+14, SurfaceY(GTop)+51, d.ClientRect, d, True);
        if DPNewStateWinTab.ActivePage = 0 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        dsurface.BoldTextOut(SurfaceX(GLeft)+54, SurfaceY(GTop)+53, Color, clBlack, '基础');
        if DPNewStateWinTab.ActivePage = 1 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        dsurface.BoldTextOut(SurfaceX(GLeft)+134, SurfaceY(GTop)+53, Color, clBlack, '内功');
        if DPNewStateWinTab.ActivePage = 2 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        if g_boXinFaType then
          dsurface.BoldTextOut(SurfaceX(GLeft)+214, SurfaceY(GTop)+53, Color, clBlack, '心法')
        else dsurface.BoldTextOut(SurfaceX(GLeft)+202, SurfaceY(GTop)+53, Color, clBlack, '传承心法')
      end else if g_boIsInternalForce then begin  //有内功
        d := WLib.Images[2245-DPNewStateWinTab.ActivePage];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+14, SurfaceY(GTop)+55, d.ClientRect, d, True);
        if DPNewStateWinTab.ActivePage = 0 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        dsurface.BoldTextOut(SurfaceX(GLeft)+74, SurfaceY(GTop)+57, Color, clBlack, '基础');
        if DPNewStateWinTab.ActivePage = 1 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        dsurface.BoldTextOut(SurfaceX(GLeft)+154, SurfaceY(GTop)+57, Color, clBlack, '内功');
      end;
      frmMain.Canvas.Font.Style := [];
    end;
    if g_ClientHumTitles.nUseTitleIndex > 0 then begin
      if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
        sTitleName := g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName;
        if sTitleName <> '' then begin
          nTitleWidth := frmMain.Canvas.TextWidth(sTitleName);
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
            if g_WUI1Images <> nil then begin
              d := g_WUI1Images.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks];
              if d <> nil then begin
                if d.Width > 16 then begin
                  nTitleWidth := d.Width;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end else begin
                  nTitleWidth := nTitleWidth + d.Width + 4;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2 - d.Width, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end;
              end;
            end;
          end;
          if d.Width < 17 then 
          dsurface.TextOut(SurfaceX(GLeft) + 150 - nTitleWidth div 2, SurfaceY(GTop) + 19, clYellow, sTitleName);
        end;
      end;
    end;
    dsurface.TextOut(SurfaceX(GLeft + 142 - frmMain.Canvas.TextWidth(FrmMain.CharName) div 2),
                     SurfaceY(GTop + 38), g_MySelf.m_nNameColor, g_MySelf.m_sUserName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitleManClick(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version <> 2}
  if g_ClientHumTitles.nUseTitleIndex > 0 then begin
    if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('是否取消当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].MakeIndex, 0);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewTitleManDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
  nOldFontSize: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
            nOldFontSize := frmMain.Canvas.Font.Size;
            frmMain.Canvas.Font.Size := 12;
            frmMain.Canvas.Font.Style := [fsBold];
            dsurface.TextOut(SurfaceX(GLeft)+40, SurfaceY(GTop)+20, clYellow, g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1].sTitleName);
            frmMain.Canvas.Font.Style := [];
            frmMain.Canvas.Font.Size := nOldFontSize;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitle1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      idx := _Max(Tag + m_btTitlePage * 5, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if g_ClientHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[g_ClientHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
          dsurface.TextOut(SurfaceX(GLeft) + 34, SurfaceY(GTop) + 15, $008200, g_ClientHumTitles.ClientHumTitles[idx].sTitleName);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewTitle1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
  {$IF M2Version <> 2}
  with Sender as TDButton do begin
    if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then Exit;
    idx := _Max(Tag + m_btTitlePage * 5, 0);
    if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
      if g_ClientHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
        if mrOk = FrmDlg.DMessageDlg ('你确定要将'+g_ClientHumTitles.ClientHumTitles[idx].sTitleName+'设置为当前称号？', [mbOk, mbCancel]) then begin
          FrmMain.SendTitleSet(g_ClientHumTitles.ClientHumTitles[idx].MakeIndex, 1);
        end;
      end;
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewTitle1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if Sender = DBNewTitleMan then begin
      if g_ClientHumTitles.nUseTitleIndex > 0 then begin
        if g_ClientHumTitles.nUseTitleIndex-1 <= High(g_ClientHumTitles.ClientHumTitles) then begin
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(g_ClientHumTitles.ClientHumTitles[g_ClientHumTitles.nUseTitleIndex-1], g_MouseTitleList, True), False);
        end;
      end;
    end else begin
      if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btTitlePage * 5, 0);
      if idx <= High(g_ClientHumTitles.ClientHumTitles) then begin
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(g_ClientHumTitles.ClientHumTitles[idx], g_MouseTitleList, True), False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(g_ClientHumTitles.ClientHumTitles) to High(g_ClientHumTitles.ClientHumTitles) do begin
      if g_ClientHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBNewPrevTitle then begin
    if m_btTitlePage > 0 then Dec (m_btTitlePage);
  end else begin
    if m_btTitlePage < (GetTitleCount+4) div 5 -1 then
       Inc (m_btTitlePage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewStNGMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    pm := nil;
    idx := _Max(Tag + InternalForceMagicPage * 5, 0);
    if idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[idx]);
      if pm <> nil then begin
        if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
        else
          DScreen.ShowTzHint (SurfaceX(GLeft)-120, SurfaceY(GTop),
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStNGPageUp then begin
    if InternalForceMagicPage > 0 then begin
      Dec (InternalForceMagicPage);
      NewNGUpLevelState(False);
    end;
  end else begin
    if InternalForceMagicPage < (g_InternalForceMagicList.Count+4) div 5 - 1 then begin
      Inc (InternalForceMagicPage);
      NewNGUpLevelState(False);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  Idx: Integer;
  pm: PTClientMagic;
  keych: Char;
{$IFEND}
begin
{$IF M2Version <> 2}
  Idx := _Max(TDBUtton(Sender).Tag + InternalForceMagicPage * 5, 0);
  if (Idx >= 0) and (Idx < g_InternalForceMagicList.Count) then begin
    pm := PTClientMagic (g_InternalForceMagicList[Idx]);
    if Word(pm.Key) = 0 then
      keych := Char(Word(1))
    else keych := Char(Word(0));
    pm.Key := keych;
    FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStNGMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  wm: TWMImages;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    pm := nil;
    Idx := _Max(Tag + InternalForceMagicPage * 5, 0);
    if Idx < g_InternalForceMagicList.Count then begin
      pm := PTClientMagic (g_InternalForceMagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx,Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
            if d <> nil then begin
              if word(pm.Key) <> 0 then begin
                g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                DrawEffect(0, 0, g_ImgMixSurface, d, {ceGrayScale}ceBlack);
                dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
              end;
            end;
          end;
        end;
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        d := g_WMainImages.Images[111]; //exp
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
        if Word(pm.Key) = 0 then begin
          Color := clSilver;
          dsurface.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName);
        end else begin
          Color := clGray;
          dsurface.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName+'[关]');
        end;
        dsurface.BoldTextOut(SurfaceX(GLeft)+52, SurfaceY(GTop)+15, Color, clBlack, IntToStr(pm.Level));
        if pm.Level < 3 then
          dsurface.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
        else dsurface.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  wm: TWMImages;
  sKeyName: string;
  btKeyLeft: Byte;
  boPieceExp: Boolean;
const
  Num: array[0..9] of string[2] = ('零','一','二','三','四','五','六','七','八','九');
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    pm := nil;
    Idx := _Max(Tag + MagicPage * 5, 0);
    if Idx < g_MagicList.Count then begin
      pm := PTClientMagic (g_MagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
          end;
        end;
        sKeyName := '';
        case byte(pm.Key) of
          byte('1'): begin
            sKeyName := 'F1';
            btKeyLeft:= 15;
          end;
          byte('2'): begin
            sKeyName := 'F2';
            btKeyLeft:= 15;
          end;
          byte('3'): begin
            sKeyName := 'F3';
            btKeyLeft:= 15;
          end;
          byte('4'): begin
            sKeyName := 'F4';
            btKeyLeft:= 15;
          end;
          byte('5'): begin
            sKeyName := 'F5';
            btKeyLeft:= 15;
          end;
          byte('6'): begin
            sKeyName := 'F6';
            btKeyLeft:= 15;
          end;
          byte('7'): begin
            sKeyName := 'F7';
            btKeyLeft:= 15;
          end;
          byte('8'): begin
            sKeyName := 'F8';
            btKeyLeft:= 15;
          end;
          byte('E'): begin
            sKeyName := 'C+F1';
            btKeyLeft:= 5;
          end;
          byte('F'): begin
            sKeyName := 'C+F2';
            btKeyLeft:= 5;
          end;
          byte('G'): begin
            sKeyName := 'C+F3';
            btKeyLeft:= 5;
          end;
          byte('H'): begin
            sKeyName := 'C+F4';
            btKeyLeft:= 5;
          end;
          byte('I'): begin
            sKeyName := 'C+F5';
            btKeyLeft:= 5;
          end;
          byte('J'): begin
            sKeyName := 'C+F6';
            btKeyLeft:= 5;
          end;
          byte('K'): begin
            sKeyName := 'C+F7';
            btKeyLeft:= 5;
          end;
          byte('L'): begin
            sKeyName := 'C+F8';
            btKeyLeft:= 5;
          end;
        end;
        if sKeyName <> '' then
          dsurface.BoldTextOut(SurfaceX(GLeft)+btKeyLeft, SurfaceY(GTop)+20, $00FF00,clBlack, sKeyName);
        dsurface.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, clSilver, clBlack, pm.Def.sMagicName);
        if not (pm.btLevelEx in [1..9]) then begin
          boPieceExp := pm.Def.wMagicId in [68, 71]; //显示经验条
          d := g_WMainImages.Images[112]; //lv
          if d <> nil then begin
            if boPieceExp then
              dsurface.Draw (SurfaceX(GLeft)+94, SurfaceY(GTop)-1, d.ClientRect, d, TRUE)
            else dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
          end;
          if not boPieceExp then begin
            d := g_WMainImages.Images[111]; //exp
            if d <> nil then begin
              dsurface.Draw(SurfaceX(GLeft)+71, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
            end;
          end;
          case pm.Def.wMagicId of
            68: begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+108, SurfaceY(GTop)-2, clSilver, clBlack, IntToStr(pm.Level));
              DBNewJQExp.GLeft := GLeft+37;
              DBNewJQExp.GTop := GTop+22;
              if not DBNewJQExp.Visible then DBNewJQExp.Visible := True;
            end;
            71: begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+108, SurfaceY(GTop)-2, clSilver, clBlack, IntToStr(pm.Level));
              DBNewHBExp.GLeft := GLeft+37;
              DBNewHBExp.GTop := GTop+22;
              if not DBNewHBExp.Visible then DBNewHBExp.Visible := True;
            end;
            95: begin//斗转星移
              dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
            end;
            100: begin//神秘解毒
              dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Level = 15 then
                dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-')
              else dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]));
              DBNewJDSee.GLeft := GLeft+171;
              DBNewJDSee.GTop := GTop-1;
              if not DBNewJDSee.Visible then DBNewJDSee.Visible := True;
            end;
            103: begin//召唤巨魔
              dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
            end;
            104: begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              if pm.Level = 100 then
                dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-')
              else dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]));
            end;
            else begin
              dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
              if not (pm.Level in [0..4]) then pm.Level := 0;
              if pm.Level < 3 then
                dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
              else dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
            end;
          end;
        end else begin //强化技能
          if (pm.Def.wMagicId = 71) and DBNewHBExp.Visible then DBNewHBExp.Visible := False;
          dsurface.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)+15, clSilver, clBlack, '强化'+Num[pm.btLevelEx]+'重');
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStMag1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    pm := nil;
    idx := _Max(Tag + MagicPage * 5, 0);
    if idx < g_MagicList.Count then begin
      pm := PTClientMagic (g_MagicList[idx]);
      if pm <> nil then begin
        DScreen.ShowTzHint (SurfaceX(GLeft)+18,
                      SurfaceY(GTop)+31,
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y\(点击技能按钮设置快捷键)', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  i, idx: integer;
  selkey: word;
  keych: char;
  pm: PTClientMagic;
  icon :Integer;
  boChange: Boolean;
{$IFEND}
begin
{$IF M2Version <> 2}
  idx := _Max(TDButton(Sender).Tag + MagicPage * 5, 0);
  if (idx >= 0) and (idx < g_MagicList.Count) then begin
    pm := PTClientMagic (g_MagicList[idx]);
    selkey := word(pm.Key);
    GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
    if pm.Def.wMagicId <> 100 then begin //神秘解读
      SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey);
      keych := char(selkey);
      boChange := False;
      if g_MagicList.Count > 0 then //20080629
      for i:=0 to g_MagicList.Count-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if pm.Key = keych then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
           boChange := True;
        end;
      end;
      if not boChange then begin
        for i:=0 to g_XinFaMagic.Count-1 do begin
          pm := PTClientMagic (g_XinFaMagic[i]);
          if pm.Key = keych then begin
             pm.Key := #0;
             FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          end;
        end;
      end;
      pm := PTClientMagic (g_MagicList[idx]);
      pm.Key := keych;
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
    end else begin
      SetSkillMemoDlg(pm.Def.wMagicId, pm.Level, pm.Def.btEffect, pm.Def.sMagicName, '神秘解读');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHBExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*5+5, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 71) and (pm.Level < 100) then begin
            rc := d.ClientRect;
            if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
              rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHBExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*5+5, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 71) then begin
      if pm.Level < 100 then begin
        sMsg := '当前经验:%d/%d';
        with DBNewHBExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), clWhite, FALSE);
      end else begin
        sMsg := '当前经验:%d/-';
        with DBNewHBExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain]), clWhite, FALSE);
      end;
      Break;
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DBNewJQExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
   d: TDirectDrawSurface;
   pm: PTClientMagic;
   I: Integer;
   magline: Integer;
   rc: TRect;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, False);
      d := g_WMain2Images.Images[578];
      if d <> nil then begin
        magline := _MIN(MagicPage*5+5, g_MagicList.Count);
        for i:=magtop to magline-1 do begin
          pm := PTClientMagic (g_MagicList[i]);
          if (pm.Def.wMagicId = 68) then begin
            if (pm.Level < 100) then begin
              rc := d.ClientRect;
              if (pm.CurTrain > 0) and (pm.Def.MaxTrain[0] > 0) then begin
                rc.Right := Round((rc.Right-rc.Left) / pm.Def.MaxTrain[0] * pm.CurTrain);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, False);
              end;
            end;
            Break;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewJQExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  sMsg:String;
  pm: PTClientMagic;
  I: Integer;
  magline: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  magline := _MIN(MagicPage*5+5, g_MagicList.Count);
  for i:=magtop to magline-1 do begin
    pm := PTClientMagic (g_MagicList[i]);
    if (pm.Def.wMagicId = 68) then begin
      if (pm.Level < 100) then begin
        sMsg := '当前经验:%d/%d';
        with DBNewJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain, pm.Def.MaxTrain[0]]), $00A8D4E8, FALSE);
      end else begin
        sMsg := '当前经验:%d/-';
        with DBNewJQExp do
          DScreen.ShowHint(SurfaceX(GLeft), SurfaceY(GTop - 17), Format(sMsg,[pm.CurTrain]), $00A8D4E8, FALSE);
      end;
      Break;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.NewMagicBtnNotVisible;
begin
  if DBNewJDSee.Visible then DBNewJDSee.Visible := False;
  if DBNewHBExp.Visible then DBNewHBExp.Visible := False;
  if DBNewJQExp.Visible then DBNewJQExp.Visible := False;
end;

procedure TFrmDlg.DBNewStPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewStPageUp then begin
    if MagicPage > 0 then begin
      NewMagicBtnNotVisible;
      Dec (MagicPage);
    end;
  end else begin
    if MagicPage < (g_MagicList.Count+4) div 5 - 1 then begin
      NewMagicBtnNotVisible;
      Inc (MagicPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinPageTab5DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinPageTab5 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then 
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [MagicPage+1, (g_MagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DCheckNewDeputyHeroWarrClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  msg: TDefaultMessage;
{$IFEND}
begin
{$IF M2Version <> 2}
  if Sender = DCheckNewDeputyHeroWarr then begin
    DCheckNewDeputyHeroWarr.Checked := True;
    DCheckNewDeputyHeroWiz.Checked := False;
    DCheckNewDeputyHeroTaos.Checked := False;
  end else if Sender = DCheckNewDeputyHeroWiz then begin
    DCheckNewDeputyHeroWarr.Checked := False;
    DCheckNewDeputyHeroWiz.Checked := True;
    DCheckNewDeputyHeroTaos.Checked := False;
  end else begin
    DCheckNewDeputyHeroWarr.Checked := False;
    DCheckNewDeputyHeroWiz.Checked := False;
    DCheckNewDeputyHeroTaos.Checked := True;
  end;
  m_btDeputyHeroJob := TDButton(Sender).Tag;
  msg := MakeDefaultMsg (aa(CM_CHOOSEHEROJOB, frmMain.TempCertification), m_btDeputyHeroJob, 0, 0, 0, frmMain.m_nSendMsgCount);
  frmMain.SendSocket(EncodeMessage (msg));
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinNGPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateWinNGPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateWinNGPage.ActivePage = 0 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $4AA6EF, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $4AA6EF, clBlack, '态');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $639ABD, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $639ABD, clBlack, '态');
    end;
    if DPNewStateWinNGPage.ActivePage = 1 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $4AA6EF, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $4AA6EF, clBlack, '能');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $639ABD, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $639ABD, clBlack, '能');
    end;
    {$IF M2Version = 1}
    if DPNewStateWinNGPage.ActivePage = 2 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $4AA6EF, clBlack, '经');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $4AA6EF, clBlack, '络');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $639ABD, clBlack, '经');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $639ABD, clBlack, '络');
    end;
    if DPNewStateWinNGPage.ActivePage = 3 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $4AA6EF, clBlack, '连');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $4AA6EF, clBlack, '击');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $639ABD, clBlack, '连');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $639ABD, clBlack, '击');
    end;
    {$IFEND}
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinNGPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateWinNGPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateWinNGPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateWinNGPage.ActivePage := 1;
    NewNGUpLevelState(False);
{$IF M2Version = 1}
  end else
  if (ly >= 91) and (ly <= 130) then begin
    ChangeNGPointPage();
    DBNewWinPointPage2.Visible := g_HumanPulseArr[0].boOpenPulse;
    DBNewWinPointPage3.Visible := g_HumanPulseArr[1].boOpenPulse;
    DBNewWinPointPage4.Visible := g_HumanPulseArr[2].boOpenPulse;
    DPNewStateWinNGPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateWinNGPage.ActivePage := 3;
{$IFEND}
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_MySelf = nil then Exit;
  with DWNewStateWinNGPageTab1 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 47, clSilver, clBlack, '当前内功等级  '+IntToStr(g_dwInternalForceLevel));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 67, clSilver, clBlack, '当前内功经验  '+IntToStr(g_dwExp69));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 87, clSilver, clBlack, '升级内功经验  '+IntToStr(g_dwMaxExp69));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 107, clSilver, clBlack, Format('内 力 值  %d/%d', [g_MySelf.m_Skill69NH, g_MySelf.m_Skill69MaxNH]));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 127, clSilver, clBlack, '内功恢复速度  '+IntToStr(g_nInternalRecovery));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 147, clSilver, clBlack, '内功伤害增加  '+IntToStr(g_nInternalHurtAdd));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 167, clSilver, clBlack, '内功伤害减免  '+IntToStr(g_nInternalHurtRelief));
  end;
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinNGPageTab2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinNGPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [InternalForceMagicPage+1, (g_InternalForceMagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterTopMag1Click(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewWinBatterTopMag4 then begin
    if not g_boOpen4BatterSkill then Exit;
  end;
  if g_WinBatterMagicList.Count > 0 then begin
    DBNewWinBatterCom.GLeft := TDButton(Sender).GLeft-2;
    DBNewWinBatterCom.GTop := TDButton(Sender).GTop+TDButton(Sender).GHeight+1;
    BatterTopMagIndex := TDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
    WinBatterComIndex := -1;
    DBNewWinBatterCom.Visible := True;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Icon: Integer;
begin
  {$IF M2Version = 1}
  with Sender as TDButton do begin
    if Sender = DBNewWinBatterTopMag4 then begin
      if not g_boOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft-3), SurfaceY(GTop-5), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;
    if g_WinBatterMagicList.Count > 0 then begin
      if g_WinBatterTopMagic[Tag].Def.sMagicName <> '' then begin
        Icon := GetBatterMagicIcon(g_WinBatterTopMagic[Tag].Def.btEffect);
        if Icon > -1 then begin
          if Downed then
            d := g_WMainImages.Images[icon+1]
          else d := g_WMainImages.Images[icon];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        if Downed then begin
          if g_WinBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2+1];
          end;
        end else begin
          if g_WinBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if (g_WinBatterTopMagic[0].Def.sMagicName = '') and (g_WinBatterTopMagic[1].Def.sMagicName = '') and (g_WinBatterTopMagic[2].Def.sMagicName = '') and (g_WinBatterTopMagic[3].Def.sMagicName = '')
           and (g_WinBatterTopMagic[0].CurTrain <> 1) and (g_WinBatterTopMagic[1].CurTrain <> 1) and (g_WinBatterTopMagic[2].CurTrain <> 1) and (g_WinBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DBNewWinBatterTopMag1 then begin
            if (not Downed) and (not DBNewWinBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft)+10, SurfaceY(GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;
procedure TFrmDlg.DBNewWinBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewWinBatterTopMag1 then begin
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterTopMag2 then begin
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterTopMag3 then begin
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterTopMag4 then begin
    if not g_boOpen4BatterSkill then Exit;
    DScreen.ShowHint(DBNewWinBatterTopMag1.SurfaceX(DBNewWinBatterTopMag1.GLeft) - 137, DBNewWinBatterTopMag1.SurfaceY(DBNewWinBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterRandom then begin
    DScreen.ShowHint(DBNewWinBatterRandom.SurfaceX(DBNewWinBatterRandom.GLeft), DBNewWinBatterRandom.SurfaceY(DBNewWinBatterRandom.GTop+DBNewWinBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewWinBatterSetKey then begin
    DScreen.ShowHint(DBNewWinBatterSetKey.SurfaceX(DBNewWinBatterSetKey.GLeft) - 60, DBNewWinBatterSetKey.SurfaceY(DBNewWinBatterSetKey.GTop+DBNewWinBatterSetKey.GHeight),
       '设置施展连击的快捷键'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterComClick(Sender: TObject; X, Y: Integer);
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
begin
  if WinBatterComIndex <> - 1 then begin
    if g_WinBatterMagicList.Count - WinBatterComIndex > 0 then begin
      for I:=Low(g_WinBatterTopMagic) to High(g_WinBatterTopMagic) do begin
        if g_WinBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_WinBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_WinBatterTopMagic[BatterTopMagIndex] := pTClientMagic(g_WinBatterMagicList.Items[WinBatterComIndex])^;
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 0;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_WinBatterMagicList[WinBatterComIndex]);
      pm.Key := Chr(BatterTopMagIndex + 1);
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, Chr(BatterTopMagIndex + 1), str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = 0 then begin//空
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end else
    if g_WinBatterMagicList.Count - WinBatterComIndex = -1 then begin//随机
      FillChar (g_WinBatterTopMagic[BatterTopMagIndex], sizeof(TClientMagic), #0);
      g_WinBatterTopMagic[BatterTopMagIndex].CurTrain := 1;
      if g_WinBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_WinBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_WinBatterMagicList[i]);
        if Ord(pm.Key) = (BatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_WinBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_WinBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_WinBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendMagicKeyChange (-1, #0, str);
    end;
    DBNewWinBatterCom.Visible := False;
  end;
end;

procedure TFrmDlg.DBNewWinBatterComDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  I: Integer;
  btLine: Byte;
  sStr: string;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewWinBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if WinBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+WinBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+WinBatterComIndex*15+19), clNavy);
    end;
    btLine := _MIN(4, g_WinBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_WinBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_WinBatterMagicList.Items[I]).Def.sMagicName;
        if I = WinBatterComIndex then
          dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if WinBatterComIndex = btLine then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if WinBatterComIndex = btLine +1 then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  btLine: Byte;
  ss: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewWinBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_WinBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    WinBatterComIndex := ss;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  trainlv: Byte;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TDButton do begin
    pm := nil;
    if Tag < g_WinBatterMagicList.Count then begin
      pm := PTClientMagic (g_WinBatterMagicList[Tag]);
      if pm <> nil then begin
        if pm.Def.sMagicName <> '' then begin
          Icon := GetBatterMagicIcon(pm.Def.btEffect);
          if Icon > -1 then begin
            if Downed then
              d := g_WMainImages.Images[Icon+1]
            else d := g_WMainImages.Images[Icon];
            if d <> nil then
              dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          d := g_WMainImages.Images[112]; //lv
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          if not (pm.Level in [0..5]) then pm.Level := 0;
          case pm.Def.btEffect of
            102..104: begin
              case Ord(pm.Key) of
                1:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+15%暴击');
                end;
                3: begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+25%暴击');
                end;
                4: begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+30%暴击');
                end;
                else
                dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%暴击');
              end;
            end;
            105..107: begin
              case Ord(pm.Key) of
                 1:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+10%暴击');
                 end;
                 2:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+15%暴击');
                 end;
                 3:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+25%暴击');
                 end;
                 4:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+30%暴击');
                 end;
                 else dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%暴击');
              end;
            end;
            108..110: begin
              case Ord(pm.Key) of
                1:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+30%暴击');
                end;
                else dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%暴击');
              end;
            end;
            111..113: begin
              case Ord(pm.Key) of
                1:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+30%暴击');
                end;
                else dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%暴击');
              end;
            end;
          end;
          if pm.Level in [0..3,5] then trainlv := pm.Level
          else if pm.Level = 4 then trainlv := 3
          else trainlv := 0;
          dsurface.BoldTextOut (SurfaceX(GLeft)+52, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
          if pm.Def.MaxTrain[trainlv] > 0 then begin
             if trainlv < 5 then
                dsurface.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
             else dsurface.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  sLines: string;
{$IFEND}
begin
{$IF M2Version = 1}
  pm := nil;
  with TDButton(Sender) do begin
    if g_WinBatterMagicList.Count - 1 >= Tag then begin
      pm := PTClientMagic (g_WinBatterMagicList[Tag]);
      if pm <> nil then begin
        case pm.Def.btEffect of
          102: begin  //三绝杀
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          111: begin //横扫千军
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以自身为/c=Yellow>\<中心，对5*5范围内的目标造成/c=Yellow>\<伤害/c=Yellow>';
          end;
          105: begin //追心刺
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，冲撞单体/c=Yellow>\<目标，在迫使其后退的同时，造/c=Yellow>\<成伤害/c=Yellow>';
          end;
          108: begin //断岳斩
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对三步内/c=Yellow>\<的单体目标造成伤害/c=Yellow>';
          end;
          112, 113: begin //冰天雪地 万剑归宗
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以目标为/c=Yellow>\<中心，对5*5范围内造成持续伤/c=Yellow>\<害/c=Yellow>';
          end;
          else sLines := '';
        end;
        if sLines <> '' then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth, SurfaceY(GTop)+GHeight, sLines, False)
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinNGPageTab3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  wXueWeiTiao: Word;
{$IFEND}
begin
{$IF M2Version = 1}
  if g_MySelf = nil then exit;
  with DWNewStateWinNGPageTab3 do begin
    if WLib <> nil then begin //20080701
      if g_MySelf.m_btSex = 1 then begin //女
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 4]
        else d := WLib.Images[FaceIndex + 5];
      end else begin
        if StatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 6]
        else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    //右上角标志
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1171]
    else d := g_WMainImages.Images[830+StatePulsePage];
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft) + 144, SurfaceY(GTop) + 11, d.ClientRect, d, TRUE);
    //经络穴位条
    if StatePulsePage = 0 then begin//冲脉,冲脉读老资源
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        wXueWeiTiao := 860
      else wXueWeiTiao := 861+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[wXueWeiTiao];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d, 255);
    end else begin
      if not g_HumanPulseArr[StatePulsePage].boOpenPulse then
        wXueWeiTiao := 2280
      else wXueWeiTiao := 2281+g_HumanPulseArr[StatePulsePage].nPulseLevel;
      d := g_WUI1Images.Images[wXueWeiTiao-(StatePulsePage-1) * 10];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, d, 255);
    end;
    //穴位针位
    if StatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1172]
    else d := g_WMainImages.Images[840+StatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d.ClientRect, d, TRUE);

    if StatePulsePage <> 4 then begin
      if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
        case g_HumanPulseArr[StatePulsePage].nPulseLevel of
          0: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
          end;
          1: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          2: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          3: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          4: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          5: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
        end;
      end else begin
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointIcon1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TDButton do begin
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= Tag+1 then
      d := g_WMainImages.Images[851]
    else if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = Tag+1)) or (StatePulsePage = 4){奇经} then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

    if ((g_btPulseOriginPage = StatePulsePage) or (StatePulsePage = 4){奇经}) and (g_btPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;

    if ((g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = Tag+1)) or ((StatePulsePage = 4) and (g_HumanPulseArr[StatePulsePage].nPulsePoint = 0) and (Tag = 0)){奇经} then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 255);
      end;
    end; 
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointIcon1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if StatePulsePage = 4 then begin//奇经
      if TDControl(Sender).Tag = 0 then begin
        if g_HumanPulseArr[StatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenPulsePoint(StatePulsePage, 1);
        end else begin
          ShowQJPractice(False);
        end;
      end;
      frmMain.SendOpenPulsePoint(StatePulsePage, TDControl(Sender).Tag+1);
    end else begin
      frmMain.SendOpenPulsePoint(StatePulsePage, TDControl(Sender).Tag+1);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointIcon1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  sLines, sPointName, sPulsDesc: string;

  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwInternalForceLevel >= nlevel then Result := '~y';
  end;
{$IFEND}
begin
{$IF M2Version = 1}
  if StatePulsePage = 4 then begin
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= TDControl(Sender).Tag+1 then begin //已打通
      DScreen.ShowHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), '神冲穴: 已打通,点击可修炼\ \奇经穴位，通过奇经神冲丸\打通，可点击进行修炼，提\升斗转星移技能等级。' , clWhite, FALSE);
    end else begin
      DScreen.ShowTzHint (TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop),
                  '神冲穴:待打通'+'~y\', FALSE, FALSE, 0);
    end;
  end else begin
    sPointName := GetPulseName(StatePulsePage,TDControl(Sender).Tag);
    if g_HumanPulseArr[StatePulsePage].nPulsePoint >= TDControl(Sender).Tag+1 then begin //已打通
      if sPointName <> '' then begin
        sLines := Format('%s穴:已打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'已通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' +  sPulsDesc;
        DScreen.ShowHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), sLines, clYellow, FALSE);
      end;
    end else if (g_btPulseOriginPage = StatePulsePage) and (g_btPulsePoint = TDControl(Sender).Tag+1) then begin //待打
      if sPointName <> '' then begin
        sLines := Format('%s穴:待打通~y\需要内功等级：%d',[sPointName, g_btPulseLevel])+GetRGB(g_btPulseLevel);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowTzHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), sLines, FALSE, FALSE, 0);
      end;
    end else begin
      if sPointName <> '' then begin
        sLines := Format('%s穴:目前不可打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), sLines, clRed, FALSE);
      end;
    end;
  end;
{$IFEND}
end;

{$IF M2Version = 1}
procedure TFrmDlg.ChangeNGPointPage();
begin
  //32 12
  DLNewWinPointName1.Caption := GetPulseName(StatePulsePage,0);
  DLNewWinPointName2.Caption := GetPulseName(StatePulsePage,1);
  DLNewWinPointName3.Caption := GetPulseName(StatePulsePage,2);
  DLNewWinPointName4.Caption := GetPulseName(StatePulsePage,3);
  DLNewWinPointName5.Caption := GetPulseName(StatePulsePage,4);
  case StatePulsePage of
    0: DBNewWinPointPractice.Caption := '修炼冲脉';
    1: DBNewWinPointPractice.Caption := '修炼阴跷';
    2: DBNewWinPointPractice.Caption := '修炼阴维';
    3: DBNewWinPointPractice.Caption := '修炼任脉';
    4: DBNewWinPointPractice.Caption := '修炼奇经';
  end;
  DBNewWinPointPractice.Enabled := not (g_HumanPulseArr[StatePulsePage].nPulseLevel >= 5) or ((g_HumanPulseArr[StatePulsePage].nPulsePoint = 0) and (StatePulsePage = 4));
  case StatePulsePage of
    0: begin
      DBNewWinPointIcon1.GLeft := 69;
      DBNewWinPointIcon1.GTop := 42;
      DBNewWinPointIcon2.GLeft := 68;
      DBNewWinPointIcon2.GTop := 71;
      DBNewWinPointIcon3.GLeft := 70;
      DBNewWinPointIcon3.GTop := 96;
      DBNewWinPointIcon4.GLeft := 77;
      DBNewWinPointIcon4.GTop := 118;
      DBNewWinPointIcon5.GLeft := 84;
      DBNewWinPointIcon5.GTop := 100;
      DLNewWinPointName1.GLeft := 113;
      DLNewWinPointName1.GTop := 47;
      DLNewWinPointName2.GLeft := 112;
      DLNewWinPointName2.GTop := 76;
      DLNewWinPointName3.GLeft := 34;
      DLNewWinPointName3.GTop := 101;
      DLNewWinPointName4.GLeft := 38;
      DLNewWinPointName4.GTop := 123;
      DLNewWinPointName5.GLeft := 118;
      DLNewWinPointName5.GTop := 104;
    end;
    1: begin
      DBNewWinPointIcon1.GLeft := 80;
      DBNewWinPointIcon1.GTop := 36;
      DBNewWinPointIcon2.GLeft := 80;
      DBNewWinPointIcon2.GTop := 76;
      DBNewWinPointIcon3.GLeft := 85;
      DBNewWinPointIcon3.GTop := 116;
      DBNewWinPointIcon4.GLeft := 93;
      DBNewWinPointIcon4.GTop := 155;
      DBNewWinPointIcon5.GLeft := 96;
      DBNewWinPointIcon5.GTop := 196;
      DLNewWinPointName1.GLeft := 36;
      DLNewWinPointName1.GTop := 41;
      DLNewWinPointName2.GLeft := 36;
      DLNewWinPointName2.GTop := 80;
      DLNewWinPointName3.GLeft := 123;
      DLNewWinPointName3.GTop := 120;
      DLNewWinPointName4.GLeft := 56;
      DLNewWinPointName4.GTop := 158;
      DLNewWinPointName5.GLeft := 61;
      DLNewWinPointName5.GTop := 201;
    end;
    2: begin
      DBNewWinPointIcon1.GLeft := 80;
      DBNewWinPointIcon1.GTop := 50;
      DBNewWinPointIcon2.GLeft := 74;
      DBNewWinPointIcon2.GTop := 80;
      DBNewWinPointIcon3.GLeft := 73;
      DBNewWinPointIcon3.GTop := 118;
      DBNewWinPointIcon4.GLeft := 69;
      DBNewWinPointIcon4.GTop := 151;
      DBNewWinPointIcon5.GLeft := 66;
      DBNewWinPointIcon5.GTop := 187;
      DLNewWinPointName1.GLeft := 35;
      DLNewWinPointName1.GTop := 53;
      DLNewWinPointName2.GLeft := 115;
      DLNewWinPointName2.GTop := 85;
      DLNewWinPointName3.GLeft := 33;
      DLNewWinPointName3.GTop := 122;
      DLNewWinPointName4.GLeft := 103;
      DLNewWinPointName4.GTop := 156;
      DLNewWinPointName5.GLeft := 99;
      DLNewWinPointName5.GTop := 192;
    end;
    3: begin
      DBNewWinPointIcon1.GLeft := 80;
      DBNewWinPointIcon1.GTop := 32;
      DBNewWinPointIcon2.GLeft := 81;
      DBNewWinPointIcon2.GTop := 52;
      DBNewWinPointIcon3.GLeft := 81;
      DBNewWinPointIcon3.GTop := 73;
      DBNewWinPointIcon4.GLeft := 80;
      DBNewWinPointIcon4.GTop := 97;
      DBNewWinPointIcon5.GLeft := 81;
      DBNewWinPointIcon5.GTop := 121;
      DLNewWinPointName1.GLeft := 34;
      DLNewWinPointName1.GTop := 37;
      DLNewWinPointName2.GLeft := 126;
      DLNewWinPointName2.GTop := 57;
      DLNewWinPointName3.GLeft := 36;
      DLNewWinPointName3.GTop := 79;
      DLNewWinPointName4.GLeft := 125;
      DLNewWinPointName4.GTop := 102;
      DLNewWinPointName5.GLeft := 37;
      DLNewWinPointName5.GTop := 126;
    end;
    4: begin
      DBNewWinPointIcon1.GLeft := 79;
      DBNewWinPointIcon1.GTop := 28;
      DBNewWinPointIcon2.GLeft := 124;
      DBNewWinPointIcon2.GTop := 114;
      DBNewWinPointIcon3.GLeft := 35;
      DBNewWinPointIcon3.GTop := 113;
      DBNewWinPointIcon4.GLeft := 97;
      DBNewWinPointIcon4.GTop := 197;
      DBNewWinPointIcon5.GLeft := 61;
      DBNewWinPointIcon5.GTop := 198;
      DLNewWinPointName1.GLeft := 36;
      DLNewWinPointName1.GTop := 36;
      DLNewWinPointName2.GLeft := 100;
      DLNewWinPointName2.GTop := 106;
      DLNewWinPointName3.GLeft := 58;
      DLNewWinPointName3.GTop := 128;
      DLNewWinPointName4.GLeft := 74;
      DLNewWinPointName4.GTop := 190;
      DLNewWinPointName5.GLeft := 35;
      DLNewWinPointName5.GTop := 202;
    end;
  end;
end;
{$IFEND}

procedure TFrmDlg.DBNewWinPointPage1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version =1}
  if StatePulsePage <> TDButton(Sender).Tag then begin
    StatePulsePage := TDButton(Sender).Tag;
    ChangeNGPointPage();
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPage1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if StatePulsePage = Tag then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    if StatePulsePage = Tag then
      Color := $73B2DE
    else Color := $5282A5;
    if not Downed then
      dsurface.BoldTextOut(SurfaceX(GLeft)+4, SurfaceY(GTop)+5, Color, clBlack, Caption)
    else dsurface.BoldTextOut(SurfaceX(GLeft)+5, SurfaceY(GTop)+6, Color, clBlack, Caption);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPracticeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if (g_HumanPulseArr[StatePulsePage].boOpenPulse) then begin
      if g_HumanPulseArr[StatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendPracticePulse(StatePulsePage);
      end;
    end else begin
      case StatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HumanPulseArr[StatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(False);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewWinPointPracticeDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  btWidth, btHeight: Byte;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin //20080701
      btWidth := GWidth div 2 - FrmMain.Canvas.TextWidth(Caption) div 2;
      btHeight := GHeight div 2 - FrmMain.Canvas.TextHeight(Caption) div 2;
      if not Enabled then begin
         d := WLib.Images[FaceIndex];
         if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        dsurface.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight{+ 5}, $0099A8AC, clBlack, Caption);
        Exit;
      end;
      if Downed then begin
        d := WLib.Images[FaceIndex + 1];
        if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
        dsurface.BoldTextOut (SurfaceX(GLeft) + btWidth+1, SurfaceY(GTop) + btHeight + 1{SurfaceY(GTop) + 6}, $0048A4E8, clBlack, Caption);
      end else begin
        if MouseMoveing then begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
              dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
          dsurface.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight, $00A8D4E8, clBlack, Caption);
        end else begin
          d := WLib.Images[FaceIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          dsurface.BoldTextOut (SurfaceX(GLeft) + btWidth, SurfaceY(GTop) + btHeight, $0088C4E8, clBlack, Caption);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinXFPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateWinXFPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateWinXFPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateWinXFPage.ActivePage := 1;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateWinXFPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateWinXFPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateWinXFPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateWinXFPage.ActivePage = 0 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '心');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '法');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '心');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '法');
    end;
    if DPNewStateWinXFPage.ActivePage = 1 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '神');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '技');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '神');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '技');
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  i, idx: integer;
  selkey: word;
  keych: char;
  pm: PTClientMagic;
  icon :Integer;
  boChange: Boolean;
{$IFEND}
begin
{$IF M2Version <> 2}
  idx := _Max(TDButton(Sender).Tag + m_btXinFaPage * 5, 0);
  if (idx >= 0) and (idx < g_XinFaMagic.Count) then begin
    pm := PTClientMagic (g_XinFaMagic[idx]);
    if pm.Def.wMagicId in [105, 110..111,112..114] then begin
      selkey := word(pm.Key);
      GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, icon);
      SetMagicKeyDlg (icon,pm.Def.btEffect, pm.Level, pm.btLevelEx, pm.Def.wMagicId, pm.Def.sMagicName, selkey);
      keych := char(selkey);
      boChange := False;
      if g_MagicList.Count > 0 then //20080629
      for i:=0 to g_MagicList.Count-1 do begin
        pm := PTClientMagic (g_MagicList[i]);
        if pm.Key = keych then begin
           pm.Key := #0;
           FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
           boChange := True;
        end;
      end;
      if not boChange then begin
        for i:=0 to g_XinFaMagic.Count-1 do begin
          pm := PTClientMagic (g_XinFaMagic[i]);
          if pm.Key = keych then begin
             pm.Key := #0;
             FrmMain.SendMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
             boChange := True;
          end;
        end;
      end;
      pm := PTClientMagic (g_XinFaMagic[idx]);
      pm.Key := keych;
      FrmMain.SendMagicKeyChange (pm.Def.wMagicId, keych, '');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  wm: TWMImages;
  sKeyName: string;
  btKeyLeft: Byte;
  boPieceExp: Boolean;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    pm := nil;
    Idx := _Max(Tag + m_btXinFaPage * 5, 0);
    if Idx < g_XinFaMagic.Count then begin
      pm := PTClientMagic (g_XinFaMagic[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
          end;
        end;
        sKeyName := '';
        case byte(pm.Key) of
          byte('1'): begin
            sKeyName := 'F1';
            btKeyLeft:= 15;
          end;
          byte('2'): begin
            sKeyName := 'F2';
            btKeyLeft:= 15;
          end;
          byte('3'): begin
            sKeyName := 'F3';
            btKeyLeft:= 15;
          end;
          byte('4'): begin
            sKeyName := 'F4';
            btKeyLeft:= 15;
          end;
          byte('5'): begin
            sKeyName := 'F5';
            btKeyLeft:= 15;
          end;
          byte('6'): begin
            sKeyName := 'F6';
            btKeyLeft:= 15;
          end;
          byte('7'): begin
            sKeyName := 'F7';
            btKeyLeft:= 15;
          end;
          byte('8'): begin
            sKeyName := 'F8';
            btKeyLeft:= 15;
          end;
          byte('E'): begin
            sKeyName := 'C+F1';
            btKeyLeft:= 5;
          end;
          byte('F'): begin
            sKeyName := 'C+F2';
            btKeyLeft:= 5;
          end;
          byte('G'): begin
            sKeyName := 'C+F3';
            btKeyLeft:= 5;
          end;
          byte('H'): begin
            sKeyName := 'C+F4';
            btKeyLeft:= 5;
          end;
          byte('I'): begin
            sKeyName := 'C+F5';
            btKeyLeft:= 5;
          end;
          byte('J'): begin
            sKeyName := 'C+F6';
            btKeyLeft:= 5;
          end;
          byte('K'): begin
            sKeyName := 'C+F7';
            btKeyLeft:= 5;
          end;
          byte('L'): begin
            sKeyName := 'C+F8';
            btKeyLeft:= 5;
          end;
        end;
        if sKeyName <> '' then
          dsurface.BoldTextOut(SurfaceX(GLeft)+btKeyLeft, SurfaceY(GTop)+20, $00FF00,clBlack, sKeyName);
        dsurface.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, clSilver, clBlack, pm.Def.sMagicName);
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then begin
            dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        end;
        dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
        //if not (pm.Level in [0..4]) then pm.Level := 0;
        if pm.Def.wMagicId in [107..109] then begin
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+71, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          end;
          if pm.Level < 10 then
            dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]))
          else dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, clSilver, clBlack, '-');
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBWinXinFaMagPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBWinXinFaMagPageUp then begin
    if m_btXinFaPage > 0 then begin
      Dec (m_btXinFaPage);
    end;
  end else begin
    if m_btXinFaPage < (g_XinFaMagic.Count+4) div 5 - 1 then begin
      Inc (m_btXinFaPage);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinXFPageTab2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinXFPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [m_btXinFaPage+1, (g_XinFaMagic.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

{$IF M2Version <> 2}
/// <param name="boVisible">是否显示</param>
/// <param name="boIsXinFa">True为心法,False为内功</param>
procedure TFrmDlg.SetNewWinStateTabVisible(boVisible, boIsXinFa: Boolean);
begin
  if boVisible then begin//显示
    DBNewStateTab3.Visible := boIsXinFa or DBNewStateTab3.Visible; //心法
    DBNewStateTab2.Visible := True; //有心法或内功都显示
    DBNewStateTab1.Visible := True;
  end else begin
    if boIsXinFa then begin
      DBNewStateTab3.Visible := False;
      g_boXinFaType := False;
    end else begin
      DBNewStateTab2.Visible := False;
      DBNewStateTab1.Visible := False
    end;
  end;
end;

/// <param name="boVisible">是否显示</param>
procedure TFrmDlg.SetNewHeroStateTabVisible(boVisible: Boolean);
begin
  DBNewStateHeroTab2.Visible := boVisible;
  DBNewStateHeroTab1.Visible := boVisible;
end;
{$IFEND}

procedure TFrmDlg.DBXinfaExpAbsorbClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if g_boXinFaType and (GetTickCount > g_dwQueryMsgTick) then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    frmMain.SendXinfaExpAbsorb;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaExpDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  pcm: PTClientMagic;
  rc : TRect;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  d := g_WUI1Images.Images[1607];
  if d <> nil then begin
    for I:=0 to g_XinFaMagic.Count-1 do begin
      pcm := pTClientMagic(g_XinFaMagic[I]);
      if pcm <> nil then begin
        if pcm.Def.wMagicId in [105, 106] then begin
          rc := d.ClientRect;
          if (pcm.CurTrain > 0)  and (pcm.Level < 100) then begin
            rc.Right := Round((rc.Right-rc.Left) / pcm.Def.MaxTrain[0] * pcm.CurTrain);
            with DBXinFaExp do 
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
          end;
          Break;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaExpMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
  function GetJobMemo(): string;
  begin
    Result := '';
    if g_MySelf <> nil then
      case g_MySelf.m_btJob of
        1: Result := '魔法';
        2: Result := '道术';
        else Result := '攻击';
      end;
  end;
const                                      //M
  sLongWeiLines = '心法经验吸收：<%d/%d/c=Red>\'+
                  ' \'+
                  '<心法下一级即可获得：/c=Lime>\'+
                  '神圣%s：<%d-%d/c=Red>\'+
                  '%s\'+
                  '对心法等级<%d/c=Red>级以下的玩家造成加成伤害';
  sChuanChengLines = '师门人气值：<%d/%d/c=Red>\'+
                     ' \'+
                     '<心法下一级/c=Yellow>\'+
                     '<升级需求：/c=Yellow>\'+
                     '<师父心法等级/c=Yellow><%d/c=Red><级/c=Yellow>\'+
                     '<本人等级/c=Yellow><%d/c=Red><级/c=Yellow>\'+
                     '<师门弟子通过完成任务获得/c=Yellow>\'+
                     '<传承心法经验/c=Yellow>';
var
  I: Integer;
  pcm: PTClientMagic;
  sShenSheng: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBXinFaExp do
  if g_HeartAbility.boHeartTpye then begin
    for I:=0 to g_XinFaMagic.Count-1 do begin
      pcm := PTClientMagic(g_XinFaMagic[I]);
      if pcm <> nil then begin
        if pcm.Def.wMagicId = 105 then begin
          if g_HeartAbility.sUpLevelSKillName = '' then
            sShenSheng := ''
          else sShenSheng := '可以学习<'+g_HeartAbility.sUpLevelSKillName+'/c=Red>';
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+20,
                                Format(sLongWeiLines, [pcm.CurTrain, pcm.Def.MaxTrain[0],
                                GetJobMemo, g_HeartAbility.wMainPower, g_HeartAbility.wMainMaxPower,
                                       sShenSheng, _Max(0, pcm.Level-1)]), False);
        end;
      end;
    end;
  end else begin
    for I:=0 to g_XinFaMagic.Count-1 do begin
      pcm := PTClientMagic(g_XinFaMagic[I]);
      if pcm <> nil then begin
        if pcm.Def.wMagicId = 106 then begin;
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-40, SurfaceY(GTop)+20,
                                Format(sChuanChengLines, [pcm.CurTrain, pcm.Def.MaxTrain[0],
                                g_HeartAbility.wUpPassHeartLevel, g_HeartAbility.wUpLevel]), False);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateWinXFPageTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  pcm: PTClientMagic;
  I: Integer;
const
  XinFaImages: array[0..4] of Word = (1890, 1770, 1830, 1860, 1800);
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinXFPageTab1 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      for I:=0 to g_XinFaMagic.Count-1 do begin
        pcm := pTClientMagic(g_XinFaMagic[I]);
        if pcm <> nil then begin
          if pcm.Def.wMagicId in [105, 106] then begin
            if pcm.Level > 99 then
              dsurface.BoldTextOut(SurfaceX(GLeft)+41, SurfaceY(GTop)+39, $8CC7EF, clBlack, 'MAX')
            else dsurface.BoldTextOut(SurfaceX(GLeft)+41, SurfaceY(GTop)+39, $8CC7EF, clBlack, IntToStr(pcm.Level));
            Break;
          end;
        end;
      end;
      d := g_WUI1Images.Images[2311];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+66, SurfaceY(GTop)+39, d, 255);
      with g_LingWuXinFa do begin
        if GetTickCount - dwStartTimeTick > 100 then begin
          dwStartTimeTick := GetTickCount;
          Inc(btCurrentFrame);
          if btCurrentFrame > 19 then btCurrentFrame := 0;
        end;
        d := WLib.Images[XinFaImages[g_HeartAbility.nHeartTpye]+btCurrentFrame];
      end;
      if d <> nil then begin
        DrawBlend(dsurface, SurfaceX(GLeft)+64, SurfaceY(GTop)+66, d, 255);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBXinFaAbdomenMouseHintMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version <> 2}
const
  XinFaHint: array[0..4] of string = (
    ('紫金为帝王之象，紫金心法戾气最重。\性格杀伐果断，十荡十决的勇气适合修\炼紫金心法，紫金心法讲究大开大合，\包罗万象。'),
    ('乙木为自然循环往生的法则，天生怀一\个怜悯之心的人，则适合修炼乙木心法\，乙木心法运行讲究生生不息，气息悠\长，最善持久战。'),
    ('大地心法主旨沉稳，不动如山。肉体强\横，老成持重的人最适合此类心法，大\地心法的运行讲究一力降十会，以拙破\巧，先立于不败之地。'),
    ('抽刀水更流，四两拨千斤。葵水心法讲\究以柔克刚，劲力阴柔，伤人经脉。修\习葵水心法讲究平心静气，后发制人，\适合心态平和之人。'),
    ('阳炎天火，焚尽万物。习此心法者，功\法凶狠毒辣，招招搏命。阳炎心法以怒\火仇恨为根本，有时伤敌伤己，爆发力\最是强劲。')
  );
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBXinFaAbdomenMouseHint do
  DScreen.ShowSpecialHint(SurfaceX(GLeft)-160, SurfaceY(GTop)+20,
                          '<'+g_XinFaName[g_HeartAbility.nHeartTpye]+'心法/c=Yellow>\'+XinFaHint[g_HeartAbility.nHeartTpye], False);
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  nTitleWidth: Integer;
  sTitleName: string;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHero do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      frmMain.Canvas.Font.Style := [fsBold];
      if g_boIsHeroInternalForce then begin  //有内功
        d := WLib.Images[2245-DPNewStateHeroTab.ActivePage];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+14, SurfaceY(GTop)+55, d.ClientRect, d, True);
        if DPNewStateHeroTab.ActivePage = 0 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        dsurface.BoldTextOut(SurfaceX(GLeft)+74, SurfaceY(GTop)+57, Color, clBlack, '基础');
        if DPNewStateHeroTab.ActivePage = 1 then
          Color := $00A8D4E8
        else Color := $00708CA0;
        dsurface.BoldTextOut(SurfaceX(GLeft)+154, SurfaceY(GTop)+57, Color, clBlack, '内功');
      end;
      frmMain.Canvas.Font.Style := [];
    end;
    dsurface.TextOut(SurfaceX(GLeft + 142 - frmMain.Canvas.TextWidth(g_HeroSelf.m_sUserName) div 2),
                     SurfaceY(GTop + 38), g_HeroSelf.m_nNameColor, g_HeroSelf.m_sUserName);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateHeroPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateHeroPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateHeroPage.ActivePage = 0 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '装');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '备');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '装');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '备');
    end;
    if DPNewStateHeroPage.ActivePage = 1 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '态');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '态');
    end;
    if DPNewStateHeroPage.ActivePage = 2 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $00A8D4E8, clBlack, '属');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $00A8D4E8, clBlack, '性');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $00708CA0, clBlack, '属');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $00708CA0, clBlack, '性');
    end;
    if DPNewStateHeroPage.ActivePage = 3 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $00A8D4E8, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $00A8D4E8, clBlack, '能');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $00708CA0, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $00708CA0, clBlack, '能');
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  g_HeroMouseStateItem.S.Name := '';
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  ax, ay, Idx: Integer;
  bbx, bby: Integer;
  wm: TWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroPageTab1 do begin
    if WLib <> nil then begin
      if g_HeroSelf.m_btSex = 1 then
        d := WLib.Images[FaceIndex-14]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    bbx := GLeft+31;
    bby := GTop+56;
    if g_HeroItems[U_DRESS].S.Name <> '' then begin //衣服
      Idx := g_HeroItems[U_DRESS].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        with GetEffecItemList(g_HeroItems[U_DRESS].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_DRESS].nIndex);
              if g_DrawHeroUseItems[U_DRESS].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
    //自己人物发型  2007.10.16
    Idx := 1799;
    if g_HeroSelf.m_btSex = 1 then  Idx := 2399;
    if g_HeroSelf.m_btSex = 0 then begin  //男
      if g_HeroSelf.m_btHair <> 0 then begin
        if Idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        end;
      end;
    end else if g_HeroSelf.m_btHair <> 1 then begin
      if Idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
    end;
    if g_HeroItems[U_WEAPON].S.Name <> '' then begin
      Idx := g_HeroItems[U_WEAPON].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with GetEffecItemList(g_HeroItems[U_WEAPON].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_WEAPON].nIndex);
              if g_DrawHeroUseItems[U_WEAPON].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
    //斗笠 20080417
    if g_HeroItems[U_ZHULI].S.Name <> '' then begin
      if g_HeroItems[U_ZHULI].S.Shape <> 2  then begin
        Idx := g_HeroItems[U_ZHULI].S.Looks;
        if Idx >= 0 then begin
          d := FrmMain.GetWStateImg(Idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (g_HeroItems[U_HELMET].S.Looks = 103) or (g_HeroItems[U_HELMET].S.Looks = 106) or (g_HeroItems[U_HELMET].S.Looks = 344) or (g_HeroItems[U_HELMET].S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
            Idx := g_HeroItems[U_HELMET].S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          Idx := g_HeroItems[U_ZHULI].S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          Idx := g_HeroItems[U_ZHULI].S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
            Idx := g_HeroItems[U_HELMET].S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;

      end;
      if g_HeroItems[U_HELMET].S.Name <> '' then begin //金牛头盔
        with GetEffecItemList(g_HeroItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_HELMET].nIndex);
              if g_DrawHeroUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end else
    if g_HeroItems[U_HELMET].S.Name <> '' then begin //头盔
      Idx := g_HeroItems[U_HELMET].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with GetEffecItemList(g_HeroItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawHeroUseItems[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawHeroUseItems[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawHeroUseItems[U_HELMET].nIndex);
              if g_DrawHeroUseItems[U_HELMET].nIndex > btShapeCount-1 then g_DrawHeroUseItems[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSHWeaponClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  where, n, sel: integer;
  flag: Boolean;
  msg: TDefaultMessage;
  MovItem: TMovingItem;
  msgWho: Byte; //2-主人 4-英雄
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  //修补火龙之心
  if g_boHeroItemMoving or g_boItemMoving then begin
    if Sender = DBNewSHBujuk then begin
      if (g_HeroItems[U_BUJUK].S.Shape = 9) and (g_HeroItems[U_BUJUK].S.StdMode = 25) and (g_HeroItems[U_BUJUK].S.Name <> '') then begin//20090205
        if g_boHeroItemMoving then begin
          if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
          if (g_MovingHeroItem.Item.S.Name = '') or (g_WaitingHeroUseItem.Item.S.Name <> '') then exit;
          MovItem := g_MovingHeroItem;
          msgWho := 4;
        end else if g_boItemMoving then begin
          if (g_MovingItem.Index = -97) or (g_MovingItem.Index = -98) then exit;
          if (g_MovingItem.Item.S.Name = '') or (g_WaitingUseItem.Item.S.Name <> '') then exit;
          MovItem := g_MovingItem;
          msgWho := 2;
        end;
        if MovItem.Item.S.Name <> '' then begin
          case MovItem.Item.S.StdMode of
            42: begin
              msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);//20071231
              FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.S.Name));//20071231
            end;
            15,19..24,26..29: begin//圣战，法神，天尊的首饰头盔(StdItem.Source = 127时认为是可以修复火龙之心 ，增加值为Stock*100)
              if (MovItem.Item.S.Source = 127) and (MovItem.Item.S.Stock > 0) then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.S.Name));
              end;
            end;
            4,47: begin//20090205 增加装备加怒气持久   技能书 藏宝图  (StdItem.Source = 127时认为是可以修复火龙之心，
              if (MovItem.Item.S.Source = 127) and (MovItem.Item.S.Reserved > 0) then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRFIRDRAGON, frmMain.TempCertification),MovItem.Item.MakeIndex, msgWho, 0, 0, frmMain.m_nSendMsgCount);
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(MovItem.Item.S.Name));
              end;
            end;
          end;
          Exit;
        end;
      end;
    end
  end;
  if g_boHeroItemMoving then begin
    flag := FALSE;
    if (g_MovingHeroItem.Index = -97) or (g_MovingHeroItem.Index = -98) then exit;
    if (g_MovingHeroItem.Item.S.Name = '') or (g_WaitingHeroUseItem.Item.S.Name <> '') then exit;
    where := GetTakeOnPosition (g_MovingHeroItem.Item.S.StdMode);
    if g_MovingHeroItem.Index >= 0 then begin
      case where of
        U_DRESS: begin
          if Sender = DBNewSHDress then begin
            if (g_HeroSelf.m_btSex = 0) and (g_MovingHeroItem.Item.S.StdMode <> 10) then Exit;//男衣服
            if (g_HeroSelf.m_btSex = 1) and (g_MovingHeroItem.Item.S.StdMode <> 11) then Exit;//女衣服
            flag := TRUE;
          end;
        end;
        U_WEAPON: if Sender = DBNewSHWeapon then flag := TRUE;
        U_NECKLACE: if Sender = DBNewSHNecklace then flag := TRUE;
        U_RIGHTHAND: if Sender = DBNewSHLight then flag := TRUE; //勋章
        U_HELMET: if Sender = DBNewSHHelmet then flag := TRUE; //头盔
        U_ZHULI: if Sender = DBNewSHHelmet then flag := True;//斗笠
        U_RINGR, U_RINGL: begin
          if Sender = DBNewSHRingL then begin
            where := U_RINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSHRingR then begin
            where := U_RINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGR: begin  //迫骂
          if Sender = DBNewSHArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
          if Sender = DBNewSHArmRingR then begin
            where := U_ARMRINGR;
            flag := TRUE;
          end;
        end;
        U_ARMRINGL: begin  //25,  刀啊风,迫骂
          if Sender = DBNewSHArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BUJUK: begin
          if Sender = DBNewSHBujuk then begin
            where := U_BUJUK;
            flag := TRUE;
          end;
          if Sender = DBNewSHArmRingL then begin
            where := U_ARMRINGL;
            flag := TRUE;
          end;
        end;
        U_BELT: begin
          if Sender = DBNewSHBelt then begin
            where := U_BELT;
            flag := TRUE;
          end;
        end;
        U_BOOTS: begin
          if Sender = DBNewSHBoots then begin
            where := U_BOOTS;
            flag := TRUE;
          end;
        end;
        U_CHARM: begin
          if Sender = DBNewSHCharm then begin
            where := U_CHARM;
            flag := TRUE;
          end;
        end;
        U_DRUM: begin
          if Sender = DBNewSHDrum then begin
            where := U_DRUM;
            flag := TRUE;
          end;
        end;
      end;
      if Sender = DBNewSHCharm then begin
        if (g_HeroItems[U_CHARM].S.Shape = 5) and (g_HeroItems[U_CHARM].S.StdMode = 7) and (g_HeroItems[U_CHARM].S.Name <> '') then begin//20090205
          case g_MovingHeroItem.Item.S.StdMode of
            7: begin
              if g_MovingHeroItem.Item.S.Shape = 3 then begin
                msg := MakeDefaultMsg (aa(CM_REPAIRDRAGONINDIA, frmMain.TempCertification),g_MovingHeroItem.Item.MakeIndex, 2, 0, 0, frmMain.m_nSendMsgCount);//20071231
                FrmMain.SendSocket (EncodeMessage (msg)+Encodestring(g_MovingHeroItem.Item.S.Name));//20071231
                Exit;
              end;
            end;
          end;
        end;
      end;
         //end;
    end else begin
      n := -(g_MovingHeroItem.Index+1);
      if n in [0..14] then begin
        ItemClickSound (g_MovingHeroItem.Item.S);
        g_HeroItems[n] := g_MovingHeroItem.Item;
        g_MovingHeroItem.Item.S.Name := '';
        g_boHeroItemMoving := FALSE;
      end;
    end;
    if flag then begin
      ItemClickSound (g_MovingHeroItem.Item.S);
      g_WaitingHeroUseItem := g_MovingHeroItem;
      g_WaitingHeroUseItem.Index := where;
      FrmMain.SendTakeOnHeroItem (where, g_MovingHeroItem.Item.MakeIndex, g_MovingHeroItem.Item.S.Name);
      g_MovingHeroItem.Item.S.Name := '';
      g_boHeroItemMoving := FALSE;
    end;
    if (Sender = DBNewSHBujuk) and (g_MovingHeroItem.Item.S.StdMode=25) and (g_MovingHeroItem.Item.S.Shape=9) and (g_boHeroItemMoving = FALSE) then begin
      DBHeroSpleenImg.Visible:=TRUE;
    end;   //20080319
  end else begin
    if g_boItemMoving then Exit;
    if (g_MovingHeroItem.Item.S.Name <> '') or (g_WaitingHeroUseItem.Item.S.Name <> '') then exit;
    Sel := -1;
    if Sender = DBNewSHDress then Sel := U_DRESS;
    if Sender = DBNewSHWeapon then Sel := U_WEAPON;
    if Sender = DBNewSHHelmet then begin//斗笠
      if g_HeroItems[U_ZHULI].S.Name <> '' then
        Sel := U_ZHULI
      else Sel := U_HELMET;
    end;
    if Sender = DBNewSHNecklace then Sel := U_NECKLACE;
    if Sender = DBNewSHLight then Sel := U_RIGHTHAND;
    if Sender = DBNewSHRingL then Sel := U_RINGL;
    if Sender = DBNewSHRingR then Sel := U_RINGR;
    if Sender = DBNewSHArmRingL then Sel := U_ARMRINGL;
    if Sender = DBNewSHArmRingR then Sel := U_ARMRINGR;
    if Sender = DBNewSHBujuk then Sel := U_BUJUK;
    if Sender = DBNewSHBelt then Sel := U_BELT;  //
    if Sender = DBNewSHBoots then Sel := U_BOOTS;
    if Sender = DBNewSHCharm then Sel := U_CHARM;
    if Sender = DBNewSHDrum then Sel := U_DRUM;
    if Sel >= 0 then begin
      if g_HeroItems[Sel].S.Name <> '' then begin
        ItemClickSound (g_HeroItems[Sel].S);
        g_MovingHeroItem.Index := -(Sel+1);
        g_MovingHeroItem.Item := g_HeroItems[Sel];
        g_HeroItems[Sel].S.Name := '';
        g_boHeroItemMoving := TRUE;
      end;
    end;
    if (Sender = DBNewSHBujuk) and (g_HeroItems[U_BUJUK].S.Shape = 9) and (g_boHeroItemMoving) then begin
      DBHeroSpleenImg.Visible:=FALSE;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSHWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  nHintX,nHintY:Integer;
  Sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  Butt:TDButton;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  Sel := -1;
  Butt:=TDButton(Sender);
  if Sender = DBNewSHDress then Sel := U_DRESS;
  if Sender = DBNewSHWeapon then Sel := U_WEAPON;
  if Sender = DBNewSHHelmet then Sel := U_HELMET;
  if Sender = DBNewSHNecklace then Sel := U_NECKLACE;
  if Sender = DBNewSHLight then Sel := U_RIGHTHAND;
  if Sender = DBNewSHRingL then Sel := U_RINGL;
  if Sender = DBNewSHRingR then Sel := U_RINGR;
  if Sender = DBNewSHArmRingL then Sel := U_ARMRINGL;
  if Sender = DBNewSHArmRingR then Sel := U_ARMRINGR;
  if Sender = DBNewSHBujuk then Sel := U_BUJUK;
  if Sender = DBNewSHBelt then Sel := U_BELT;
  if Sender = DBNewSHBoots then Sel := U_BOOTS;
  if Sender = DBNewSHCharm then Sel := U_CHARM;
  if Sender = DBNewSHDrum then Sel := U_DRUM;

  if Sel >= 0 then begin
    g_HeroMouseStateItem := g_HeroItems[Sel];
    if (g_HeroItems[Sel].S.Name <> '') or (g_HeroItems[U_ZHULI].S.Name <> '') then begin
      if (Sel = U_HELMET) and (g_HeroItems[U_ZHULI].S.Name <> '') then begin
        g_HeroMouseItem := g_HeroItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
        if iname <> '' then begin
          if g_HeroItems[U_ZHULI].Dura = 0 then hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(g_HeroItems[Sel].S.Name, 2);
      if DWNewStateHero.GLeft >= 350 then
        nHintX:=DWNewStateHero.SurfaceX(DWNewStateHero.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DWNewStateHero.SurfaceX(DWNewStateHero.GLeft)+DWNewStateHero.GWidth;
      nHintY:=DWNewStateHero.SurfaceY(DWNewStateHero.GTop) +50;
      g_HeroMouseItem := g_HeroItems[Sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 2{英雄});
      if (iname <> '') or (Lines <> '') then begin
        if g_HeroItems[Sel].Dura = 0 then hcolor := 'red'
        else hcolor := '';
        with Butt as TDButton do begin
          if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintX,
                                    nHintY,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s',
                                    [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False);
          end else begin
              DScreen.ShowSpecialHint(nHintx,
                                      nHinty,
                                      Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,2)]), False
                                      );
          end;
        end;
      end;
      g_HeroMouseItem.S.Name := '';
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DBNewSHNecklaceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx, nWhere, ax, ay: integer;
  d: TDirectDrawSurface;
  wm: TWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  nWhere := -1;
  if Sender = DBNewSHNecklace then nWhere := U_NECKLACE;
  if Sender = DBNewSHLight then nWhere := U_RIGHTHAND;
  if Sender = DBNewSHArmRingR then nWhere := U_ARMRINGR;
  if Sender = DBNewSHArmRingL then nWhere := U_ARMRINGL;
  if Sender = DBNewSHRingR then nWhere := U_RINGR;
  if Sender = DBNewSHRingL then nWhere := U_RINGL;
  if Sender = DBNewSHBujuk then nWhere := U_BUJUK;
  if Sender = DBNewSHBelt then nWhere := U_BELT;
  if Sender = DBNewSHBoots then nWhere := U_BOOTS;
  if Sender = DBNewSHCharm then nWhere := U_CHARM;
  if Sender = DBNewSHDrum then nWhere := U_DRUM;

  if nWhere >= 0 then begin
    if g_HeroItems[nWhere].S.Name <> '' then begin
      idx := g_HeroItems[nWhere].S.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx);
        if d <> nil then begin
          with TDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft + (GWidth - d.Width) div 2),
                          SurfaceY(GTop + (GHeight - d.Height) div 2),
                          d.ClientRect, d, TRUE);
            if GetEffecItemList(g_HeroItems[nWhere].S.Name).btShapeCount > 0 then begin
              with GetEffecItemList(g_HeroItems[nWhere].S.Name) do begin
                if GetTickCount - g_DrawHeroUseItems[nWhere].dwDrawTick >= 150 then begin
                  g_DrawHeroUseItems[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawHeroUseItems[nWhere].nIndex);
                  if g_DrawHeroUseItems[nWhere].nIndex > btShapeCount-1 then g_DrawHeroUseItems[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawHeroUseItems[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    DrawBlend(dsurface,SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d, 255);
                  end;
                end;
              end;
            end else begin
              if g_HeroItems[nWhere].S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  DrawBlend(dsurface,SurfaceX(GLeft-21), SurfaceY(GTop-23), d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DBNewStateHeroNGPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateHeroNGPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateHeroNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateHeroNGPage.ActivePage = 0 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $4AA6EF, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $4AA6EF, clBlack, '态');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $639ABD, clBlack, '状');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $639ABD, clBlack, '态');
    end;
    if DPNewStateHeroNGPage.ActivePage = 1 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $4AA6EF, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $4AA6EF, clBlack, '能');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $639ABD, clBlack, '技');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $639ABD, clBlack, '能');
    end;
    {$IF M2Version = 1}
    if DPNewStateHeroNGPage.ActivePage = 2 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+90, $4AA6EF, clBlack, '经');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+103, $4AA6EF, clBlack, '络');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+90, $639ABD, clBlack, '经');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+103, $639ABD, clBlack, '络');
    end;
    if DPNewStateHeroNGPage.ActivePage = 3 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+130, $4AA6EF, clBlack, '连');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+143, $4AA6EF, clBlack, '击');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+130, $639ABD, clBlack, '连');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+143, $639ABD, clBlack, '击');
    end;
    {$IFEND}
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateHeroPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateHeroPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateHeroPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateHeroPage.ActivePage := 1;
  end else
  if (ly >= 91) and (ly <= 130) then begin
    DPNewStateHeroPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateHeroPage.ActivePage := 3;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
begin
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with dsurface do begin
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+32, clSilver, clBlack, Format('职业：%s       等级:%d',
                  [GetJobName(g_HeroSelf.m_btJob), g_HeroSelf.m_Abil.Level]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+47, clSilver, clBlack, '当前经验  ' + IntToStr(g_HeroSelf.m_Abil.nExp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+62, clSilver, clBlack, '升级经验  ' + IntToStr(g_HeroSelf.m_Abil.nMaxExp));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+91, clSilver, clBlack, Format('体力值：%d/%d', [g_HeroSelf.m_Abil.HP, g_HeroSelf.m_Abil.MaxHP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+106, clSilver, clBlack, Format('魔法值：%d/%d', [g_HeroSelf.m_Abil.MP, g_HeroSelf.m_Abil.MaxMP]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+121, clSilver, clBlack, Format('药力值：%d/%d', [g_HeroSelf.m_Abil.MedicineValue, g_HeroSelf.m_Abil.MaxMedicineValue]));
      BoldTextOut(SurfaceX(GLeft)+37, SurfaceY(GTop)+136, clSilver, clBlack, '酒量：' + IntToStr(g_HeroSelf.m_Abil.MaxAlcohol));
    end;
  end;
end;
procedure TFrmDlg.DWNewStateHeroPageTab3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroPageTab3 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    with dsurface do begin
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+35, clSilver, clBlack, Format('防御 %d-%d', [LoWord(g_HeroSelf.m_Abil.AC), HiWord(g_HeroSelf.m_Abil.AC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+50, clSilver, clBlack, Format('魔御 %d-%d', [LoWord(g_HeroSelf.m_Abil.MAC), HiWord(g_HeroSelf.m_Abil.MAC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+65, clSilver, clBlack, Format('攻击 %d-%d', [LoWord(g_HeroSelf.m_Abil.DC), HiWord(g_HeroSelf.m_Abil.DC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+80, clSilver, clBlack, Format('魔法 %d-%d', [LoWord(g_HeroSelf.m_Abil.MC), HiWord(g_HeroSelf.m_Abil.MC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+95, clSilver, clBlack, Format('道术 %d-%d', [LoWord(g_HeroSelf.m_Abil.SC), HiWord(g_HeroSelf.m_Abil.SC)]));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+110, clSilver, clBlack, '精确度     ' + IntToStr(g_nHeroHitPoint));
      BoldTextOut(SurfaceX(GLeft)+20, SurfaceY(GTop)+125, clSilver, clBlack, '敏捷度     ' + IntToStr(g_nHeroSpeedPoint));

      if g_HeroSelf.m_Abil.Weight > g_HeroSelf.m_Abil.MaxWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clRed, clBlack, Format('背包重量  %d/%d', [g_HeroSelf.m_Abil.Weight, g_HeroSelf.m_Abil.MaxWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+35, clSilver, clBlack, Format('背包重量  %d/%d', [g_HeroSelf.m_Abil.Weight, g_HeroSelf.m_Abil.MaxWeight]));
      if g_HeroSelf.m_Abil.WearWeight > g_HeroSelf.m_Abil.MaxWearWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clRed, clBlack, Format('穿戴重量  %d/%d', [g_HeroSelf.m_Abil.WearWeight, g_HeroSelf.m_Abil.MaxWearWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+50, clSilver, clBlack, Format('穿戴重量  %d/%d', [g_HeroSelf.m_Abil.WearWeight, g_HeroSelf.m_Abil.MaxWearWeight]));
      if g_HeroSelf.m_Abil.HandWeight > g_HeroSelf.m_Abil.MaxHandWeight then
        BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clRed, clBlack, Format('腕力      %d/%d', [g_HeroSelf.m_Abil.HandWeight, g_HeroSelf.m_Abil.MaxHandWeight]))
      else BoldTextOut(SurfaceX(GLeft)+120, SurfaceY(GTop)+65, clSilver, clBlack, Format('腕力      %d/%d', [g_HeroSelf.m_Abil.HandWeight, g_HeroSelf.m_Abil.MaxHandWeight]));
      BoldTextOut (SurfaceX(GLeft)+120, SurfaceY(GTop)+80, clSilver, clBlack, '魔法防御  ' + IntToStr(g_nHeroAntiMagic * 10) + '%');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroPageTab5DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateHeroPageTab5 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [HeroMagicPage+1, (g_HeroMagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  nTitleWidth: Integer;
  sTitleName: string;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateUser do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
      if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        sTitleName := UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName;
        if sTitleName <> '' then begin
          nTitleWidth := frmMain.Canvas.TextWidth(sTitleName);
          if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
            if g_WUI1Images <> nil then begin
              d := g_WUI1Images.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks];
              if d <> nil then begin
                if d.Width > 16 then begin
                  nTitleWidth := d.Width;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end else begin
                  nTitleWidth := nTitleWidth + d.Width + 4;
                  dsurface.Draw(SurfaceX(GLeft)+ 146 - nTitleWidth div 2 - d.Width, SurfaceY(GTop) + 24 - d.Height div 2, d.ClientRect, d, True);
                end;
              end;
            end;
          end;
          if d.Width < 17 then 
          dsurface.TextOut(SurfaceX(GLeft) + 150 - nTitleWidth div 2, SurfaceY(GTop) + 19, clYellow, sTitleName);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  lx,ly:integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  g_MouseUserStateItem.S.Name := '';
  if g_MouseUserTitleList.Count > 0 then
    g_MouseUserTitleList.Clear;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserPageTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  ax, ay, Idx: Integer;
  bbx, bby: Integer;
  Sex, Hair: Byte;
  wm: TWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateUserPageTab1 do begin
    Sex := UserState1.Feature.nDress mod 2; //DRESSfeature (UserState1.Feature) mod 2;    //性别
    Hair := UserState1.feature.btHair; //HAIRfeature (UserState1.Feature);
    if WLib <> nil then begin
      if Sex = 1 then
        d := WLib.Images[FaceIndex+1]
      else d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    bbx := GLeft+31;
    bby := GTop+56;
    if UserState1.UseItems[U_DRESS].S.Name <> '' then begin //衣服
      Idx := UserState1.UseItems[U_DRESS].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        with GetEffecItemList(UserState1.UseItems[U_DRESS].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_DRESS].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_DRESS].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_DRESS].nIndex);
              if g_DrawUseItems1[U_DRESS].nIndex > btShapeCount-1 then g_DrawUseItems1[U_DRESS].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_DRESS].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
    //自己人物发型  2007.10.16
    Idx := 1799;
    if Sex = 1 then idx := 2399;
    if Sex = 0 then begin  //男
      if Hair <> 0 then begin
        if Idx > 0 then begin
          d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
          if d <> nil then
            dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
        end;
      end;
    end else if Hair <> 1 then begin
      if Idx > 0 then begin
        d := g_WHairImgImages.GetCachedImage (Idx, ax, ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
      end;
    end else begin
      d := g_WHairImgImages.GetCachedImage (1199, ax, ay);
      if d <> nil then
        dsurface.Draw (SurfaceX(bbx)+ax, SurfaceY(bby)+ay, d.ClientRect, d, TRUE);
    end;
    if UserState1.UseItems[U_WEAPON].S.Name <> '' then begin
      Idx := UserState1.UseItems[U_WEAPON].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with GetEffecItemList(UserState1.UseItems[U_WEAPON].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_WEAPON].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_WEAPON].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_WEAPON].nIndex);
              if g_DrawUseItems1[U_WEAPON].nIndex > btShapeCount-1 then g_DrawUseItems1[U_WEAPON].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_WEAPON].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
    //斗笠 20080417
    if UserState1.UseItems[U_ZHULI].S.Name <> '' then begin
      if UserState1.UseItems[U_ZHULI].S.Shape <> 2  then begin
        Idx := UserState1.UseItems[U_ZHULI].S.Looks;
        if Idx >= 0 then begin
          d := FrmMain.GetWStateImg(Idx,ax,ay);
          if d <> nil then
             dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        end;
      end else begin     //黑巾
        if (UserState1.UseItems[U_HELMET].S.Looks = 103) or (UserState1.UseItems[U_HELMET].S.Looks = 106) or (UserState1.UseItems[U_HELMET].S.Looks = 344) or (UserState1.UseItems[U_HELMET].S.Looks = 1113) then begin //黑铁头盔 黄金头盔 骷髅头盔 道士头盔  部分头盔是先画头盔的
          if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
            Idx := UserState1.UseItems[U_HELMET].S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
          Idx := UserState1.UseItems[U_ZHULI].S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
              dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
        end else begin
          Idx := UserState1.UseItems[U_ZHULI].S.Looks;
          if Idx >= 0 then begin
            d := FrmMain.GetWStateImg(Idx,ax,ay);
            if d <> nil then
            dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
          end;
          if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
            Idx := UserState1.UseItems[U_HELMET].S.Looks;
            if Idx >= 0 then begin
              d := FrmMain.GetWStateImg(Idx,ax,ay);
              if d <> nil then
                 dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
            end;
          end;
        end;

      end;
      if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //金牛头盔
        with GetEffecItemList(UserState1.UseItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_HELMET].nIndex);
              if g_DrawUseItems1[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems1[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end else
    if UserState1.UseItems[U_HELMET].S.Name <> '' then begin //头盔
      Idx := UserState1.UseItems[U_HELMET].S.Looks;
      if Idx >= 0 then begin
        d := FrmMain.GetWStateImg(Idx,ax,ay);
        if d <> nil then
          dsurface.Draw (SurfaceX(bbx+ax), SurfaceY(bby+ay), d.ClientRect, d, TRUE);
        with GetEffecItemList(UserState1.UseItems[U_HELMET].S.Name) do begin
          if btShapeCount > 0 then begin
            if GetTickCount - g_DrawUseItems1[U_HELMET].dwDrawTick >= 150 then begin
              g_DrawUseItems1[U_HELMET].dwDrawTick := GetTickCount;
              Inc(g_DrawUseItems1[U_HELMET].nIndex);
              if g_DrawUseItems1[U_HELMET].nIndex > btShapeCount-1 then g_DrawUseItems1[U_HELMET].nIndex := 0;
            end;
            wm := GetItemEffectWil(btShapeWilIndex);
            if wm <> nil then begin
              d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[U_HELMET].nIndex, ax, ay);
              if d <> nil then begin
                DrawBlend(dsurface,SurfaceX(bbx)+ax+nShapeX, SurfaceY(bby)+ay+nShapeY, d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateUserPageTab2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateUserPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      if g_MouseUserTitleList.Count > 0 then begin
        for I:=0 to g_MouseUserTitleList.Count-1 do
          dsurface.TextOut(SurfaceX(GLeft)+140, SurfaceY(GTop)+72+I*14, clYellow, g_MouseUserTitleList[I]);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterComClick(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  I: Integer;
  str: string;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version = 1}
  if HeroBatterComIndex <> - 1 then begin
    if g_HeroBatterMagicList.Count - HeroBatterComIndex > 0 then begin
      for I:=Low(g_HeroBatterTopMagic) to High(g_HeroBatterTopMagic) do begin
        if g_HeroBatterTopMagic[I].Def.sMagicName = pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^.Def.sMagicName then begin
          FillChar (g_HeroBatterTopMagic[I], sizeof(TClientMagic), #0);
        end;
      end;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex] := pTClientMagic(g_HeroBatterMagicList.Items[HeroBatterComIndex])^;
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 0;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
           pm.Key := #0;
           FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
        end;
      end;
      pm := PTClientMagic (g_HeroBatterMagicList[HeroBatterComIndex]);
      pm.Key := Chr(HeroBatterTopMagIndex + 1);
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, Chr(HeroBatterTopMagIndex + 1), str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = 0 then begin//空
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end else
    if g_HeroBatterMagicList.Count - HeroBatterComIndex = -1 then begin//随机
      FillChar (g_HeroBatterTopMagic[HeroBatterTopMagIndex], sizeof(TClientMagic), #0);
      g_HeroBatterTopMagic[HeroBatterTopMagIndex].CurTrain := 1;
      if g_HeroBatterMagicList.Count > 0 then //20080629
      for i:=0 to g_HeroBatterMagicList.Count-1 do begin
        pm := PTClientMagic (g_HeroBatterMagicList[i]);
        if Ord(pm.Key) = (HeroBatterTopMagIndex + 1) then begin
          pm.Key := #0;
          FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
          Break;
        end;
      end;
      if g_HeroBatterTopMagic[0].CurTrain = 1 then str := '1/' else str := '0/';
      if g_HeroBatterTopMagic[1].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[2].CurTrain = 1 then str := str+'1/' else str := str+'0/';
      if g_HeroBatterTopMagic[3].CurTrain = 1 then str := str+'1' else str := str+'0';
      FrmMain.SendHeroMagicKeyChange (-1, #0, str);
    end;
    DBNewHeroBatterCom.Visible := False;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterComDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  I: Integer;
  btLine: Byte;
  sStr: string;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewHeroBatterCom do begin
    if WLib <> nil then begin //20080701
     d := WLib.Images[FaceIndex];
     if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    if HeroBatterComIndex <> -1 then begin
      dsurface.FillRect(Rect(SurfaceX(GLeft)+8, SurfaceY(GTop)+4+HeroBatterComIndex*15 ,SurfaceX(GLeft)+GWidth-8,SurfaceY(GTop)+HeroBatterComIndex*15+19), clNavy);
    end;
    btLine := _MIN(4, g_HeroBatterMagicList.Count);
    for I:=0 to btLine -1 do begin
      if pTClientMagic(g_HeroBatterMagicList.Items[I]) <> nil then begin
        sStr := pTClientMagic(g_HeroBatterMagicList.Items[I]).Def.sMagicName;
        if I = HeroBatterComIndex then
          dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, clWhite, sStr)
        else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+I*15, $007FA3BB, sStr);
      end;
    end;
    if HeroBatterComIndex = btLine then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, clWhite, '空')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+btLine*15, $007FA3BB, '空');
    if HeroBatterComIndex = btLine +1 then
      dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, clWhite, '随机')
    else dsurface.TextOut (SurfaceX(GLeft+14), SurfaceY(GTop+7)+(btLine+1)*15, $007FA3BB, '随机');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterComMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  btLine: Byte;
  ss: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewHeroBatterCom do begin
    ss := ((Y - GTop) - 1) div 15;
    btLine := _MIN(4, g_HeroBatterMagicList.Count) + 2;
    if ss >= btLine then ss := btLine - 1;
    if ss <= 0 then ss := 0;
    HeroBatterComIndex := ss;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  trainlv: Byte;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TDButton do begin
    pm := nil;
    if Tag < g_HeroBatterMagicList.Count then begin
      pm := PTClientMagic (g_HeroBatterMagicList[Tag]);
      if pm <> nil then begin
        if pm.Def.sMagicName <> '' then begin
          Icon := GetBatterMagicIcon(pm.Def.btEffect);
          if Icon > -1 then begin
            if Downed then
              d := g_WMainImages.Images[Icon+1]
            else d := g_WMainImages.Images[Icon];
            if d <> nil then
              dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
          end;
          d := g_WMainImages.Images[112]; //lv
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then
            dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          if not (pm.Level in [0..5]) then pm.Level := 0;
          case pm.Def.btEffect of
            102..104: begin
              case Ord(pm.Key) of
                1:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+15%暴击');
                end;
                3: begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+25%暴击');
                end;
                4: begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%+30%暴击');
                end;
                else
                dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[0].nStormsHit)+'%暴击');
              end;
            end;
            105..107: begin
              case Ord(pm.Key) of
                 1:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+10%暴击');
                 end;
                 2:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+15%暴击');
                 end;
                 3:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+25%暴击');
                 end;
                 4:begin
                    dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%+30%暴击');
                 end;
                 else dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[1].nStormsHit)+'%暴击');
              end;
            end;
            108..110: begin
              case Ord(pm.Key) of
                1:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                   dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%+30%暴击');
                end;
                else dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                      clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[2].nStormsHit)+'%暴击');
              end;
            end;
            111..113: begin
              case Ord(pm.Key) of
                1:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+10%暴击');
                end;
                2:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+15%暴击');
                end;
                3:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+25%暴击');
                end;
                4:begin
                  dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%+30%暴击');
                end;
                else dsurface.BoldTextOut (SurfaceX(GLeft)+38, SurfaceY(GTop)-1,
                        clSilver, clBlack, pm.Def.sMagicName+':'+IntToStr(g_HumanPulseArr[3].nStormsHit)+'%暴击');
              end;
            end;
          end;
          if pm.Level in [0..3,5] then trainlv := pm.Level
          else if pm.Level = 4 then trainlv := 3
          else trainlv := 0;
          dsurface.BoldTextOut (SurfaceX(GLeft)+52, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.Level));
          if pm.Def.MaxTrain[trainlv] > 0 then begin
             if trainlv < 5 then
                dsurface.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[trainlv]))
             else dsurface.BoldTextOut (SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  sLines: string;
{$IFEND}
begin
{$IF M2Version = 1}
  pm := nil;
  with TDButton(Sender) do begin
    if g_HeroBatterMagicList.Count - 1 >= Tag then begin
      pm := PTClientMagic (g_HeroBatterMagicList[Tag]);
      if pm <> nil then begin
        case pm.Def.btEffect of
          102: begin  //三绝杀
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          103,104,106,107,109,110: begin //双龙破 虎啸诀 凤舞祭 八卦掌 惊雷爆 三焰咒
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对单体目/c=Yellow>\<标造成伤害/c=Yellow>';
          end;
          111: begin //横扫千军
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以自身为/c=Yellow>\<中心，对5*5范围内的目标造成/c=Yellow>\<伤害/c=Yellow>';
          end;
          105: begin //追心刺
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<近身攻击，冲撞单体/c=Yellow>\<目标，在迫使其后退的同时，造/c=Yellow>\<成伤害/c=Yellow>';
          end;
          108: begin //断岳斩
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<远程攻击，对三步内/c=Yellow>\<的单体目标造成伤害/c=Yellow>';
          end;
          112, 113: begin //冰天雪地 万剑归宗
            sLines := '<' + pm.Def.sMagicName + '：/c=Lime>\<范围攻击，以目标为/c=Yellow>\<中心，对5*5范围内造成持续伤/c=Yellow>\<害/c=Yellow>';
          end;
          else sLines := '';
        end;
        if sLines <> '' then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)+GWidth, SurfaceY(GTop)+GHeight, sLines, False)
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterRandomClick(Sender: TObject; X, Y: Integer);
{$IF M2Version = 1}
var
  pm: PTClientMagic;
  I: Integer;
{$IFEND}
begin
{$IF M2Version = 1}
  FillChar (g_HeroBatterTopMagic, sizeof(TClientMagic)*4, #0);
  if g_HeroBatterMagicList.Count > 0 then begin
    for i:=0 to g_HeroBatterMagicList.Count-1 do begin
      pm := PTClientMagic (g_HeroBatterMagicList[i]);
      if (Ord(pm.Key) = 1) or (Ord(pm.Key) = 2) or (Ord(pm.Key) = 3) or (Ord(pm.Key) = 4) then begin
        pm.Key := #0;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, #0, '');//将原来设置的技能快捷键清0
      end;
    end;
  end;
  g_HeroBatterTopMagic[0].CurTrain := 1;
  g_HeroBatterTopMagic[1].CurTrain := 1;
  g_HeroBatterTopMagic[2].CurTrain := 1;
  g_HeroBatterTopMagic[3].CurTrain := 1;
  FrmMain.SendHeroMagicKeyChange (-1, #0, '1/1/1/1');
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterTopMag1Click(Sender: TObject; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewHeroBatterTopMag4 then begin
    if not g_boHeroOpen4BatterSkill then Exit;
  end;
  if g_HeroBatterMagicList.Count > 0 then begin
    DBNewHeroBatterCom.GLeft := TDButton(Sender).GLeft-2;
    DBNewHeroBatterCom.GTop := TDButton(Sender).GTop+TDButton(Sender).GHeight+1;
    HeroBatterTopMagIndex := TDButton(Sender).Tag;  //全局变量,代表设置上面3格哪个.
    HeroBatterComIndex := -1;
    DBNewHeroBatterCom.Visible := True;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterTopMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
  {$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  Icon: Integer;
  {$IFEND}
begin
  {$IF M2Version = 1}
  with Sender as TDButton do begin
    if Sender = DBNewHeroBatterTopMag4 then begin
      if not g_boHeroOpen4BatterSkill then begin
        d := g_WMainImages.Images[912];
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft-3), SurfaceY(GTop-5), d.ClientRect, d, TRUE);
        Exit;
      end;
    end;
    if g_HeroBatterMagicList.Count > 0 then begin
      if g_HeroBatterTopMagic[Tag].Def.sMagicName <> '' then begin
        Icon := GetBatterMagicIcon(g_HeroBatterTopMagic[Tag].Def.btEffect);
        if Icon > -1 then begin
          if Downed then
            d := g_WMainImages.Images[icon+1]
          else d := g_WMainImages.Images[icon];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        end;
      end else begin
        if Downed then begin
          if g_HeroBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[910]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2+1];
          end;
        end else begin
          if g_HeroBatterTopMagic[Tag].CurTrain = 1 then
            d := g_WMainImages.Images[909]
          else begin
            if Sender = DWinBatterTopMag4 then
              d := g_WUI1Images.Images[1297]
            else d := g_WMainImages.Images[903 + Tag*2];
          end;
        end;
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
        if (g_HeroBatterTopMagic[0].Def.sMagicName = '') and (g_HeroBatterTopMagic[1].Def.sMagicName = '') and (g_HeroBatterTopMagic[2].Def.sMagicName = '') and (g_HeroBatterTopMagic[3].Def.sMagicName = '')
           and (g_HeroBatterTopMagic[0].CurTrain <> 1) and (g_HeroBatterTopMagic[1].CurTrain <> 1) and (g_HeroBatterTopMagic[2].CurTrain <> 1) and (g_HeroBatterTopMagic[3].CurTrain <> 1) then begin
          if Sender = DBNewHeroBatterTopMag1 then begin
            if (not Downed) and (not DBNewHeroBatterCom.Visible) then begin
              if GetTickCount - BatterTopTimeTick > 200 then begin
                BatterTopTimeTick := GetTickCount;
                Inc(BatterTopImginsex);
                if BatterTopImginsex > 1 then BatterTopImginsex := 0;
              end;
              d := g_WMainImages.Images[903+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              d := g_WMainImages.Images[918+BatterTopImginsex];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft)+10, SurfaceY(GTop)+30, d.ClientRect, d, TRUE);
            end;
          end;
        end;
      end;
    end else begin
      d := g_WMainImages.Images[913];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewHeroBatterTopMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
begin
  {$IF M2Version = 1}
  if Sender = DBNewHeroBatterTopMag1 then begin
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第1招，\可增加爆击率10%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterTopMag2 then begin
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第2招，\可增加爆击率15%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterTopMag3 then begin
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第3招，\可增加爆击率25%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterTopMag4 then begin
    if not g_boHeroOpen4BatterSkill then Exit;
    DScreen.ShowHint(DBNewHeroBatterTopMag1.SurfaceX(DBNewHeroBatterTopMag1.GLeft) - 137, DBNewHeroBatterTopMag1.SurfaceY(DBNewHeroBatterTopMag1.GTop),
       '连击技第4招，\可增加爆击率30%。\点击可编辑连击招式。'
       , clYellow, FALSE);
    Exit;
  end;
  if Sender = DBNewHeroBatterRandom then begin
    DScreen.ShowHint(DBNewHeroBatterRandom.SurfaceX(DBNewHeroBatterRandom.GLeft), DBNewHeroBatterRandom.SurfaceY(DBNewHeroBatterRandom.GTop+DBNewHeroBatterRandom.GHeight),
       '随机组合连击招式'
       , clYellow, FALSE);
    Exit;
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewHeroLiquorProgressDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  rc: Trect;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DBNewHeroLiquorProgress do begin
    if WLib <> nil then begin //20080701
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;

    d := g_WMain2Images.Images[576];
    if d <> nil then begin
      rc := d.ClientRect;

      if g_HeroSelf.m_Abil.Alcohol > 0 then begin//酒量 20080622
        rc.Right := Round((rc.Right-rc.Left) / g_HeroSelf.m_Abil.MaxAlcohol * g_HeroSelf.m_Abil.Alcohol);
        dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), rc, d, TRUE);
      end;
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DBNewHeroPointIcon1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if HeroStatePulsePage = 4 then begin//奇经
      if TDControl(Sender).Tag = 0 then begin
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0 then begin
          frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, 1);
        end else begin
          ShowQJPractice(True);
        end;
      end;
      frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, TDControl(Sender).Tag+1);
    end else begin
      frmMain.SendOpenHeroPulsePoint(HeroStatePulsePage, TDControl(Sender).Tag+1);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointIcon1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TDButton do begin
    if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= Tag+1 then
      d := g_WMainImages.Images[851]
    else if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = Tag+1)) or (HeroStatePulsePage = 4){奇经} then begin
      d := g_WMainImages.Images[852];
    end else d := g_WMainImages.Images[850];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);

    if ((g_btHeroPulseOriginPage = HeroStatePulsePage) or (HeroStatePulsePage = 4){奇经}) and (g_btHeroPulseLevel > 0) then begin
      if GetTickCount - PulseOriginTimeTick > 300 then begin//原点闪动计时
        PulseOriginTimeTick := GetTickCount();
        Inc(PulseOriginImginsex);
      end;
      if PulseOriginImginsex > 1 then PulseOriginImginsex := 0;
    end;

    if ((g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = Tag+1)) or ((HeroStatePulsePage = 4) and (g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0) and (Tag = 0)){奇经} then begin
      if PulseOriginImginsex = 1 then begin
        d := g_WMainImages.Images[853];
        if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft), SurfaceY(GTop), d, 255);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointIcon1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  sLines, sPointName, sPulsDesc: string;

  function GetRGB(nlevel: Byte):string;
  begin
    Result := '~r';
    if g_dwHeroInternalForceLevel >= nlevel then Result := '~y';
  end;
{$IFEND}
begin
{$IF M2Version = 1}
  if HeroStatePulsePage = 4 then begin
    if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= TDControl(Sender).Tag+1 then begin //已打通
      DScreen.ShowHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), '神冲穴: 已打通,点击可修炼\ \奇经穴位，通过奇经神冲丸\打通，可点击进行修炼，提\升斗转星移技能等级。' , clWhite, FALSE);
    end else begin
      DScreen.ShowTzHint (TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop),
                  '神冲穴:待打通'+'~y\', FALSE, FALSE, 0);
    end;
  end else begin
    sPointName := GetPulseName(HeroStatePulsePage,TDControl(Sender).Tag);
    if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint >= TDControl(Sender).Tag+1 then begin //已打通
      if sPointName <> '' then begin
        sLines := Format('%s穴:已打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'已通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' +  sPulsDesc;
        DScreen.ShowHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), sLines, clYellow, FALSE);
      end;
    end else if (g_btHeroPulseOriginPage = HeroStatePulsePage) and (g_btHeroPulsePoint = TDControl(Sender).Tag+1) then begin //待打
      if sPointName <> '' then begin
        sLines := Format('%s穴:待打通~y\需要内功等级：%d',[sPointName, g_btHeroPulseLevel])+GetRGB(g_btHeroPulseLevel);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowTzHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), sLines, FALSE, FALSE, 0);
      end;
    end else begin
      if sPointName <> '' then begin
        sLines := Format('%s穴:目前不可打通',[sPointName]);
        sPulsDesc := GetPulsDesc(sPointName+'未通');
        if sPulsDesc <> '' then
          sLines := sLines + '\ \' + sPulsDesc;
        DScreen.ShowHint(TDControl(Sender).SurfaceX(TDControl(Sender).GLeft)+ TDControl(Sender).GWidth, TDControl(Sender).SurfaceY(TDControl(Sender).GTop), sLines, clRed, FALSE);
      end;
    end;
  end;
{$IFEND}
end;

{$IF M2Version =1}
procedure TFrmDlg.ChangeHeroNGPointPage();
begin
  //32 12
  DLNewHeroPointName1.Caption := GetPulseName(HeroStatePulsePage,0);
  DLNewHeroPointName2.Caption := GetPulseName(HeroStatePulsePage,1);
  DLNewHeroPointName3.Caption := GetPulseName(HeroStatePulsePage,2);
  DLNewHeroPointName4.Caption := GetPulseName(HeroStatePulsePage,3);
  DLNewHeroPointName5.Caption := GetPulseName(HeroStatePulsePage,4);
  case HeroStatePulsePage of
    0: DBNewHeroPointPractice.Caption := '修炼冲脉';
    1: DBNewHeroPointPractice.Caption := '修炼阴跷';
    2: DBNewHeroPointPractice.Caption := '修炼阴维';
    3: DBNewHeroPointPractice.Caption := '修炼任脉';
    4: DBNewHeroPointPractice.Caption := '修炼奇经';
  end;
  DBNewHeroPointPractice.Enabled := not (g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel >= 5) or ((g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint = 0) and (HeroStatePulsePage = 4));
  case HeroStatePulsePage of
    0: begin
      DBNewHeroPointIcon1.GLeft := 69;
      DBNewHeroPointIcon1.GTop := 42;
      DBNewHeroPointIcon2.GLeft := 68;
      DBNewHeroPointIcon2.GTop := 71;
      DBNewHeroPointIcon3.GLeft := 70;
      DBNewHeroPointIcon3.GTop := 96;
      DBNewHeroPointIcon4.GLeft := 77;
      DBNewHeroPointIcon4.GTop := 118;
      DBNewHeroPointIcon5.GLeft := 84;
      DBNewHeroPointIcon5.GTop := 100;
      DLNewHeroPointName1.GLeft := 113;
      DLNewHeroPointName1.GTop := 47;
      DLNewHeroPointName2.GLeft := 112;
      DLNewHeroPointName2.GTop := 76;
      DLNewHeroPointName3.GLeft := 34;
      DLNewHeroPointName3.GTop := 101;
      DLNewHeroPointName4.GLeft := 38;
      DLNewHeroPointName4.GTop := 123;
      DLNewHeroPointName5.GLeft := 118;
      DLNewHeroPointName5.GTop := 104;
    end;
    1: begin
      DBNewHeroPointIcon1.GLeft := 80;
      DBNewHeroPointIcon1.GTop := 36;
      DBNewHeroPointIcon2.GLeft := 80;
      DBNewHeroPointIcon2.GTop := 76;
      DBNewHeroPointIcon3.GLeft := 85;
      DBNewHeroPointIcon3.GTop := 116;
      DBNewHeroPointIcon4.GLeft := 93;
      DBNewHeroPointIcon4.GTop := 155;
      DBNewHeroPointIcon5.GLeft := 96;
      DBNewHeroPointIcon5.GTop := 196;
      DLNewHeroPointName1.GLeft := 36;
      DLNewHeroPointName1.GTop := 41;
      DLNewHeroPointName2.GLeft := 36;
      DLNewHeroPointName2.GTop := 80;
      DLNewHeroPointName3.GLeft := 123;
      DLNewHeroPointName3.GTop := 120;
      DLNewHeroPointName4.GLeft := 56;
      DLNewHeroPointName4.GTop := 158;
      DLNewHeroPointName5.GLeft := 61;
      DLNewHeroPointName5.GTop := 201;
    end;
    2: begin
      DBNewHeroPointIcon1.GLeft := 80;
      DBNewHeroPointIcon1.GTop := 50;
      DBNewHeroPointIcon2.GLeft := 74;
      DBNewHeroPointIcon2.GTop := 80;
      DBNewHeroPointIcon3.GLeft := 73;
      DBNewHeroPointIcon3.GTop := 118;
      DBNewHeroPointIcon4.GLeft := 69;
      DBNewHeroPointIcon4.GTop := 151;
      DBNewHeroPointIcon5.GLeft := 66;
      DBNewHeroPointIcon5.GTop := 187;
      DLNewHeroPointName1.GLeft := 35;
      DLNewHeroPointName1.GTop := 53;
      DLNewHeroPointName2.GLeft := 115;
      DLNewHeroPointName2.GTop := 85;
      DLNewHeroPointName3.GLeft := 33;
      DLNewHeroPointName3.GTop := 122;
      DLNewHeroPointName4.GLeft := 103;
      DLNewHeroPointName4.GTop := 156;
      DLNewHeroPointName5.GLeft := 99;
      DLNewHeroPointName5.GTop := 192;
    end;
    3: begin
      DBNewHeroPointIcon1.GLeft := 80;
      DBNewHeroPointIcon1.GTop := 32;
      DBNewHeroPointIcon2.GLeft := 81;
      DBNewHeroPointIcon2.GTop := 52;
      DBNewHeroPointIcon3.GLeft := 81;
      DBNewHeroPointIcon3.GTop := 73;
      DBNewHeroPointIcon4.GLeft := 80;
      DBNewHeroPointIcon4.GTop := 97;
      DBNewHeroPointIcon5.GLeft := 81;
      DBNewHeroPointIcon5.GTop := 121;
      DLNewHeroPointName1.GLeft := 34;
      DLNewHeroPointName1.GTop := 37;
      DLNewHeroPointName2.GLeft := 126;
      DLNewHeroPointName2.GTop := 57;
      DLNewHeroPointName3.GLeft := 36;
      DLNewHeroPointName3.GTop := 79;
      DLNewHeroPointName4.GLeft := 125;
      DLNewHeroPointName4.GTop := 102;
      DLNewHeroPointName5.GLeft := 37;
      DLNewHeroPointName5.GTop := 126;
    end;
    4: begin
      DBNewHeroPointIcon1.GLeft := 79;
      DBNewHeroPointIcon1.GTop := 28;
      DBNewHeroPointIcon2.GLeft := 124;
      DBNewHeroPointIcon2.GTop := 114;
      DBNewHeroPointIcon3.GLeft := 35;
      DBNewHeroPointIcon3.GTop := 113;
      DBNewHeroPointIcon4.GLeft := 97;
      DBNewHeroPointIcon4.GTop := 197;
      DBNewHeroPointIcon5.GLeft := 61;
      DBNewHeroPointIcon5.GTop := 198;
      DLNewHeroPointName1.GLeft := 36;
      DLNewHeroPointName1.GTop := 36;
      DLNewHeroPointName2.GLeft := 100;
      DLNewHeroPointName2.GTop := 106;
      DLNewHeroPointName3.GLeft := 58;
      DLNewHeroPointName3.GTop := 128;
      DLNewHeroPointName4.GLeft := 74;
      DLNewHeroPointName4.GTop := 190;
      DLNewHeroPointName5.GLeft := 35;
      DLNewHeroPointName5.GTop := 202;
    end;
  end;
end;
{$IFEND}

procedure TFrmDlg.DBNewHeroPointPage1Click(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version =1}
  if HeroStatePulsePage <> TDButton(Sender).Tag then begin
    HeroStatePulsePage := TDButton(Sender).Tag;
    ChangeHeroNGPointPage();
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPage1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version = 1}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if HeroStatePulsePage = Tag then
        d := WLib.Images[FaceIndex]
      else d := WLib.Images[FaceIndex+1];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    if HeroStatePulsePage = Tag then
      Color := $73B2DE
    else Color := $5282A5;
    if not Downed then
      dsurface.BoldTextOut(SurfaceX(GLeft)+4, SurfaceY(GTop)+5, Color, clBlack, Caption)
    else dsurface.BoldTextOut(SurfaceX(GLeft)+5, SurfaceY(GTop)+6, Color, clBlack, Caption);
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPracticeClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version = 1}
  if GetTickCount > g_dwQueryMsgTick then begin
    g_dwQueryMsgTick := GetTickCount + 1000;
    if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
      if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel < 5 then begin
        frmMain.SendHeroPracticePulse(HeroStatePulsePage);
      end;
    end else begin
      case HeroStatePulsePage of
        0: DMessageDlg ('打通冲脉的五个穴位，才能修炼冲脉，习得连击招式！', [mbOk]);
        1: DMessageDlg ('打通阴跷的五个穴位，才能修炼阴跷，习得连击招式！', [mbOk]);
        2: DMessageDlg ('打通阴维的五个穴位，才能修炼阴维，习得连击招式！', [mbOk]);
        3: DMessageDlg ('打通任脉的五个穴位，才能修炼任脉，习得连击招式！', [mbOk]);
        4: begin
          if g_HeroHumanPulseArr[HeroStatePulsePage].nPulsePoint > 0 then begin
            ShowQJPractice(True);
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroPointPracticeMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version = 1}
var
  str: string;
{$IFEND}
begin
{$IF M2Version = 1}
  with DBNewHeroPointPractice do begin
    if HeroStatePulsePage = 4 then begin
      DScreen.ShowHint(SurfaceX(GLeft) - DScreen.HintWidth, SurfaceY(GTop) - DScreen.HintHeight,
                               '修炼穴位\点击可选择进行修炼的穴位，\提升穴位的修为，\可获得对应技能并提升等级。', clWhite, FALSE);
    end else begin
      if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
        case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
          0: str := GetPulsDesc(format('HP%s已通-%d',[GetPulsePageName(HeroStatePulsePage), g_HeroSelf.m_btJob]));
          1..4: str := GetPulsDesc('HP'+GetPulsePageName(HeroStatePulsePage)+IntToStr(g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel));
        end;
        if g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel <> 5 then
        DScreen.ShowSpecialHint(SurfaceX(GLeft)- DScreen.HintWidth, SurfaceY(GTop)-DScreen.HintHeight,
                      format('英雄经络修炼累计<%d/c=Yellow>点\当前经络修炼还需<%d/c=Yellow>点'+str,[g_dwHeroPulsExp,g_HeroHumanPulseArr[HeroStatePulsePage].dwUpPulseLevelExp]), False);
      end else begin
        str := GetPulsDesc('HP'+GetPulsePageName(HeroStatePulsePage)+'未通');
        if str <> '' then
        DScreen.ShowHint(SurfaceX(GLeft) - DScreen.HintWidth, SurfaceY(GTop) - DScreen.HintHeight,
                               str, clWhite, FALSE);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  keych: char;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
  idx := _Max(TDButton(Sender).Tag + HeroMagicPage * 5, 0);
  if (idx >= 0) and (idx < g_HeroMagicList.Count) then begin
    pm := PTClientMagic (g_HeroMagicList[idx]);
    if pm.Def.wMagicId <> 99 then begin
      if not (pm.Def.wMagicId in [3,4,60..65,67,88,95]) then begin
        if word(pm.Key) = 0 then
          keych := char(word(1))
        else keych := char(word(0));
        pm.Key := keych;
        FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych,'');
      end;
    end else begin
      SetHeroSkillMemoDlg(pm.Def.wMagicId, pm.Def.btEffect, pm.Def.sMagicName, '强身术修炼');
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  wm: TWMImages;
  boPieceExp: Boolean;
  MagColor: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    pm := nil;
    Idx := _Max(Tag + HeroMagicPage * 5, 0);
    if Idx < g_HeroMagicList.Count then begin
      pm := PTClientMagic (g_HeroMagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx, Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then begin
                if word(pm.Key) = 0 then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                else begin
                  g_ImgMixSurface.SetSize(d.Width, d.Height);
                  g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                  DrawEffect(0, 0, g_ImgMixSurface, d, ceBlack);
                  dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
                end;
              end;
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then begin
                if word(pm.Key) = 0 then
                  dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE)
                else begin
                  g_ImgMixSurface.SetSize(d.Width, d.Height);
                  g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                  DrawEffect(0, 0, g_ImgMixSurface, d, ceBlack);
                  dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
                end;
              end;
            end;
          end;
        end;
        if word(pm.Key) = 0 then begin
          MagColor := clSilver;
          dsurface.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, MagColor, clBlack, pm.Def.sMagicName);
        end else begin
          MagColor := clGray;
          dsurface.BoldTextOut(SurfaceX(GLeft)+34, SurfaceY(GTop)-1, MagColor, clBlack, pm.Def.sMagicName+'[关]');
        end;
        boPieceExp := pm.Def.wMagicId in [68]; //显示经验条
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then begin
          if boPieceExp then
            dsurface.Draw (SurfaceX(GLeft)+94, SurfaceY(GTop)-1, d.ClientRect, d, TRUE)
          else dsurface.Draw (SurfaceX(GLeft)+34, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        end;
        if not boPieceExp then begin
          d := g_WMainImages.Images[111]; //exp
          if d <> nil then begin
            dsurface.Draw(SurfaceX(GLeft)+71, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
          end;
        end;
        case pm.Def.wMagicId of
          68: begin//酒气护体
            dsurface.BoldTextOut(SurfaceX(GLeft)+108, SurfaceY(GTop)-2, clSilver, clBlack, IntToStr(pm.Level));
            DBNewHeroJQExp.GLeft := GLeft+37;
            DBNewHeroJQExp.GTop := GTop+22;
            if not DBNewHeroJQExp.Visible then DBNewHeroJQExp.Visible := True;
          end;
          95: begin//斗转星移
            dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-');
          end;
          99: begin//强身术
            dsurface.BoldTextOut (SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            if pm.Level = 99 then
              dsurface.BoldTextOut (SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-')
            else dsurface.BoldTextOut (SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.CurTrain) + '/' + IntToStr(pm.Def.MaxTrain[0]));
          end;
          104: begin
            dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            if pm.Level = 100 then
              dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-')
            else dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[0]]));
          end;
          else begin
            dsurface.BoldTextOut(SurfaceX(GLeft)+48, SurfaceY(GTop)+15, MagColor, clBlack, IntToStr(pm.Level));
            if not (pm.Level in [0..4]) then pm.Level := 0;
            if pm.Level < 3 then
              dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
            else dsurface.BoldTextOut(SurfaceX(GLeft)+90, SurfaceY(GTop)+15, MagColor, clBlack, '-');
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStMag1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    pm := nil;
    idx := _Max(Tag + HeroMagicPage * 5, 0);
    if idx < g_HeroMagicList.Count then begin
      pm := PTClientMagic (g_HeroMagicList[idx]);
      if pm <> nil then begin
        DScreen.ShowTzHint (SurfaceX(GLeft)-120,
                      SurfaceY(GTop),
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('普通技能',pm.Def.sMagicName)+'~y', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGMag1Click(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  Idx: Integer;
  pm: PTClientMagic;
  keych: Char;
{$IFEND}
begin
{$IF M2Version <> 2}
  Idx := _Max(TDBUtton(Sender).Tag + HeroInternalForceMagicPage * 5, 0);
  if (Idx >= 0) and (Idx < g_HeroInternalForceMagicList.Count) then begin
    pm := PTClientMagic (g_HeroInternalForceMagicList[Idx]);
    if Word(pm.Key) = 0 then
      keych := Char(Word(1))
    else keych := Char(Word(0));
    pm.Key := keych;
    FrmMain.SendHeroMagicKeyChange (pm.Def.wMagicId, keych, '');
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGMag1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  Idx, Icon: integer;
  d: TDirectDrawSurface;
  pm: PTClientMagic;
  wm: TWMImages;
  Color: TColor;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    pm := nil;
    Idx := _Max(Tag + HeroInternalForceMagicPage * 5, 0);
    if Idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[Idx]);
      if pm <> nil then begin
        wm := GetMagicIcon(pm.Def.btEffect, pm.Level, pm.Def.wMagicId, pm.btLevelEx,Icon);
        if wm <> nil then begin
          if Icon >= 0 then begin
            if not Downed then begin
              d := wm.Images[Icon];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end else begin
              d := wm.Images[Icon+1];
              if d <> nil then
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
            end;
            if d <> nil then begin
              if word(pm.Key) <> 0 then begin
                g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                DrawEffect(0, 0, g_ImgMixSurface, d, {ceGrayScale}ceBlack);
                dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
              end;
            end;
          end;
        end;
        d := g_WMainImages.Images[112]; //lv
        if d <> nil then
          dsurface.Draw (SurfaceX(GLeft)+38, SurfaceY(GTop)+16, d.ClientRect, d, TRUE);
        d := g_WMainImages.Images[111]; //exp
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+75, SurfaceY(GTop)+17, d.ClientRect, d, TRUE);
        if Word(pm.Key) = 0 then begin
          Color := clSilver;
          dsurface.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName);
        end else begin
          Color := clGray;
          dsurface.BoldTextOut(SurfaceX(GLeft)+38, SurfaceY(GTop)-1, Color, clBlack, pm.Def.sMagicName+'[关]');
        end;
        dsurface.BoldTextOut(SurfaceX(GLeft)+52, SurfaceY(GTop)+15, Color, clBlack, IntToStr(pm.Level));
        if pm.Level < 3 then
          dsurface.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, Format('%d/%d', [pm.CurTrain, pm.Def.MaxTrain[pm.Level]]))
        else dsurface.BoldTextOut(SurfaceX(GLeft)+94, SurfaceY(GTop)+15, clSilver, clBlack, '-');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGMag1MouseMove(Sender: TObject;
  Shift: TShiftState; X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: integer;
  pm: PTClientMagic;
const
	Lines = '<%s:/c=Lime fontstyle=bold>\<%s/c=Yellow>\<升级到技能等级%d/c=Yellow>\<需要内功等级/c=Yellow><%d/c=Red><级/c=Yellow>\<%s/c=Yellow><%d/c=Red><颗/c=Yellow>';
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    pm := nil;
    idx := _Max(Tag + HeroInternalForceMagicPage * 5, 0);
    if idx < g_HeroInternalForceMagicList.Count then begin
      pm := PTClientMagic (g_HeroInternalForceMagicList[idx]);
      if pm <> nil then begin
        if (pm.Level > 2) and (boISAngerMagic(pm.Def.wMagicId)) and (pm.Def.wPower > 0) then
          DScreen.ShowSpecialHint(SurfaceX(GLeft)-120, SurfaceY(GTop),
                Format(Lines, [pm.Def.sMagicName, GetSkillDesc('内功技能',pm.Def.sMagicName), pm.Level+1, pm.Def.wPower, g_sGameNGStrong, pm.Def.wMaxPower]), False)
        else
          DScreen.ShowTzHint (SurfaceX(GLeft)-120, SurfaceY(GTop),
                      pm.Def.sMagicName+'：~l\'+GetSkillDesc('内功技能',pm.Def.sMagicName)+'~y\', FALSE, True, 40);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStNGPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewHeroStNGPageUp then begin
    if HeroInternalForceMagicPage > 0 then begin
      Dec (HeroInternalForceMagicPage);
      NewNGUpLevelState(True);
    end;
  end else begin
    if HeroInternalForceMagicPage < (g_HeroInternalForceMagicList.Count+4) div 5 - 1 then begin
      Inc (HeroInternalForceMagicPage);
      NewNGUpLevelState(True);
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewHeroStPageUpClick(Sender: TObject; X, Y: Integer);
begin
{$IF M2Version <> 2}
  if Sender = DBNewHeroStPageUp then begin
    if HeroMagicPage > 0 then begin
      if DBNewHeroJQExp.Visible then DBNewHeroJQExp.Visible := False;
      Dec (HeroMagicPage);
    end;
  end else begin
    if HeroMagicPage < (g_HeroMagicList.Count+4) div 5 - 1 then begin
      if DBNewHeroJQExp.Visible then DBNewHeroJQExp.Visible := False;
      Inc (HeroMagicPage);
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DBNewStateHeroNGPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateHeroNGPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateHeroNGPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateHeroNGPage.ActivePage := 1;
    NewNGUpLevelState(True);
{$IF M2Version = 1}
  end else
  if (ly >= 91) and (ly <= 130) then begin
    ChangeHeroNGPointPage();
    DBNewHeroPointPage2.Visible := g_HeroHumanPulseArr[0].boOpenPulse;
    DBNewHeroPointPage3.Visible := g_HeroHumanPulseArr[1].boOpenPulse;
    DBNewHeroPointPage4.Visible := g_HeroHumanPulseArr[2].boOpenPulse;
    DPNewStateHeroNGPage.ActivePage := 2;
  end else
  if (ly >= 131) and (ly <= 170) then begin
    DPNewStateHeroNGPage.ActivePage := 3;
{$IFEND}
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  if g_HeroSelf = nil then Exit;
  with DWNewStateHeroNGPageTab1 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateHeroNGPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 47, clSilver, clBlack, '当前内功等级  '+IntToStr(g_dwHeroInternalForceLevel));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 67, clSilver, clBlack, '当前内功经验  '+IntToStr(g_dwHeroExp69));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 87, clSilver, clBlack, '升级内功经验  '+IntToStr(g_dwHeroMaxExp69));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 107, clSilver, clBlack, Format('内 力 值  %d/%d', [g_HeroSelf.m_Skill69NH, g_HeroSelf.m_Skill69MaxNH]));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 127, clSilver, clBlack, '内功恢复速度  '+IntToStr(g_nHeroInternalRecovery));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 147, clSilver, clBlack, '内功伤害增加  '+IntToStr(g_nHeroInternalHurtAdd));
    dsurface.BoldTextOut (SurfaceX(GLeft) + 18, SurfaceY(GTop) + 167, clSilver, clBlack, '内功伤害减免  '+IntToStr(g_nHeroInternalHurtRelief));
  end;
{$IFEND}
end;
procedure TFrmDlg.DWNewStateHeroNGPageTab2DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateHeroNGPageTab2 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      dsurface.BoldTextOut(SurfaceX(GLeft)+101, SurfaceY(GTop)+251, $8CC7EF, clBlack, Format('%d/%d', [HeroInternalForceMagicPage+1, (g_HeroInternalForceMagicList.Count+4) div 5]));
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DWNewStateHeroNGPageTab3DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version = 1}
var
  d: TDirectDrawSurface;
  wXueWeiTiao: Word;
{$IFEND}
begin
{$IF M2Version = 1}
  if g_HeroSelf = nil then exit;
  with DWNewStateHeroNGPageTab3 do begin
    if WLib <> nil then begin //20080701
      if g_HeroSelf.m_btSex = 1 then begin //女
        if HeroStatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 4]
        else d := WLib.Images[FaceIndex + 5];
      end else begin
        if HeroStatePulsePage = 0 then
          d := WLib.Images[FaceIndex + 6]
        else d := WLib.Images[FaceIndex];
      end;
      if d <> nil then
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
    end;
    //右上角标志
    if HeroStatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1171]
    else d := g_WMainImages.Images[830+HeroStatePulsePage];
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft) + 144, SurfaceY(GTop) + 11, d.ClientRect, d, TRUE);
    //经络穴位条
    if HeroStatePulsePage = 0 then begin//冲脉,冲脉读老资源
      if not g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse then
        wXueWeiTiao := 860
      else wXueWeiTiao := 861+g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel;
      d := g_WMainImages.Images[wXueWeiTiao];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d, 255);
    end else begin
      if not g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse then
        wXueWeiTiao := 2280
      else wXueWeiTiao := 2281+g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel;
      d := g_WUI1Images.Images[wXueWeiTiao-(HeroStatePulsePage-1) * 10];
      if d <> nil then
        DrawBlend(dsurface, SurfaceX(GLeft)+2, SurfaceY(GTop)+2, d, 255);
    end;
    //穴位针位
    if HeroStatePulsePage = 4 then //奇经
      d := g_WMainImages.Images[1172]
    else d := g_WMainImages.Images[840+HeroStatePulsePage];
    if d <> nil then
    dsurface.Draw (SurfaceX(GLeft)+33, SurfaceY(GTop)+13, d.ClientRect, d, TRUE);

    if HeroStatePulsePage <> 4 then begin
      if (g_HeroHumanPulseArr[HeroStatePulsePage].boOpenPulse) then begin
        case g_HeroHumanPulseArr[HeroStatePulsePage].nPulseLevel of
          0: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '已');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
          end;
          1: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '一');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          2: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '二');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          3: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '三');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          4: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '四');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
          5: begin
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '五');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '重');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '经');
            dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '络');
          end;
        end;
      end else begin
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+139, $0088C4E8, clBlack, '经');
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+153, $0088C4E8, clBlack, '络');
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+167, $0088C4E8, clBlack, '未');
        dsurface.BoldTextOut (SurfaceX(GLeft)+148, SurfaceY(GTop)+181, $0088C4E8, clBlack, '通');
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSUNecklaceDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx, nWhere, ax, ay: integer;
  d: TDirectDrawSurface;
  wm: TWMImages;
{$IFEND}
begin
{$IF M2Version <> 2}
  nWhere := -1;
  if Sender = DBNewSUNecklace then nWhere := U_NECKLACE;
  if Sender = DBNewSULight then nWhere := U_RIGHTHAND;
  if Sender = DBNewSUArmRingR then nWhere := U_ARMRINGR;
  if Sender = DBNewSUArmRingL then nWhere := U_ARMRINGL;
  if Sender = DBNewSURingR then nWhere := U_RINGR;
  if Sender = DBNewSURingL then nWhere := U_RINGL;
  if Sender = DBNewSUBujuk then nWhere := U_BUJUK;
  if Sender = DBNewSUBelt then nWhere := U_BELT;
  if Sender = DBNewSUBoots then nWhere := U_BOOTS;
  if Sender = DBNewSUCharm then nWhere := U_CHARM;
  if Sender = DBNewSUDrum then nWhere := U_Drum;

  if nWhere >= 0 then begin
    if UserState1.UseItems[nWhere].S.Name <> '' then begin
      idx := UserState1.UseItems[nWhere].S.looks;
      if idx >= 0 then begin
        d := frmMain.GetWStateImg(idx);
        if d <> nil then begin
          with TDButton(Sender) do begin
            dsurface.Draw (SurfaceX(GLeft) + (GWidth - d.Width) div 2 + 2,
                          SurfaceY(GTop) + (GHeight - d.Height) div 2 + 1,
                          d.ClientRect, d, TRUE);
            if GetEffecItemList(UserState1.UseItems[nWhere].S.Name).btShapeCount > 0 then begin
              with GetEffecItemList(UserState1.UseItems[nWhere].S.Name) do begin
                if GetTickCount - g_DrawUseItems1[nWhere].dwDrawTick >= 150 then begin
                  g_DrawUseItems1[nWhere].dwDrawTick := GetTickCount;
                  Inc(g_DrawUseItems1[nWhere].nIndex);
                  if g_DrawUseItems1[nWhere].nIndex > btShapeCount-1 then g_DrawUseItems1[nWhere].nIndex := 0;
                end;
                wm := GetItemEffectWil(btShapeWilIndex);
                if wm <> nil then begin
                  d := wm.GetCachedImage(wShapeIndex+g_DrawUseItems1[nWhere].nIndex, ax, ay);
                  if d <> nil then begin
                    DrawBlend(dsurface,SurfaceX(GLeft)+ax+nShapeX, SurfaceY(GTop)+ay+nShapeY, d, 255);
                  end;
                end;
              end;
            end else begin
              if UserState1.UseItems[nWhere].S.Reserved1 = 1 then begin
                ItemLightTimeImg(); //物品发光变换函数 20080223
                d := g_WMain2Images.Images[ItemLightImgIdx + 260];
                if d <> nil then
                  DrawBlend(dsurface,SurfaceX(GLeft-21), SurfaceY(GTop-23), d, 255);
              end;
            end;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewSUWeaponMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
{$IF M2Version <> 2}
var
  nHintX,nHintY:Integer;
  sel: integer;
  iname, iname1, d1, d2, d3, d4, d5, d6, d7: string;
  useable: Boolean;
  hcolor: string;
  TzHintInfo: pTTzHintInfo;
  Lines: string;
{$IFEND}
begin
{$IF M2Version <> 2}
  sel := -1;
  Lines := '';
  if Sender = DBNewSUDress then sel := U_DRESS;
  if Sender = DBNewSUWeapon then sel := U_WEAPON;
  if Sender = DBNewSUHelmet then sel := U_HELMET;
  if Sender = DBNewSUNecklace then sel := U_NECKLACE;
  if Sender = DBNewSULight then sel := U_RIGHTHAND;
  if Sender = DBNewSURingL then sel := U_RINGL;
  if Sender = DBNewSURingR then sel := U_RINGR;
  if Sender = DBNewSUArmRingL then sel := U_ARMRINGL;
  if Sender = DBNewSUArmRingR then sel := U_ARMRINGR;

  if Sender = DBNewSUBujuk then sel := U_BUJUK;
  if Sender = DBNewSUBelt then sel := U_BELT;
  if Sender = DBNewSUBoots then sel := U_BOOTS;
  if Sender = DBNewSUCharm then sel := U_CHARM;
  if Sender = DBNewSUDrum then sel := U_DRUM;
  if sel >= 0 then begin
    g_MouseUserStateItem := UserState1.UseItems[sel];
    if (UserState1.UseItems[sel].S.Name <> '') or (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin
      if (sel = U_HELMET) and (UserState1.UseItems[U_ZHULI].S.Name <> '') then begin
        g_MouseItem := UserState1.UseItems[U_ZHULI];
        GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1);
        if iname <> '' then begin
          if UserState1.UseItems[U_ZHULI].Dura = 0 then
            hcolor := 'Red'
          else hcolor := '';
          Lines := Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7])//iname+'~y\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + d4 + '~y\'+ d5 + '\' + d6 + '\' + d7 + '\ \';
        end;
      end;
      TzHintInfo := GetTzInfo(UserState1.UseItems[sel].S.Name, 3);
      if DWNewStateUser.GLeft >= 350 then
        nHintX:=DWNewStateUser.SurfaceX(DWNewStateUser.GLeft) - _Min(DScreen.HintWidth, 400)
      else nHintX:=DWNewStateUser.SurfaceX(DWNewStateUser.GLeft)+DWNewStateUser.GWidth;
      nHintY:=DWNewStateUser.SurfaceY(DWNewStateUser.GTop) +50;
      g_MouseItem := UserState1.UseItems[sel];
      GetMouseItemInfo (iname, iname1, d1, d2, d3, d4, d5, d6, d7, useable, 1{主人});
      if (iname <> '') or (Lines <> '') then begin
        if UserState1.UseItems[sel].Dura = 0 then
          hcolor := 'Red'
        else hcolor := '';
        with Sender as TDButton do begin
          if TzHintInfo =nil then begin
            DScreen.ShowSpecialHint(nHintx,
                                    nHinty,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7]), False//'<'+iname+'/c=Yellow>\'+ d1 + hcolor + '\' + d2 + '\' + d3 + '\' + '<'+d4+'/c=Yellow>\'+ d5 + '\' + d6 + '\' + d7, FALSE
                                    );

          end else begin
            DScreen.ShowSpecialHint(nHintx,
                                    nHinty,
                                    Lines + Format('<%s/c=Yellow><%s/c=Red>\<%s/c=%s>\%s\%s\<%s/c=Yellow>\%s\%s\%s\ \<%s/c=Yellow fontstyle=bold fontsize=10>\ \%s', [iname, iname1, d1, hColor, d2, d3, d4, d5, d6, d7, TzHintInfo.sTzCaption, GetTzStateInfo(TzHintInfo,3)]), False
                                    );
          end;
        end;
      end;
      g_MouseItem.S.Name := '';
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DBNewStateUserPageClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
var
  ly: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  ly := Y - DBNewStateUserPage.GTop;
  if (ly >= 0) and (ly <= 50) then begin
    DPNewStateUserPage.ActivePage := 0;
  end else
  if (ly >= 51) and (ly <= 90) then begin
    DPNewStateUserPage.ActivePage := 1;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewStateUserPageDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DBNewStateUserPage do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex+DPNewStateUserPage.ActivePage];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    frmMain.Canvas.Font.Style:=[fsBold];
    if DPNewStateUserPage.ActivePage = 0 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+10, $00A8D4E8, clBlack, '装');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+23, $00A8D4E8, clBlack, '备');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+10, $00708CA0, clBlack, '装');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+23, $00708CA0, clBlack, '备');
    end;
    if DPNewStateUserPage.ActivePage = 1 then begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+50, $00A8D4E8, clBlack, '称');
      dsurface.BoldTextOut (SurfaceX(GLeft)+6, SurfaceY(GTop)+63, $00A8D4E8, clBlack, '号');
    end else begin
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+50, $00708CA0, clBlack, '称');
      dsurface.BoldTextOut (SurfaceX(GLeft)+7, SurfaceY(GTop)+63, $00708CA0, clBlack, '号');
    end;
    frmMain.Canvas.Font.Style:=[];
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewUserPrevTitleClick(Sender: TObject; X, Y: Integer);
{$IF M2Version <> 2}
  function GetTitleCount(): Byte;
  var
    I: Integer;
  begin
    Result := 0;
    for I:=Low(UserState1.wHumTitles.ClientHumTitles) to High(UserState1.wHumTitles.ClientHumTitles) do begin
      if UserState1.wHumTitles.ClientHumTitles[I].sTitleName <> '' then begin
        Inc(Result);
      end;
    end;
  end;
{$IFEND}
begin
  {$IF M2Version <> 2}
  if Sender = DBNewUserPrevTitle then begin
    if m_btUserTitlePage > 0 then Dec (m_btUserTitlePage);
  end else begin
    if m_btUserTitlePage < (GetTitleCount+3) div 4 -1 then
       Inc (m_btUserTitlePage);
  end;
  {$IFEND}
end;

procedure TFrmDlg.DBNewUserTitle1DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      idx := _Max(Tag + m_btUserTitlePage * 5, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        if UserState1.wHumTitles.ClientHumTitles[idx].sTitleName <> '' then begin
          if UserState1.wHumTitles.ClientHumTitles[idx].Looks >= 0 then begin
            if (GetUserTitlePageIdx-1 = Tag) and (GetUserTitlePageIdx <> 0) then begin
              d := WLib.Images[FaceIndex];
              if d <> nil then begin
                g_ImgMixSurface.SetSize(d.Width, d.Height);
                g_ImgMixSurface.Draw(0, 0, d.ClientRect, d, FALSE);
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                g_ImgMixSurface.Draw (0, 0, d.ClientRect, d, TRUE);
                DrawEffect(0, 0, g_ImgMixSurface, g_ImgMixSurface, ceGrayScale);
                dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), g_ImgMixSurface.ClientRect, g_ImgMixSurface, True);
              end;
            end else begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+1];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[idx].Looks+2];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
          end;
          dsurface.TextOut(SurfaceX(GLeft) + 34, SurfaceY(GTop) + 15, $008200, UserState1.wHumTitles.ClientHumTitles[idx].sTitleName);
        end;
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewUserTitle1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
{$IF M2Version <> 2}
var
  idx: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  DScreen.ClearHint;
  with Sender as TDButton do begin
    if Sender = DBNewUserTitleMan then begin
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                  SurfaceY(GTop)+GHeight,
                                  GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1], g_MouseUserTitleList, True), False);
        end;
      end;
    end else begin
      if (GetTitlePageIdx(5)-1 = Tag) and (GetTitlePageIdx(5) <> 0) then begin
        DScreen.ClearHint;
        Exit;
      end;
      idx := _Max(Tag + m_btTitlePage * 5, 0);
      if idx <= High(UserState1.wHumTitles.ClientHumTitles) then begin
        DScreen.ShowSpecialHint(SurfaceX(GLeft),
                                SurfaceY(GTop)+GHeight,
                                GetTitleInfo(UserState1.wHumTitles.ClientHumTitles[idx], g_MouseUserTitleList, True), False);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DBNewUserTitleManDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  idx: Integer;
  d: TDirectDrawSurface;
  nOldFontSize: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with Sender as TDButton do begin
    if WLib <> nil then begin
      if UserState1.wHumTitles.nUseTitleIndex > 0 then begin
        if UserState1.wHumTitles.nUseTitleIndex-1 <= High(UserState1.wHumTitles.ClientHumTitles) then begin
          if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName <> '' then begin
            if UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks >= 0 then begin
              if not Downed then begin
                d := WLib.Images[FaceIndex+1];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+3];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end else begin
                d := WLib.Images[FaceIndex+2];
                if d <> nil then begin
                   dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
                end;
                d := WLib.Images[UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].Looks+4];
                if d <> nil then
                    dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, TRUE);
              end;
            end;
            nOldFontSize := frmMain.Canvas.Font.Size;
            frmMain.Canvas.Font.Size := 12;
            frmMain.Canvas.Font.Style := [fsBold];
            dsurface.TextOut(SurfaceX(GLeft)+40, SurfaceY(GTop)+20, clYellow, UserState1.wHumTitles.ClientHumTitles[UserState1.wHumTitles.nUseTitleIndex-1].sTitleName);
            frmMain.Canvas.Font.Style := [];
            frmMain.Canvas.Font.Size := nOldFontSize;
          end;
        end;
      end;
    end;
  end;
{$IFEND}
end;
procedure TFrmDlg.DWNewStateWinPageTab4DirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
{$IF M2Version <> 2}
var
  d: TDirectDrawSurface;
  I: Integer;
{$IFEND}
begin
{$IF M2Version <> 2}
  with DWNewStateWinPageTab4 do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
      if g_MouseTitleList.Count > 0 then begin
        for I:=0 to g_MouseTitleList.Count-1 do
          dsurface.TextOut(SurfaceX(GLeft)+140, SurfaceY(GTop)+72+I*14, clYellow, g_MouseTitleList[I]);
      end;
    end;
  end;
{$IFEND}
end;

procedure TFrmDlg.DMemoXinFaHintDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  i, ElemCount, ScrollAmount,TopIndex: Integer;
  data, fdata, cmdstr, cmdparam: string;
  sx: integer;
  pcp: PTClickPoint;
  Color: TColor;
  sColor, cmdtitle, sTemp: string;
begin
  with DMemoXinFaHint do begin    //防止除0错误By TasNat at: 2012-10-19 09:25:05
    ElemCount:= (GHeight - 2) div _MAX(1, LinesHeight);  //一共能显示几行
    if ElemCount > Lines.Count then ElemCount:= Lines.Count;  //如果一共能显示的行数 > 列表总数
    ScrollAmount:= Lines.Count - ElemCount;  //剩余多少个行
    if DScroll <> nil then begin
      if ScrollAmount > 0 then begin
        DScroll.FArrowInc:= 1.0 / ScrollAmount;
        DScroll.FPageInc := 4.0 / ScrollAmount;
      end else begin
        DScroll.FArrowInc:= 0;
        DScroll.FPageInc := 0;
      end;
      TopIndex:= Round(DScroll.Theta * ScrollAmount);
    end;
    if (TopIndex + ElemCount > Lines.Count) then TopIndex:= _Max(Lines.Count - ElemCount, 0);
    for I:= 0 to ElemCount - 1 do begin
      sx := 0;
      fdata := '';
      data := Lines.Strings[I+TopIndex];
      while (pos('<', data) > 0) and (pos('>', data) > 0) and (data <> '') do begin  //如果是连接
        if data[1] <> '<' then begin
          data := '<' + GetValidStr3 (data, fdata, ['<']);
        end;
        data := ArrestStringEx (data, '<', '>', cmdstr);//得到"<"和">" 号之间的字   赋予给 cmdstr
        if cmdstr <> '' then begin
          cmdparam := GetValidStr3 (cmdstr, cmdstr, ['/']); //cmdparam : 命令参数
        end;
        if fdata <> '' then begin
          dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, fdata);
          sx := sx + FrmMain.Canvas.TextWidth(fdata);
        end;
        if (cmdstr <> '') then begin
          if CompareLStr(cmdparam, 'FCOLOR=', length('FCOLOR=')) then begin
            sColor := GetValidStr3(cmdparam, sTemp, ['=']);
            Color := GetRGB(Lobyte(Str_ToInt(sColor, 255)));
            dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), Color, clBlack, cmdstr)  //显示颜色文字
          end;
          FrmMain.Canvas.Font.Style := FrmMain.Canvas.Font.Style - [fsUnderline];
          sx := sx + FrmMain.Canvas.TextWidth(cmdstr);
        end;
      end;
      if data <> '' then
        dsurface.BoldTextOut (SurfaceX(GLeft+sx), SurfaceY(GTop+I*LinesHeight), clWhite, clBlack, data);
    end;
  end;
end;

procedure TFrmDlg.DMemoXinFaHintScrollBarDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
   d: TDirectDrawSurface;
   Rc:Trect;
begin
  with Sender as TDMemoScrollBar do begin
    d := g_WMain2Images.Images[291];
    if d <> nil then begin
      Rc := d.ClientRect;
      Rc.Bottom := GHeight;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop), Rc, d, True);
      Rc := d.ClientRect;
      Rc.Top := d.Height-GHeight;
      Rc.Bottom := d.Height;
      dsurface.Draw (SurfaceX(GLeft), SurfaceY(GTop)+1, Rc, d, True);
    end;
  end;
end;

procedure TFrmDlg.DWBottomCenterDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  nLeft, nTop, nLen: Integer;
  PaintRect: TRect;
begin
  with DWBottomCenter do begin
    DScreen.DelChatTopString();
    dsurface.FastFillRect(Bounds(GLeft, GTop + 56, GWidth, GHeight), clWhite);
    d := g_WchantkkImages.Images[11];
    if d <> nil then begin
      nLen := GLeft + GWidth;
      nLeft := GLeft;
      nTop := GTop + 54;
      while nLeft < nLen do begin
        if nLeft + d.Width <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, Width - nLeft, d.Height);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nLeft, d.Width);
      end;
    end;
    d := g_WchantkkImages.Images[16];
    if d <> nil then begin
      nLen := GLeft + GWidth;
      nLeft := GLeft;
      nTop := GTop + (GHeight - d.Height);
      while nLeft < nLen do begin
        if nLeft + d.Width <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, GWidth - nLeft, d.Height);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nLeft, d.Width);
      end;
    end;
    d := g_WchantkkImages.Images[13];
    if d <> nil then begin
      nLen := GTop + GHeight;
      nLeft := GLeft;
      nTop := GTop + 54;
      while nTop < nLen do begin
        if nTop + d.Height <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, GWidth, GHeight - nTop);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nTop, d.Height);
      end;
    end;
    d := g_WchantkkImages.Images[14];
    if d <> nil then begin
      nLen := GTop + GHeight;
      nLeft := GLeft + (GWidth - d.Width);
      nTop := GTop + 54;
      while nTop < nLen do begin
        if nTop + d.Height <= nLen then
          PaintRect := d.ClientRect
        else
          PaintRect := Bounds(0, 0, GWidth, GHeight - nTop);

        dsurface.Draw(nLeft, nTop, PaintRect, d, False);
        Inc(nTop, d.Height);
      end;
    end;
    d := g_WchantkkImages.Images[10];
    if d <> nil then begin
      nLeft := GLeft;
      nTop := GTop + 54;
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[12];
    if d <> nil then begin
      nLeft := GLeft + (GWidth - d.Width);
      nTop := GTop + 54;
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[15];
    if d <> nil then begin
      nLeft := GLeft;
      nTop := GTop + (GHeight - d.Height);
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[17];
    if d <> nil then begin
      nLeft := GLeft + (GWidth - d.Width);
      nTop := GTop + (GHeight - d.Height);
      dsurface.Draw(nLeft, nTop, d.ClientRect, d, False);
    end;

    d := g_WchantkkImages.Images[2];
    if d <> nil then
      dsurface.Draw(GLeft + (GWidth - d.Width) div 2, GTop + 2, d.ClientRect, d, True);
  end;
end;

procedure TFrmDlg.DWBottomCenterMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  MoveChatDlgY := Y;
end;

procedure TFrmDlg.DWBottomCenterMouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
begin
  if DWBottomCenter.Downed and (MoveChatDlgY <> Y) then begin
    ChatMemoHeight := _MAX(ChatMemoHeight + (MoveChatDlgY - Y), 211);
    ChatMemoHeight := _MIN(ChatMemoHeight, SCREENHEIGHT);
    SetChatDlgHeight(ChatMemoHeight);
    {DWBottomCenter.GHeight := ChatMemoHeight;
    DWBottomCenter.GTop := SCREENHEIGHT - DWBottomCenter.GHeight; }
    MoveChatDlgY := Y;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWBottomRightDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Rc: TRect;
  r: Real;
begin


  with DWBottomRight do begin
    {$IF M2Version = 2} //1.76
    d := g_qingqingImages.Images[25];
    {$ELSE}  //修复关闭英雄系统还显示召唤英雄的图标By TasNat at: 2012-11-30 15:31:44
    if g_boOpenHero then     
      d := g_WchantkkImages.Images[1]
    else
      d := g_qingqingImages.Images[25];
    {$IFEND}
    if d <> nil then
      dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);

    d := nil;
    case g_nDayBright of
      0: d := g_WMainImages.Images[15];  //早上
      1: d := g_WMainImages.Images[12];  //白天
      2: d := g_WMainImages.Images[13];  //傍晚
      3: d := g_WMainImages.Images[14];  //晚上
    end;
    if d <> nil then
      dsurface.Draw (SurfaceX(GLeft)+148, SurfaceY(GTop)+81, d.ClientRect, d, FALSE);
    {$IF M2Version <> 2}
    if g_boOpenHero then begin
      d := g_WMain3Images.Images[313];
      if d <> nil then
        dsurface.Draw (SurfaceX(GLeft)+33, SurfaceY(GTop)+105, d.ClientRect, d, TRUE);
    end;
    {$IFEND}
    if g_MySelf <> nil then begin
      if DBNewStateTab3.Visible then
        dsurface.BoldTextOut(SurfaceX(GLeft)+66, SurfaceY(GTop)+147, clYellow, clBlack, IntToStr(g_MySelf.m_Abil.Level))
      else PomiTextOut (dsurface, SurfaceX(GLeft)+60, SurfaceY(GTop)+150, IntToStr(g_MySelf.m_Abil.Level));
      {$IF M2Version = 2}
      dsurface.BoldTextOut (635, 464, clWhite, clBlack, g_sAttackMode);
      {$ELSE}
      if g_boOpenHero then begin
        dsurface.BoldTextOut (SurfaceX(GLeft)+35, SurfaceY(GTop)+126, clWhite, clBlack, g_sAttackMode);
      end else begin
        dsurface.BoldTextOut (SurfaceX(GLeft)+41, SurfaceY(GTop)+113, clWhite, clBlack, g_sAttackMode);
      end;
      {$IFEND}
      if (g_MySelf.m_Abil.nMaxExp > 0) and (g_MySelf.m_Abil.MaxWeight > 0) then begin
        d := g_WMainImages.Images[7];
        if d <> nil then begin
          //经验条
          rc := d.ClientRect;
          if g_MySelf.m_Abil.nExp > 0 then
            r := g_MySelf.m_Abil.nMaxExp / g_MySelf.m_Abil.nExp
          else r := 0;
          if r > 0 then
            rc.Right := Round (rc.Right / r)
          else rc.Right := 0;
          dsurface.Draw (SurfaceX(GLeft)+66, SurfaceY(GTop)+179, rc, d, FALSE);
          //背包重量条
          rc := d.ClientRect;
          if g_MySelf.m_Abil.Weight > 0 then
            r := g_MySelf.m_Abil.MaxWeight / g_MySelf.m_Abil.Weight
          else r := 0;
          if r > 0 then
            rc.Right := Round (rc.Right / r)
          else rc.Right := 0;
          dsurface.Draw (SurfaceX(GLeft)+66, SurfaceY(GTop)+212, rc, d, FALSE);
         end;
      end;
      //饥饿程度
      if g_nMyHungryState in [1..4] then begin
        d := g_WMainImages.Images[16 + g_nMyHungryState-1];
        if d <> nil then begin
          dsurface.Draw (SurfaceX(GLeft)+154, SurfaceY(GTop)+207, d.ClientRect, d, TRUE);
        end;
      end;
      {$IF M2Version <> 2}
      if g_boXinFaType then begin //105魔法
        d := g_WUI1Images.Images[2330];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+38, SurfaceY(GTop)+140, d.ClientRect, d, True);
        d := g_WUI1Images.Images[2331];
        if d <> nil then
          dsurface.Draw(SurfaceX(GLeft)+38, SurfaceY(GTop)+172, d.ClientRect, d, True);
        if g_boShowXinFaAbsorb then begin
          if GetTickCount - g_dwXinFaAbsorbTimeKick > 200 then begin
            g_dwXinFaAbsorbTimeKick := GetTickCount;
            Inc(g_btXinFaAbsorbImgIndex);
            if g_btXinFaAbsorbImgIndex > 1 then g_btXinFaAbsorbImgIndex := 0;
          end;
          d := g_WMainImages.Images[918+g_btXinFaAbsorbImgIndex];
          if d <> nil then
            dsurface.Draw (SurfaceX(GLeft)+42, SurfaceY(GTop)+192, d.ClientRect, d, TRUE);
        end;
      end;
      {$IFEND}
      dsurface.BoldTextOut (SurfaceX(GLeft)+72, SurfaceY(GTop)+230, clWhite, clBlack, FormatDateTime('hh:mm:ss',Now));
    end;
  end;
end;

procedure TFrmDlg.DWBottomLeftDirectPaint(Sender: TObject;
  dsurface: TDirectDrawSurface);
var
  d: TDirectDrawSurface;
  Rc: TRect;
begin
  with DWBottomLeft do begin
    if WLib <> nil then begin
      d := WLib.Images[FaceIndex];
      if d <> nil then
        dsurface.Draw(SurfaceX(GLeft), SurfaceY(GTop), d.ClientRect, d, True);
    end;
    {$IF M2Version <> 2}
    if g_boOpenLeiMei then begin
      d := g_WUI1Images.Images[896];
      if d <> nil then
          dsurface.Draw (0, SurfaceY(GTop)+20, d.ClientRect, d, TRUE);
    end;
    {$IFEND}
    if g_MySelf <> nil then begin
    //显示HP及MP 图形
      if (g_MySelf.m_Abil.MaxHP > 0) and (g_MySelf.m_Abil.MaxMP > 0) then begin
        if (g_MySelf.m_btJob = 0) and (g_MySelf.m_Abil.Level < 28) then begin //武士
          d := g_WMainImages.Images[5];
          if d <> nil then begin
            Rc := d.ClientRect;
            Rc.Right := d.ClientRect.Right - 2;
            dsurface.Draw (38, SurfaceY(GTop)+91, Rc, d, FALSE);
          end;
          d := g_WMainImages.Images[6];
          if d <> nil then begin
            Rc := d.ClientRect;
            Rc.Right := d.ClientRect.Right - 2;
            Rc.Top := Round(Rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
            dsurface.Draw (38, SurfaceY(GTop)+91+Rc.Top, Rc, d, FALSE);
          end;
        end else begin
          d := g_WMainImages.Images[4];
          if d <> nil then begin
            //HP 图形
            Rc := d.ClientRect;
            Rc.Right := d.ClientRect.Right div 2 - 1;
            Rc.Top := Round(Rc.Bottom / g_MySelf.m_Abil.MaxHP * (g_MySelf.m_Abil.MaxHP - g_MySelf.m_Abil.HP));
            dsurface.Draw (40, SurfaceY(GTop)+92+Rc.Top, Rc, d, FALSE);
            //MP 图形
            Rc := d.ClientRect;
            Rc.Left := d.ClientRect.Right div 2 + 1;
            Rc.Right := d.ClientRect.Right - 1;
            Rc.Top := Round(Rc.Bottom / g_MySelf.m_Abil.MaxMP * (g_MySelf.m_Abil.MaxMP - g_MySelf.m_Abil.MP));
            dsurface.Draw (40 + Rc.Left, SurfaceY(GTop)+93+Rc.Top, Rc, d, FALSE);
          end;
        end;
      end;
    {$IF M2Version = 1}
      if g_MySelf.m_Abil.MaxTransferValue > 0 then begin
        d := g_WMainImages.Images[1200];
        if d <> nil then begin
          dsurface.Draw (12, 416, d.ClientRect, d, TRUE);
        end;

        d:= g_WMainImages.Images[1201];
        if d <> nil then begin
          rc := d.ClientRect;
          rc.Top := Round(rc.Bottom / g_MySelf.m_Abil.MaxTransferValue * (g_MySelf.m_Abil.MaxTransferValue - g_MySelf.m_Abil.TransferValue));
          dsurface.Draw (20, 425+rc.Top, rc, d, TRUE);
        end;
      end;
    {$IFEND}
      dsurface.BoldTextOut (27, 563, clWhite, clBlack, (format('%d/%d',[g_MySelf.m_Abil.HP,g_MySelf.m_Abil.MaxHP])));
      dsurface.BoldTextOut (92, 563, clWhite, clBlack, (format('%d/%d',[g_MySelf.m_Abil.MP,g_MySelf.m_Abil.MaxMP])));
      dsurface.BoldTextOut (7, SCREENHEIGHT-15, clWhite, clBlack, Format('%s %d:%d',[g_sMapTitle, g_MySelf.m_nCurrX, g_MySelf.m_nCurrY]));
      {$IF M2Version <> 2}
      if g_MySelf.m_nState and $00020000 <> 0 then begin //心法激活
        if GetTickCount - m_dwAbilTick > 100 then begin
          m_dwAbilTick := GetTickCount;
          Inc(m_btAbilIndex);
          if m_btAbilIndex >= 12 then m_btAbilIndex := 0;
        end;
        d := g_WMagic10Images.Images[240 + m_btAbilIndex];
        if d <> nil then
          DrawBlend(dsurface,38, SurfaceY(GTop)+90, d, 255);
        d := g_WMagic10Images.Images[260 + m_btAbilIndex];
        if d <> nil then
          DrawBlend(dsurface,38, SurfaceY(GTop)+90, d, 255);
        d := g_WMagic10Images.Images[280 + m_btAbilIndex];
        if d <> nil then
          DrawBlend(dsurface,-62, SurfaceY(GTop)-10, d, 255);
      end;
      {$IFEND}
    end;
  end;
end;

procedure TFrmDlg.DChatMemoMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
var
  Str: string;
  DMemo: TDChatMemo;
   function ExtractUserName (line: string): string;
   var
      uname: string;
   begin
      if line[1]='[' then begin
        line := GetValidStr3 (line, line, [']']);
      end;
      GetValidStr3 (line, line, ['(', '!', '*', '/', ')']);
      GetValidStr3 (line, uname, [' ', '=', ':','[']);
      if uname <> '' then
         if (uname[1] = '/') or (uname[1] = '(') or (uname[1] = ' ') or (uname[1] = '[') then
            uname := '';
      Result := uname;
   end;
begin
  DMemo := TDChatMemo(Sender);
  if DMemo.ShowScroll and (X >= DMemo.GLeft + DMemo.GWidth - DMemo.ScrollSize) then Exit;
  if (DMemo.ItemIndex - DMemo.TopIndex >= 0) and (DMemo.ItemIndex - DMemo.TopIndex < DMemo.TopLines.Count) then begin
    if not PlayScene.EdChat.Visible then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
    end;
    if ssCtrl in shift then begin
      PlayScene.EdChat.Text :=DMemo.TopLines[DMemo.ItemIndex - DMemo.TopIndex];
    end else begin
      PlayScene.EdChat.Text := '/' + ExtractUserName (DMemo.TopLines[DMemo.ItemIndex - DMemo.TopIndex]) + ' ';
    end;
    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
    PlayScene.EdChat.SelLength := 0;
  end else
    if (DMemo.ItemIndex - DMemo.TopLines.Count >= 0) and (DMemo.ItemIndex - DMemo.TopLines.Count < DMemo.Lines.Count) then begin
    if not PlayScene.EdChat.Visible then begin
      PlayScene.EdChat.Visible := TRUE;
      PlayScene.EdChat.SetFocus;
    end;
    if ssCtrl in shift then begin
      PlayScene.EdChat.Text :=DMemo.Lines[DMemo.ItemIndex - DMemo.TopLines.Count];
    end else begin
      PlayScene.EdChat.Text := '/' + ExtractUserName (DMemo.Lines[DMemo.ItemIndex - DMemo.TopLines.Count]) + ' ';
    end;
    PlayScene.EdChat.SelStart := Length(PlayScene.EdChat.Text);
    PlayScene.EdChat.SelLength := 0;
  end else
    PlayScene.EdChat.Text := '';
end;

procedure TFrmDlg.DChatMemoInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
begin
  IsRealArea := True;
end;

procedure TFrmDlg.DChatMemoChange(Sender: TObject);
var
  I: Integer;
  ChatMemo: TDChatMemo;
begin
  ChatMemo := TDChatMemo(Sender);
  if ChatMemo.Lines.Count > 200 then begin
    for I := 0 to 9 do begin
      if ChatMemo.Lines.Count > 0 then ChatMemo.Delete(0) else break;
    end;
  end;
  if ChatMemo.TopLines.Count > 3 then ChatMemo.DeleteTop(0); //不允许超过3条信息
end;

procedure TFrmDlg.DWBottomLeftMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg: string;
  nHintX, nHintY: Integer;
begin
  {$IF M2Version = 1}
  if g_MySelf <> nil then begin
    if ((X>=42) and (X<=60)) and ((Y>=SCREENHEIGHT-177) and (Y<=SCREENHEIGHT-139)) then begin
      if g_MySelf.m_Abil.MaxTransferValue <= 0 then Exit;
      sMsg := IntToStr(g_MySelf.m_Abil.TransferValue)+ '/' + IntToStr(g_MySelf.m_Abil.MaxTransferValue);
      nHintX := 12;
      nHintY := SCREENHEIGHT - 186;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      Exit;
    end;
  end;
  {$IFEND}
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWBottomRightMouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
var
  sMsg: string;
  nHintX, nHintY: Integer;
begin
  if g_MySelf <> nil then begin
    if ((X >= SCREENWIDTH - 135) and (X <= SCREENWIDTH - 96)) and ((Y >= SCREENHEIGHT - 108) and (Y <= SCREENHEIGHT - 92)) then begin
      sMsg := '当前等级';
      nHintX := SCREENWIDTH - 135;
      nHintY := SCREENHEIGHT - 92+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end
    else if ((X >= SCREENWIDTH - 135) and (X <= SCREENWIDTH - 55)) and ((Y >= SCREENHEIGHT - 77) and (Y <= SCREENHEIGHT - 63)) then begin
      sMsg := '当前经验';
      nHintX := SCREENWIDTH - 135;
      nHintY := SCREENHEIGHT - 63+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg+FloatToStrFixFmt(100 * (g_MySelf.m_Abil.nExp / g_MySelf.m_Abil.nMaxExp), 3, 2) +'%', clWhite, TRUE);
      Exit;
    end
    else if ((X >= SCREENWIDTH - 135) and (X <= SCREENWIDTH - 55)) and ((Y >= SCREENHEIGHT - 44) and (Y <= SCREENHEIGHT - 28)) then begin
      sMsg := format('包裹负重%d/%d',[g_MySelf.m_Abil.Weight,g_MySelf.m_Abil.MaxWeight]);
      nHintX := SCREENWIDTH - 135;
      nHintY := SCREENHEIGHT - 28+20;
      DScreen.ShowHint(nHintX,nHintY,sMsg, clWhite, TRUE);
      exit;
    end;
  end;
  DScreen.ClearHint;
end;

procedure TFrmDlg.DWBottomCenterInRealArea(Sender: TObject; X, Y: Integer;
  var IsRealArea: Boolean);
var
  d: TDirectDrawSurface;
begin
  if Y >= 54 then IsRealArea := True
  else begin
    d := g_WchantkkImages.Images[27];
    if (d <> nil) then
      IsRealArea := d.Pixels[X, Y] > 0
    else
      IsRealArea := True;
  end;
end;
end.

